{"map":{"version":3,"sources":["app.js"],"names":["modules","installedModules","__webpack_require__","moduleId","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","eval","__webpack_exports__"],"mappings":"CAAS,SAAUA,GAET,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAJ,EAAQG,GAAUK,KAAKH,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBO,EAAIT,EAGxBE,EAAoBQ,EAAIT,EAGxBC,EAAoBS,EAAI,SAASP,EAASQ,EAAMC,GAC3CX,EAAoBY,EAAEV,EAASQ,IAClCG,OAAOC,eAAeZ,EAASQ,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEX,EAAoBiB,EAAI,SAASf,GACX,oBAAXgB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeZ,EAASgB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeZ,EAAS,aAAc,CAAEkB,OAAO,KAQvDpB,EAAoBqB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQpB,EAAoBoB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAzB,EAAoBiB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOpB,EAAoBS,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRxB,EAAoB4B,EAAI,SAASzB,GAChC,IAAIQ,EAASR,GAAUA,EAAOoB,WAC7B,WAAwB,OAAOpB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBS,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRX,EAAoBY,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG9B,EAAoBiC,EAAI,OAIjBjC,EAAoBA,EAAoBkC,EAAI,GAnFpD,CAsFC,CAEJ,SAAU/B,OAAQD,QAASF,qBAEjCmC,KAAK,is+BAIC,SAAUhC,OAAQD,QAASF,qBAEjCmC,KAAK,+2jFAIC,SAAUhC,OAAQD,QAASF,qBAEjCmC,KAAK,uiwOAIC,SAAUhC,EAAQD,EAASF,GAEjCG,EAAOD,QAAUF,EAAoB,IAK/B,SAAUG,OAAQD,QAASF,qBAEjCmC,KAAK,2YAIC,SAAUhC,OAAQD,QAASF,qBAEjC,aACAmC,KAAK,stMAIC,SAAUhC,OAAQiC,oBAAqBpC,qBAE7C,aACAmC,KAAK"},"code":"!function(n){var t={};function e(l){if(t[l])return t[l].exports;var c=t[l]={i:l,l:!1,exports:{}};return n[l].call(c.exports,c,c.exports,e),c.l=!0,c.exports}e.m=n,e.c=t,e.d=function(n,t,l){e.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:l})},e.r=function(n){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(n,\"__esModule\",{value:!0})},e.t=function(n,t){if(1&t&&(n=e(n)),8&t)return n;if(4&t&&\"object\"==typeof n&&n&&n.__esModule)return n;var l=Object.create(null);if(e.r(l),Object.defineProperty(l,\"default\",{enumerable:!0,value:n}),2&t&&\"string\"!=typeof n)for(var c in n)e.d(l,c,function(t){return n[t]}.bind(null,c));return l},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,\"a\",t),t},e.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},e.p=\"/js/\",e(e.s=3)}([function(module,exports,__webpack_require__){eval(\"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\\n * @license MIT */\\n\\n;(function(root, factory) {\\n\\n  if (true) {\\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n  } else {}\\n\\n})(this, function() {\\n  var NProgress = {};\\n\\n  NProgress.version = '0.2.0';\\n\\n  var Settings = NProgress.settings = {\\n    minimum: 0.08,\\n    easing: 'ease',\\n    positionUsing: '',\\n    speed: 200,\\n    trickle: true,\\n    trickleRate: 0.02,\\n    trickleSpeed: 800,\\n    showSpinner: true,\\n    barSelector: '[role=\\\"bar\\\"]',\\n    spinnerSelector: '[role=\\\"spinner\\\"]',\\n    parent: 'body',\\n    template: '<div class=\\\"bar\\\" role=\\\"bar\\\"><div class=\\\"peg\\\"></div></div><div class=\\\"spinner\\\" role=\\\"spinner\\\"><div class=\\\"spinner-icon\\\"></div></div>'\\n  };\\n\\n  /**\\n   * Updates configuration.\\n   *\\n   *     NProgress.configure({\\n   *       minimum: 0.1\\n   *     });\\n   */\\n  NProgress.configure = function(options) {\\n    var key, value;\\n    for (key in options) {\\n      value = options[key];\\n      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\\n    }\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Last number.\\n   */\\n\\n  NProgress.status = null;\\n\\n  /**\\n   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\\n   *\\n   *     NProgress.set(0.4);\\n   *     NProgress.set(1.0);\\n   */\\n\\n  NProgress.set = function(n) {\\n    var started = NProgress.isStarted();\\n\\n    n = clamp(n, Settings.minimum, 1);\\n    NProgress.status = (n === 1 ? null : n);\\n\\n    var progress = NProgress.render(!started),\\n        bar      = progress.querySelector(Settings.barSelector),\\n        speed    = Settings.speed,\\n        ease     = Settings.easing;\\n\\n    progress.offsetWidth; /* Repaint */\\n\\n    queue(function(next) {\\n      // Set positionUsing if it hasn't already been set\\n      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\\n\\n      // Add transition\\n      css(bar, barPositionCSS(n, speed, ease));\\n\\n      if (n === 1) {\\n        // Fade out\\n        css(progress, { \\n          transition: 'none', \\n          opacity: 1 \\n        });\\n        progress.offsetWidth; /* Repaint */\\n\\n        setTimeout(function() {\\n          css(progress, { \\n            transition: 'all ' + speed + 'ms linear', \\n            opacity: 0 \\n          });\\n          setTimeout(function() {\\n            NProgress.remove();\\n            next();\\n          }, speed);\\n        }, speed);\\n      } else {\\n        setTimeout(next, speed);\\n      }\\n    });\\n\\n    return this;\\n  };\\n\\n  NProgress.isStarted = function() {\\n    return typeof NProgress.status === 'number';\\n  };\\n\\n  /**\\n   * Shows the progress bar.\\n   * This is the same as setting the status to 0%, except that it doesn't go backwards.\\n   *\\n   *     NProgress.start();\\n   *\\n   */\\n  NProgress.start = function() {\\n    if (!NProgress.status) NProgress.set(0);\\n\\n    var work = function() {\\n      setTimeout(function() {\\n        if (!NProgress.status) return;\\n        NProgress.trickle();\\n        work();\\n      }, Settings.trickleSpeed);\\n    };\\n\\n    if (Settings.trickle) work();\\n\\n    return this;\\n  };\\n\\n  /**\\n   * Hides the progress bar.\\n   * This is the *sort of* the same as setting the status to 100%, with the\\n   * difference being `done()` makes some placebo effect of some realistic motion.\\n   *\\n   *     NProgress.done();\\n   *\\n   * If `true` is passed, it will show the progress bar even if its hidden.\\n   *\\n   *     NProgress.done(true);\\n   */\\n\\n  NProgress.done = function(force) {\\n    if (!force && !NProgress.status) return this;\\n\\n    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\\n  };\\n\\n  /**\\n   * Increments by a random amount.\\n   */\\n\\n  NProgress.inc = function(amount) {\\n    var n = NProgress.status;\\n\\n    if (!n) {\\n      return NProgress.start();\\n    } else {\\n      if (typeof amount !== 'number') {\\n        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\\n      }\\n\\n      n = clamp(n + amount, 0, 0.994);\\n      return NProgress.set(n);\\n    }\\n  };\\n\\n  NProgress.trickle = function() {\\n    return NProgress.inc(Math.random() * Settings.trickleRate);\\n  };\\n\\n  /**\\n   * Waits for all supplied jQuery promises and\\n   * increases the progress as the promises resolve.\\n   *\\n   * @param $promise jQUery Promise\\n   */\\n  (function() {\\n    var initial = 0, current = 0;\\n\\n    NProgress.promise = function($promise) {\\n      if (!$promise || $promise.state() === \\\"resolved\\\") {\\n        return this;\\n      }\\n\\n      if (current === 0) {\\n        NProgress.start();\\n      }\\n\\n      initial++;\\n      current++;\\n\\n      $promise.always(function() {\\n        current--;\\n        if (current === 0) {\\n            initial = 0;\\n            NProgress.done();\\n        } else {\\n            NProgress.set((initial - current) / initial);\\n        }\\n      });\\n\\n      return this;\\n    };\\n\\n  })();\\n\\n  /**\\n   * (Internal) renders the progress bar markup based on the `template`\\n   * setting.\\n   */\\n\\n  NProgress.render = function(fromStart) {\\n    if (NProgress.isRendered()) return document.getElementById('nprogress');\\n\\n    addClass(document.documentElement, 'nprogress-busy');\\n    \\n    var progress = document.createElement('div');\\n    progress.id = 'nprogress';\\n    progress.innerHTML = Settings.template;\\n\\n    var bar      = progress.querySelector(Settings.barSelector),\\n        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\\n        parent   = document.querySelector(Settings.parent),\\n        spinner;\\n    \\n    css(bar, {\\n      transition: 'all 0 linear',\\n      transform: 'translate3d(' + perc + '%,0,0)'\\n    });\\n\\n    if (!Settings.showSpinner) {\\n      spinner = progress.querySelector(Settings.spinnerSelector);\\n      spinner && removeElement(spinner);\\n    }\\n\\n    if (parent != document.body) {\\n      addClass(parent, 'nprogress-custom-parent');\\n    }\\n\\n    parent.appendChild(progress);\\n    return progress;\\n  };\\n\\n  /**\\n   * Removes the element. Opposite of render().\\n   */\\n\\n  NProgress.remove = function() {\\n    removeClass(document.documentElement, 'nprogress-busy');\\n    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\\n    var progress = document.getElementById('nprogress');\\n    progress && removeElement(progress);\\n  };\\n\\n  /**\\n   * Checks if the progress bar is rendered.\\n   */\\n\\n  NProgress.isRendered = function() {\\n    return !!document.getElementById('nprogress');\\n  };\\n\\n  /**\\n   * Determine which positioning CSS rule to use.\\n   */\\n\\n  NProgress.getPositioningCSS = function() {\\n    // Sniff on document.body.style\\n    var bodyStyle = document.body.style;\\n\\n    // Sniff prefixes\\n    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\\n                       ('MozTransform' in bodyStyle) ? 'Moz' :\\n                       ('msTransform' in bodyStyle) ? 'ms' :\\n                       ('OTransform' in bodyStyle) ? 'O' : '';\\n\\n    if (vendorPrefix + 'Perspective' in bodyStyle) {\\n      // Modern browsers with 3D support, e.g. Webkit, IE10\\n      return 'translate3d';\\n    } else if (vendorPrefix + 'Transform' in bodyStyle) {\\n      // Browsers without 3D support, e.g. IE9\\n      return 'translate';\\n    } else {\\n      // Browsers without translate() support, e.g. IE7-8\\n      return 'margin';\\n    }\\n  };\\n\\n  /**\\n   * Helpers\\n   */\\n\\n  function clamp(n, min, max) {\\n    if (n < min) return min;\\n    if (n > max) return max;\\n    return n;\\n  }\\n\\n  /**\\n   * (Internal) converts a percentage (`0..1`) to a bar translateX\\n   * percentage (`-100%..0%`).\\n   */\\n\\n  function toBarPerc(n) {\\n    return (-1 + n) * 100;\\n  }\\n\\n\\n  /**\\n   * (Internal) returns the correct CSS for changing the bar's\\n   * position given an n percentage, and speed and ease from Settings\\n   */\\n\\n  function barPositionCSS(n, speed, ease) {\\n    var barCSS;\\n\\n    if (Settings.positionUsing === 'translate3d') {\\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\\n    } else if (Settings.positionUsing === 'translate') {\\n      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\\n    } else {\\n      barCSS = { 'margin-left': toBarPerc(n)+'%' };\\n    }\\n\\n    barCSS.transition = 'all '+speed+'ms '+ease;\\n\\n    return barCSS;\\n  }\\n\\n  /**\\n   * (Internal) Queues a function to be executed.\\n   */\\n\\n  var queue = (function() {\\n    var pending = [];\\n    \\n    function next() {\\n      var fn = pending.shift();\\n      if (fn) {\\n        fn(next);\\n      }\\n    }\\n\\n    return function(fn) {\\n      pending.push(fn);\\n      if (pending.length == 1) next();\\n    };\\n  })();\\n\\n  /**\\n   * (Internal) Applies css properties to an element, similar to the jQuery \\n   * css method.\\n   *\\n   * While this helper does assist with vendor prefixed property names, it \\n   * does not perform any manipulation of values prior to setting styles.\\n   */\\n\\n  var css = (function() {\\n    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\\n        cssProps    = {};\\n\\n    function camelCase(string) {\\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\\\da-z])/gi, function(match, letter) {\\n        return letter.toUpperCase();\\n      });\\n    }\\n\\n    function getVendorProp(name) {\\n      var style = document.body.style;\\n      if (name in style) return name;\\n\\n      var i = cssPrefixes.length,\\n          capName = name.charAt(0).toUpperCase() + name.slice(1),\\n          vendorName;\\n      while (i--) {\\n        vendorName = cssPrefixes[i] + capName;\\n        if (vendorName in style) return vendorName;\\n      }\\n\\n      return name;\\n    }\\n\\n    function getStyleProp(name) {\\n      name = camelCase(name);\\n      return cssProps[name] || (cssProps[name] = getVendorProp(name));\\n    }\\n\\n    function applyCss(element, prop, value) {\\n      prop = getStyleProp(prop);\\n      element.style[prop] = value;\\n    }\\n\\n    return function(element, properties) {\\n      var args = arguments,\\n          prop, \\n          value;\\n\\n      if (args.length == 2) {\\n        for (prop in properties) {\\n          value = properties[prop];\\n          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\\n        }\\n      } else {\\n        applyCss(element, args[1], args[2]);\\n      }\\n    }\\n  })();\\n\\n  /**\\n   * (Internal) Determines if an element or space separated list of class names contains a class name.\\n   */\\n\\n  function hasClass(element, name) {\\n    var list = typeof element == 'string' ? element : classList(element);\\n    return list.indexOf(' ' + name + ' ') >= 0;\\n  }\\n\\n  /**\\n   * (Internal) Adds a class to an element.\\n   */\\n\\n  function addClass(element, name) {\\n    var oldList = classList(element),\\n        newList = oldList + name;\\n\\n    if (hasClass(oldList, name)) return; \\n\\n    // Trim the opening space.\\n    element.className = newList.substring(1);\\n  }\\n\\n  /**\\n   * (Internal) Removes a class from an element.\\n   */\\n\\n  function removeClass(element, name) {\\n    var oldList = classList(element),\\n        newList;\\n\\n    if (!hasClass(element, name)) return;\\n\\n    // Replace the class name.\\n    newList = oldList.replace(' ' + name + ' ', ' ');\\n\\n    // Trim the opening and closing spaces.\\n    element.className = newList.substring(1, newList.length - 1);\\n  }\\n\\n  /**\\n   * (Internal) Gets a space separated list of the class names on the element. \\n   * The list is wrapped with a single space on each end to facilitate finding \\n   * matches within the list.\\n   */\\n\\n  function classList(element) {\\n    return (' ' + (element.className || '') + ' ').replace(/\\\\s+/gi, ' ');\\n  }\\n\\n  /**\\n   * (Internal) Removes an element from the DOM.\\n   */\\n\\n  function removeElement(element) {\\n    element && element.parentNode && element.parentNode.removeChild(element);\\n  }\\n\\n  return NProgress;\\n});\\n\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ucHJvZ3Jlc3MvbnByb2dyZXNzLmpzPzMyM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyogTlByb2dyZXNzLCAoYykgMjAxMywgMjAxNCBSaWNvIFN0YS4gQ3J1eiAtIGh0dHA6Ly9yaWNvc3RhY3J1ei5jb20vbnByb2dyZXNzXG4gKiBAbGljZW5zZSBNSVQgKi9cblxuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290Lk5Qcm9ncmVzcyA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgdmFyIE5Qcm9ncmVzcyA9IHt9O1xuXG4gIE5Qcm9ncmVzcy52ZXJzaW9uID0gJzAuMi4wJztcblxuICB2YXIgU2V0dGluZ3MgPSBOUHJvZ3Jlc3Muc2V0dGluZ3MgPSB7XG4gICAgbWluaW11bTogMC4wOCxcbiAgICBlYXNpbmc6ICdlYXNlJyxcbiAgICBwb3NpdGlvblVzaW5nOiAnJyxcbiAgICBzcGVlZDogMjAwLFxuICAgIHRyaWNrbGU6IHRydWUsXG4gICAgdHJpY2tsZVJhdGU6IDAuMDIsXG4gICAgdHJpY2tsZVNwZWVkOiA4MDAsXG4gICAgc2hvd1NwaW5uZXI6IHRydWUsXG4gICAgYmFyU2VsZWN0b3I6ICdbcm9sZT1cImJhclwiXScsXG4gICAgc3Bpbm5lclNlbGVjdG9yOiAnW3JvbGU9XCJzcGlubmVyXCJdJyxcbiAgICBwYXJlbnQ6ICdib2R5JyxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJiYXJcIiByb2xlPVwiYmFyXCI+PGRpdiBjbGFzcz1cInBlZ1wiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJzcGlubmVyXCIgcm9sZT1cInNwaW5uZXJcIj48ZGl2IGNsYXNzPVwic3Bpbm5lci1pY29uXCI+PC9kaXY+PC9kaXY+J1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuY29uZmlndXJlKHtcbiAgICogICAgICAgbWluaW11bTogMC4xXG4gICAqICAgICB9KTtcbiAgICovXG4gIE5Qcm9ncmVzcy5jb25maWd1cmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIFNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTGFzdCBudW1iZXIuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5zdGF0dXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9ncmVzcyBiYXIgc3RhdHVzLCB3aGVyZSBgbmAgaXMgYSBudW1iZXIgZnJvbSBgMC4wYCB0byBgMS4wYC5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMC40KTtcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMS4wKTtcbiAgICovXG5cbiAgTlByb2dyZXNzLnNldCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgc3RhcnRlZCA9IE5Qcm9ncmVzcy5pc1N0YXJ0ZWQoKTtcblxuICAgIG4gPSBjbGFtcChuLCBTZXR0aW5ncy5taW5pbXVtLCAxKTtcbiAgICBOUHJvZ3Jlc3Muc3RhdHVzID0gKG4gPT09IDEgPyBudWxsIDogbik7XG5cbiAgICB2YXIgcHJvZ3Jlc3MgPSBOUHJvZ3Jlc3MucmVuZGVyKCFzdGFydGVkKSxcbiAgICAgICAgYmFyICAgICAgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLmJhclNlbGVjdG9yKSxcbiAgICAgICAgc3BlZWQgICAgPSBTZXR0aW5ncy5zcGVlZCxcbiAgICAgICAgZWFzZSAgICAgPSBTZXR0aW5ncy5lYXNpbmc7XG5cbiAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDsgLyogUmVwYWludCAqL1xuXG4gICAgcXVldWUoZnVuY3Rpb24obmV4dCkge1xuICAgICAgLy8gU2V0IHBvc2l0aW9uVXNpbmcgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzZXRcbiAgICAgIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAnJykgU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9IE5Qcm9ncmVzcy5nZXRQb3NpdGlvbmluZ0NTUygpO1xuXG4gICAgICAvLyBBZGQgdHJhbnNpdGlvblxuICAgICAgY3NzKGJhciwgYmFyUG9zaXRpb25DU1Mobiwgc3BlZWQsIGVhc2UpKTtcblxuICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgY3NzKHByb2dyZXNzLCB7IFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJywgXG4gICAgICAgICAgb3BhY2l0eTogMSBcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2dyZXNzLm9mZnNldFdpZHRoOyAvKiBSZXBhaW50ICovXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjc3MocHJvZ3Jlc3MsIHsgXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsICcgKyBzcGVlZCArICdtcyBsaW5lYXInLCBcbiAgICAgICAgICAgIG9wYWNpdHk6IDAgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9LCBzcGVlZCk7XG4gICAgICAgIH0sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQobmV4dCwgc3BlZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgTlByb2dyZXNzLmlzU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0eXBlb2YgTlByb2dyZXNzLnN0YXR1cyA9PT0gJ251bWJlcic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgc2V0dGluZyB0aGUgc3RhdHVzIHRvIDAlLCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGdvIGJhY2t3YXJkcy5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgKlxuICAgKi9cbiAgTlByb2dyZXNzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFOUHJvZ3Jlc3Muc3RhdHVzKSBOUHJvZ3Jlc3Muc2V0KDApO1xuXG4gICAgdmFyIHdvcmsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuO1xuICAgICAgICBOUHJvZ3Jlc3MudHJpY2tsZSgpO1xuICAgICAgICB3b3JrKCk7XG4gICAgICB9LCBTZXR0aW5ncy50cmlja2xlU3BlZWQpO1xuICAgIH07XG5cbiAgICBpZiAoU2V0dGluZ3MudHJpY2tsZSkgd29yaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlICpzb3J0IG9mKiB0aGUgc2FtZSBhcyBzZXR0aW5nIHRoZSBzdGF0dXMgdG8gMTAwJSwgd2l0aCB0aGVcbiAgICogZGlmZmVyZW5jZSBiZWluZyBgZG9uZSgpYCBtYWtlcyBzb21lIHBsYWNlYm8gZWZmZWN0IG9mIHNvbWUgcmVhbGlzdGljIG1vdGlvbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKCk7XG4gICAqXG4gICAqIElmIGB0cnVlYCBpcyBwYXNzZWQsIGl0IHdpbGwgc2hvdyB0aGUgcHJvZ3Jlc3MgYmFyIGV2ZW4gaWYgaXRzIGhpZGRlbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKHRydWUpO1xuICAgKi9cblxuICBOUHJvZ3Jlc3MuZG9uZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSAmJiAhTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gTlByb2dyZXNzLmluYygwLjMgKyAwLjUgKiBNYXRoLnJhbmRvbSgpKS5zZXQoMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgYnkgYSByYW5kb20gYW1vdW50LlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuaW5jID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgdmFyIG4gPSBOUHJvZ3Jlc3Muc3RhdHVzO1xuXG4gICAgaWYgKCFuKSB7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBhbW91bnQgPSAoMSAtIG4pICogY2xhbXAoTWF0aC5yYW5kb20oKSAqIG4sIDAuMSwgMC45NSk7XG4gICAgICB9XG5cbiAgICAgIG4gPSBjbGFtcChuICsgYW1vdW50LCAwLCAwLjk5NCk7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnNldChuKTtcbiAgICB9XG4gIH07XG5cbiAgTlByb2dyZXNzLnRyaWNrbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTlByb2dyZXNzLmluYyhNYXRoLnJhbmRvbSgpICogU2V0dGluZ3MudHJpY2tsZVJhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYWxsIHN1cHBsaWVkIGpRdWVyeSBwcm9taXNlcyBhbmRcbiAgICogaW5jcmVhc2VzIHRoZSBwcm9ncmVzcyBhcyB0aGUgcHJvbWlzZXMgcmVzb2x2ZS5cbiAgICpcbiAgICogQHBhcmFtICRwcm9taXNlIGpRVWVyeSBQcm9taXNlXG4gICAqL1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluaXRpYWwgPSAwLCBjdXJyZW50ID0gMDtcblxuICAgIE5Qcm9ncmVzcy5wcm9taXNlID0gZnVuY3Rpb24oJHByb21pc2UpIHtcbiAgICAgIGlmICghJHByb21pc2UgfHwgJHByb21pc2Uuc3RhdGUoKSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA9PT0gMCkge1xuICAgICAgICBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbCsrO1xuICAgICAgY3VycmVudCsrO1xuXG4gICAgICAkcHJvbWlzZS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGN1cnJlbnQtLTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWwgPSAwO1xuICAgICAgICAgICAgTlByb2dyZXNzLmRvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5zZXQoKGluaXRpYWwgLSBjdXJyZW50KSAvIGluaXRpYWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJlbmRlcnMgdGhlIHByb2dyZXNzIGJhciBtYXJrdXAgYmFzZWQgb24gdGhlIGB0ZW1wbGF0ZWBcbiAgICogc2V0dGluZy5cbiAgICovXG5cbiAgTlByb2dyZXNzLnJlbmRlciA9IGZ1bmN0aW9uKGZyb21TdGFydCkge1xuICAgIGlmIChOUHJvZ3Jlc3MuaXNSZW5kZXJlZCgpKSByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICBcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcm9ncmVzcy5pZCA9ICducHJvZ3Jlc3MnO1xuICAgIHByb2dyZXNzLmlubmVySFRNTCA9IFNldHRpbmdzLnRlbXBsYXRlO1xuXG4gICAgdmFyIGJhciAgICAgID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5iYXJTZWxlY3RvciksXG4gICAgICAgIHBlcmMgICAgID0gZnJvbVN0YXJ0ID8gJy0xMDAnIDogdG9CYXJQZXJjKE5Qcm9ncmVzcy5zdGF0dXMgfHwgMCksXG4gICAgICAgIHBhcmVudCAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5wYXJlbnQpLFxuICAgICAgICBzcGlubmVyO1xuICAgIFxuICAgIGNzcyhiYXIsIHtcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMCBsaW5lYXInLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIHBlcmMgKyAnJSwwLDApJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFTZXR0aW5ncy5zaG93U3Bpbm5lcikge1xuICAgICAgc3Bpbm5lciA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3Muc3Bpbm5lclNlbGVjdG9yKTtcbiAgICAgIHNwaW5uZXIgJiYgcmVtb3ZlRWxlbWVudChzcGlubmVyKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ICE9IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGFkZENsYXNzKHBhcmVudCwgJ25wcm9ncmVzcy1jdXN0b20tcGFyZW50Jyk7XG4gICAgfVxuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHByb2dyZXNzKTtcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQuIE9wcG9zaXRlIG9mIHJlbmRlcigpLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnBhcmVudCksICducHJvZ3Jlc3MtY3VzdG9tLXBhcmVudCcpO1xuICAgIHZhciBwcm9ncmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcbiAgICBwcm9ncmVzcyAmJiByZW1vdmVFbGVtZW50KHByb2dyZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwcm9ncmVzcyBiYXIgaXMgcmVuZGVyZWQuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5pc1JlbmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hpY2ggcG9zaXRpb25pbmcgQ1NTIHJ1bGUgdG8gdXNlLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuZ2V0UG9zaXRpb25pbmdDU1MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTbmlmZiBvbiBkb2N1bWVudC5ib2R5LnN0eWxlXG4gICAgdmFyIGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG5cbiAgICAvLyBTbmlmZiBwcmVmaXhlc1xuICAgIHZhciB2ZW5kb3JQcmVmaXggPSAoJ1dlYmtpdFRyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdXZWJraXQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdNb3pUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnTW96JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnbXNUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnbXMnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdPVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ08nIDogJyc7XG5cbiAgICBpZiAodmVuZG9yUHJlZml4ICsgJ1BlcnNwZWN0aXZlJyBpbiBib2R5U3R5bGUpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VycyB3aXRoIDNEIHN1cHBvcnQsIGUuZy4gV2Via2l0LCBJRTEwXG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkJztcbiAgICB9IGVsc2UgaWYgKHZlbmRvclByZWZpeCArICdUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkge1xuICAgICAgLy8gQnJvd3NlcnMgd2l0aG91dCAzRCBzdXBwb3J0LCBlLmcuIElFOVxuICAgICAgcmV0dXJuICd0cmFuc2xhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VycyB3aXRob3V0IHRyYW5zbGF0ZSgpIHN1cHBvcnQsIGUuZy4gSUU3LThcbiAgICAgIHJldHVybiAnbWFyZ2luJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhbXAobiwgbWluLCBtYXgpIHtcbiAgICBpZiAobiA8IG1pbikgcmV0dXJuIG1pbjtcbiAgICBpZiAobiA+IG1heCkgcmV0dXJuIG1heDtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIGNvbnZlcnRzIGEgcGVyY2VudGFnZSAoYDAuLjFgKSB0byBhIGJhciB0cmFuc2xhdGVYXG4gICAqIHBlcmNlbnRhZ2UgKGAtMTAwJS4uMCVgKS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9CYXJQZXJjKG4pIHtcbiAgICByZXR1cm4gKC0xICsgbikgKiAxMDA7XG4gIH1cblxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJldHVybnMgdGhlIGNvcnJlY3QgQ1NTIGZvciBjaGFuZ2luZyB0aGUgYmFyJ3NcbiAgICogcG9zaXRpb24gZ2l2ZW4gYW4gbiBwZXJjZW50YWdlLCBhbmQgc3BlZWQgYW5kIGVhc2UgZnJvbSBTZXR0aW5nc1xuICAgKi9cblxuICBmdW5jdGlvbiBiYXJQb3NpdGlvbkNTUyhuLCBzcGVlZCwgZWFzZSkge1xuICAgIHZhciBiYXJDU1M7XG5cbiAgICBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZTNkJykge1xuICAgICAgYmFyQ1NTID0geyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnK3RvQmFyUGVyYyhuKSsnJSwwLDApJyB9O1xuICAgIH0gZWxzZSBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZScpIHtcbiAgICAgIGJhckNTUyA9IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcrdG9CYXJQZXJjKG4pKyclLDApJyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJDU1MgPSB7ICdtYXJnaW4tbGVmdCc6IHRvQmFyUGVyYyhuKSsnJScgfTtcbiAgICB9XG5cbiAgICBiYXJDU1MudHJhbnNpdGlvbiA9ICdhbGwgJytzcGVlZCsnbXMgJytlYXNlO1xuXG4gICAgcmV0dXJuIGJhckNTUztcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIFF1ZXVlcyBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKi9cblxuICB2YXIgcXVldWUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBlbmRpbmcgPSBbXTtcbiAgICBcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIGZuID0gcGVuZGluZy5zaGlmdCgpO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgcGVuZGluZy5wdXNoKGZuKTtcbiAgICAgIGlmIChwZW5kaW5nLmxlbmd0aCA9PSAxKSBuZXh0KCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSBBcHBsaWVzIGNzcyBwcm9wZXJ0aWVzIHRvIGFuIGVsZW1lbnQsIHNpbWlsYXIgdG8gdGhlIGpRdWVyeSBcbiAgICogY3NzIG1ldGhvZC5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBoZWxwZXIgZG9lcyBhc3Npc3Qgd2l0aCB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkgbmFtZXMsIGl0IFxuICAgKiBkb2VzIG5vdCBwZXJmb3JtIGFueSBtYW5pcHVsYXRpb24gb2YgdmFsdWVzIHByaW9yIHRvIHNldHRpbmcgc3R5bGVzLlxuICAgKi9cblxuICB2YXIgY3NzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjc3NQcmVmaXhlcyA9IFsgJ1dlYmtpdCcsICdPJywgJ01veicsICdtcycgXSxcbiAgICAgICAgY3NzUHJvcHMgICAgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXi1tcy0vLCAnbXMtJykucmVwbGFjZSgvLShbXFxkYS16XSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmVuZG9yUHJvcChuYW1lKSB7XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgaWYgKG5hbWUgaW4gc3R5bGUpIHJldHVybiBuYW1lO1xuXG4gICAgICB2YXIgaSA9IGNzc1ByZWZpeGVzLmxlbmd0aCxcbiAgICAgICAgICBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgdmVuZG9yTmFtZTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmVuZG9yTmFtZSA9IGNzc1ByZWZpeGVzW2ldICsgY2FwTmFtZTtcbiAgICAgICAgaWYgKHZlbmRvck5hbWUgaW4gc3R5bGUpIHJldHVybiB2ZW5kb3JOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdHlsZVByb3AobmFtZSkge1xuICAgICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcbiAgICAgIHJldHVybiBjc3NQcm9wc1tuYW1lXSB8fCAoY3NzUHJvcHNbbmFtZV0gPSBnZXRWZW5kb3JQcm9wKG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJvcCA9IGdldFN0eWxlUHJvcChwcm9wKTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcHJvcCwgXG4gICAgICAgICAgdmFsdWU7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIGFwcGx5Q3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlDc3MoZWxlbWVudCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIERldGVybWluZXMgaWYgYW4gZWxlbWVudCBvciBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lcyBjb250YWlucyBhIGNsYXNzIG5hbWUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgbGlzdCA9IHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnID8gZWxlbWVudCA6IGNsYXNzTGlzdChlbGVtZW50KTtcbiAgICByZXR1cm4gbGlzdC5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpID49IDA7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBBZGRzIGEgY2xhc3MgdG8gYW4gZWxlbWVudC5cbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBvbGRMaXN0ID0gY2xhc3NMaXN0KGVsZW1lbnQpLFxuICAgICAgICBuZXdMaXN0ID0gb2xkTGlzdCArIG5hbWU7XG5cbiAgICBpZiAoaGFzQ2xhc3Mob2xkTGlzdCwgbmFtZSkpIHJldHVybjsgXG5cbiAgICAvLyBUcmltIHRoZSBvcGVuaW5nIHNwYWNlLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50LlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIG9sZExpc3QgPSBjbGFzc0xpc3QoZWxlbWVudCksXG4gICAgICAgIG5ld0xpc3Q7XG5cbiAgICBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpKSByZXR1cm47XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBjbGFzcyBuYW1lLlxuICAgIG5ld0xpc3QgPSBvbGRMaXN0LnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcblxuICAgIC8vIFRyaW0gdGhlIG9wZW5pbmcgYW5kIGNsb3Npbmcgc3BhY2VzLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSwgbmV3TGlzdC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIEdldHMgYSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiB0aGUgY2xhc3MgbmFtZXMgb24gdGhlIGVsZW1lbnQuIFxuICAgKiBUaGUgbGlzdCBpcyB3cmFwcGVkIHdpdGggYSBzaW5nbGUgc3BhY2Ugb24gZWFjaCBlbmQgdG8gZmFjaWxpdGF0ZSBmaW5kaW5nIFxuICAgKiBtYXRjaGVzIHdpdGhpbiB0aGUgbGlzdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhc3NMaXN0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gKCcgJyArIChlbGVtZW50LmNsYXNzTmFtZSB8fCAnJykgKyAnICcpLnJlcGxhY2UoL1xccysvZ2ksICcgJyk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gTlByb2dyZXNzO1xufSk7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///0\\n\")},function(module,exports,__webpack_require__){eval('!function (e, t) {\\n   true ? module.exports = t() : undefined;\\n}(this, function () {\\n  return function (e) {\\n    var t = {};\\n\\n    function n(i) {\\n      if (t[i]) return t[i].exports;\\n      var o = t[i] = {\\n        i: i,\\n        l: !1,\\n        exports: {}\\n      };\\n      return e[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\\n    }\\n\\n    return n.m = e, n.c = t, n.d = function (e, t, i) {\\n      n.o(e, t) || Object.defineProperty(e, t, {\\n        enumerable: !0,\\n        get: i\\n      });\\n    }, n.r = function (e) {\\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\\n        value: \"Module\"\\n      }), Object.defineProperty(e, \"__esModule\", {\\n        value: !0\\n      });\\n    }, n.t = function (e, t) {\\n      if (1 & t && (e = n(e)), 8 & t) return e;\\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\\n      var i = Object.create(null);\\n      if (n.r(i), Object.defineProperty(i, \"default\", {\\n        enumerable: !0,\\n        value: e\\n      }), 2 & t && \"string\" != typeof e) for (var o in e) n.d(i, o, function (t) {\\n        return e[t];\\n      }.bind(null, o));\\n      return i;\\n    }, n.n = function (e) {\\n      var t = e && e.__esModule ? function () {\\n        return e.default;\\n      } : function () {\\n        return e;\\n      };\\n      return n.d(t, \"a\", t), t;\\n    }, n.o = function (e, t) {\\n      return Object.prototype.hasOwnProperty.call(e, t);\\n    }, n.p = \"\", n(n.s = 0);\\n  }([function (e, t, n) {\\n    (function (t) {\\n      e.exports = t.Phoenix = n(2);\\n    }).call(this, n(1));\\n  }, function (e, t) {\\n    var n;\\n\\n    n = function () {\\n      return this;\\n    }();\\n\\n    try {\\n      n = n || new Function(\"return this\")();\\n    } catch (e) {\\n      \"object\" == typeof window && (n = window);\\n    }\\n\\n    e.exports = n;\\n  }, function (e, t, n) {\\n    \"use strict\";\\n\\n    function i(e) {\\n      return function (e) {\\n        if (Array.isArray(e)) return a(e);\\n      }(e) || function (e) {\\n        if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);\\n      }(e) || s(e) || function () {\\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\\n      }();\\n    }\\n\\n    function o(e) {\\n      return (o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\\n        return typeof e;\\n      } : function (e) {\\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\\n      })(e);\\n    }\\n\\n    function r(e, t) {\\n      return function (e) {\\n        if (Array.isArray(e)) return e;\\n      }(e) || function (e, t) {\\n        if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(e))) return;\\n        var n = [],\\n            i = !0,\\n            o = !1,\\n            r = void 0;\\n\\n        try {\\n          for (var s, a = e[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); i = !0);\\n        } catch (e) {\\n          o = !0, r = e;\\n        } finally {\\n          try {\\n            i || null == a.return || a.return();\\n          } finally {\\n            if (o) throw r;\\n          }\\n        }\\n\\n        return n;\\n      }(e, t) || s(e, t) || function () {\\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\\n      }();\\n    }\\n\\n    function s(e, t) {\\n      if (e) {\\n        if (\"string\" == typeof e) return a(e, t);\\n        var n = Object.prototype.toString.call(e).slice(8, -1);\\n        return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(n) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0;\\n      }\\n    }\\n\\n    function a(e, t) {\\n      (null == t || t > e.length) && (t = e.length);\\n\\n      for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\\n\\n      return i;\\n    }\\n\\n    function c(e, t) {\\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\\n    }\\n\\n    function u(e, t) {\\n      for (var n = 0; n < t.length; n++) {\\n        var i = t[n];\\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\\n      }\\n    }\\n\\n    function h(e, t, n) {\\n      return t && u(e.prototype, t), n && u(e, n), e;\\n    }\\n\\n    n.r(t), n.d(t, \"Channel\", function () {\\n      return _;\\n    }), n.d(t, \"Serializer\", function () {\\n      return H;\\n    }), n.d(t, \"Socket\", function () {\\n      return U;\\n    }), n.d(t, \"LongPoll\", function () {\\n      return D;\\n    }), n.d(t, \"Ajax\", function () {\\n      return M;\\n    }), n.d(t, \"Presence\", function () {\\n      return N;\\n    });\\n\\n    var l = \"undefined\" != typeof self ? self : null,\\n        f = \"undefined\" != typeof window ? window : null,\\n        d = l || f || void 0,\\n        p = 0,\\n        v = 1,\\n        y = 2,\\n        m = 3,\\n        g = \"closed\",\\n        k = \"errored\",\\n        b = \"joined\",\\n        j = \"joining\",\\n        C = \"leaving\",\\n        E = \"phx_close\",\\n        R = \"phx_error\",\\n        T = \"phx_join\",\\n        S = \"phx_reply\",\\n        w = \"phx_leave\",\\n        A = [E, R, T, S, w],\\n        L = \"longpoll\",\\n        x = \"websocket\",\\n        O = function (e) {\\n      if (\"function\" == typeof e) return e;\\n      return function () {\\n        return e;\\n      };\\n    },\\n        P = function () {\\n      function e(t, n, i, o) {\\n        c(this, e), this.channel = t, this.event = n, this.payload = i || function () {\\n          return {};\\n        }, this.receivedResp = null, this.timeout = o, this.timeoutTimer = null, this.recHooks = [], this.sent = !1;\\n      }\\n\\n      return h(e, [{\\n        key: \"resend\",\\n        value: function (e) {\\n          this.timeout = e, this.reset(), this.send();\\n        }\\n      }, {\\n        key: \"send\",\\n        value: function () {\\n          this.hasReceived(\"timeout\") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({\\n            topic: this.channel.topic,\\n            event: this.event,\\n            payload: this.payload(),\\n            ref: this.ref,\\n            join_ref: this.channel.joinRef()\\n          }));\\n        }\\n      }, {\\n        key: \"receive\",\\n        value: function (e, t) {\\n          return this.hasReceived(e) && t(this.receivedResp.response), this.recHooks.push({\\n            status: e,\\n            callback: t\\n          }), this;\\n        }\\n      }, {\\n        key: \"reset\",\\n        value: function () {\\n          this.cancelRefEvent(), this.ref = null, this.refEvent = null, this.receivedResp = null, this.sent = !1;\\n        }\\n      }, {\\n        key: \"matchReceive\",\\n        value: function (e) {\\n          var t = e.status,\\n              n = e.response;\\n          e.ref;\\n          this.recHooks.filter(function (e) {\\n            return e.status === t;\\n          }).forEach(function (e) {\\n            return e.callback(n);\\n          });\\n        }\\n      }, {\\n        key: \"cancelRefEvent\",\\n        value: function () {\\n          this.refEvent && this.channel.off(this.refEvent);\\n        }\\n      }, {\\n        key: \"cancelTimeout\",\\n        value: function () {\\n          clearTimeout(this.timeoutTimer), this.timeoutTimer = null;\\n        }\\n      }, {\\n        key: \"startTimeout\",\\n        value: function () {\\n          var e = this;\\n          this.timeoutTimer && this.cancelTimeout(), this.ref = this.channel.socket.makeRef(), this.refEvent = this.channel.replyEventName(this.ref), this.channel.on(this.refEvent, function (t) {\\n            e.cancelRefEvent(), e.cancelTimeout(), e.receivedResp = t, e.matchReceive(t);\\n          }), this.timeoutTimer = setTimeout(function () {\\n            e.trigger(\"timeout\", {});\\n          }, this.timeout);\\n        }\\n      }, {\\n        key: \"hasReceived\",\\n        value: function (e) {\\n          return this.receivedResp && this.receivedResp.status === e;\\n        }\\n      }, {\\n        key: \"trigger\",\\n        value: function (e, t) {\\n          this.channel.trigger(this.refEvent, {\\n            status: e,\\n            response: t\\n          });\\n        }\\n      }]), e;\\n    }(),\\n        _ = function () {\\n      function e(t, n, i) {\\n        var o = this;\\n        c(this, e), this.state = g, this.topic = t, this.params = O(n || {}), this.socket = i, this.bindings = [], this.bindingRef = 0, this.timeout = this.socket.timeout, this.joinedOnce = !1, this.joinPush = new P(this, T, this.params, this.timeout), this.pushBuffer = [], this.stateChangeRefs = [], this.rejoinTimer = new J(function () {\\n          o.socket.isConnected() && o.rejoin();\\n        }, this.socket.rejoinAfterMs), this.stateChangeRefs.push(this.socket.onError(function () {\\n          return o.rejoinTimer.reset();\\n        })), this.stateChangeRefs.push(this.socket.onOpen(function () {\\n          o.rejoinTimer.reset(), o.isErrored() && o.rejoin();\\n        })), this.joinPush.receive(\"ok\", function () {\\n          o.state = b, o.rejoinTimer.reset(), o.pushBuffer.forEach(function (e) {\\n            return e.send();\\n          }), o.pushBuffer = [];\\n        }), this.joinPush.receive(\"error\", function () {\\n          o.state = k, o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\\n        }), this.onClose(function () {\\n          o.rejoinTimer.reset(), o.socket.hasLogger() && o.socket.log(\"channel\", \"close \".concat(o.topic, \" \").concat(o.joinRef())), o.state = g, o.socket.remove(o);\\n        }), this.onError(function (e) {\\n          o.socket.hasLogger() && o.socket.log(\"channel\", \"error \".concat(o.topic), e), o.isJoining() && o.joinPush.reset(), o.state = k, o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\\n        }), this.joinPush.receive(\"timeout\", function () {\\n          o.socket.hasLogger() && o.socket.log(\"channel\", \"timeout \".concat(o.topic, \" (\").concat(o.joinRef(), \")\"), o.joinPush.timeout), new P(o, w, O({}), o.timeout).send(), o.state = k, o.joinPush.reset(), o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\\n        }), this.on(S, function (e, t) {\\n          o.trigger(o.replyEventName(t), e);\\n        });\\n      }\\n\\n      return h(e, [{\\n        key: \"join\",\\n        value: function () {\\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\\n          if (this.joinedOnce) throw new Error(\"tried to join multiple times. \\'join\\' can only be called a single time per channel instance\");\\n          return this.timeout = e, this.joinedOnce = !0, this.rejoin(), this.joinPush;\\n        }\\n      }, {\\n        key: \"onClose\",\\n        value: function (e) {\\n          this.on(E, e);\\n        }\\n      }, {\\n        key: \"onError\",\\n        value: function (e) {\\n          return this.on(R, function (t) {\\n            return e(t);\\n          });\\n        }\\n      }, {\\n        key: \"on\",\\n        value: function (e, t) {\\n          var n = this.bindingRef++;\\n          return this.bindings.push({\\n            event: e,\\n            ref: n,\\n            callback: t\\n          }), n;\\n        }\\n      }, {\\n        key: \"off\",\\n        value: function (e, t) {\\n          this.bindings = this.bindings.filter(function (n) {\\n            return !(n.event === e && (void 0 === t || t === n.ref));\\n          });\\n        }\\n      }, {\\n        key: \"canPush\",\\n        value: function () {\\n          return this.socket.isConnected() && this.isJoined();\\n        }\\n      }, {\\n        key: \"push\",\\n        value: function (e, t) {\\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.timeout;\\n          if (t = t || {}, !this.joinedOnce) throw new Error(\"tried to push \\'\".concat(e, \"\\' to \\'\").concat(this.topic, \"\\' before joining. Use channel.join() before pushing events\"));\\n          var i = new P(this, e, function () {\\n            return t;\\n          }, n);\\n          return this.canPush() ? i.send() : (i.startTimeout(), this.pushBuffer.push(i)), i;\\n        }\\n      }, {\\n        key: \"leave\",\\n        value: function () {\\n          var e = this,\\n              t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\\n          this.rejoinTimer.reset(), this.joinPush.cancelTimeout(), this.state = C;\\n\\n          var n = function () {\\n            e.socket.hasLogger() && e.socket.log(\"channel\", \"leave \".concat(e.topic)), e.trigger(E, \"leave\");\\n          },\\n              i = new P(this, w, O({}), t);\\n\\n          return i.receive(\"ok\", function () {\\n            return n();\\n          }).receive(\"timeout\", function () {\\n            return n();\\n          }), i.send(), this.canPush() || i.trigger(\"ok\", {}), i;\\n        }\\n      }, {\\n        key: \"onMessage\",\\n        value: function (e, t, n) {\\n          return t;\\n        }\\n      }, {\\n        key: \"isLifecycleEvent\",\\n        value: function (e) {\\n          return A.indexOf(e) >= 0;\\n        }\\n      }, {\\n        key: \"isMember\",\\n        value: function (e, t, n, i) {\\n          return this.topic === e && (!i || i === this.joinRef() || !this.isLifecycleEvent(t) || (this.socket.hasLogger() && this.socket.log(\"channel\", \"dropping outdated message\", {\\n            topic: e,\\n            event: t,\\n            payload: n,\\n            joinRef: i\\n          }), !1));\\n        }\\n      }, {\\n        key: \"joinRef\",\\n        value: function () {\\n          return this.joinPush.ref;\\n        }\\n      }, {\\n        key: \"rejoin\",\\n        value: function () {\\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\\n          this.isLeaving() || (this.socket.leaveOpenTopic(this.topic), this.state = j, this.joinPush.resend(e));\\n        }\\n      }, {\\n        key: \"trigger\",\\n        value: function (e, t, n, i) {\\n          var o = this.onMessage(e, t, n, i);\\n          if (t && !o) throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\\n\\n          for (var r = this.bindings.filter(function (t) {\\n            return t.event === e;\\n          }), s = 0; s < r.length; s++) {\\n            r[s].callback(o, n, i || this.joinRef());\\n          }\\n        }\\n      }, {\\n        key: \"replyEventName\",\\n        value: function (e) {\\n          return \"chan_reply_\".concat(e);\\n        }\\n      }, {\\n        key: \"isClosed\",\\n        value: function () {\\n          return this.state === g;\\n        }\\n      }, {\\n        key: \"isErrored\",\\n        value: function () {\\n          return this.state === k;\\n        }\\n      }, {\\n        key: \"isJoined\",\\n        value: function () {\\n          return this.state === b;\\n        }\\n      }, {\\n        key: \"isJoining\",\\n        value: function () {\\n          return this.state === j;\\n        }\\n      }, {\\n        key: \"isLeaving\",\\n        value: function () {\\n          return this.state === C;\\n        }\\n      }]), e;\\n    }(),\\n        H = {\\n      HEADER_LENGTH: 1,\\n      META_LENGTH: 4,\\n      KINDS: {\\n        push: 0,\\n        reply: 1,\\n        broadcast: 2\\n      },\\n      encode: function (e, t) {\\n        if (e.payload.constructor === ArrayBuffer) return t(this.binaryEncode(e));\\n        var n = [e.join_ref, e.ref, e.topic, e.event, e.payload];\\n        return t(JSON.stringify(n));\\n      },\\n      decode: function (e, t) {\\n        if (e.constructor === ArrayBuffer) return t(this.binaryDecode(e));\\n        var n = r(JSON.parse(e), 5);\\n        return t({\\n          join_ref: n[0],\\n          ref: n[1],\\n          topic: n[2],\\n          event: n[3],\\n          payload: n[4]\\n        });\\n      },\\n      binaryEncode: function (e) {\\n        var t = e.join_ref,\\n            n = e.ref,\\n            i = e.event,\\n            o = e.topic,\\n            r = e.payload,\\n            s = this.META_LENGTH + t.length + n.length + o.length + i.length,\\n            a = new ArrayBuffer(this.HEADER_LENGTH + s),\\n            c = new DataView(a),\\n            u = 0;\\n        c.setUint8(u++, this.KINDS.push), c.setUint8(u++, t.length), c.setUint8(u++, n.length), c.setUint8(u++, o.length), c.setUint8(u++, i.length), Array.from(t, function (e) {\\n          return c.setUint8(u++, e.charCodeAt(0));\\n        }), Array.from(n, function (e) {\\n          return c.setUint8(u++, e.charCodeAt(0));\\n        }), Array.from(o, function (e) {\\n          return c.setUint8(u++, e.charCodeAt(0));\\n        }), Array.from(i, function (e) {\\n          return c.setUint8(u++, e.charCodeAt(0));\\n        });\\n        var h = new Uint8Array(a.byteLength + r.byteLength);\\n        return h.set(new Uint8Array(a), 0), h.set(new Uint8Array(r), a.byteLength), h.buffer;\\n      },\\n      binaryDecode: function (e) {\\n        var t = new DataView(e),\\n            n = t.getUint8(0),\\n            i = new TextDecoder();\\n\\n        switch (n) {\\n          case this.KINDS.push:\\n            return this.decodePush(e, t, i);\\n\\n          case this.KINDS.reply:\\n            return this.decodeReply(e, t, i);\\n\\n          case this.KINDS.broadcast:\\n            return this.decodeBroadcast(e, t, i);\\n        }\\n      },\\n      decodePush: function (e, t, n) {\\n        var i = t.getUint8(1),\\n            o = t.getUint8(2),\\n            r = t.getUint8(3),\\n            s = this.HEADER_LENGTH + this.META_LENGTH - 1,\\n            a = n.decode(e.slice(s, s + i));\\n        s += i;\\n        var c = n.decode(e.slice(s, s + o));\\n        s += o;\\n        var u = n.decode(e.slice(s, s + r));\\n        return s += r, {\\n          join_ref: a,\\n          ref: null,\\n          topic: c,\\n          event: u,\\n          payload: e.slice(s, e.byteLength)\\n        };\\n      },\\n      decodeReply: function (e, t, n) {\\n        var i = t.getUint8(1),\\n            o = t.getUint8(2),\\n            r = t.getUint8(3),\\n            s = t.getUint8(4),\\n            a = this.HEADER_LENGTH + this.META_LENGTH,\\n            c = n.decode(e.slice(a, a + i));\\n        a += i;\\n        var u = n.decode(e.slice(a, a + o));\\n        a += o;\\n        var h = n.decode(e.slice(a, a + r));\\n        a += r;\\n        var l = n.decode(e.slice(a, a + s));\\n        a += s;\\n        var f = e.slice(a, e.byteLength);\\n        return {\\n          join_ref: c,\\n          ref: u,\\n          topic: h,\\n          event: S,\\n          payload: {\\n            status: l,\\n            response: f\\n          }\\n        };\\n      },\\n      decodeBroadcast: function (e, t, n) {\\n        var i = t.getUint8(1),\\n            o = t.getUint8(2),\\n            r = this.HEADER_LENGTH + 2,\\n            s = n.decode(e.slice(r, r + i));\\n        r += i;\\n        var a = n.decode(e.slice(r, r + o));\\n        return r += o, {\\n          join_ref: null,\\n          ref: null,\\n          topic: s,\\n          event: a,\\n          payload: e.slice(r, e.byteLength)\\n        };\\n      }\\n    },\\n        U = function () {\\n      function e(t) {\\n        var n = this,\\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\\n        c(this, e), this.stateChangeCallbacks = {\\n          open: [],\\n          close: [],\\n          error: [],\\n          message: []\\n        }, this.channels = [], this.sendBuffer = [], this.ref = 0, this.timeout = i.timeout || 1e4, this.transport = i.transport || d.WebSocket || D, this.defaultEncoder = H.encode.bind(H), this.defaultDecoder = H.decode.bind(H), this.closeWasClean = !1, this.unloaded = !1, this.binaryType = i.binaryType || \"arraybuffer\", this.transport !== D ? (this.encode = i.encode || this.defaultEncoder, this.decode = i.decode || this.defaultDecoder) : (this.encode = this.defaultEncoder, this.decode = this.defaultDecoder), f && f.addEventListener && f.addEventListener(\"unload\", function (e) {\\n          n.conn && (n.unloaded = !0, n.abnormalClose(\"unloaded\"));\\n        }), this.heartbeatIntervalMs = i.heartbeatIntervalMs || 3e4, this.rejoinAfterMs = function (e) {\\n          return i.rejoinAfterMs ? i.rejoinAfterMs(e) : [1e3, 2e3, 5e3][e - 1] || 1e4;\\n        }, this.reconnectAfterMs = function (e) {\\n          return n.unloaded ? 100 : i.reconnectAfterMs ? i.reconnectAfterMs(e) : [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][e - 1] || 5e3;\\n        }, this.logger = i.logger || null, this.longpollerTimeout = i.longpollerTimeout || 2e4, this.params = O(i.params || {}), this.endPoint = \"\".concat(t, \"/\").concat(x), this.vsn = i.vsn || \"2.0.0\", this.heartbeatTimer = null, this.pendingHeartbeatRef = null, this.reconnectTimer = new J(function () {\\n          n.teardown(function () {\\n            return n.connect();\\n          });\\n        }, this.reconnectAfterMs);\\n      }\\n\\n      return h(e, [{\\n        key: \"protocol\",\\n        value: function () {\\n          return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\\n        }\\n      }, {\\n        key: \"endPointURL\",\\n        value: function () {\\n          var e = M.appendParams(M.appendParams(this.endPoint, this.params()), {\\n            vsn: this.vsn\\n          });\\n          return \"/\" !== e.charAt(0) ? e : \"/\" === e.charAt(1) ? \"\".concat(this.protocol(), \":\").concat(e) : \"\".concat(this.protocol(), \"://\").concat(location.host).concat(e);\\n        }\\n      }, {\\n        key: \"disconnect\",\\n        value: function (e, t, n) {\\n          this.closeWasClean = !0, this.reconnectTimer.reset(), this.teardown(e, t, n);\\n        }\\n      }, {\\n        key: \"connect\",\\n        value: function (e) {\\n          var t = this;\\n          e && (console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\"), this.params = O(e)), this.conn || (this.closeWasClean = !1, this.conn = new this.transport(this.endPointURL()), this.conn.binaryType = this.binaryType, this.conn.timeout = this.longpollerTimeout, this.conn.onopen = function () {\\n            return t.onConnOpen();\\n          }, this.conn.onerror = function (e) {\\n            return t.onConnError(e);\\n          }, this.conn.onmessage = function (e) {\\n            return t.onConnMessage(e);\\n          }, this.conn.onclose = function (e) {\\n            return t.onConnClose(e);\\n          });\\n        }\\n      }, {\\n        key: \"log\",\\n        value: function (e, t, n) {\\n          this.logger(e, t, n);\\n        }\\n      }, {\\n        key: \"hasLogger\",\\n        value: function () {\\n          return null !== this.logger;\\n        }\\n      }, {\\n        key: \"onOpen\",\\n        value: function (e) {\\n          var t = this.makeRef();\\n          return this.stateChangeCallbacks.open.push([t, e]), t;\\n        }\\n      }, {\\n        key: \"onClose\",\\n        value: function (e) {\\n          var t = this.makeRef();\\n          return this.stateChangeCallbacks.close.push([t, e]), t;\\n        }\\n      }, {\\n        key: \"onError\",\\n        value: function (e) {\\n          var t = this.makeRef();\\n          return this.stateChangeCallbacks.error.push([t, e]), t;\\n        }\\n      }, {\\n        key: \"onMessage\",\\n        value: function (e) {\\n          var t = this.makeRef();\\n          return this.stateChangeCallbacks.message.push([t, e]), t;\\n        }\\n      }, {\\n        key: \"onConnOpen\",\\n        value: function () {\\n          this.hasLogger() && this.log(\"transport\", \"connected to \".concat(this.endPointURL())), this.unloaded = !1, this.closeWasClean = !1, this.flushSendBuffer(), this.reconnectTimer.reset(), this.resetHeartbeat(), this.stateChangeCallbacks.open.forEach(function (e) {\\n            return (0, r(e, 2)[1])();\\n          });\\n        }\\n      }, {\\n        key: \"resetHeartbeat\",\\n        value: function () {\\n          var e = this;\\n          this.conn && this.conn.skipHeartbeat || (this.pendingHeartbeatRef = null, clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(function () {\\n            return e.sendHeartbeat();\\n          }, this.heartbeatIntervalMs));\\n        }\\n      }, {\\n        key: \"teardown\",\\n        value: function (e, t, n) {\\n          var i = this;\\n          if (!this.conn) return e && e();\\n          this.waitForBufferDone(function () {\\n            i.conn && (t ? i.conn.close(t, n || \"\") : i.conn.close()), i.waitForSocketClosed(function () {\\n              i.conn && (i.conn.onclose = function () {}, i.conn = null), e && e();\\n            });\\n          });\\n        }\\n      }, {\\n        key: \"waitForBufferDone\",\\n        value: function (e) {\\n          var t = this,\\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\\n          5 !== n && this.conn && this.conn.bufferedAmount ? setTimeout(function () {\\n            t.waitForBufferDone(e, n + 1);\\n          }, 150 * n) : e();\\n        }\\n      }, {\\n        key: \"waitForSocketClosed\",\\n        value: function (e) {\\n          var t = this,\\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\\n          5 !== n && this.conn && this.conn.readyState !== m ? setTimeout(function () {\\n            t.waitForSocketClosed(e, n + 1);\\n          }, 150 * n) : e();\\n        }\\n      }, {\\n        key: \"onConnClose\",\\n        value: function (e) {\\n          this.hasLogger() && this.log(\"transport\", \"close\", e), this.triggerChanError(), clearInterval(this.heartbeatTimer), this.closeWasClean || this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(function (t) {\\n            return (0, r(t, 2)[1])(e);\\n          });\\n        }\\n      }, {\\n        key: \"onConnError\",\\n        value: function (e) {\\n          this.hasLogger() && this.log(\"transport\", e), this.triggerChanError(), this.stateChangeCallbacks.error.forEach(function (t) {\\n            return (0, r(t, 2)[1])(e);\\n          });\\n        }\\n      }, {\\n        key: \"triggerChanError\",\\n        value: function () {\\n          this.channels.forEach(function (e) {\\n            e.isErrored() || e.isLeaving() || e.isClosed() || e.trigger(R);\\n          });\\n        }\\n      }, {\\n        key: \"connectionState\",\\n        value: function () {\\n          switch (this.conn && this.conn.readyState) {\\n            case p:\\n              return \"connecting\";\\n\\n            case v:\\n              return \"open\";\\n\\n            case y:\\n              return \"closing\";\\n\\n            default:\\n              return \"closed\";\\n          }\\n        }\\n      }, {\\n        key: \"isConnected\",\\n        value: function () {\\n          return \"open\" === this.connectionState();\\n        }\\n      }, {\\n        key: \"remove\",\\n        value: function (e) {\\n          this.off(e.stateChangeRefs), this.channels = this.channels.filter(function (t) {\\n            return t.joinRef() !== e.joinRef();\\n          });\\n        }\\n      }, {\\n        key: \"off\",\\n        value: function (e) {\\n          for (var t in this.stateChangeCallbacks) this.stateChangeCallbacks[t] = this.stateChangeCallbacks[t].filter(function (t) {\\n            var n = r(t, 1)[0];\\n            return -1 === e.indexOf(n);\\n          });\\n        }\\n      }, {\\n        key: \"channel\",\\n        value: function (e) {\\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\\n              n = new _(e, t, this);\\n          return this.channels.push(n), n;\\n        }\\n      }, {\\n        key: \"push\",\\n        value: function (e) {\\n          var t = this;\\n\\n          if (this.hasLogger()) {\\n            var n = e.topic,\\n                i = e.event,\\n                o = e.payload,\\n                r = e.ref,\\n                s = e.join_ref;\\n            this.log(\"push\", \"\".concat(n, \" \").concat(i, \" (\").concat(s, \", \").concat(r, \")\"), o);\\n          }\\n\\n          this.isConnected() ? this.encode(e, function (e) {\\n            return t.conn.send(e);\\n          }) : this.sendBuffer.push(function () {\\n            return t.encode(e, function (e) {\\n              return t.conn.send(e);\\n            });\\n          });\\n        }\\n      }, {\\n        key: \"makeRef\",\\n        value: function () {\\n          var e = this.ref + 1;\\n          return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString();\\n        }\\n      }, {\\n        key: \"sendHeartbeat\",\\n        value: function () {\\n          if (this.isConnected()) {\\n            if (this.pendingHeartbeatRef) return this.pendingHeartbeatRef = null, this.hasLogger() && this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\"), void this.abnormalClose(\"heartbeat timeout\");\\n            this.pendingHeartbeatRef = this.makeRef(), this.push({\\n              topic: \"phoenix\",\\n              event: \"heartbeat\",\\n              payload: {},\\n              ref: this.pendingHeartbeatRef\\n            });\\n          }\\n        }\\n      }, {\\n        key: \"abnormalClose\",\\n        value: function (e) {\\n          this.closeWasClean = !1, this.conn.readyState === v && this.conn.close(1e3, e);\\n        }\\n      }, {\\n        key: \"flushSendBuffer\",\\n        value: function () {\\n          this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(function (e) {\\n            return e();\\n          }), this.sendBuffer = []);\\n        }\\n      }, {\\n        key: \"onConnMessage\",\\n        value: function (e) {\\n          var t = this;\\n          this.decode(e.data, function (e) {\\n            var n = e.topic,\\n                i = e.event,\\n                o = e.payload,\\n                s = e.ref,\\n                a = e.join_ref;\\n            s && s === t.pendingHeartbeatRef && (t.pendingHeartbeatRef = null), t.hasLogger() && t.log(\"receive\", \"\".concat(o.status || \"\", \" \").concat(n, \" \").concat(i, \" \").concat(s && \"(\" + s + \")\" || \"\"), o);\\n\\n            for (var c = 0; c < t.channels.length; c++) {\\n              var u = t.channels[c];\\n              u.isMember(n, i, o, a) && u.trigger(i, o, s, a);\\n            }\\n\\n            for (var h = 0; h < t.stateChangeCallbacks.message.length; h++) {\\n              (0, r(t.stateChangeCallbacks.message[h], 2)[1])(e);\\n            }\\n          });\\n        }\\n      }, {\\n        key: \"leaveOpenTopic\",\\n        value: function (e) {\\n          var t = this.channels.find(function (t) {\\n            return t.topic === e && (t.isJoined() || t.isJoining());\\n          });\\n          t && (this.hasLogger() && this.log(\"transport\", \\'leaving duplicate topic \"\\'.concat(e, \\'\"\\')), t.leave());\\n        }\\n      }]), e;\\n    }(),\\n        D = function () {\\n      function e(t) {\\n        c(this, e), this.endPoint = null, this.token = null, this.skipHeartbeat = !0, this.onopen = function () {}, this.onerror = function () {}, this.onmessage = function () {}, this.onclose = function () {}, this.pollEndpoint = this.normalizeEndpoint(t), this.readyState = p, this.poll();\\n      }\\n\\n      return h(e, [{\\n        key: \"normalizeEndpoint\",\\n        value: function (e) {\\n          return e.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + x), \"$1/\" + L);\\n        }\\n      }, {\\n        key: \"endpointURL\",\\n        value: function () {\\n          return M.appendParams(this.pollEndpoint, {\\n            token: this.token\\n          });\\n        }\\n      }, {\\n        key: \"closeAndRetry\",\\n        value: function () {\\n          this.close(), this.readyState = p;\\n        }\\n      }, {\\n        key: \"ontimeout\",\\n        value: function () {\\n          this.onerror(\"timeout\"), this.closeAndRetry();\\n        }\\n      }, {\\n        key: \"poll\",\\n        value: function () {\\n          var e = this;\\n          this.readyState !== v && this.readyState !== p || M.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (t) {\\n            if (t) {\\n              var n = t.status,\\n                  i = t.token,\\n                  o = t.messages;\\n              e.token = i;\\n            } else n = 0;\\n\\n            switch (n) {\\n              case 200:\\n                o.forEach(function (t) {\\n                  return e.onmessage({\\n                    data: t\\n                  });\\n                }), e.poll();\\n                break;\\n\\n              case 204:\\n                e.poll();\\n                break;\\n\\n              case 410:\\n                e.readyState = v, e.onopen(), e.poll();\\n                break;\\n\\n              case 403:\\n                e.onerror(), e.close();\\n                break;\\n\\n              case 0:\\n              case 500:\\n                e.onerror(), e.closeAndRetry();\\n                break;\\n\\n              default:\\n                throw new Error(\"unhandled poll status \".concat(n));\\n            }\\n          });\\n        }\\n      }, {\\n        key: \"send\",\\n        value: function (e) {\\n          var t = this;\\n          M.request(\"POST\", this.endpointURL(), \"application/json\", e, this.timeout, this.onerror.bind(this, \"timeout\"), function (e) {\\n            e && 200 === e.status || (t.onerror(e && e.status), t.closeAndRetry());\\n          });\\n        }\\n      }, {\\n        key: \"close\",\\n        value: function (e, t) {\\n          this.readyState = m, this.onclose();\\n        }\\n      }]), e;\\n    }(),\\n        M = function () {\\n      function e() {\\n        c(this, e);\\n      }\\n\\n      return h(e, null, [{\\n        key: \"request\",\\n        value: function (e, t, n, i, o, r, s) {\\n          if (d.XDomainRequest) {\\n            var a = new XDomainRequest();\\n            this.xdomainRequest(a, e, t, i, o, r, s);\\n          } else {\\n            var c = new d.XMLHttpRequest();\\n            this.xhrRequest(c, e, t, n, i, o, r, s);\\n          }\\n        }\\n      }, {\\n        key: \"xdomainRequest\",\\n        value: function (e, t, n, i, o, r, s) {\\n          var a = this;\\n          e.timeout = o, e.open(t, n), e.onload = function () {\\n            var t = a.parseJSON(e.responseText);\\n            s && s(t);\\n          }, r && (e.ontimeout = r), e.onprogress = function () {}, e.send(i);\\n        }\\n      }, {\\n        key: \"xhrRequest\",\\n        value: function (e, t, n, i, o, r, s, a) {\\n          var c = this;\\n          e.open(t, n, !0), e.timeout = r, e.setRequestHeader(\"Content-Type\", i), e.onerror = function () {\\n            a && a(null);\\n          }, e.onreadystatechange = function () {\\n            if (e.readyState === c.states.complete && a) {\\n              var t = c.parseJSON(e.responseText);\\n              a(t);\\n            }\\n          }, s && (e.ontimeout = s), e.send(o);\\n        }\\n      }, {\\n        key: \"parseJSON\",\\n        value: function (e) {\\n          if (!e || \"\" === e) return null;\\n\\n          try {\\n            return JSON.parse(e);\\n          } catch (t) {\\n            return console && console.log(\"failed to parse JSON response\", e), null;\\n          }\\n        }\\n      }, {\\n        key: \"serialize\",\\n        value: function (e, t) {\\n          var n = [];\\n\\n          for (var i in e) if (e.hasOwnProperty(i)) {\\n            var r = t ? \"\".concat(t, \"[\").concat(i, \"]\") : i,\\n                s = e[i];\\n            \"object\" === o(s) ? n.push(this.serialize(s, r)) : n.push(encodeURIComponent(r) + \"=\" + encodeURIComponent(s));\\n          }\\n\\n          return n.join(\"&\");\\n        }\\n      }, {\\n        key: \"appendParams\",\\n        value: function (e, t) {\\n          if (0 === Object.keys(t).length) return e;\\n          var n = e.match(/\\\\?/) ? \"&\" : \"?\";\\n          return \"\".concat(e).concat(n).concat(this.serialize(t));\\n        }\\n      }]), e;\\n    }();\\n\\n    M.states = {\\n      complete: 4\\n    };\\n\\n    var N = function () {\\n      function e(t) {\\n        var n = this,\\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\\n        c(this, e);\\n        var o = i.events || {\\n          state: \"presence_state\",\\n          diff: \"presence_diff\"\\n        };\\n        this.state = {}, this.pendingDiffs = [], this.channel = t, this.joinRef = null, this.caller = {\\n          onJoin: function () {},\\n          onLeave: function () {},\\n          onSync: function () {}\\n        }, this.channel.on(o.state, function (t) {\\n          var i = n.caller,\\n              o = i.onJoin,\\n              r = i.onLeave,\\n              s = i.onSync;\\n          n.joinRef = n.channel.joinRef(), n.state = e.syncState(n.state, t, o, r), n.pendingDiffs.forEach(function (t) {\\n            n.state = e.syncDiff(n.state, t, o, r);\\n          }), n.pendingDiffs = [], s();\\n        }), this.channel.on(o.diff, function (t) {\\n          var i = n.caller,\\n              o = i.onJoin,\\n              r = i.onLeave,\\n              s = i.onSync;\\n          n.inPendingSyncState() ? n.pendingDiffs.push(t) : (n.state = e.syncDiff(n.state, t, o, r), s());\\n        });\\n      }\\n\\n      return h(e, [{\\n        key: \"onJoin\",\\n        value: function (e) {\\n          this.caller.onJoin = e;\\n        }\\n      }, {\\n        key: \"onLeave\",\\n        value: function (e) {\\n          this.caller.onLeave = e;\\n        }\\n      }, {\\n        key: \"onSync\",\\n        value: function (e) {\\n          this.caller.onSync = e;\\n        }\\n      }, {\\n        key: \"list\",\\n        value: function (t) {\\n          return e.list(this.state, t);\\n        }\\n      }, {\\n        key: \"inPendingSyncState\",\\n        value: function () {\\n          return !this.joinRef || this.joinRef !== this.channel.joinRef();\\n        }\\n      }], [{\\n        key: \"syncState\",\\n        value: function (e, t, n, i) {\\n          var o = this,\\n              r = this.clone(e),\\n              s = {},\\n              a = {};\\n          return this.map(r, function (e, n) {\\n            t[e] || (a[e] = n);\\n          }), this.map(t, function (e, t) {\\n            var n = r[e];\\n\\n            if (n) {\\n              var i = t.metas.map(function (e) {\\n                return e.phx_ref;\\n              }),\\n                  c = n.metas.map(function (e) {\\n                return e.phx_ref;\\n              }),\\n                  u = t.metas.filter(function (e) {\\n                return c.indexOf(e.phx_ref) < 0;\\n              }),\\n                  h = n.metas.filter(function (e) {\\n                return i.indexOf(e.phx_ref) < 0;\\n              });\\n              u.length > 0 && (s[e] = t, s[e].metas = u), h.length > 0 && (a[e] = o.clone(n), a[e].metas = h);\\n            } else s[e] = t;\\n          }), this.syncDiff(r, {\\n            joins: s,\\n            leaves: a\\n          }, n, i);\\n        }\\n      }, {\\n        key: \"syncDiff\",\\n        value: function (e, t, n, o) {\\n          var r = t.joins,\\n              s = t.leaves,\\n              a = this.clone(e);\\n          return n || (n = function () {}), o || (o = function () {}), this.map(r, function (e, t) {\\n            var o = a[e];\\n\\n            if (a[e] = t, o) {\\n              var r,\\n                  s = a[e].metas.map(function (e) {\\n                return e.phx_ref;\\n              }),\\n                  c = o.metas.filter(function (e) {\\n                return s.indexOf(e.phx_ref) < 0;\\n              });\\n              (r = a[e].metas).unshift.apply(r, i(c));\\n            }\\n\\n            n(e, o, t);\\n          }), this.map(s, function (e, t) {\\n            var n = a[e];\\n\\n            if (n) {\\n              var i = t.metas.map(function (e) {\\n                return e.phx_ref;\\n              });\\n              n.metas = n.metas.filter(function (e) {\\n                return i.indexOf(e.phx_ref) < 0;\\n              }), o(e, n, t), 0 === n.metas.length && delete a[e];\\n            }\\n          }), a;\\n        }\\n      }, {\\n        key: \"list\",\\n        value: function (e, t) {\\n          return t || (t = function (e, t) {\\n            return t;\\n          }), this.map(e, function (e, n) {\\n            return t(e, n);\\n          });\\n        }\\n      }, {\\n        key: \"map\",\\n        value: function (e, t) {\\n          return Object.getOwnPropertyNames(e).map(function (n) {\\n            return t(n, e[n]);\\n          });\\n        }\\n      }, {\\n        key: \"clone\",\\n        value: function (e) {\\n          return JSON.parse(JSON.stringify(e));\\n        }\\n      }]), e;\\n    }(),\\n        J = function () {\\n      function e(t, n) {\\n        c(this, e), this.callback = t, this.timerCalc = n, this.timer = null, this.tries = 0;\\n      }\\n\\n      return h(e, [{\\n        key: \"reset\",\\n        value: function () {\\n          this.tries = 0, clearTimeout(this.timer);\\n        }\\n      }, {\\n        key: \"scheduleTimeout\",\\n        value: function () {\\n          var e = this;\\n          clearTimeout(this.timer), this.timer = setTimeout(function () {\\n            e.tries = e.tries + 1, e.callback();\\n          }, this.timerCalc(this.tries + 1));\\n        }\\n      }]), e;\\n    }();\\n  }]);\\n});//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9hbGVhay9zcmMvZmVlZGV4L2RlcHMvcGhvZW5peC9wcml2L3N0YXRpYy9waG9lbml4LmpzPzVjY2MiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5QaG9lbml4PXQoKTplLlBob2VuaXg9dCgpfSh0aGlzLChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiBuKGkpe2lmKHRbaV0pcmV0dXJuIHRbaV0uZXhwb3J0czt2YXIgbz10W2ldPXtpOmksbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtpXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxuKSxvLmw9ITAsby5leHBvcnRzfXJldHVybiBuLm09ZSxuLmM9dCxuLmQ9ZnVuY3Rpb24oZSx0LGkpe24ubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDppfSl9LG4ucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxuLnQ9ZnVuY3Rpb24oZSx0KXtpZigxJnQmJihlPW4oZSkpLDgmdClyZXR1cm4gZTtpZig0JnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIGk9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihuLnIoaSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGksXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBvIGluIGUpbi5kKGksbyxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0uYmluZChudWxsLG8pKTtyZXR1cm4gaX0sbi5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBuLmQodCxcImFcIix0KSx0fSxuLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LG4ucD1cIlwiLG4obi5zPTApfShbZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbih0KXtlLmV4cG9ydHM9dC5QaG9lbml4PW4oMil9KS5jYWxsKHRoaXMsbigxKSl9LGZ1bmN0aW9uKGUsdCl7dmFyIG47bj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtuPW58fG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl9Y2F0Y2goZSl7XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmKG49d2luZG93KX1lLmV4cG9ydHM9bn0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGEoZSl9KGUpfHxmdW5jdGlvbihlKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKXJldHVybiBBcnJheS5mcm9tKGUpfShlKXx8cyhlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBvKGUpe3JldHVybihvPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiByKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9KGUpfHxmdW5jdGlvbihlLHQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTeW1ib2x8fCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSkpcmV0dXJuO3ZhciBuPVtdLGk9ITAsbz0hMSxyPXZvaWQgMDt0cnl7Zm9yKHZhciBzLGE9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShpPShzPWEubmV4dCgpKS5kb25lKSYmKG4ucHVzaChzLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtpPSEwKTt9Y2F0Y2goZSl7bz0hMCxyPWV9ZmluYWxseXt0cnl7aXx8bnVsbD09YS5yZXR1cm58fGEucmV0dXJuKCl9ZmluYWxseXtpZihvKXRocm93IHJ9fXJldHVybiBufShlLHQpfHxzKGUsdCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBzKGUsdCl7aWYoZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIGEoZSx0KTt2YXIgbj1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkuc2xpY2UoOCwtMSk7cmV0dXJuXCJPYmplY3RcIj09PW4mJmUuY29uc3RydWN0b3ImJihuPWUuY29uc3RydWN0b3IubmFtZSksXCJNYXBcIj09PW58fFwiU2V0XCI9PT1uP0FycmF5LmZyb20obik6XCJBcmd1bWVudHNcIj09PW58fC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pP2EoZSx0KTp2b2lkIDB9fWZ1bmN0aW9uIGEoZSx0KXsobnVsbD09dHx8dD5lLmxlbmd0aCkmJih0PWUubGVuZ3RoKTtmb3IodmFyIG49MCxpPW5ldyBBcnJheSh0KTtuPHQ7bisrKWlbbl09ZVtuXTtyZXR1cm4gaX1mdW5jdGlvbiBjKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiB1KGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGkua2V5LGkpfX1mdW5jdGlvbiBoKGUsdCxuKXtyZXR1cm4gdCYmdShlLnByb3RvdHlwZSx0KSxuJiZ1KGUsbiksZX1uLnIodCksbi5kKHQsXCJDaGFubmVsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIF99KSksbi5kKHQsXCJTZXJpYWxpemVyXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEh9KSksbi5kKHQsXCJTb2NrZXRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gVX0pKSxuLmQodCxcIkxvbmdQb2xsXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIER9KSksbi5kKHQsXCJBamF4XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIE19KSksbi5kKHQsXCJQcmVzZW5jZVwiLChmdW5jdGlvbigpe3JldHVybiBOfSkpO3ZhciBsPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6bnVsbCxmPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93Om51bGwsZD1sfHxmfHx2b2lkIDAscD0wLHY9MSx5PTIsbT0zLGc9XCJjbG9zZWRcIixrPVwiZXJyb3JlZFwiLGI9XCJqb2luZWRcIixqPVwiam9pbmluZ1wiLEM9XCJsZWF2aW5nXCIsRT1cInBoeF9jbG9zZVwiLFI9XCJwaHhfZXJyb3JcIixUPVwicGh4X2pvaW5cIixTPVwicGh4X3JlcGx5XCIsdz1cInBoeF9sZWF2ZVwiLEE9W0UsUixULFMsd10sTD1cImxvbmdwb2xsXCIseD1cIndlYnNvY2tldFwiLE89ZnVuY3Rpb24oZSl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZSlyZXR1cm4gZTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZX19LFA9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixpLG8pe2ModGhpcyxlKSx0aGlzLmNoYW5uZWw9dCx0aGlzLmV2ZW50PW4sdGhpcy5wYXlsb2FkPWl8fGZ1bmN0aW9uKCl7cmV0dXJue319LHRoaXMucmVjZWl2ZWRSZXNwPW51bGwsdGhpcy50aW1lb3V0PW8sdGhpcy50aW1lb3V0VGltZXI9bnVsbCx0aGlzLnJlY0hvb2tzPVtdLHRoaXMuc2VudD0hMX1yZXR1cm4gaChlLFt7a2V5OlwicmVzZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy50aW1lb3V0PWUsdGhpcy5yZXNldCgpLHRoaXMuc2VuZCgpfX0se2tleTpcInNlbmRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpfHwodGhpcy5zdGFydFRpbWVvdXQoKSx0aGlzLnNlbnQ9ITAsdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHt0b3BpYzp0aGlzLmNoYW5uZWwudG9waWMsZXZlbnQ6dGhpcy5ldmVudCxwYXlsb2FkOnRoaXMucGF5bG9hZCgpLHJlZjp0aGlzLnJlZixqb2luX3JlZjp0aGlzLmNoYW5uZWwuam9pblJlZigpfSkpfX0se2tleTpcInJlY2VpdmVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmhhc1JlY2VpdmVkKGUpJiZ0KHRoaXMucmVjZWl2ZWRSZXNwLnJlc3BvbnNlKSx0aGlzLnJlY0hvb2tzLnB1c2goe3N0YXR1czplLGNhbGxiYWNrOnR9KSx0aGlzfX0se2tleTpcInJlc2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNhbmNlbFJlZkV2ZW50KCksdGhpcy5yZWY9bnVsbCx0aGlzLnJlZkV2ZW50PW51bGwsdGhpcy5yZWNlaXZlZFJlc3A9bnVsbCx0aGlzLnNlbnQ9ITF9fSx7a2V5OlwibWF0Y2hSZWNlaXZlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdGF0dXMsbj1lLnJlc3BvbnNlO2UucmVmO3RoaXMucmVjSG9va3MuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5zdGF0dXM9PT10fSkpLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlLmNhbGxiYWNrKG4pfSkpfX0se2tleTpcImNhbmNlbFJlZkV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnJlZkV2ZW50JiZ0aGlzLmNoYW5uZWwub2ZmKHRoaXMucmVmRXZlbnQpfX0se2tleTpcImNhbmNlbFRpbWVvdXRcIix2YWx1ZTpmdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lciksdGhpcy50aW1lb3V0VGltZXI9bnVsbH19LHtrZXk6XCJzdGFydFRpbWVvdXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy50aW1lb3V0VGltZXImJnRoaXMuY2FuY2VsVGltZW91dCgpLHRoaXMucmVmPXRoaXMuY2hhbm5lbC5zb2NrZXQubWFrZVJlZigpLHRoaXMucmVmRXZlbnQ9dGhpcy5jaGFubmVsLnJlcGx5RXZlbnROYW1lKHRoaXMucmVmKSx0aGlzLmNoYW5uZWwub24odGhpcy5yZWZFdmVudCwoZnVuY3Rpb24odCl7ZS5jYW5jZWxSZWZFdmVudCgpLGUuY2FuY2VsVGltZW91dCgpLGUucmVjZWl2ZWRSZXNwPXQsZS5tYXRjaFJlY2VpdmUodCl9KSksdGhpcy50aW1lb3V0VGltZXI9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnRyaWdnZXIoXCJ0aW1lb3V0XCIse30pfSksdGhpcy50aW1lb3V0KX19LHtrZXk6XCJoYXNSZWNlaXZlZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlY2VpdmVkUmVzcCYmdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzPT09ZX19LHtrZXk6XCJ0cmlnZ2VyXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLmNoYW5uZWwudHJpZ2dlcih0aGlzLnJlZkV2ZW50LHtzdGF0dXM6ZSxyZXNwb25zZTp0fSl9fV0pLGV9KCksXz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLGkpe3ZhciBvPXRoaXM7Yyh0aGlzLGUpLHRoaXMuc3RhdGU9Zyx0aGlzLnRvcGljPXQsdGhpcy5wYXJhbXM9TyhufHx7fSksdGhpcy5zb2NrZXQ9aSx0aGlzLmJpbmRpbmdzPVtdLHRoaXMuYmluZGluZ1JlZj0wLHRoaXMudGltZW91dD10aGlzLnNvY2tldC50aW1lb3V0LHRoaXMuam9pbmVkT25jZT0hMSx0aGlzLmpvaW5QdXNoPW5ldyBQKHRoaXMsVCx0aGlzLnBhcmFtcyx0aGlzLnRpbWVvdXQpLHRoaXMucHVzaEJ1ZmZlcj1bXSx0aGlzLnN0YXRlQ2hhbmdlUmVmcz1bXSx0aGlzLnJlam9pblRpbWVyPW5ldyBKKChmdW5jdGlvbigpe28uc29ja2V0LmlzQ29ubmVjdGVkKCkmJm8ucmVqb2luKCl9KSx0aGlzLnNvY2tldC5yZWpvaW5BZnRlck1zKSx0aGlzLnN0YXRlQ2hhbmdlUmVmcy5wdXNoKHRoaXMuc29ja2V0Lm9uRXJyb3IoKGZ1bmN0aW9uKCl7cmV0dXJuIG8ucmVqb2luVGltZXIucmVzZXQoKX0pKSksdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbk9wZW4oKGZ1bmN0aW9uKCl7by5yZWpvaW5UaW1lci5yZXNldCgpLG8uaXNFcnJvcmVkKCkmJm8ucmVqb2luKCl9KSkpLHRoaXMuam9pblB1c2gucmVjZWl2ZShcIm9rXCIsKGZ1bmN0aW9uKCl7by5zdGF0ZT1iLG8ucmVqb2luVGltZXIucmVzZXQoKSxvLnB1c2hCdWZmZXIuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2VuZCgpfSkpLG8ucHVzaEJ1ZmZlcj1bXX0pKSx0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJlcnJvclwiLChmdW5jdGlvbigpe28uc3RhdGU9ayxvLnNvY2tldC5pc0Nvbm5lY3RlZCgpJiZvLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpfSkpLHRoaXMub25DbG9zZSgoZnVuY3Rpb24oKXtvLnJlam9pblRpbWVyLnJlc2V0KCksby5zb2NrZXQuaGFzTG9nZ2VyKCkmJm8uc29ja2V0LmxvZyhcImNoYW5uZWxcIixcImNsb3NlIFwiLmNvbmNhdChvLnRvcGljLFwiIFwiKS5jb25jYXQoby5qb2luUmVmKCkpKSxvLnN0YXRlPWcsby5zb2NrZXQucmVtb3ZlKG8pfSkpLHRoaXMub25FcnJvcigoZnVuY3Rpb24oZSl7by5zb2NrZXQuaGFzTG9nZ2VyKCkmJm8uc29ja2V0LmxvZyhcImNoYW5uZWxcIixcImVycm9yIFwiLmNvbmNhdChvLnRvcGljKSxlKSxvLmlzSm9pbmluZygpJiZvLmpvaW5QdXNoLnJlc2V0KCksby5zdGF0ZT1rLG8uc29ja2V0LmlzQ29ubmVjdGVkKCkmJm8ucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCl9KSksdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwidGltZW91dFwiLChmdW5jdGlvbigpe28uc29ja2V0Lmhhc0xvZ2dlcigpJiZvLnNvY2tldC5sb2coXCJjaGFubmVsXCIsXCJ0aW1lb3V0IFwiLmNvbmNhdChvLnRvcGljLFwiIChcIikuY29uY2F0KG8uam9pblJlZigpLFwiKVwiKSxvLmpvaW5QdXNoLnRpbWVvdXQpLG5ldyBQKG8sdyxPKHt9KSxvLnRpbWVvdXQpLnNlbmQoKSxvLnN0YXRlPWssby5qb2luUHVzaC5yZXNldCgpLG8uc29ja2V0LmlzQ29ubmVjdGVkKCkmJm8ucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCl9KSksdGhpcy5vbihTLChmdW5jdGlvbihlLHQpe28udHJpZ2dlcihvLnJlcGx5RXZlbnROYW1lKHQpLGUpfSkpfXJldHVybiBoKGUsW3trZXk6XCJqb2luXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06dGhpcy50aW1lb3V0O2lmKHRoaXMuam9pbmVkT25jZSl0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byBqb2luIG11bHRpcGxlIHRpbWVzLiAnam9pbicgY2FuIG9ubHkgYmUgY2FsbGVkIGEgc2luZ2xlIHRpbWUgcGVyIGNoYW5uZWwgaW5zdGFuY2VcIik7cmV0dXJuIHRoaXMudGltZW91dD1lLHRoaXMuam9pbmVkT25jZT0hMCx0aGlzLnJlam9pbigpLHRoaXMuam9pblB1c2h9fSx7a2V5Olwib25DbG9zZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMub24oRSxlKX19LHtrZXk6XCJvbkVycm9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub24oUiwoZnVuY3Rpb24odCl7cmV0dXJuIGUodCl9KSl9fSx7a2V5Olwib25cIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuYmluZGluZ1JlZisrO3JldHVybiB0aGlzLmJpbmRpbmdzLnB1c2goe2V2ZW50OmUscmVmOm4sY2FsbGJhY2s6dH0pLG59fSx7a2V5Olwib2ZmXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLmJpbmRpbmdzPXRoaXMuYmluZGluZ3MuZmlsdGVyKChmdW5jdGlvbihuKXtyZXR1cm4hKG4uZXZlbnQ9PT1lJiYodm9pZCAwPT09dHx8dD09PW4ucmVmKSl9KSl9fSx7a2V5OlwiY2FuUHVzaFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkmJnRoaXMuaXNKb2luZWQoKX19LHtrZXk6XCJwdXNoXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06dGhpcy50aW1lb3V0O2lmKHQ9dHx8e30sIXRoaXMuam9pbmVkT25jZSl0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byBwdXNoICdcIi5jb25jYXQoZSxcIicgdG8gJ1wiKS5jb25jYXQodGhpcy50b3BpYyxcIicgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNcIikpO3ZhciBpPW5ldyBQKHRoaXMsZSwoZnVuY3Rpb24oKXtyZXR1cm4gdH0pLG4pO3JldHVybiB0aGlzLmNhblB1c2goKT9pLnNlbmQoKTooaS5zdGFydFRpbWVvdXQoKSx0aGlzLnB1c2hCdWZmZXIucHVzaChpKSksaX19LHtrZXk6XCJsZWF2ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp0aGlzLnRpbWVvdXQ7dGhpcy5yZWpvaW5UaW1lci5yZXNldCgpLHRoaXMuam9pblB1c2guY2FuY2VsVGltZW91dCgpLHRoaXMuc3RhdGU9Qzt2YXIgbj1mdW5jdGlvbigpe2Uuc29ja2V0Lmhhc0xvZ2dlcigpJiZlLnNvY2tldC5sb2coXCJjaGFubmVsXCIsXCJsZWF2ZSBcIi5jb25jYXQoZS50b3BpYykpLGUudHJpZ2dlcihFLFwibGVhdmVcIil9LGk9bmV3IFAodGhpcyx3LE8oe30pLHQpO3JldHVybiBpLnJlY2VpdmUoXCJva1wiLChmdW5jdGlvbigpe3JldHVybiBuKCl9KSkucmVjZWl2ZShcInRpbWVvdXRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbigpfSkpLGkuc2VuZCgpLHRoaXMuY2FuUHVzaCgpfHxpLnRyaWdnZXIoXCJva1wiLHt9KSxpfX0se2tleTpcIm9uTWVzc2FnZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdH19LHtrZXk6XCJpc0xpZmVjeWNsZUV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIEEuaW5kZXhPZihlKT49MH19LHtrZXk6XCJpc01lbWJlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGkpe3JldHVybiB0aGlzLnRvcGljPT09ZSYmKCFpfHxpPT09dGhpcy5qb2luUmVmKCl8fCF0aGlzLmlzTGlmZWN5Y2xlRXZlbnQodCl8fCh0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSYmdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLFwiZHJvcHBpbmcgb3V0ZGF0ZWQgbWVzc2FnZVwiLHt0b3BpYzplLGV2ZW50OnQscGF5bG9hZDpuLGpvaW5SZWY6aX0pLCExKSl9fSx7a2V5Olwiam9pblJlZlwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuam9pblB1c2gucmVmfX0se2tleTpcInJlam9pblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnRoaXMudGltZW91dDt0aGlzLmlzTGVhdmluZygpfHwodGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYyksdGhpcy5zdGF0ZT1qLHRoaXMuam9pblB1c2gucmVzZW5kKGUpKX19LHtrZXk6XCJ0cmlnZ2VyXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSl7dmFyIG89dGhpcy5vbk1lc3NhZ2UoZSx0LG4saSk7aWYodCYmIW8pdGhyb3cgbmV3IEVycm9yKFwiY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkXCIpO2Zvcih2YXIgcj10aGlzLmJpbmRpbmdzLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZXZlbnQ9PT1lfSkpLHM9MDtzPHIubGVuZ3RoO3MrKyl7cltzXS5jYWxsYmFjayhvLG4saXx8dGhpcy5qb2luUmVmKCkpfX19LHtrZXk6XCJyZXBseUV2ZW50TmFtZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwiY2hhbl9yZXBseV9cIi5jb25jYXQoZSl9fSx7a2V5OlwiaXNDbG9zZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlPT09Z319LHtrZXk6XCJpc0Vycm9yZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlPT09a319LHtrZXk6XCJpc0pvaW5lZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGU9PT1ifX0se2tleTpcImlzSm9pbmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGU9PT1qfX0se2tleTpcImlzTGVhdmluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhdGU9PT1DfX1dKSxlfSgpLEg9e0hFQURFUl9MRU5HVEg6MSxNRVRBX0xFTkdUSDo0LEtJTkRTOntwdXNoOjAscmVwbHk6MSxicm9hZGNhc3Q6Mn0sZW5jb2RlOmZ1bmN0aW9uKGUsdCl7aWYoZS5wYXlsb2FkLmNvbnN0cnVjdG9yPT09QXJyYXlCdWZmZXIpcmV0dXJuIHQodGhpcy5iaW5hcnlFbmNvZGUoZSkpO3ZhciBuPVtlLmpvaW5fcmVmLGUucmVmLGUudG9waWMsZS5ldmVudCxlLnBheWxvYWRdO3JldHVybiB0KEpTT04uc3RyaW5naWZ5KG4pKX0sZGVjb2RlOmZ1bmN0aW9uKGUsdCl7aWYoZS5jb25zdHJ1Y3Rvcj09PUFycmF5QnVmZmVyKXJldHVybiB0KHRoaXMuYmluYXJ5RGVjb2RlKGUpKTt2YXIgbj1yKEpTT04ucGFyc2UoZSksNSk7cmV0dXJuIHQoe2pvaW5fcmVmOm5bMF0scmVmOm5bMV0sdG9waWM6blsyXSxldmVudDpuWzNdLHBheWxvYWQ6bls0XX0pfSxiaW5hcnlFbmNvZGU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5qb2luX3JlZixuPWUucmVmLGk9ZS5ldmVudCxvPWUudG9waWMscj1lLnBheWxvYWQscz10aGlzLk1FVEFfTEVOR1RIK3QubGVuZ3RoK24ubGVuZ3RoK28ubGVuZ3RoK2kubGVuZ3RoLGE9bmV3IEFycmF5QnVmZmVyKHRoaXMuSEVBREVSX0xFTkdUSCtzKSxjPW5ldyBEYXRhVmlldyhhKSx1PTA7Yy5zZXRVaW50OCh1KyssdGhpcy5LSU5EUy5wdXNoKSxjLnNldFVpbnQ4KHUrKyx0Lmxlbmd0aCksYy5zZXRVaW50OCh1Kyssbi5sZW5ndGgpLGMuc2V0VWludDgodSsrLG8ubGVuZ3RoKSxjLnNldFVpbnQ4KHUrKyxpLmxlbmd0aCksQXJyYXkuZnJvbSh0LChmdW5jdGlvbihlKXtyZXR1cm4gYy5zZXRVaW50OCh1KyssZS5jaGFyQ29kZUF0KDApKX0pKSxBcnJheS5mcm9tKG4sKGZ1bmN0aW9uKGUpe3JldHVybiBjLnNldFVpbnQ4KHUrKyxlLmNoYXJDb2RlQXQoMCkpfSkpLEFycmF5LmZyb20obywoZnVuY3Rpb24oZSl7cmV0dXJuIGMuc2V0VWludDgodSsrLGUuY2hhckNvZGVBdCgwKSl9KSksQXJyYXkuZnJvbShpLChmdW5jdGlvbihlKXtyZXR1cm4gYy5zZXRVaW50OCh1KyssZS5jaGFyQ29kZUF0KDApKX0pKTt2YXIgaD1uZXcgVWludDhBcnJheShhLmJ5dGVMZW5ndGgrci5ieXRlTGVuZ3RoKTtyZXR1cm4gaC5zZXQobmV3IFVpbnQ4QXJyYXkoYSksMCksaC5zZXQobmV3IFVpbnQ4QXJyYXkociksYS5ieXRlTGVuZ3RoKSxoLmJ1ZmZlcn0sYmluYXJ5RGVjb2RlOmZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBEYXRhVmlldyhlKSxuPXQuZ2V0VWludDgoMCksaT1uZXcgVGV4dERlY29kZXI7c3dpdGNoKG4pe2Nhc2UgdGhpcy5LSU5EUy5wdXNoOnJldHVybiB0aGlzLmRlY29kZVB1c2goZSx0LGkpO2Nhc2UgdGhpcy5LSU5EUy5yZXBseTpyZXR1cm4gdGhpcy5kZWNvZGVSZXBseShlLHQsaSk7Y2FzZSB0aGlzLktJTkRTLmJyb2FkY2FzdDpyZXR1cm4gdGhpcy5kZWNvZGVCcm9hZGNhc3QoZSx0LGkpfX0sZGVjb2RlUHVzaDpmdW5jdGlvbihlLHQsbil7dmFyIGk9dC5nZXRVaW50OCgxKSxvPXQuZ2V0VWludDgoMikscj10LmdldFVpbnQ4KDMpLHM9dGhpcy5IRUFERVJfTEVOR1RIK3RoaXMuTUVUQV9MRU5HVEgtMSxhPW4uZGVjb2RlKGUuc2xpY2UocyxzK2kpKTtzKz1pO3ZhciBjPW4uZGVjb2RlKGUuc2xpY2UocyxzK28pKTtzKz1vO3ZhciB1PW4uZGVjb2RlKGUuc2xpY2UocyxzK3IpKTtyZXR1cm4gcys9cix7am9pbl9yZWY6YSxyZWY6bnVsbCx0b3BpYzpjLGV2ZW50OnUscGF5bG9hZDplLnNsaWNlKHMsZS5ieXRlTGVuZ3RoKX19LGRlY29kZVJlcGx5OmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10LmdldFVpbnQ4KDEpLG89dC5nZXRVaW50OCgyKSxyPXQuZ2V0VWludDgoMykscz10LmdldFVpbnQ4KDQpLGE9dGhpcy5IRUFERVJfTEVOR1RIK3RoaXMuTUVUQV9MRU5HVEgsYz1uLmRlY29kZShlLnNsaWNlKGEsYStpKSk7YSs9aTt2YXIgdT1uLmRlY29kZShlLnNsaWNlKGEsYStvKSk7YSs9bzt2YXIgaD1uLmRlY29kZShlLnNsaWNlKGEsYStyKSk7YSs9cjt2YXIgbD1uLmRlY29kZShlLnNsaWNlKGEsYStzKSk7YSs9czt2YXIgZj1lLnNsaWNlKGEsZS5ieXRlTGVuZ3RoKTtyZXR1cm57am9pbl9yZWY6YyxyZWY6dSx0b3BpYzpoLGV2ZW50OlMscGF5bG9hZDp7c3RhdHVzOmwscmVzcG9uc2U6Zn19fSxkZWNvZGVCcm9hZGNhc3Q6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXQuZ2V0VWludDgoMSksbz10LmdldFVpbnQ4KDIpLHI9dGhpcy5IRUFERVJfTEVOR1RIKzIscz1uLmRlY29kZShlLnNsaWNlKHIscitpKSk7cis9aTt2YXIgYT1uLmRlY29kZShlLnNsaWNlKHIscitvKSk7cmV0dXJuIHIrPW8se2pvaW5fcmVmOm51bGwscmVmOm51bGwsdG9waWM6cyxldmVudDphLHBheWxvYWQ6ZS5zbGljZShyLGUuYnl0ZUxlbmd0aCl9fX0sVT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIG49dGhpcyxpPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtjKHRoaXMsZSksdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcz17b3BlbjpbXSxjbG9zZTpbXSxlcnJvcjpbXSxtZXNzYWdlOltdfSx0aGlzLmNoYW5uZWxzPVtdLHRoaXMuc2VuZEJ1ZmZlcj1bXSx0aGlzLnJlZj0wLHRoaXMudGltZW91dD1pLnRpbWVvdXR8fDFlNCx0aGlzLnRyYW5zcG9ydD1pLnRyYW5zcG9ydHx8ZC5XZWJTb2NrZXR8fEQsdGhpcy5kZWZhdWx0RW5jb2Rlcj1ILmVuY29kZS5iaW5kKEgpLHRoaXMuZGVmYXVsdERlY29kZXI9SC5kZWNvZGUuYmluZChIKSx0aGlzLmNsb3NlV2FzQ2xlYW49ITEsdGhpcy51bmxvYWRlZD0hMSx0aGlzLmJpbmFyeVR5cGU9aS5iaW5hcnlUeXBlfHxcImFycmF5YnVmZmVyXCIsdGhpcy50cmFuc3BvcnQhPT1EPyh0aGlzLmVuY29kZT1pLmVuY29kZXx8dGhpcy5kZWZhdWx0RW5jb2Rlcix0aGlzLmRlY29kZT1pLmRlY29kZXx8dGhpcy5kZWZhdWx0RGVjb2Rlcik6KHRoaXMuZW5jb2RlPXRoaXMuZGVmYXVsdEVuY29kZXIsdGhpcy5kZWNvZGU9dGhpcy5kZWZhdWx0RGVjb2RlciksZiYmZi5hZGRFdmVudExpc3RlbmVyJiZmLmFkZEV2ZW50TGlzdGVuZXIoXCJ1bmxvYWRcIiwoZnVuY3Rpb24oZSl7bi5jb25uJiYobi51bmxvYWRlZD0hMCxuLmFibm9ybWFsQ2xvc2UoXCJ1bmxvYWRlZFwiKSl9KSksdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zPWkuaGVhcnRiZWF0SW50ZXJ2YWxNc3x8M2U0LHRoaXMucmVqb2luQWZ0ZXJNcz1mdW5jdGlvbihlKXtyZXR1cm4gaS5yZWpvaW5BZnRlck1zP2kucmVqb2luQWZ0ZXJNcyhlKTpbMWUzLDJlMyw1ZTNdW2UtMV18fDFlNH0sdGhpcy5yZWNvbm5lY3RBZnRlck1zPWZ1bmN0aW9uKGUpe3JldHVybiBuLnVubG9hZGVkPzEwMDppLnJlY29ubmVjdEFmdGVyTXM/aS5yZWNvbm5lY3RBZnRlck1zKGUpOlsxMCw1MCwxMDAsMTUwLDIwMCwyNTAsNTAwLDFlMywyZTNdW2UtMV18fDVlM30sdGhpcy5sb2dnZXI9aS5sb2dnZXJ8fG51bGwsdGhpcy5sb25ncG9sbGVyVGltZW91dD1pLmxvbmdwb2xsZXJUaW1lb3V0fHwyZTQsdGhpcy5wYXJhbXM9TyhpLnBhcmFtc3x8e30pLHRoaXMuZW5kUG9pbnQ9XCJcIi5jb25jYXQodCxcIi9cIikuY29uY2F0KHgpLHRoaXMudnNuPWkudnNufHxcIjIuMC4wXCIsdGhpcy5oZWFydGJlYXRUaW1lcj1udWxsLHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZj1udWxsLHRoaXMucmVjb25uZWN0VGltZXI9bmV3IEooKGZ1bmN0aW9uKCl7bi50ZWFyZG93bigoZnVuY3Rpb24oKXtyZXR1cm4gbi5jb25uZWN0KCl9KSl9KSx0aGlzLnJlY29ubmVjdEFmdGVyTXMpfXJldHVybiBoKGUsW3trZXk6XCJwcm90b2NvbFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGxvY2F0aW9uLnByb3RvY29sLm1hdGNoKC9eaHR0cHMvKT9cIndzc1wiOlwid3NcIn19LHtrZXk6XCJlbmRQb2ludFVSTFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9TS5hcHBlbmRQYXJhbXMoTS5hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCx0aGlzLnBhcmFtcygpKSx7dnNuOnRoaXMudnNufSk7cmV0dXJuXCIvXCIhPT1lLmNoYXJBdCgwKT9lOlwiL1wiPT09ZS5jaGFyQXQoMSk/XCJcIi5jb25jYXQodGhpcy5wcm90b2NvbCgpLFwiOlwiKS5jb25jYXQoZSk6XCJcIi5jb25jYXQodGhpcy5wcm90b2NvbCgpLFwiOi8vXCIpLmNvbmNhdChsb2NhdGlvbi5ob3N0KS5jb25jYXQoZSl9fSx7a2V5OlwiZGlzY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt0aGlzLmNsb3NlV2FzQ2xlYW49ITAsdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpLHRoaXMudGVhcmRvd24oZSx0LG4pfX0se2tleTpcImNvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO2UmJihjb25zb2xlJiZjb25zb2xlLmxvZyhcInBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBwYXNzIDpwYXJhbXMgdG8gdGhlIFNvY2tldCBjb25zdHJ1Y3RvclwiKSx0aGlzLnBhcmFtcz1PKGUpKSx0aGlzLmNvbm58fCh0aGlzLmNsb3NlV2FzQ2xlYW49ITEsdGhpcy5jb25uPW5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZFBvaW50VVJMKCkpLHRoaXMuY29ubi5iaW5hcnlUeXBlPXRoaXMuYmluYXJ5VHlwZSx0aGlzLmNvbm4udGltZW91dD10aGlzLmxvbmdwb2xsZXJUaW1lb3V0LHRoaXMuY29ubi5vbm9wZW49ZnVuY3Rpb24oKXtyZXR1cm4gdC5vbkNvbm5PcGVuKCl9LHRoaXMuY29ubi5vbmVycm9yPWZ1bmN0aW9uKGUpe3JldHVybiB0Lm9uQ29ubkVycm9yKGUpfSx0aGlzLmNvbm4ub25tZXNzYWdlPWZ1bmN0aW9uKGUpe3JldHVybiB0Lm9uQ29ubk1lc3NhZ2UoZSl9LHRoaXMuY29ubi5vbmNsb3NlPWZ1bmN0aW9uKGUpe3JldHVybiB0Lm9uQ29ubkNsb3NlKGUpfSl9fSx7a2V5OlwibG9nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3RoaXMubG9nZ2VyKGUsdCxuKX19LHtrZXk6XCJoYXNMb2dnZXJcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5sb2dnZXJ9fSx7a2V5Olwib25PcGVuXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5tYWtlUmVmKCk7cmV0dXJuIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5wdXNoKFt0LGVdKSx0fX0se2tleTpcIm9uQ2xvc2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLm1ha2VSZWYoKTtyZXR1cm4gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5wdXNoKFt0LGVdKSx0fX0se2tleTpcIm9uRXJyb3JcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLm1ha2VSZWYoKTtyZXR1cm4gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFt0LGVdKSx0fX0se2tleTpcIm9uTWVzc2FnZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMubWFrZVJlZigpO3JldHVybiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UucHVzaChbdCxlXSksdH19LHtrZXk6XCJvbkNvbm5PcGVuXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmhhc0xvZ2dlcigpJiZ0aGlzLmxvZyhcInRyYW5zcG9ydFwiLFwiY29ubmVjdGVkIHRvIFwiLmNvbmNhdCh0aGlzLmVuZFBvaW50VVJMKCkpKSx0aGlzLnVubG9hZGVkPSExLHRoaXMuY2xvc2VXYXNDbGVhbj0hMSx0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpLHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKSx0aGlzLnJlc2V0SGVhcnRiZWF0KCksdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybigwLHIoZSwyKVsxXSkoKX0pKX19LHtrZXk6XCJyZXNldEhlYXJ0YmVhdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLmNvbm4mJnRoaXMuY29ubi5za2lwSGVhcnRiZWF0fHwodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmPW51bGwsY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKSx0aGlzLmhlYXJ0YmVhdFRpbWVyPXNldEludGVydmFsKChmdW5jdGlvbigpe3JldHVybiBlLnNlbmRIZWFydGJlYXQoKX0pLHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcykpfX0se2tleTpcInRlYXJkb3duXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXM7aWYoIXRoaXMuY29ubilyZXR1cm4gZSYmZSgpO3RoaXMud2FpdEZvckJ1ZmZlckRvbmUoKGZ1bmN0aW9uKCl7aS5jb25uJiYodD9pLmNvbm4uY2xvc2UodCxufHxcIlwiKTppLmNvbm4uY2xvc2UoKSksaS53YWl0Rm9yU29ja2V0Q2xvc2VkKChmdW5jdGlvbigpe2kuY29ubiYmKGkuY29ubi5vbmNsb3NlPWZ1bmN0aW9uKCl7fSxpLmNvbm49bnVsbCksZSYmZSgpfSkpfSkpfX0se2tleTpcIndhaXRGb3JCdWZmZXJEb25lXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToxOzUhPT1uJiZ0aGlzLmNvbm4mJnRoaXMuY29ubi5idWZmZXJlZEFtb3VudD9zZXRUaW1lb3V0KChmdW5jdGlvbigpe3Qud2FpdEZvckJ1ZmZlckRvbmUoZSxuKzEpfSksMTUwKm4pOmUoKX19LHtrZXk6XCJ3YWl0Rm9yU29ja2V0Q2xvc2VkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXToxOzUhPT1uJiZ0aGlzLmNvbm4mJnRoaXMuY29ubi5yZWFkeVN0YXRlIT09bT9zZXRUaW1lb3V0KChmdW5jdGlvbigpe3Qud2FpdEZvclNvY2tldENsb3NlZChlLG4rMSl9KSwxNTAqbik6ZSgpfX0se2tleTpcIm9uQ29ubkNsb3NlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5oYXNMb2dnZXIoKSYmdGhpcy5sb2coXCJ0cmFuc3BvcnRcIixcImNsb3NlXCIsZSksdGhpcy50cmlnZ2VyQ2hhbkVycm9yKCksY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKSx0aGlzLmNsb3NlV2FzQ2xlYW58fHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCksdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5jbG9zZS5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4oMCxyKHQsMilbMV0pKGUpfSkpfX0se2tleTpcIm9uQ29ubkVycm9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5oYXNMb2dnZXIoKSYmdGhpcy5sb2coXCJ0cmFuc3BvcnRcIixlKSx0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKSx0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybigwLHIodCwyKVsxXSkoZSl9KSl9fSx7a2V5OlwidHJpZ2dlckNoYW5FcnJvclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jaGFubmVscy5mb3JFYWNoKChmdW5jdGlvbihlKXtlLmlzRXJyb3JlZCgpfHxlLmlzTGVhdmluZygpfHxlLmlzQ2xvc2VkKCl8fGUudHJpZ2dlcihSKX0pKX19LHtrZXk6XCJjb25uZWN0aW9uU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLmNvbm4mJnRoaXMuY29ubi5yZWFkeVN0YXRlKXtjYXNlIHA6cmV0dXJuXCJjb25uZWN0aW5nXCI7Y2FzZSB2OnJldHVyblwib3BlblwiO2Nhc2UgeTpyZXR1cm5cImNsb3NpbmdcIjtkZWZhdWx0OnJldHVyblwiY2xvc2VkXCJ9fX0se2tleTpcImlzQ29ubmVjdGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm5cIm9wZW5cIj09PXRoaXMuY29ubmVjdGlvblN0YXRlKCl9fSx7a2V5OlwicmVtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5vZmYoZS5zdGF0ZUNoYW5nZVJlZnMpLHRoaXMuY2hhbm5lbHM9dGhpcy5jaGFubmVscy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmpvaW5SZWYoKSE9PWUuam9pblJlZigpfSkpfX0se2tleTpcIm9mZlwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzKXRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3NbdF09dGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrc1t0XS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3ZhciBuPXIodCwxKVswXTtyZXR1cm4tMT09PWUuaW5kZXhPZihuKX0pKX19LHtrZXk6XCJjaGFubmVsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG49bmV3IF8oZSx0LHRoaXMpO3JldHVybiB0aGlzLmNoYW5uZWxzLnB1c2gobiksbn19LHtrZXk6XCJwdXNoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztpZih0aGlzLmhhc0xvZ2dlcigpKXt2YXIgbj1lLnRvcGljLGk9ZS5ldmVudCxvPWUucGF5bG9hZCxyPWUucmVmLHM9ZS5qb2luX3JlZjt0aGlzLmxvZyhcInB1c2hcIixcIlwiLmNvbmNhdChuLFwiIFwiKS5jb25jYXQoaSxcIiAoXCIpLmNvbmNhdChzLFwiLCBcIikuY29uY2F0KHIsXCIpXCIpLG8pfXRoaXMuaXNDb25uZWN0ZWQoKT90aGlzLmVuY29kZShlLChmdW5jdGlvbihlKXtyZXR1cm4gdC5jb25uLnNlbmQoZSl9KSk6dGhpcy5zZW5kQnVmZmVyLnB1c2goKGZ1bmN0aW9uKCl7cmV0dXJuIHQuZW5jb2RlKGUsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmNvbm4uc2VuZChlKX0pKX0pKX19LHtrZXk6XCJtYWtlUmVmXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnJlZisxO3JldHVybiBlPT09dGhpcy5yZWY/dGhpcy5yZWY9MDp0aGlzLnJlZj1lLHRoaXMucmVmLnRvU3RyaW5nKCl9fSx7a2V5Olwic2VuZEhlYXJ0YmVhdFwiLHZhbHVlOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0Nvbm5lY3RlZCgpKXtpZih0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpcmV0dXJuIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZj1udWxsLHRoaXMuaGFzTG9nZ2VyKCkmJnRoaXMubG9nKFwidHJhbnNwb3J0XCIsXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKSx2b2lkIHRoaXMuYWJub3JtYWxDbG9zZShcImhlYXJ0YmVhdCB0aW1lb3V0XCIpO3RoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZj10aGlzLm1ha2VSZWYoKSx0aGlzLnB1c2goe3RvcGljOlwicGhvZW5peFwiLGV2ZW50OlwiaGVhcnRiZWF0XCIscGF5bG9hZDp7fSxyZWY6dGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmfSl9fX0se2tleTpcImFibm9ybWFsQ2xvc2VcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmNsb3NlV2FzQ2xlYW49ITEsdGhpcy5jb25uLnJlYWR5U3RhdGU9PT12JiZ0aGlzLmNvbm4uY2xvc2UoMWUzLGUpfX0se2tleTpcImZsdXNoU2VuZEJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pc0Nvbm5lY3RlZCgpJiZ0aGlzLnNlbmRCdWZmZXIubGVuZ3RoPjAmJih0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUoKX0pKSx0aGlzLnNlbmRCdWZmZXI9W10pfX0se2tleTpcIm9uQ29ubk1lc3NhZ2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3RoaXMuZGVjb2RlKGUuZGF0YSwoZnVuY3Rpb24oZSl7dmFyIG49ZS50b3BpYyxpPWUuZXZlbnQsbz1lLnBheWxvYWQscz1lLnJlZixhPWUuam9pbl9yZWY7cyYmcz09PXQucGVuZGluZ0hlYXJ0YmVhdFJlZiYmKHQucGVuZGluZ0hlYXJ0YmVhdFJlZj1udWxsKSx0Lmhhc0xvZ2dlcigpJiZ0LmxvZyhcInJlY2VpdmVcIixcIlwiLmNvbmNhdChvLnN0YXR1c3x8XCJcIixcIiBcIikuY29uY2F0KG4sXCIgXCIpLmNvbmNhdChpLFwiIFwiKS5jb25jYXQocyYmXCIoXCIrcytcIilcInx8XCJcIiksbyk7Zm9yKHZhciBjPTA7Yzx0LmNoYW5uZWxzLmxlbmd0aDtjKyspe3ZhciB1PXQuY2hhbm5lbHNbY107dS5pc01lbWJlcihuLGksbyxhKSYmdS50cmlnZ2VyKGksbyxzLGEpfWZvcih2YXIgaD0wO2g8dC5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmxlbmd0aDtoKyspeygwLHIodC5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlW2hdLDIpWzFdKShlKX19KSl9fSx7a2V5OlwibGVhdmVPcGVuVG9waWNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmNoYW5uZWxzLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvcGljPT09ZSYmKHQuaXNKb2luZWQoKXx8dC5pc0pvaW5pbmcoKSl9KSk7dCYmKHRoaXMuaGFzTG9nZ2VyKCkmJnRoaXMubG9nKFwidHJhbnNwb3J0XCIsJ2xlYXZpbmcgZHVwbGljYXRlIHRvcGljIFwiJy5jb25jYXQoZSwnXCInKSksdC5sZWF2ZSgpKX19XSksZX0oKSxEPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtjKHRoaXMsZSksdGhpcy5lbmRQb2ludD1udWxsLHRoaXMudG9rZW49bnVsbCx0aGlzLnNraXBIZWFydGJlYXQ9ITAsdGhpcy5vbm9wZW49ZnVuY3Rpb24oKXt9LHRoaXMub25lcnJvcj1mdW5jdGlvbigpe30sdGhpcy5vbm1lc3NhZ2U9ZnVuY3Rpb24oKXt9LHRoaXMub25jbG9zZT1mdW5jdGlvbigpe30sdGhpcy5wb2xsRW5kcG9pbnQ9dGhpcy5ub3JtYWxpemVFbmRwb2ludCh0KSx0aGlzLnJlYWR5U3RhdGU9cCx0aGlzLnBvbGwoKX1yZXR1cm4gaChlLFt7a2V5Olwibm9ybWFsaXplRW5kcG9pbnRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKFwid3M6Ly9cIixcImh0dHA6Ly9cIikucmVwbGFjZShcIndzczovL1wiLFwiaHR0cHM6Ly9cIikucmVwbGFjZShuZXcgUmVnRXhwKFwiKC4qKS9cIit4KSxcIiQxL1wiK0wpfX0se2tleTpcImVuZHBvaW50VVJMXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gTS5hcHBlbmRQYXJhbXModGhpcy5wb2xsRW5kcG9pbnQse3Rva2VuOnRoaXMudG9rZW59KX19LHtrZXk6XCJjbG9zZUFuZFJldHJ5XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmNsb3NlKCksdGhpcy5yZWFkeVN0YXRlPXB9fSx7a2V5Olwib250aW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpLHRoaXMuY2xvc2VBbmRSZXRyeSgpfX0se2tleTpcInBvbGxcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5yZWFkeVN0YXRlIT09diYmdGhpcy5yZWFkeVN0YXRlIT09cHx8TS5yZXF1ZXN0KFwiR0VUXCIsdGhpcy5lbmRwb2ludFVSTCgpLFwiYXBwbGljYXRpb24vanNvblwiLG51bGwsdGhpcy50aW1lb3V0LHRoaXMub250aW1lb3V0LmJpbmQodGhpcyksKGZ1bmN0aW9uKHQpe2lmKHQpe3ZhciBuPXQuc3RhdHVzLGk9dC50b2tlbixvPXQubWVzc2FnZXM7ZS50b2tlbj1pfWVsc2Ugbj0wO3N3aXRjaChuKXtjYXNlIDIwMDpvLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBlLm9ubWVzc2FnZSh7ZGF0YTp0fSl9KSksZS5wb2xsKCk7YnJlYWs7Y2FzZSAyMDQ6ZS5wb2xsKCk7YnJlYWs7Y2FzZSA0MTA6ZS5yZWFkeVN0YXRlPXYsZS5vbm9wZW4oKSxlLnBvbGwoKTticmVhaztjYXNlIDQwMzplLm9uZXJyb3IoKSxlLmNsb3NlKCk7YnJlYWs7Y2FzZSAwOmNhc2UgNTAwOmUub25lcnJvcigpLGUuY2xvc2VBbmRSZXRyeSgpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwidW5oYW5kbGVkIHBvbGwgc3RhdHVzIFwiLmNvbmNhdChuKSl9fSkpfX0se2tleTpcInNlbmRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO00ucmVxdWVzdChcIlBPU1RcIix0aGlzLmVuZHBvaW50VVJMKCksXCJhcHBsaWNhdGlvbi9qc29uXCIsZSx0aGlzLnRpbWVvdXQsdGhpcy5vbmVycm9yLmJpbmQodGhpcyxcInRpbWVvdXRcIiksKGZ1bmN0aW9uKGUpe2UmJjIwMD09PWUuc3RhdHVzfHwodC5vbmVycm9yKGUmJmUuc3RhdHVzKSx0LmNsb3NlQW5kUmV0cnkoKSl9KSl9fSx7a2V5OlwiY2xvc2VcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMucmVhZHlTdGF0ZT1tLHRoaXMub25jbG9zZSgpfX1dKSxlfSgpLE09ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7Yyh0aGlzLGUpfXJldHVybiBoKGUsbnVsbCxbe2tleTpcInJlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpLG8scixzKXtpZihkLlhEb21haW5SZXF1ZXN0KXt2YXIgYT1uZXcgWERvbWFpblJlcXVlc3Q7dGhpcy54ZG9tYWluUmVxdWVzdChhLGUsdCxpLG8scixzKX1lbHNle3ZhciBjPW5ldyBkLlhNTEh0dHBSZXF1ZXN0O3RoaXMueGhyUmVxdWVzdChjLGUsdCxuLGksbyxyLHMpfX19LHtrZXk6XCJ4ZG9tYWluUmVxdWVzdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGksbyxyLHMpe3ZhciBhPXRoaXM7ZS50aW1lb3V0PW8sZS5vcGVuKHQsbiksZS5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgdD1hLnBhcnNlSlNPTihlLnJlc3BvbnNlVGV4dCk7cyYmcyh0KX0sciYmKGUub250aW1lb3V0PXIpLGUub25wcm9ncmVzcz1mdW5jdGlvbigpe30sZS5zZW5kKGkpfX0se2tleTpcInhoclJlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpLG8scixzLGEpe3ZhciBjPXRoaXM7ZS5vcGVuKHQsbiwhMCksZS50aW1lb3V0PXIsZS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsaSksZS5vbmVycm9yPWZ1bmN0aW9uKCl7YSYmYShudWxsKX0sZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZihlLnJlYWR5U3RhdGU9PT1jLnN0YXRlcy5jb21wbGV0ZSYmYSl7dmFyIHQ9Yy5wYXJzZUpTT04oZS5yZXNwb25zZVRleHQpO2EodCl9fSxzJiYoZS5vbnRpbWVvdXQ9cyksZS5zZW5kKG8pfX0se2tleTpcInBhcnNlSlNPTlwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFlfHxcIlwiPT09ZSlyZXR1cm4gbnVsbDt0cnl7cmV0dXJuIEpTT04ucGFyc2UoZSl9Y2F0Y2godCl7cmV0dXJuIGNvbnNvbGUmJmNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcIixlKSxudWxsfX19LHtrZXk6XCJzZXJpYWxpemVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPVtdO2Zvcih2YXIgaSBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkoaSkpe3ZhciByPXQ/XCJcIi5jb25jYXQodCxcIltcIikuY29uY2F0KGksXCJdXCIpOmkscz1lW2ldO1wib2JqZWN0XCI9PT1vKHMpP24ucHVzaCh0aGlzLnNlcmlhbGl6ZShzLHIpKTpuLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHIpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChzKSl9cmV0dXJuIG4uam9pbihcIiZcIil9fSx7a2V5OlwiYXBwZW5kUGFyYW1zXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtpZigwPT09T2JqZWN0LmtleXModCkubGVuZ3RoKXJldHVybiBlO3ZhciBuPWUubWF0Y2goL1xcPy8pP1wiJlwiOlwiP1wiO3JldHVyblwiXCIuY29uY2F0KGUpLmNvbmNhdChuKS5jb25jYXQodGhpcy5zZXJpYWxpemUodCkpfX1dKSxlfSgpO00uc3RhdGVzPXtjb21wbGV0ZTo0fTt2YXIgTj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7dmFyIG49dGhpcyxpPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtjKHRoaXMsZSk7dmFyIG89aS5ldmVudHN8fHtzdGF0ZTpcInByZXNlbmNlX3N0YXRlXCIsZGlmZjpcInByZXNlbmNlX2RpZmZcIn07dGhpcy5zdGF0ZT17fSx0aGlzLnBlbmRpbmdEaWZmcz1bXSx0aGlzLmNoYW5uZWw9dCx0aGlzLmpvaW5SZWY9bnVsbCx0aGlzLmNhbGxlcj17b25Kb2luOmZ1bmN0aW9uKCl7fSxvbkxlYXZlOmZ1bmN0aW9uKCl7fSxvblN5bmM6ZnVuY3Rpb24oKXt9fSx0aGlzLmNoYW5uZWwub24oby5zdGF0ZSwoZnVuY3Rpb24odCl7dmFyIGk9bi5jYWxsZXIsbz1pLm9uSm9pbixyPWkub25MZWF2ZSxzPWkub25TeW5jO24uam9pblJlZj1uLmNoYW5uZWwuam9pblJlZigpLG4uc3RhdGU9ZS5zeW5jU3RhdGUobi5zdGF0ZSx0LG8sciksbi5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoZnVuY3Rpb24odCl7bi5zdGF0ZT1lLnN5bmNEaWZmKG4uc3RhdGUsdCxvLHIpfSkpLG4ucGVuZGluZ0RpZmZzPVtdLHMoKX0pKSx0aGlzLmNoYW5uZWwub24oby5kaWZmLChmdW5jdGlvbih0KXt2YXIgaT1uLmNhbGxlcixvPWkub25Kb2luLHI9aS5vbkxlYXZlLHM9aS5vblN5bmM7bi5pblBlbmRpbmdTeW5jU3RhdGUoKT9uLnBlbmRpbmdEaWZmcy5wdXNoKHQpOihuLnN0YXRlPWUuc3luY0RpZmYobi5zdGF0ZSx0LG8scikscygpKX0pKX1yZXR1cm4gaChlLFt7a2V5Olwib25Kb2luXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5jYWxsZXIub25Kb2luPWV9fSx7a2V5Olwib25MZWF2ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuY2FsbGVyLm9uTGVhdmU9ZX19LHtrZXk6XCJvblN5bmNcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmNhbGxlci5vblN5bmM9ZX19LHtrZXk6XCJsaXN0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGUubGlzdCh0aGlzLnN0YXRlLHQpfX0se2tleTpcImluUGVuZGluZ1N5bmNTdGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuam9pblJlZnx8dGhpcy5qb2luUmVmIT09dGhpcy5jaGFubmVsLmpvaW5SZWYoKX19XSxbe2tleTpcInN5bmNTdGF0ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGkpe3ZhciBvPXRoaXMscj10aGlzLmNsb25lKGUpLHM9e30sYT17fTtyZXR1cm4gdGhpcy5tYXAociwoZnVuY3Rpb24oZSxuKXt0W2VdfHwoYVtlXT1uKX0pKSx0aGlzLm1hcCh0LChmdW5jdGlvbihlLHQpe3ZhciBuPXJbZV07aWYobil7dmFyIGk9dC5tZXRhcy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnBoeF9yZWZ9KSksYz1uLm1ldGFzLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUucGh4X3JlZn0pKSx1PXQubWV0YXMuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gYy5pbmRleE9mKGUucGh4X3JlZik8MH0pKSxoPW4ubWV0YXMuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gaS5pbmRleE9mKGUucGh4X3JlZik8MH0pKTt1Lmxlbmd0aD4wJiYoc1tlXT10LHNbZV0ubWV0YXM9dSksaC5sZW5ndGg+MCYmKGFbZV09by5jbG9uZShuKSxhW2VdLm1ldGFzPWgpfWVsc2Ugc1tlXT10fSkpLHRoaXMuc3luY0RpZmYocix7am9pbnM6cyxsZWF2ZXM6YX0sbixpKX19LHtrZXk6XCJzeW5jRGlmZlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLG8pe3ZhciByPXQuam9pbnMscz10LmxlYXZlcyxhPXRoaXMuY2xvbmUoZSk7cmV0dXJuIG58fChuPWZ1bmN0aW9uKCl7fSksb3x8KG89ZnVuY3Rpb24oKXt9KSx0aGlzLm1hcChyLChmdW5jdGlvbihlLHQpe3ZhciBvPWFbZV07aWYoYVtlXT10LG8pe3ZhciByLHM9YVtlXS5tZXRhcy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnBoeF9yZWZ9KSksYz1vLm1ldGFzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIHMuaW5kZXhPZihlLnBoeF9yZWYpPDB9KSk7KHI9YVtlXS5tZXRhcykudW5zaGlmdC5hcHBseShyLGkoYykpfW4oZSxvLHQpfSkpLHRoaXMubWFwKHMsKGZ1bmN0aW9uKGUsdCl7dmFyIG49YVtlXTtpZihuKXt2YXIgaT10Lm1ldGFzLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUucGh4X3JlZn0pKTtuLm1ldGFzPW4ubWV0YXMuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gaS5pbmRleE9mKGUucGh4X3JlZik8MH0pKSxvKGUsbix0KSwwPT09bi5tZXRhcy5sZW5ndGgmJmRlbGV0ZSBhW2VdfX0pKSxhfX0se2tleTpcImxpc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiB0fHwodD1mdW5jdGlvbihlLHQpe3JldHVybiB0fSksdGhpcy5tYXAoZSwoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdChlLG4pfSkpfX0se2tleTpcIm1hcFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuIHQobixlW25dKX0pKX19LHtrZXk6XCJjbG9uZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGUpKX19XSksZX0oKSxKPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4pe2ModGhpcyxlKSx0aGlzLmNhbGxiYWNrPXQsdGhpcy50aW1lckNhbGM9bix0aGlzLnRpbWVyPW51bGwsdGhpcy50cmllcz0wfXJldHVybiBoKGUsW3trZXk6XCJyZXNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy50cmllcz0wLGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKX19LHtrZXk6XCJzY2hlZHVsZVRpbWVvdXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7Y2xlYXJUaW1lb3V0KHRoaXMudGltZXIpLHRoaXMudGltZXI9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnRyaWVzPWUudHJpZXMrMSxlLmNhbGxiYWNrKCl9KSx0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzKzEpKX19XSksZX0oKX1dKX0pKTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///1\\n')},function(module,exports,__webpack_require__){eval('!function (e, t) {\\n   true ? module.exports = t() : undefined;\\n}(this, function () {\\n  return function (e) {\\n    var t = {};\\n\\n    function n(i) {\\n      if (t[i]) return t[i].exports;\\n      var r = t[i] = {\\n        i: i,\\n        l: !1,\\n        exports: {}\\n      };\\n      return e[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports;\\n    }\\n\\n    return n.m = e, n.c = t, n.d = function (e, t, i) {\\n      n.o(e, t) || Object.defineProperty(e, t, {\\n        configurable: !1,\\n        enumerable: !0,\\n        get: i\\n      });\\n    }, n.r = function (e) {\\n      Object.defineProperty(e, \"__esModule\", {\\n        value: !0\\n      });\\n    }, n.n = function (e) {\\n      var t = e && e.__esModule ? function () {\\n        return e.default;\\n      } : function () {\\n        return e;\\n      };\\n      return n.d(t, \"a\", t), t;\\n    }, n.o = function (e, t) {\\n      return Object.prototype.hasOwnProperty.call(e, t);\\n    }, n.p = \"\", n(n.s = 2);\\n  }([function (e, t, n) {\\n    \"use strict\";\\n\\n    n.r(t);\\n    var i,\\n        r = 11;\\n    var o = \"http://www.w3.org/1999/xhtml\",\\n        a = \"undefined\" == typeof document ? void 0 : document,\\n        u = !!a && \"content\" in a.createElement(\"template\"),\\n        s = !!a && a.createRange && \"createContextualFragment\" in a.createRange();\\n\\n    function c(e) {\\n      return e = e.trim(), u ? function (e) {\\n        var t = a.createElement(\"template\");\\n        return t.innerHTML = e, t.content.childNodes[0];\\n      }(e) : s ? function (e) {\\n        return i || (i = a.createRange()).selectNode(a.body), i.createContextualFragment(e).childNodes[0];\\n      }(e) : function (e) {\\n        var t = a.createElement(\"body\");\\n        return t.innerHTML = e, t.childNodes[0];\\n      }(e);\\n    }\\n\\n    function l(e, t) {\\n      var n,\\n          i,\\n          r = e.nodeName,\\n          o = t.nodeName;\\n      return r === o || (n = r.charCodeAt(0), i = o.charCodeAt(0), n <= 90 && i >= 97 ? r === o.toUpperCase() : i <= 90 && n >= 97 && o === r.toUpperCase());\\n    }\\n\\n    function d(e, t, n) {\\n      e[n] !== t[n] && (e[n] = t[n], e[n] ? e.setAttribute(n, \"\") : e.removeAttribute(n));\\n    }\\n\\n    var h = {\\n      OPTION: function (e, t) {\\n        var n = e.parentNode;\\n\\n        if (n) {\\n          var i = n.nodeName.toUpperCase();\\n          \"OPTGROUP\" === i && (i = (n = n.parentNode) && n.nodeName.toUpperCase()), \"SELECT\" !== i || n.hasAttribute(\"multiple\") || (e.hasAttribute(\"selected\") && !t.selected && (e.setAttribute(\"selected\", \"selected\"), e.removeAttribute(\"selected\")), n.selectedIndex = -1);\\n        }\\n\\n        d(e, t, \"selected\");\\n      },\\n      INPUT: function (e, t) {\\n        d(e, t, \"checked\"), d(e, t, \"disabled\"), e.value !== t.value && (e.value = t.value), t.hasAttribute(\"value\") || e.removeAttribute(\"value\");\\n      },\\n      TEXTAREA: function (e, t) {\\n        var n = t.value;\\n        e.value !== n && (e.value = n);\\n        var i = e.firstChild;\\n\\n        if (i) {\\n          var r = i.nodeValue;\\n          if (r == n || !n && r == e.placeholder) return;\\n          i.nodeValue = n;\\n        }\\n      },\\n      SELECT: function (e, t) {\\n        if (!t.hasAttribute(\"multiple\")) {\\n          for (var n, i, r = -1, o = 0, a = e.firstChild; a;) if (\"OPTGROUP\" === (i = a.nodeName && a.nodeName.toUpperCase())) a = (n = a).firstChild;else {\\n            if (\"OPTION\" === i) {\\n              if (a.hasAttribute(\"selected\")) {\\n                r = o;\\n                break;\\n              }\\n\\n              o++;\\n            }\\n\\n            !(a = a.nextSibling) && n && (a = n.nextSibling, n = null);\\n          }\\n\\n          e.selectedIndex = r;\\n        }\\n      }\\n    },\\n        f = 1,\\n        v = 11,\\n        p = 3,\\n        g = 8;\\n\\n    function m() {}\\n\\n    function y(e) {\\n      if (e) return e.getAttribute && e.getAttribute(\"id\") || e.id;\\n    }\\n\\n    var b = function (e) {\\n      return function (t, n, i) {\\n        if (i || (i = {}), \"string\" == typeof n) if (\"#document\" === t.nodeName || \"HTML\" === t.nodeName || \"BODY\" === t.nodeName) {\\n          var r = n;\\n          (n = a.createElement(\"html\")).innerHTML = r;\\n        } else n = c(n);\\n        var u = i.getNodeKey || y,\\n            s = i.onBeforeNodeAdded || m,\\n            d = i.onNodeAdded || m,\\n            b = i.onBeforeElUpdated || m,\\n            k = i.onElUpdated || m,\\n            w = i.onBeforeNodeDiscarded || m,\\n            E = i.onNodeDiscarded || m,\\n            A = i.onBeforeElChildrenUpdated || m,\\n            S = !0 === i.childrenOnly,\\n            x = Object.create(null),\\n            C = [];\\n\\n        function P(e) {\\n          C.push(e);\\n        }\\n\\n        function L(e, t, n) {\\n          !1 !== w(e) && (t && t.removeChild(e), E(e), function e(t, n) {\\n            if (t.nodeType === f) for (var i = t.firstChild; i;) {\\n              var r = void 0;\\n              n && (r = u(i)) ? P(r) : (E(i), i.firstChild && e(i, n)), i = i.nextSibling;\\n            }\\n          }(e, n));\\n        }\\n\\n        function I(e) {\\n          d(e);\\n\\n          for (var t = e.firstChild; t;) {\\n            var n = t.nextSibling,\\n                i = u(t);\\n\\n            if (i) {\\n              var r = x[i];\\n              r && l(t, r) ? (t.parentNode.replaceChild(r, t), T(r, t)) : I(t);\\n            } else I(t);\\n\\n            t = n;\\n          }\\n        }\\n\\n        function T(t, n, i) {\\n          var r = u(n);\\n\\n          if (r && delete x[r], !i) {\\n            if (!1 === b(t, n)) return;\\n            if (e(t, n), k(t), !1 === A(t, n)) return;\\n          }\\n\\n          \"TEXTAREA\" !== t.nodeName ? function (e, t) {\\n            var n,\\n                i,\\n                r,\\n                o,\\n                c,\\n                d = t.firstChild,\\n                v = e.firstChild;\\n\\n            e: for (; d;) {\\n              for (o = d.nextSibling, n = u(d); v;) {\\n                if (r = v.nextSibling, d.isSameNode && d.isSameNode(v)) {\\n                  d = o, v = r;\\n                  continue e;\\n                }\\n\\n                i = u(v);\\n                var m = v.nodeType,\\n                    y = void 0;\\n\\n                if (m === d.nodeType && (m === f ? (n ? n !== i && ((c = x[n]) ? r === c ? y = !1 : (e.insertBefore(c, v), i ? P(i) : L(v, e, !0), v = c) : y = !1) : i && (y = !1), (y = !1 !== y && l(v, d)) && T(v, d)) : m !== p && m != g || (y = !0, v.nodeValue !== d.nodeValue && (v.nodeValue = d.nodeValue))), y) {\\n                  d = o, v = r;\\n                  continue e;\\n                }\\n\\n                i ? P(i) : L(v, e, !0), v = r;\\n              }\\n\\n              if (n && (c = x[n]) && l(c, d)) e.appendChild(c), T(c, d);else {\\n                var b = s(d);\\n                !1 !== b && (b && (d = b), d.actualize && (d = d.actualize(e.ownerDocument || a)), e.appendChild(d), I(d));\\n              }\\n              d = o, v = r;\\n            }\\n\\n            !function (e, t, n) {\\n              for (; t;) {\\n                var i = t.nextSibling;\\n                (n = u(t)) ? P(n) : L(t, e, !0), t = i;\\n              }\\n            }(e, v, i);\\n            var k = h[e.nodeName];\\n            k && k(e, t);\\n          }(t, n) : h.TEXTAREA(t, n);\\n        }\\n\\n        !function e(t) {\\n          if (t.nodeType === f || t.nodeType === v) for (var n = t.firstChild; n;) {\\n            var i = u(n);\\n            i && (x[i] = n), e(n), n = n.nextSibling;\\n          }\\n        }(t);\\n        var D = t,\\n            _ = D.nodeType,\\n            N = n.nodeType;\\n        if (!S) if (_ === f) N === f ? l(t, n) || (E(t), D = function (e, t) {\\n          for (var n = e.firstChild; n;) {\\n            var i = n.nextSibling;\\n            t.appendChild(n), n = i;\\n          }\\n\\n          return t;\\n        }(t, function (e, t) {\\n          return t && t !== o ? a.createElementNS(t, e) : a.createElement(e);\\n        }(n.nodeName, n.namespaceURI))) : D = n;else if (_ === p || _ === g) {\\n          if (N === _) return D.nodeValue !== n.nodeValue && (D.nodeValue = n.nodeValue), D;\\n          D = n;\\n        }\\n        if (D === n) E(t);else {\\n          if (n.isSameNode && n.isSameNode(D)) return;\\n          if (T(D, n, S), C) for (var R = 0, O = C.length; R < O; R++) {\\n            var j = x[C[R]];\\n            j && L(j, j.parentNode, !1);\\n          }\\n        }\\n        return !S && D !== t && t.parentNode && (D.actualize && (D = D.actualize(t.ownerDocument || a)), t.parentNode.replaceChild(D, t)), D;\\n      };\\n    }(function (e, t) {\\n      var n,\\n          i,\\n          o,\\n          a,\\n          u = t.attributes;\\n\\n      if (t.nodeType !== r && e.nodeType !== r) {\\n        for (var s = u.length - 1; s >= 0; s--) i = (n = u[s]).name, o = n.namespaceURI, a = n.value, o ? (i = n.localName || i, e.getAttributeNS(o, i) !== a && (\"xmlns\" === n.prefix && (i = n.name), e.setAttributeNS(o, i, a))) : e.getAttribute(i) !== a && e.setAttribute(i, a);\\n\\n        for (var c = e.attributes, l = c.length - 1; l >= 0; l--) i = (n = c[l]).name, (o = n.namespaceURI) ? (i = n.localName || i, t.hasAttributeNS(o, i) || e.removeAttributeNS(o, i)) : t.hasAttribute(i) || e.removeAttribute(i);\\n      }\\n    });\\n\\n    function k(e) {\\n      return P(e) || S(e) || L(e) || C();\\n    }\\n\\n    function w(e, t) {\\n      var n = Object.keys(e);\\n\\n      if (Object.getOwnPropertySymbols) {\\n        var i = Object.getOwnPropertySymbols(e);\\n        t && (i = i.filter(function (t) {\\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\\n        })), n.push.apply(n, i);\\n      }\\n\\n      return n;\\n    }\\n\\n    function E(e, t, n) {\\n      return t in e ? Object.defineProperty(e, t, {\\n        value: n,\\n        enumerable: !0,\\n        configurable: !0,\\n        writable: !0\\n      }) : e[t] = n, e;\\n    }\\n\\n    function A(e) {\\n      return function (e) {\\n        if (Array.isArray(e)) return I(e);\\n      }(e) || S(e) || L(e) || function () {\\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\\n      }();\\n    }\\n\\n    function S(e) {\\n      if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);\\n    }\\n\\n    function x(e, t) {\\n      return P(e) || function (e, t) {\\n        if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(e))) return;\\n        var n = [],\\n            i = !0,\\n            r = !1,\\n            o = void 0;\\n\\n        try {\\n          for (var a, u = e[Symbol.iterator](); !(i = (a = u.next()).done) && (n.push(a.value), !t || n.length !== t); i = !0);\\n        } catch (e) {\\n          r = !0, o = e;\\n        } finally {\\n          try {\\n            i || null == u.return || u.return();\\n          } finally {\\n            if (r) throw o;\\n          }\\n        }\\n\\n        return n;\\n      }(e, t) || L(e, t) || C();\\n    }\\n\\n    function C() {\\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\\n    }\\n\\n    function P(e) {\\n      if (Array.isArray(e)) return e;\\n    }\\n\\n    function L(e, t) {\\n      if (e) {\\n        if (\"string\" == typeof e) return I(e, t);\\n        var n = Object.prototype.toString.call(e).slice(8, -1);\\n        return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(e) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? I(e, t) : void 0;\\n      }\\n    }\\n\\n    function I(e, t) {\\n      (null == t || t > e.length) && (t = e.length);\\n\\n      for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\\n\\n      return i;\\n    }\\n\\n    function T(e, t) {\\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\\n    }\\n\\n    function D(e, t) {\\n      for (var n = 0; n < t.length; n++) {\\n        var i = t[n];\\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\\n      }\\n    }\\n\\n    function _(e, t, n) {\\n      return t && D(e.prototype, t), n && D(e, n), e;\\n    }\\n\\n    function N(e) {\\n      \"@babel/helpers - typeof\";\\n\\n      return (N = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\\n        return typeof e;\\n      } : function (e) {\\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\\n      })(e);\\n    }\\n\\n    n.d(t, \"debug\", function () {\\n      return K;\\n    }), n.d(t, \"Rendered\", function () {\\n      return ue;\\n    }), n.d(t, \"LiveSocket\", function () {\\n      return se;\\n    }), n.d(t, \"Browser\", function () {\\n      return ce;\\n    }), n.d(t, \"DOM\", function () {\\n      return le;\\n    }), n.d(t, \"View\", function () {\\n      return fe;\\n    });\\n\\n    var R = [1e3, 3e3],\\n        O = \"data-phx-view\",\\n        j = [\"phx-click-loading\", \"phx-change-loading\", \"phx-submit-loading\", \"phx-keydown-loading\", \"phx-keyup-loading\", \"phx-blur-loading\", \"phx-focus-loading\"],\\n        H = \"data-phx-component\",\\n        F = \"data-phx-ref\",\\n        M = \"data-phx-upload-ref\",\\n        U = \"[\".concat(O, \"]\"),\\n        B = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\", \"date\", \"time\"],\\n        J = [\"checkbox\", \"radio\"],\\n        V = 1,\\n        W = \"phx-\",\\n        q = {\\n      debounce: 300,\\n      throttle: 300\\n    },\\n        z = function (e, t) {\\n      return console.error && console.error(e, t);\\n    };\\n\\n    var K = function (e, t, n, i) {\\n      e.liveSocket.isDebugEnabled() && console.log(\"\".concat(e.id, \" \").concat(t, \": \").concat(n, \" - \"), i);\\n    },\\n        X = function (e) {\\n      return \"function\" == typeof e ? e : function () {\\n        return e;\\n      };\\n    },\\n        $ = function (e) {\\n      return JSON.parse(JSON.stringify(e));\\n    },\\n        G = function (e, t, n) {\\n      do {\\n        if (e.matches(\"[\".concat(t, \"]\"))) return e;\\n        e = e.parentElement || e.parentNode;\\n      } while (null !== e && 1 === e.nodeType && !(n && n.isSameNode(e) || e.matches(U)));\\n\\n      return null;\\n    },\\n        Y = function (e) {\\n      return null !== e && \"object\" === N(e) && !(e instanceof Array);\\n    },\\n        Q = function (e) {\\n      for (var t in e) return !1;\\n\\n      return !0;\\n    },\\n        Z = function (e, t) {\\n      return e && t(e);\\n    },\\n        ee = function () {\\n      function e(t, n, i) {\\n        T(this, e), this.ref = ie.genFileRef(n), this.fileEl = t, this.file = n, this.view = i, this.meta = null, this._isCancelled = !1, this._isDone = !1, this._progress = 0, this._onDone = function () {};\\n      }\\n\\n      return _(e, null, [{\\n        key: \"isActive\",\\n        value: function (e, t) {\\n          var n = void 0 === t._phxRef,\\n              i = e.getAttribute(\"data-phx-active-refs\").split(\",\").indexOf(ie.genFileRef(t)) >= 0;\\n          return t.size > 0 && (n || i);\\n        }\\n      }, {\\n        key: \"isPreflighted\",\\n        value: function (e, t) {\\n          var n = e.getAttribute(\"data-phx-preflighted-refs\").split(\",\").indexOf(ie.genFileRef(t)) >= 0;\\n          return n && this.isActive(e, t);\\n        }\\n      }]), _(e, [{\\n        key: \"metadata\",\\n        value: function () {\\n          return this.meta;\\n        }\\n      }, {\\n        key: \"progress\",\\n        value: function (e) {\\n          var t = this;\\n          this._progress = Math.floor(e), this._progress >= 100 ? (this._progress = 100, this._isDone = !0, this.view.pushFileProgress(this.fileEl, this.ref, 100, function () {\\n            ie.untrackFile(t.fileEl, t.file), t._onDone();\\n          })) : this.view.pushFileProgress(this.fileEl, this.ref, this._progress);\\n        }\\n      }, {\\n        key: \"cancel\",\\n        value: function () {\\n          this._isCancelled = !0, this._isDone = !0, this._onDone();\\n        }\\n      }, {\\n        key: \"isDone\",\\n        value: function () {\\n          return this._isDone;\\n        }\\n      }, {\\n        key: \"error\",\\n        value: function () {\\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"failed\";\\n          this.view.pushFileProgress(this.fileEl, this.ref, {\\n            error: e\\n          });\\n        }\\n      }, {\\n        key: \"onDone\",\\n        value: function (e) {\\n          this._onDone = e;\\n        }\\n      }, {\\n        key: \"toPreflightPayload\",\\n        value: function () {\\n          return {\\n            last_modified: this.file.lastModified,\\n            name: this.file.name,\\n            size: this.file.size,\\n            type: this.file.type,\\n            ref: this.ref\\n          };\\n        }\\n      }, {\\n        key: \"uploader\",\\n        value: function (e) {\\n          if (this.meta.uploader) {\\n            var t = e[this.meta.uploader] || z(\"no uploader configured for \".concat(this.meta.uploader));\\n            return {\\n              name: this.meta.uploader,\\n              callback: t\\n            };\\n          }\\n\\n          return {\\n            name: \"channel\",\\n            callback: re\\n          };\\n        }\\n      }, {\\n        key: \"zipPostFlight\",\\n        value: function (e) {\\n          this.meta = e.entries[this.ref], this.meta || z(\"no preflight upload response returned with ref \".concat(this.ref), {\\n            input: this.fileEl,\\n            response: e\\n          });\\n        }\\n      }]), e;\\n    }(),\\n        te = {\\n      LiveFileUpload: {\\n        preflightedRefs: function () {\\n          return this.el.getAttribute(\"data-phx-preflighted-refs\");\\n        },\\n        mounted: function () {\\n          this.preflightedWas = this.preflightedRefs();\\n        },\\n        updated: function () {\\n          var e = this.preflightedRefs();\\n          this.preflightedWas !== e && (this.preflightedWas = e, \"\" === e && this.__view.cancelSubmit(this.el.form));\\n        }\\n      }\\n    };\\n\\n    te.LiveImgPreview = {\\n      mounted: function () {\\n        var e = this;\\n        this.ref = this.el.getAttribute(\"data-phx-entry-ref\"), this.inputEl = document.getElementById(this.el.getAttribute(M)), ie.getEntryDataURL(this.inputEl, this.ref, function (t) {\\n          return e.el.src = t;\\n        });\\n      }\\n    };\\n\\n    var ne = 0,\\n        ie = function () {\\n      function e(t, n, i) {\\n        T(this, e), this.view = n, this.onComplete = i, this._entries = Array.from(e.filesAwaitingPreflight(t) || []).map(function (e) {\\n          return new ee(t, e, n);\\n        }), this.numEntriesInProgress = this._entries.length;\\n      }\\n\\n      return _(e, null, [{\\n        key: \"genFileRef\",\\n        value: function (e) {\\n          var t = e._phxRef;\\n          return void 0 !== t ? t : (e._phxRef = (ne++).toString(), e._phxRef);\\n        }\\n      }, {\\n        key: \"getEntryDataURL\",\\n        value: function (e, t, n) {\\n          var i = this,\\n              r = this.activeFiles(e).find(function (e) {\\n            return i.genFileRef(e) === t;\\n          }),\\n              o = new FileReader();\\n          o.onload = function (e) {\\n            return n(e.target.result);\\n          }, o.readAsDataURL(r);\\n        }\\n      }, {\\n        key: \"hasUploadsInProgress\",\\n        value: function (e) {\\n          var t = 0;\\n          return le.findUploadInputs(e).forEach(function (e) {\\n            e.getAttribute(\"data-phx-preflighted-refs\") !== e.getAttribute(\"data-phx-done-refs\") && t++;\\n          }), t > 0;\\n        }\\n      }, {\\n        key: \"serializeUploads\",\\n        value: function (e) {\\n          var t = this,\\n              n = {};\\n          return this.activeFiles(e, \"serialize\").forEach(function (i) {\\n            var r = {\\n              path: e.name\\n            },\\n                o = e.getAttribute(M);\\n            n[o] = n[o] || [], r.ref = t.genFileRef(i), r.name = i.name, r.type = i.type, r.size = i.size, n[o].push(r);\\n          }), n;\\n        }\\n      }, {\\n        key: \"clearFiles\",\\n        value: function (e) {\\n          e.value = null, le.putPrivate(e, \"files\", []);\\n        }\\n      }, {\\n        key: \"untrackFile\",\\n        value: function (e, t) {\\n          le.putPrivate(e, \"files\", le.private(e, \"files\").filter(function (e) {\\n            return !Object.is(e, t);\\n          }));\\n        }\\n      }, {\\n        key: \"trackFiles\",\\n        value: function (e, t) {\\n          var n = this;\\n\\n          if (null !== e.getAttribute(\"multiple\")) {\\n            var i = t.filter(function (t) {\\n              return !n.activeFiles(e).find(function (e) {\\n                return Object.is(e, t);\\n              });\\n            });\\n            le.putPrivate(e, \"files\", this.activeFiles(e).concat(i)), e.value = null;\\n          } else le.putPrivate(e, \"files\", t);\\n        }\\n      }, {\\n        key: \"activeFileInputs\",\\n        value: function (e) {\\n          var t = this,\\n              n = le.findUploadInputs(e);\\n          return Array.from(n).filter(function (e) {\\n            return e.files && t.activeFiles(e).length > 0;\\n          });\\n        }\\n      }, {\\n        key: \"activeFiles\",\\n        value: function (e) {\\n          return (le.private(e, \"files\") || []).filter(function (t) {\\n            return ee.isActive(e, t);\\n          });\\n        }\\n      }, {\\n        key: \"inputsAwaitingPreflight\",\\n        value: function (e) {\\n          var t = this,\\n              n = le.findUploadInputs(e);\\n          return Array.from(n).filter(function (e) {\\n            return t.filesAwaitingPreflight(e).length > 0;\\n          });\\n        }\\n      }, {\\n        key: \"filesAwaitingPreflight\",\\n        value: function (e) {\\n          return this.activeFiles(e).filter(function (t) {\\n            return !ee.isPreflighted(e, t);\\n          });\\n        }\\n      }]), _(e, [{\\n        key: \"entries\",\\n        value: function () {\\n          return this._entries;\\n        }\\n      }, {\\n        key: \"initAdapterUpload\",\\n        value: function (e, t, n) {\\n          var i = this;\\n          this._entries = this._entries.map(function (t) {\\n            return t.zipPostFlight(e), t.onDone(function () {\\n              i.numEntriesInProgress--, 0 === i.numEntriesInProgress && i.onComplete();\\n            }), t;\\n          });\\n\\n          var r = this._entries.reduce(function (e, t) {\\n            var i = t.uploader(n.uploaders),\\n                r = i.name,\\n                o = i.callback;\\n            return e[r] = e[r] || {\\n              callback: o,\\n              entries: []\\n            }, e[r].entries.push(t), e;\\n          }, {});\\n\\n          for (var o in r) {\\n            var a = r[o];\\n            (0, a.callback)(a.entries, t, e, n);\\n          }\\n        }\\n      }]), e;\\n    }(),\\n        re = function (e, t, n, i) {\\n      e.forEach(function (e) {\\n        new oe(e, n.config.chunk_size, i).upload();\\n      });\\n    },\\n        oe = function () {\\n      function e(t, n, i) {\\n        T(this, e), this.liveSocket = i, this.entry = t, this.offset = 0, this.chunkSize = n, this.uploadChannel = i.channel(\"lvu:\".concat(t.ref), {\\n          token: t.metadata()\\n        });\\n      }\\n\\n      return _(e, [{\\n        key: \"upload\",\\n        value: function () {\\n          var e = this;\\n          this.uploadChannel.join().receive(\"ok\", function (t) {\\n            return e.readNextChunk();\\n          }).receive(\"error\", function (t) {\\n            e.uploadChannel.leave(), e.entry.error();\\n          });\\n        }\\n      }, {\\n        key: \"isDone\",\\n        value: function () {\\n          return this.offset >= this.entry.file.size;\\n        }\\n      }, {\\n        key: \"readNextChunk\",\\n        value: function () {\\n          var e = this,\\n              t = new window.FileReader(),\\n              n = this.entry.file.slice(this.offset, this.chunkSize + this.offset);\\n          t.onload = function (t) {\\n            if (null !== t.target.error) return z(\"Read error: \" + t.target.error);\\n            e.offset += t.target.result.byteLength, e.pushChunk(t.target.result);\\n          }, t.readAsArrayBuffer(n);\\n        }\\n      }, {\\n        key: \"pushChunk\",\\n        value: function (e) {\\n          var t = this;\\n          this.uploadChannel.isJoined() && this.uploadChannel.push(\"chunk\", e).receive(\"ok\", function () {\\n            t.entry.progress(t.offset / t.entry.file.size * 100), t.isDone() || setTimeout(function () {\\n              return t.readNextChunk();\\n            }, t.liveSocket.getLatencySim() || 0);\\n          });\\n        }\\n      }]), e;\\n    }(),\\n        ae = function (e) {\\n      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\\n          n = new FormData(e),\\n          i = [];\\n      n.forEach(function (e, t, n) {\\n        e instanceof File && i.push(t);\\n      }), i.forEach(function (e) {\\n        return n.delete(e);\\n      });\\n\\n      var r,\\n          o = new URLSearchParams(),\\n          a = function (e) {\\n        if (\"undefined\" == typeof Symbol || null == e[Symbol.iterator]) {\\n          if (Array.isArray(e) || (e = L(e))) {\\n            var t = 0,\\n                n = function () {};\\n\\n            return {\\n              s: n,\\n              n: function () {\\n                return t >= e.length ? {\\n                  done: !0\\n                } : {\\n                  done: !1,\\n                  value: e[t++]\\n                };\\n              },\\n              e: function (e) {\\n                throw e;\\n              },\\n              f: n\\n            };\\n          }\\n\\n          throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\\n        }\\n\\n        var i,\\n            r,\\n            o = !0,\\n            a = !1;\\n        return {\\n          s: function () {\\n            i = e[Symbol.iterator]();\\n          },\\n          n: function () {\\n            var e = i.next();\\n            return o = e.done, e;\\n          },\\n          e: function (e) {\\n            a = !0, r = e;\\n          },\\n          f: function () {\\n            try {\\n              o || null == i.return || i.return();\\n            } finally {\\n              if (a) throw r;\\n            }\\n          }\\n        };\\n      }(n.entries());\\n\\n      try {\\n        for (a.s(); !(r = a.n()).done;) {\\n          var u = x(r.value, 2),\\n              s = u[0],\\n              c = u[1];\\n          o.append(s, c);\\n        }\\n      } catch (e) {\\n        a.e(e);\\n      } finally {\\n        a.f();\\n      }\\n\\n      for (var l in t) o.append(l, t[l]);\\n\\n      return o.toString();\\n    },\\n        ue = function () {\\n      function e(t, n) {\\n        T(this, e), this.viewId = t, this.rendered = {}, this.mergeDiff(n);\\n      }\\n\\n      return _(e, null, [{\\n        key: \"extract\",\\n        value: function (e) {\\n          var t = e.r,\\n              n = e.e,\\n              i = e.t;\\n          return delete e.r, delete e.e, delete e.t, {\\n            diff: e,\\n            title: i,\\n            reply: t || null,\\n            events: n || []\\n          };\\n        }\\n      }]), _(e, [{\\n        key: \"parentViewId\",\\n        value: function () {\\n          return this.viewId;\\n        }\\n      }, {\\n        key: \"toString\",\\n        value: function (e) {\\n          return this.recursiveToString(this.rendered, this.rendered.c, e);\\n        }\\n      }, {\\n        key: \"recursiveToString\",\\n        value: function (e) {\\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.c,\\n              n = arguments.length > 2 ? arguments[2] : void 0,\\n              i = {\\n            buffer: \"\",\\n            components: t,\\n            onlyCids: n = n ? new Set(n) : null\\n          };\\n          return this.toOutputBuffer(e, i), i.buffer;\\n        }\\n      }, {\\n        key: \"componentCIDs\",\\n        value: function (e) {\\n          return Object.keys(e.c || {}).map(function (e) {\\n            return parseInt(e);\\n          });\\n        }\\n      }, {\\n        key: \"isComponentOnlyDiff\",\\n        value: function (e) {\\n          return !!e.c && 1 === Object.keys(e).length;\\n        }\\n      }, {\\n        key: \"getComponent\",\\n        value: function (e, t) {\\n          return e.c[t];\\n        }\\n      }, {\\n        key: \"mergeDiff\",\\n        value: function (e) {\\n          var t = e.c;\\n\\n          if (delete e.c, this.rendered = this.recursiveMerge(this.rendered, e), this.rendered.c = this.rendered.c || {}, t) {\\n            var n = this.rendered.c;\\n\\n            for (var i in t) {\\n              var r = t[i],\\n                  o = r,\\n                  a = o.s;\\n\\n              if (\"number\" == typeof a) {\\n                for (; \"number\" == typeof a;) a = (o = a > 0 ? t[a] : n[-a]).s;\\n\\n                o = $(o), this.doRecursiveMerge(o, r), o.s = a;\\n              } else o = n[i] || {}, o = this.recursiveMerge(o, r);\\n\\n              t[i] = o;\\n            }\\n\\n            for (var u in t) n[u] = t[u];\\n\\n            e.c = t;\\n          }\\n        }\\n      }, {\\n        key: \"recursiveMerge\",\\n        value: function (e, t) {\\n          return void 0 !== t.s ? t : (this.doRecursiveMerge(e, t), e);\\n        }\\n      }, {\\n        key: \"doRecursiveMerge\",\\n        value: function (e, t) {\\n          for (var n in t) {\\n            var i = t[n],\\n                r = e[n];\\n            Y(i) && void 0 === i.s && Y(r) ? this.doRecursiveMerge(r, i) : e[n] = i;\\n          }\\n        }\\n      }, {\\n        key: \"componentToString\",\\n        value: function (e) {\\n          return this.recursiveCIDToString(this.rendered.c, e);\\n        }\\n      }, {\\n        key: \"pruneCIDs\",\\n        value: function (e) {\\n          var t = this;\\n          e.forEach(function (e) {\\n            return delete t.rendered.c[e];\\n          });\\n        }\\n      }, {\\n        key: \"get\",\\n        value: function () {\\n          return this.rendered;\\n        }\\n      }, {\\n        key: \"isNewFingerprint\",\\n        value: function () {\\n          return !!(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).s;\\n        }\\n      }, {\\n        key: \"toOutputBuffer\",\\n        value: function (e, t) {\\n          if (e.d) return this.comprehensionToBuffer(e, t);\\n          var n = e.s;\\n          t.buffer += n[0];\\n\\n          for (var i = 1; i < n.length; i++) this.dynamicToBuffer(e[i - 1], t), t.buffer += n[i];\\n        }\\n      }, {\\n        key: \"comprehensionToBuffer\",\\n        value: function (e, t) {\\n          for (var n = e.d, i = e.s, r = 0; r < n.length; r++) {\\n            var o = n[r];\\n            t.buffer += i[0];\\n\\n            for (var a = 1; a < i.length; a++) this.dynamicToBuffer(o[a - 1], t), t.buffer += i[a];\\n          }\\n        }\\n      }, {\\n        key: \"dynamicToBuffer\",\\n        value: function (e, t) {\\n          \"number\" == typeof e ? t.buffer += this.recursiveCIDToString(t.components, e, t.onlyCids) : Y(e) ? this.toOutputBuffer(e, t) : t.buffer += e;\\n        }\\n      }, {\\n        key: \"recursiveCIDToString\",\\n        value: function (e, t, n) {\\n          var i = this,\\n              r = e[t] || z(\"no component for CID \".concat(t), e),\\n              o = document.createElement(\"template\");\\n          o.innerHTML = this.recursiveToString(r, e, n);\\n          var a = o.content,\\n              u = n && !n.has(t),\\n              s = x(Array.from(a.childNodes).reduce(function (e, n, r) {\\n            var a = x(e, 2),\\n                s = a[0],\\n                c = a[1];\\n            return n.nodeType === Node.ELEMENT_NODE ? n.getAttribute(H) ? [s, !0] : (n.setAttribute(H, t), n.id || (n.id = \"\".concat(i.parentViewId(), \"-\").concat(t, \"-\").concat(r)), u && (n.setAttribute(\"data-phx-skip\", \"\"), n.innerHTML = \"\"), [!0, c]) : \"\" !== n.nodeValue.trim() ? (z(\"only HTML element tags are allowed at the root of components.\\\\n\\\\n\" + \\'got: \"\\'.concat(n.nodeValue.trim(), \\'\"\\\\n\\\\n\\') + \"within:\\\\n\", o.innerHTML.trim()), n.replaceWith(i.createSpan(n.nodeValue, t)), [!0, c]) : (n.remove(), [s, c]);\\n          }, [!1, !1]), 2),\\n              c = s[0],\\n              l = s[1];\\n          return c || l ? !c && l ? (z(\"expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.\", o.innerHTML.trim()), o.innerHTML) : o.innerHTML : (z(\"expected at least one HTML element tag inside a component, but the component is empty:\\\\n\", o.innerHTML.trim()), this.createSpan(\"\", t).outerHTML);\\n        }\\n      }, {\\n        key: \"createSpan\",\\n        value: function (e, t) {\\n          var n = document.createElement(\"span\");\\n          return n.innerText = e, n.setAttribute(H, t), n;\\n        }\\n      }]), e;\\n    }(),\\n        se = function () {\\n      function e(t, n) {\\n        var i = this,\\n            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\\n        if (T(this, e), this.unloaded = !1, !n || \"Object\" === n.constructor.name) throw new Error(\\'\\\\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\\\\n\\\\n          import {Socket} from \"phoenix\"\\\\n          import {LiveSocket} from \"phoenix_live_view\"\\\\n          let liveSocket = new LiveSocket(\"/live\", Socket, {...})\\\\n      \\');\\n        this.socket = new n(t, r), this.bindingPrefix = r.bindingPrefix || W, this.opts = r, this.params = X(r.params || {}), this.viewLogger = r.viewLogger, this.metadataCallbacks = r.metadata || {}, this.defaults = Object.assign($(q), r.defaults || {}), this.activeElement = null, this.prevActive = null, this.silenced = !1, this.main = null, this.linkRef = 0, this.roots = {}, this.href = window.location.href, this.pendingLink = null, this.currentLocation = $(window.location), this.hooks = r.hooks || {}, this.uploaders = r.uploaders || {}, this.loaderTimeout = r.loaderTimeout || V, this.boundTopLevelEvents = !1, this.domCallbacks = Object.assign({\\n          onNodeAdded: X(),\\n          onBeforeElUpdated: X()\\n        }, r.dom || {}), window.addEventListener(\"unload\", function (e) {\\n          i.unloaded = !0;\\n        }), this.socket.onOpen(function () {\\n          i.isUnloaded() && window.location.reload();\\n        });\\n      }\\n\\n      return _(e, [{\\n        key: \"isProfileEnabled\",\\n        value: function () {\\n          return \"true\" === sessionStorage.getItem(\"phx:live-socket:profiling\");\\n        }\\n      }, {\\n        key: \"isDebugEnabled\",\\n        value: function () {\\n          return \"true\" === sessionStorage.getItem(\"phx:live-socket:debug\");\\n        }\\n      }, {\\n        key: \"enableDebug\",\\n        value: function () {\\n          sessionStorage.setItem(\"phx:live-socket:debug\", \"true\");\\n        }\\n      }, {\\n        key: \"enableProfiling\",\\n        value: function () {\\n          sessionStorage.setItem(\"phx:live-socket:profiling\", \"true\");\\n        }\\n      }, {\\n        key: \"disableDebug\",\\n        value: function () {\\n          sessionStorage.removeItem(\"phx:live-socket:debug\");\\n        }\\n      }, {\\n        key: \"disableProfiling\",\\n        value: function () {\\n          sessionStorage.removeItem(\"phx:live-socket:profiling\");\\n        }\\n      }, {\\n        key: \"enableLatencySim\",\\n        value: function (e) {\\n          this.enableDebug(), console.log(\"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\"), sessionStorage.setItem(\"phx:live-socket:latency-sim\", e);\\n        }\\n      }, {\\n        key: \"disableLatencySim\",\\n        value: function () {\\n          sessionStorage.removeItem(\"phx:live-socket:latency-sim\");\\n        }\\n      }, {\\n        key: \"getLatencySim\",\\n        value: function () {\\n          var e = sessionStorage.getItem(\"phx:live-socket:latency-sim\");\\n          return e ? parseInt(e) : null;\\n        }\\n      }, {\\n        key: \"getSocket\",\\n        value: function () {\\n          return this.socket;\\n        }\\n      }, {\\n        key: \"connect\",\\n        value: function () {\\n          var e = this,\\n              t = function () {\\n            e.joinRootViews() && (e.bindTopLevelEvents(), e.socket.connect());\\n          };\\n\\n          [\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0 ? t() : document.addEventListener(\"DOMContentLoaded\", function () {\\n            return t();\\n          });\\n        }\\n      }, {\\n        key: \"disconnect\",\\n        value: function (e) {\\n          this.socket.disconnect(e);\\n        }\\n      }, {\\n        key: \"triggerDOM\",\\n        value: function (e, t) {\\n          var n;\\n          (n = this.domCallbacks)[e].apply(n, A(t));\\n        }\\n      }, {\\n        key: \"time\",\\n        value: function (e, t) {\\n          if (!this.isProfileEnabled() || !console.time) return t();\\n          console.time(e);\\n          var n = t();\\n          return console.timeEnd(e), n;\\n        }\\n      }, {\\n        key: \"log\",\\n        value: function (e, t, n) {\\n          if (this.viewLogger) {\\n            var i = x(n(), 2),\\n                r = i[0],\\n                o = i[1];\\n            this.viewLogger(e, t, r, o);\\n          } else if (this.isDebugEnabled()) {\\n            var a = x(n(), 2),\\n                u = a[0],\\n                s = a[1];\\n            K(e, t, u, s);\\n          }\\n        }\\n      }, {\\n        key: \"onChannel\",\\n        value: function (e, t, n) {\\n          var i = this;\\n          e.on(t, function (e) {\\n            var t = i.getLatencySim();\\n            t ? (console.log(\"simulating \".concat(t, \"ms of latency from server to client\")), setTimeout(function () {\\n              return n(e);\\n            }, t)) : n(e);\\n          });\\n        }\\n      }, {\\n        key: \"wrapPush\",\\n        value: function (e, t, n) {\\n          var i = this,\\n              r = this.getLatencySim(),\\n              o = e.joinCount;\\n          if (!r) return t.timeout ? n().receive(\"timeout\", function () {\\n            e.joinCount === o && i.reloadWithJitter(e, function () {\\n              i.log(e, \"timeout\", function () {\\n                return [\"received timeout while communicating with server. Falling back to hard refresh for recovery\"];\\n              });\\n            });\\n          }) : n();\\n          console.log(\"simulating \".concat(r, \"ms of latency from client to server\"));\\n          var a = {\\n            receives: [],\\n            receive: function (e, t) {\\n              this.receives.push([e, t]);\\n            }\\n          };\\n          return setTimeout(function () {\\n            a.receives.reduce(function (e, t) {\\n              var n = x(t, 2),\\n                  i = n[0],\\n                  r = n[1];\\n              return e.receive(i, r);\\n            }, n());\\n          }, r), a;\\n        }\\n      }, {\\n        key: \"reloadWithJitter\",\\n        value: function (e, t) {\\n          var n = this;\\n          e.destroy(), this.disconnect();\\n          var i = R[0],\\n              r = R[1],\\n              o = Math.floor(Math.random() * (r - i + 1)) + i,\\n              a = ce.updateLocal(e.name(), \"consecutive-reloads\", 0, function (e) {\\n            return e + 1;\\n          });\\n          t ? t() : this.log(e, \"join\", function () {\\n            return [\"encountered \".concat(a, \" consecutive reloads\")];\\n          }), a > 10 && (this.log(e, \"join\", function () {\\n            return [\"exceeded \".concat(10, \" consecutive reloads. Entering failsafe mode\")];\\n          }), o = 3e4), setTimeout(function () {\\n            n.hasPendingLink() ? window.location = n.pendingLink : window.location.reload();\\n          }, o);\\n        }\\n      }, {\\n        key: \"getHookCallbacks\",\\n        value: function (e) {\\n          return e && e.startsWith(\"Phoenix.\") ? te[e.split(\".\")[1]] : this.hooks[e];\\n        }\\n      }, {\\n        key: \"isUnloaded\",\\n        value: function () {\\n          return this.unloaded;\\n        }\\n      }, {\\n        key: \"isConnected\",\\n        value: function () {\\n          return this.socket.isConnected();\\n        }\\n      }, {\\n        key: \"getBindingPrefix\",\\n        value: function () {\\n          return this.bindingPrefix;\\n        }\\n      }, {\\n        key: \"binding\",\\n        value: function (e) {\\n          return \"\".concat(this.getBindingPrefix()).concat(e);\\n        }\\n      }, {\\n        key: \"channel\",\\n        value: function (e, t) {\\n          return this.socket.channel(e, t);\\n        }\\n      }, {\\n        key: \"joinRootViews\",\\n        value: function () {\\n          var e = this,\\n              t = !1;\\n          return le.all(document, \"\".concat(U, \":not([\").concat(\"data-phx-parent-id\", \"])\"), function (n) {\\n            if (!e.getRootById(n.id)) {\\n              var i = e.joinRootView(n, e.getHref());\\n              e.root = e.root || i, n.getAttribute(\"data-phx-main\") && (e.main = i);\\n            }\\n\\n            t = !0;\\n          }), t;\\n        }\\n      }, {\\n        key: \"redirect\",\\n        value: function (e, t) {\\n          this.disconnect(), ce.redirect(e, t);\\n        }\\n      }, {\\n        key: \"replaceMain\",\\n        value: function (e, t) {\\n          var n = this,\\n              i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,\\n              r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.setPendingLink(e),\\n              o = this.main.el;\\n          this.main.showLoader(this.loaderTimeout), this.main.destroy(), ce.fetchPage(e, function (a, u) {\\n            if (200 !== a) return n.redirect(e);\\n            var s = document.createElement(\"template\");\\n            s.innerHTML = u;\\n            var c = s.content.childNodes[0];\\n            if (!c || !n.isPhxView(c)) return n.redirect(e);\\n            n.joinRootView(c, e, t, function (e, t) {\\n              1 === t && (n.commitPendingLink(r) ? (o.replaceWith(e.el), n.main = e, i && i()) : e.destroy());\\n            });\\n          });\\n        }\\n      }, {\\n        key: \"isPhxView\",\\n        value: function (e) {\\n          return e.getAttribute && null !== e.getAttribute(O);\\n        }\\n      }, {\\n        key: \"joinRootView\",\\n        value: function (e, t, n, i) {\\n          var r = new fe(e, this, null, t, n);\\n          return this.roots[r.id] = r, r.join(i), r;\\n        }\\n      }, {\\n        key: \"owner\",\\n        value: function (e, t) {\\n          var n = this,\\n              i = Z(e.closest(U), function (e) {\\n            return n.getViewByEl(e);\\n          });\\n          i && t(i);\\n        }\\n      }, {\\n        key: \"withinOwners\",\\n        value: function (e, t) {\\n          var n = this;\\n          this.owner(e, function (i) {\\n            var r = e.getAttribute(n.binding(\"target\"));\\n            null === r ? t(i, e) : i.withinTargets(r, t);\\n          });\\n        }\\n      }, {\\n        key: \"getViewByEl\",\\n        value: function (e) {\\n          var t = e.getAttribute(\"data-phx-root-id\");\\n          return Z(this.getRootById(t), function (t) {\\n            return t.getDescendentByEl(e);\\n          });\\n        }\\n      }, {\\n        key: \"getRootById\",\\n        value: function (e) {\\n          return this.roots[e];\\n        }\\n      }, {\\n        key: \"destroyAllViews\",\\n        value: function () {\\n          for (var e in this.roots) this.roots[e].destroy(), delete this.roots[e];\\n        }\\n      }, {\\n        key: \"destroyViewByEl\",\\n        value: function (e) {\\n          var t = this.getRootById(e.getAttribute(\"data-phx-root-id\"));\\n          t && t.destroyDescendent(e.id);\\n        }\\n      }, {\\n        key: \"setActiveElement\",\\n        value: function (e) {\\n          var t = this;\\n\\n          if (this.activeElement !== e) {\\n            this.activeElement = e;\\n\\n            var n = function () {\\n              e === t.activeElement && (t.activeElement = null), e.removeEventListener(\"mouseup\", t), e.removeEventListener(\"touchend\", t);\\n            };\\n\\n            e.addEventListener(\"mouseup\", n), e.addEventListener(\"touchend\", n);\\n          }\\n        }\\n      }, {\\n        key: \"getActiveElement\",\\n        value: function () {\\n          return document.activeElement === document.body ? this.activeElement || document.activeElement : document.activeElement || document.body;\\n        }\\n      }, {\\n        key: \"dropActiveElement\",\\n        value: function (e) {\\n          this.prevActive && e.ownsElement(this.prevActive) && (this.prevActive = null);\\n        }\\n      }, {\\n        key: \"restorePreviouslyActiveFocus\",\\n        value: function () {\\n          this.prevActive && this.prevActive !== document.body && this.prevActive.focus();\\n        }\\n      }, {\\n        key: \"blurActiveElement\",\\n        value: function () {\\n          this.prevActive = this.getActiveElement(), this.prevActive !== document.body && this.prevActive.blur();\\n        }\\n      }, {\\n        key: \"bindTopLevelEvents\",\\n        value: function () {\\n          var e = this;\\n          this.boundTopLevelEvents || (this.boundTopLevelEvents = !0, document.body.addEventListener(\"click\", function () {}), window.addEventListener(\"pageshow\", function (t) {\\n            t.persisted && (e.withPageLoading({\\n              to: window.location.href,\\n              kind: \"redirect\"\\n            }), window.location.reload());\\n          }), this.bindClicks(), this.bindNav(), this.bindForms(), this.bind({\\n            keyup: \"keyup\",\\n            keydown: \"keydown\"\\n          }, function (t, n, i, r, o, a, u) {\\n            var s = r.getAttribute(e.binding(\"key\")),\\n                c = t.key && t.key.toLowerCase();\\n            s && s.toLowerCase() !== c || i.pushKey(r, o, n, a, function (e) {\\n              for (var t = 1; t < arguments.length; t++) {\\n                var n = null != arguments[t] ? arguments[t] : {};\\n                t % 2 ? w(Object(n), !0).forEach(function (t) {\\n                  E(e, t, n[t]);\\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w(Object(n)).forEach(function (t) {\\n                  Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\\n                });\\n              }\\n\\n              return e;\\n            }({\\n              key: t.key\\n            }, e.eventMeta(n, t, r)));\\n          }), this.bind({\\n            blur: \"focusout\",\\n            focus: \"focusin\"\\n          }, function (t, n, i, r, o, a, u) {\\n            u || i.pushEvent(n, r, o, a, e.eventMeta(n, t, r));\\n          }), this.bind({\\n            blur: \"blur\",\\n            focus: \"focus\"\\n          }, function (t, n, i, r, o, a, u) {\\n            u && \"window\" !== !u && i.pushEvent(n, r, o, a, e.eventMeta(n, t, r));\\n          }), window.addEventListener(\"dragover\", function (e) {\\n            return e.preventDefault();\\n          }), window.addEventListener(\"drop\", function (t) {\\n            t.preventDefault();\\n            var n = Z(G(t.target, e.binding(\"drop-target\")), function (t) {\\n              return t.getAttribute(e.binding(\"drop-target\"));\\n            }),\\n                i = n && document.getElementById(n),\\n                r = Array.from(t.dataTransfer.files || []);\\n            i && !i.disabled && 0 !== r.length && i.files instanceof FileList && (ie.trackFiles(i, r), i.dispatchEvent(new Event(\"input\", {\\n              bubbles: !0\\n            })));\\n          }));\\n        }\\n      }, {\\n        key: \"eventMeta\",\\n        value: function (e, t, n) {\\n          var i = this.metadataCallbacks[e];\\n          return i ? i(t, n) : {};\\n        }\\n      }, {\\n        key: \"setPendingLink\",\\n        value: function (e) {\\n          return this.linkRef++, this.pendingLink = e, this.linkRef;\\n        }\\n      }, {\\n        key: \"commitPendingLink\",\\n        value: function (e) {\\n          return this.linkRef === e && (this.href = this.pendingLink, this.pendingLink = null, !0);\\n        }\\n      }, {\\n        key: \"getHref\",\\n        value: function () {\\n          return this.href;\\n        }\\n      }, {\\n        key: \"hasPendingLink\",\\n        value: function () {\\n          return !!this.pendingLink;\\n        }\\n      }, {\\n        key: \"bind\",\\n        value: function (e, t) {\\n          var n = this,\\n              i = function (i) {\\n            var r = e[i];\\n            n.on(r, function (e) {\\n              var r = n.binding(i),\\n                  o = n.binding(\"window-\".concat(i)),\\n                  a = e.target.getAttribute && e.target.getAttribute(r);\\n              a ? n.debounce(e.target, e, function () {\\n                n.withinOwners(e.target, function (n, r) {\\n                  t(e, i, n, e.target, r, a, null);\\n                });\\n              }) : le.all(document, \"[\".concat(o, \"]\"), function (r) {\\n                var a = r.getAttribute(o);\\n                n.debounce(r, e, function () {\\n                  n.withinOwners(r, function (n, o) {\\n                    t(e, i, n, r, o, a, \"window\");\\n                  });\\n                });\\n              });\\n            });\\n          };\\n\\n          for (var r in e) i(r);\\n        }\\n      }, {\\n        key: \"bindClicks\",\\n        value: function () {\\n          this.bindClick(\"click\", \"click\", !1), this.bindClick(\"mousedown\", \"capture-click\", !0);\\n        }\\n      }, {\\n        key: \"bindClick\",\\n        value: function (e, t, n) {\\n          var i = this,\\n              r = this.binding(t);\\n          window.addEventListener(e, function (e) {\\n            if (i.isConnected()) {\\n              var t = null,\\n                  o = (t = n ? e.target.matches(\"[\".concat(r, \"]\")) ? e.target : e.target.querySelector(\"[\".concat(r, \"]\")) : G(e.target, r)) && t.getAttribute(r);\\n              o && (\"#\" === t.getAttribute(\"href\") && e.preventDefault(), i.debounce(t, e, function () {\\n                i.withinOwners(t, function (n, r) {\\n                  n.pushEvent(\"click\", t, r, o, i.eventMeta(\"click\", e, t));\\n                });\\n              }));\\n            }\\n          }, n);\\n        }\\n      }, {\\n        key: \"bindNav\",\\n        value: function () {\\n          var e = this;\\n\\n          if (ce.canPushState()) {\\n            history.scrollRestoration && (history.scrollRestoration = \"manual\");\\n            var t = null;\\n            window.addEventListener(\"scroll\", function (e) {\\n              clearTimeout(t), t = setTimeout(function () {\\n                ce.updateCurrentState(function (e) {\\n                  return Object.assign(e, {\\n                    scroll: window.scrollY\\n                  });\\n                });\\n              }, 100);\\n            }), window.addEventListener(\"popstate\", function (t) {\\n              if (e.registerNewLocation(window.location)) {\\n                var n = t.state || {},\\n                    i = n.type,\\n                    r = n.id,\\n                    o = n.root,\\n                    a = n.scroll,\\n                    u = window.location.href;\\n                e.main.isConnected() && \"patch\" === i && r === e.main.id ? e.main.pushLinkPatch(u, null) : e.replaceMain(u, null, function () {\\n                  o && e.replaceRootHistory(), \"number\" == typeof a && setTimeout(function () {\\n                    window.scrollTo(0, a);\\n                  }, 0);\\n                });\\n              }\\n            }, !1), window.addEventListener(\"click\", function (t) {\\n              var n = G(t.target, \"data-phx-link\"),\\n                  i = n && n.getAttribute(\"data-phx-link\"),\\n                  r = t.metaKey || t.ctrlKey || 1 === t.button;\\n\\n              if (i && e.isConnected() && e.main && !r) {\\n                var o = n.href,\\n                    a = n.getAttribute(\"data-phx-link-state\");\\n                if (t.preventDefault(), e.pendingLink !== o) if (\"patch\" === i) e.pushHistoryPatch(o, a, n);else {\\n                  if (\"redirect\" !== i) throw new Error(\"expected \".concat(\"data-phx-link\", \\' to be \"patch\" or \"redirect\", got: \\').concat(i));\\n                  e.historyRedirect(o, a);\\n                }\\n              }\\n            }, !1);\\n          }\\n        }\\n      }, {\\n        key: \"withPageLoading\",\\n        value: function (e, t) {\\n          le.dispatchEvent(window, \"phx:page-loading-start\", e);\\n\\n          var n = function () {\\n            return le.dispatchEvent(window, \"phx:page-loading-stop\", e);\\n          };\\n\\n          return t ? t(n) : n;\\n        }\\n      }, {\\n        key: \"pushHistoryPatch\",\\n        value: function (e, t, n) {\\n          var i = this;\\n          this.withPageLoading({\\n            to: e,\\n            kind: \"patch\"\\n          }, function (r) {\\n            i.main.pushLinkPatch(e, n, function () {\\n              i.historyPatch(e, t), r();\\n            });\\n          });\\n        }\\n      }, {\\n        key: \"historyPatch\",\\n        value: function (e, t) {\\n          ce.pushState(t, {\\n            type: \"patch\",\\n            id: this.main.id\\n          }, e), this.registerNewLocation(window.location);\\n        }\\n      }, {\\n        key: \"historyRedirect\",\\n        value: function (e, t, n) {\\n          var i = this,\\n              r = window.scrollY;\\n          this.withPageLoading({\\n            to: e,\\n            kind: \"redirect\"\\n          }, function (o) {\\n            i.replaceMain(e, n, function () {\\n              ce.pushState(t, {\\n                type: \"redirect\",\\n                id: i.main.id,\\n                scroll: r\\n              }, e), i.registerNewLocation(window.location), o();\\n            });\\n          });\\n        }\\n      }, {\\n        key: \"replaceRootHistory\",\\n        value: function () {\\n          ce.pushState(\"replace\", {\\n            root: !0,\\n            type: \"patch\",\\n            id: this.main.id\\n          });\\n        }\\n      }, {\\n        key: \"registerNewLocation\",\\n        value: function (e) {\\n          var t = this.currentLocation;\\n          return t.pathname + t.search !== e.pathname + e.search && (this.currentLocation = $(e), !0);\\n        }\\n      }, {\\n        key: \"bindForms\",\\n        value: function () {\\n          var e = this,\\n              t = 0;\\n          this.on(\"submit\", function (t) {\\n            var n = t.target.getAttribute(e.binding(\"submit\"));\\n            n && (t.preventDefault(), t.target.disabled = !0, e.withinOwners(t.target, function (e, i) {\\n              return e.submitForm(t.target, i, n);\\n            }));\\n          }, !1);\\n\\n          for (var n = function () {\\n            var n = r[i];\\n            e.on(n, function (i) {\\n              var r = i.target,\\n                  o = r.form && r.form.getAttribute(e.binding(\"change\"));\\n\\n              if (o && (\"number\" !== r.type || !r.validity || !r.validity.badInput)) {\\n                var a = t;\\n                t++;\\n                var u = le.private(r, \"prev-iteration\") || {},\\n                    s = u.at,\\n                    c = u.type;\\n                s === a - 1 && n !== c || (le.putPrivate(r, \"prev-iteration\", {\\n                  at: a,\\n                  type: n\\n                }), e.debounce(r, i, function () {\\n                  e.withinOwners(r.form, function (t, n) {\\n                    le.putPrivate(r, \"phx-has-focused\", !0), le.isTextualInput(r) || e.setActiveElement(r), t.pushInput(r, n, o, i.target);\\n                  });\\n                }));\\n              }\\n            }, !1);\\n          }, i = 0, r = [\"change\", \"input\"]; i < r.length; i++) n();\\n        }\\n      }, {\\n        key: \"debounce\",\\n        value: function (e, t, n) {\\n          var i = this.binding(\"debounce\"),\\n              r = this.binding(\"throttle\"),\\n              o = this.defaults.debounce.toString(),\\n              a = this.defaults.throttle.toString();\\n          le.debounce(e, t, i, o, r, a, n);\\n        }\\n      }, {\\n        key: \"silenceEvents\",\\n        value: function (e) {\\n          this.silenced = !0, e(), this.silenced = !1;\\n        }\\n      }, {\\n        key: \"on\",\\n        value: function (e, t) {\\n          var n = this;\\n          window.addEventListener(e, function (e) {\\n            n.silenced || t(e);\\n          });\\n        }\\n      }]), e;\\n    }(),\\n        ce = {\\n      canPushState: function () {\\n        return void 0 !== history.pushState;\\n      },\\n      dropLocal: function (e, t) {\\n        return window.localStorage.removeItem(this.localKey(e, t));\\n      },\\n      updateLocal: function (e, t, n, i) {\\n        var r = this.getLocal(e, t),\\n            o = this.localKey(e, t),\\n            a = null === r ? n : i(r);\\n        return window.localStorage.setItem(o, JSON.stringify(a)), a;\\n      },\\n      getLocal: function (e, t) {\\n        return JSON.parse(window.localStorage.getItem(this.localKey(e, t)));\\n      },\\n      fetchPage: function (e, t) {\\n        var n = new XMLHttpRequest();\\n        n.open(\"GET\", e, !0), n.timeout = 3e4, n.setRequestHeader(\"content-type\", \"text/html\"), n.setRequestHeader(\"cache-control\", \"max-age=0, no-cache, no-store, must-revalidate, post-check=0, pre-check=0\"), n.setRequestHeader(\"x-requested-with\", \"live-link\"), n.onerror = function () {\\n          return t(400);\\n        }, n.ontimeout = function () {\\n          return t(504);\\n        }, n.onreadystatechange = function () {\\n          if (4 === n.readyState) {\\n            var i = new URL(e),\\n                r = i.pathname + i.search,\\n                o = Z(n.getResponseHeader(\"x-response-url\") || n.responseURL, function (e) {\\n              return new URL(e);\\n            }),\\n                a = o ? o.pathname + o.search : null;\\n            return \"live-link\" !== n.getResponseHeader(\"x-requested-with\") ? t(400) : null === o || a != r ? t(302) : 200 !== n.status ? t(n.status) : void t(200, n.responseText);\\n          }\\n        }, n.send();\\n      },\\n      updateCurrentState: function (e) {\\n        this.canPushState() && history.replaceState(e(history.state || {}), \"\", window.location.href);\\n      },\\n      pushState: function (e, t, n) {\\n        if (this.canPushState()) {\\n          if (n !== window.location.href) {\\n            if (\"redirect\" == t.type && t.scroll) {\\n              var i = history.state || {};\\n              i.scroll = t.scroll, history.replaceState(i, \"\", window.location.href);\\n            }\\n\\n            delete t.scroll, history[e + \"State\"](t, \"\", n || null);\\n            var r = this.getHashTargetEl(window.location.hash);\\n            r ? r.scrollIntoView() : \"redirect\" === t.type && window.scroll(0, 0);\\n          }\\n        } else this.redirect(n);\\n      },\\n      setCookie: function (e, t) {\\n        document.cookie = \"\".concat(e, \"=\").concat(t);\\n      },\\n      getCookie: function (e) {\\n        return document.cookie.replace(new RegExp(\"(?:(?:^|.*;s*)\".concat(e, \"s*=s*([^;]*).*$)|^.*$\")), \"$1\");\\n      },\\n      redirect: function (e, t) {\\n        t && ce.setCookie(\"__phoenix_flash__\", t + \"; max-age=60000; path=/\"), window.location = e;\\n      },\\n      localKey: function (e, t) {\\n        return \"\".concat(e, \"-\").concat(t);\\n      },\\n      getHashTargetEl: function (e) {\\n        var t = e.toString().substring(1);\\n        if (\"\" !== t) return document.getElementById(t) || document.querySelector(\\'a[name=\"\\'.concat(t, \\'\"]\\'));\\n      }\\n    },\\n        le = {\\n      byId: function (e) {\\n        return document.getElementById(e) || z(\"no id found for \".concat(e));\\n      },\\n      removeClass: function (e, t) {\\n        e.classList.remove(t), 0 === e.classList.length && e.removeAttribute(\"class\");\\n      },\\n      all: function (e, t, n) {\\n        var i = Array.from(e.querySelectorAll(t));\\n        return n ? i.forEach(n) : i;\\n      },\\n      childNodeLength: function (e) {\\n        var t = document.createElement(\"template\");\\n        return t.innerHTML = e, t.content.childElementCount;\\n      },\\n      isUploadInput: function (e) {\\n        return \"file\" === e.type && null !== e.getAttribute(M);\\n      },\\n      findUploadInputs: function (e) {\\n        return this.all(e, \\'input[type=\"file\"][\\'.concat(M, \"]\"));\\n      },\\n      findComponentNodeList: function (e, t) {\\n        return this.filterWithinSameLiveView(this.all(e, \"[\".concat(H, \\'=\"\\').concat(t, \\'\"]\\')), e);\\n      },\\n      isPhxDestroyed: function (e) {\\n        return !(!e.id || !le.private(e, \"destroyed\"));\\n      },\\n      markPhxChildDestroyed: function (e) {\\n        e.setAttribute(\"data-phx-session\", \"\"), this.putPrivate(e, \"destroyed\", !0);\\n      },\\n      findPhxChildrenInFragment: function (e, t) {\\n        var n = document.createElement(\"template\");\\n        return n.innerHTML = e, this.findPhxChildren(n.content, t);\\n      },\\n      isIgnored: function (e, t) {\\n        return \"ignore\" === (e.getAttribute(t) || e.getAttribute(\"data-phx-update\"));\\n      },\\n      isPhxUpdate: function (e, t, n) {\\n        return e.getAttribute && n.indexOf(e.getAttribute(t)) >= 0;\\n      },\\n      findPhxChildren: function (e, t) {\\n        return this.all(e, \"\".concat(U, \"[\").concat(\"data-phx-parent-id\", \\'=\"\\').concat(t, \\'\"]\\'));\\n      },\\n      findParentCIDs: function (e, t) {\\n        var n = this,\\n            i = new Set(t);\\n        return t.reduce(function (t, i) {\\n          var r = \"[\".concat(H, \\'=\"\\').concat(i, \\'\"] [\\').concat(H, \"]\");\\n          return n.filterWithinSameLiveView(n.all(e, r), e).map(function (e) {\\n            return parseInt(e.getAttribute(H));\\n          }).forEach(function (e) {\\n            return t.delete(e);\\n          }), t;\\n        }, i);\\n      },\\n      filterWithinSameLiveView: function (e, t) {\\n        var n = this;\\n        return t.querySelector(U) ? e.filter(function (e) {\\n          return n.withinSameLiveView(e, t);\\n        }) : e;\\n      },\\n      withinSameLiveView: function (e, t) {\\n        for (; e = e.parentNode;) {\\n          if (e.isSameNode(t)) return !0;\\n          if (e.getAttribute(O)) return !1;\\n        }\\n      },\\n      private: function (e, t) {\\n        return e.phxPrivate && e.phxPrivate[t];\\n      },\\n      deletePrivate: function (e, t) {\\n        e.phxPrivate && delete e.phxPrivate[t];\\n      },\\n      putPrivate: function (e, t, n) {\\n        e.phxPrivate || (e.phxPrivate = {}), e.phxPrivate[t] = n;\\n      },\\n      copyPrivates: function (e, t) {\\n        t.phxPrivate && (e.phxPrivate = $(t.phxPrivate));\\n      },\\n      putTitle: function (e) {\\n        var t = document.querySelector(\"title\").dataset,\\n            n = t.prefix,\\n            i = t.suffix;\\n        document.title = \"\".concat(n || \"\").concat(e).concat(i || \"\");\\n      },\\n      debounce: function (e, t, n, i, r, o, a) {\\n        var u = this,\\n            s = e.getAttribute(n),\\n            c = e.getAttribute(r);\\n        \"\" === s && (s = i), \"\" === c && (c = o);\\n        var l = s || c;\\n\\n        switch (l) {\\n          case null:\\n            return a();\\n\\n          case \"blur\":\\n            return void (this.once(e, \"debounce-blur\") && e.addEventListener(\"blur\", function () {\\n              return a();\\n            }));\\n\\n          default:\\n            var d = parseInt(l),\\n                h = this.incCycle(e, \"debounce-trigger\", function () {\\n              return c ? u.deletePrivate(e, \"throttled\") : a();\\n            });\\n            if (isNaN(d)) return z(\"invalid throttle/debounce value: \".concat(l));\\n\\n            if (c) {\\n              var f = !1;\\n\\n              if (\"keydown\" === t.type) {\\n                var v = this.private(e, \"debounce-prev-key\");\\n                this.putPrivate(e, \"debounce-prev-key\", t.key), f = v !== t.key;\\n              }\\n\\n              if (!f && this.private(e, \"throttled\")) return !1;\\n              a(), this.putPrivate(e, \"throttled\", !0), setTimeout(function () {\\n                return u.triggerCycle(e, \"debounce-trigger\");\\n              }, d);\\n            } else setTimeout(function () {\\n              return u.triggerCycle(e, \"debounce-trigger\", h);\\n            }, d);\\n\\n            e.form && this.once(e.form, \"bind-debounce\") && e.form.addEventListener(\"submit\", function (t) {\\n              Array.from(new FormData(e.form).entries(), function (t) {\\n                var n = x(t, 2),\\n                    i = n[0],\\n                    r = (n[1], e.form.querySelector(\\'[name=\"\\'.concat(i, \\'\"]\\')));\\n                u.incCycle(r, \"debounce-trigger\"), u.deletePrivate(r, \"throttled\");\\n              });\\n            }), this.once(e, \"bind-debounce\") && e.addEventListener(\"blur\", function (t) {\\n              return u.triggerCycle(e, \"debounce-trigger\");\\n            });\\n        }\\n      },\\n      triggerCycle: function (e, t, n) {\\n        var i = x(this.private(e, t), 2),\\n            r = i[0],\\n            o = i[1];\\n        n || (n = r), n === r && (this.incCycle(e, t), o());\\n      },\\n      once: function (e, t) {\\n        return !0 !== this.private(e, t) && (this.putPrivate(e, t, !0), !0);\\n      },\\n      incCycle: function (e, t) {\\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {},\\n            i = x(this.private(e, t) || [0, n], 2),\\n            r = i[0];\\n        i[1];\\n        return r++, this.putPrivate(e, t, [r, n]), r;\\n      },\\n      discardError: function (e, t, n) {\\n        var i = t.getAttribute && t.getAttribute(n),\\n            r = i && e.querySelector(\\'[id=\"\\'.concat(i, \\'\"], [name=\"\\').concat(i, \\'\"]\\'));\\n        r && (this.private(r, \"phx-has-focused\") || this.private(r.form, \"phx-has-submitted\") || t.classList.add(\"phx-no-feedback\"));\\n      },\\n      showError: function (e, t) {\\n        var n = this;\\n        (e.id || e.name) && this.all(e.form, \"[\".concat(t, \\'=\"\\').concat(e.id, \\'\"], [\\').concat(t, \\'=\"\\').concat(e.name, \\'\"]\\'), function (e) {\\n          n.removeClass(e, \"phx-no-feedback\");\\n        });\\n      },\\n      isPhxChild: function (e) {\\n        return e.getAttribute && e.getAttribute(\"data-phx-parent-id\");\\n      },\\n      dispatchEvent: function (e, t) {\\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\\n            i = new CustomEvent(t, {\\n          bubbles: !0,\\n          cancelable: !0,\\n          detail: n\\n        });\\n        e.dispatchEvent(i);\\n      },\\n      cloneNode: function (e, t) {\\n        if (void 0 === t) return e.cloneNode(!0);\\n        var n = e.cloneNode(!1);\\n        return n.innerHTML = t, n;\\n      },\\n      mergeAttrs: function (e, t) {\\n        for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = n.exclude || [], r = n.isIgnored, o = t.attributes, a = o.length - 1; a >= 0; a--) {\\n          var u = o[a].name;\\n          i.indexOf(u) < 0 && e.setAttribute(u, t.getAttribute(u));\\n        }\\n\\n        for (var s = e.attributes, c = s.length - 1; c >= 0; c--) {\\n          var l = s[c].name;\\n          r ? l.startsWith(\"data-\") && !t.hasAttribute(l) && e.removeAttribute(l) : t.hasAttribute(l) || e.removeAttribute(l);\\n        }\\n      },\\n      mergeFocusedInput: function (e, t) {\\n        e instanceof HTMLSelectElement || le.mergeAttrs(e, t, {\\n          except: [\"value\"]\\n        }), t.readOnly ? e.setAttribute(\"readonly\", !0) : e.removeAttribute(\"readonly\");\\n      },\\n      hasSelectionRange: function (e) {\\n        return e.setSelectionRange && (\"text\" === e.type || \"textarea\" === e.type);\\n      },\\n      restoreFocus: function (e, t, n) {\\n        if (le.isTextualInput(e)) {\\n          var i = e.matches(\":focus\");\\n          e.readOnly && e.blur(), i || e.focus(), this.hasSelectionRange(e) && e.setSelectionRange(t, n);\\n        }\\n      },\\n      isFormInput: function (e) {\\n        return /^(?:input|select|textarea)$/i.test(e.tagName) && \"button\" !== e.type;\\n      },\\n      syncAttrsToProps: function (e) {\\n        e instanceof HTMLInputElement && J.indexOf(e.type.toLocaleLowerCase()) >= 0 && (e.checked = null !== e.getAttribute(\"checked\"));\\n      },\\n      isTextualInput: function (e) {\\n        return B.indexOf(e.type) >= 0;\\n      },\\n      isNowTriggerFormExternal: function (e, t) {\\n        return e.getAttribute && null !== e.getAttribute(t);\\n      },\\n      syncPendingRef: function (e, t, n) {\\n        var i = e.getAttribute(F);\\n        return null === i || (le.isFormInput(e) || null !== e.getAttribute(n) ? (le.isUploadInput(e) && le.mergeAttrs(e, t, {\\n          isIgnored: !0\\n        }), le.putPrivate(e, F, t), !1) : (j.forEach(function (n) {\\n          e.classList.contains(n) && t.classList.add(n);\\n        }), t.setAttribute(F, i), !0));\\n      },\\n      cleanChildNodes: function (e, t) {\\n        if (le.isPhxUpdate(e, t, [\"append\", \"prepend\"])) {\\n          var n = [];\\n          e.childNodes.forEach(function (e) {\\n            e.id || (e.nodeType === Node.TEXT_NODE && \"\" === e.nodeValue.trim() || z(\"only HTML element tags with an id are allowed inside containers with phx-update.\\\\n\\\\n\" + \\'removing illegal node: \"\\'.concat((e.outerHTML || e.nodeValue).trim(), \\'\"\\\\n\\\\n\\')), n.push(e));\\n          }), n.forEach(function (e) {\\n            return e.remove();\\n          });\\n        }\\n      }\\n    },\\n        de = function () {\\n      function e(t, n, i) {\\n        T(this, e);\\n        var r = new Set(),\\n            o = new Set(A(n.children).map(function (e) {\\n          return e.id;\\n        })),\\n            a = [];\\n        Array.from(t.children).forEach(function (e) {\\n          if (e.id && (r.add(e.id), o.has(e.id))) {\\n            var t = e.previousElementSibling && e.previousElementSibling.id;\\n            a.push({\\n              elementId: e.id,\\n              previousElementId: t\\n            });\\n          }\\n        }), this.containerId = n.id, this.updateType = i, this.elementsToModify = a, this.elementIdsToAdd = A(o).filter(function (e) {\\n          return !r.has(e);\\n        });\\n      }\\n\\n      return _(e, [{\\n        key: \"perform\",\\n        value: function () {\\n          var e = le.byId(this.containerId);\\n          this.elementsToModify.forEach(function (t) {\\n            t.previousElementId ? Z(document.getElementById(t.previousElementId), function (e) {\\n              Z(document.getElementById(t.elementId), function (t) {\\n                t.previousElementSibling && t.previousElementSibling.id == e.id || e.insertAdjacentElement(\"afterend\", t);\\n              });\\n            }) : Z(document.getElementById(t.elementId), function (t) {\\n              null == t.previousElementSibling || e.insertAdjacentElement(\"afterbegin\", t);\\n            });\\n          }), \"prepend\" == this.updateType && this.elementIdsToAdd.reverse().forEach(function (t) {\\n            Z(document.getElementById(t), function (t) {\\n              return e.insertAdjacentElement(\"afterbegin\", t);\\n            });\\n          });\\n        }\\n      }]), e;\\n    }(),\\n        he = function () {\\n      function e(t, n, i, r, o) {\\n        T(this, e), this.view = t, this.liveSocket = t.liveSocket, this.container = n, this.id = i, this.rootID = t.root.id, this.html = r, this.targetCID = o, this.cidPatch = \"number\" == typeof this.targetCID, this.callbacks = {\\n          beforeadded: [],\\n          beforeupdated: [],\\n          beforephxChildAdded: [],\\n          afteradded: [],\\n          afterupdated: [],\\n          afterdiscarded: [],\\n          afterphxChildAdded: []\\n        };\\n      }\\n\\n      return _(e, null, [{\\n        key: \"patchEl\",\\n        value: function (e, t, n) {\\n          b(e, t, {\\n            childrenOnly: !1,\\n            onBeforeElUpdated: function (e, t) {\\n              if (n && n.isSameNode(e) && le.isFormInput(e)) return le.mergeFocusedInput(e, t), !1;\\n            }\\n          });\\n        }\\n      }]), _(e, [{\\n        key: \"before\",\\n        value: function (e, t) {\\n          this.callbacks[\"before\".concat(e)].push(t);\\n        }\\n      }, {\\n        key: \"after\",\\n        value: function (e, t) {\\n          this.callbacks[\"after\".concat(e)].push(t);\\n        }\\n      }, {\\n        key: \"trackBefore\",\\n        value: function (e) {\\n          for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];\\n\\n          this.callbacks[\"before\".concat(e)].forEach(function (e) {\\n            return e.apply(void 0, n);\\n          });\\n        }\\n      }, {\\n        key: \"trackAfter\",\\n        value: function (e) {\\n          for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];\\n\\n          this.callbacks[\"after\".concat(e)].forEach(function (e) {\\n            return e.apply(void 0, n);\\n          });\\n        }\\n      }, {\\n        key: \"markPrunableContentForRemoval\",\\n        value: function () {\\n          le.all(this.container, \"[phx-update=append] > *, [phx-update=prepend] > *\", function (e) {\\n            e.setAttribute(\"data-phx-remove\", \"\");\\n          });\\n        }\\n      }, {\\n        key: \"perform\",\\n        value: function () {\\n          var e = this,\\n              t = this.view,\\n              n = this.liveSocket,\\n              i = this.container,\\n              r = this.html,\\n              o = this.isCIDPatch() ? this.targetCIDContainer(r) : i;\\n\\n          if (!this.isCIDPatch() || o) {\\n            var a = n.getActiveElement(),\\n                u = a && le.hasSelectionRange(a) ? a : {},\\n                s = u.selectionStart,\\n                c = u.selectionEnd,\\n                l = n.binding(\"update\"),\\n                d = n.binding(\"feedback-for\"),\\n                h = n.binding(\"disable-with\"),\\n                f = n.binding(\"trigger-action\"),\\n                v = [],\\n                p = [],\\n                g = [],\\n                m = null,\\n                y = n.time(\"premorph container prep\", function () {\\n              return e.buildDiffHTML(i, r, l, o);\\n            });\\n            return this.trackBefore(\"added\", i), this.trackBefore(\"updated\", i, i), n.time(\"morphdom\", function () {\\n              b(o, y, {\\n                childrenOnly: null === o.getAttribute(H),\\n                getNodeKey: function (e) {\\n                  return le.isPhxDestroyed(e) ? null : e.id;\\n                },\\n                onBeforeNodeAdded: function (t) {\\n                  return le.discardError(o, t, d), e.trackBefore(\"added\", t), t;\\n                },\\n                onNodeAdded: function (n) {\\n                  le.isNowTriggerFormExternal(n, f) && (m = n), le.isPhxChild(n) && t.ownsElement(n) && e.trackAfter(\"phxChildAdded\", n), v.push(n);\\n                },\\n                onNodeDiscarded: function (t) {\\n                  le.isPhxChild(t) && n.destroyViewByEl(t), e.trackAfter(\"discarded\", t);\\n                },\\n                onBeforeNodeDiscarded: function (t) {\\n                  return !(!t.getAttribute || null === t.getAttribute(\"data-phx-remove\")) || (null === t.parentNode || !le.isPhxUpdate(t.parentNode, l, [\"append\", \"prepend\"]) || !t.id) && !e.skipCIDSibling(t);\\n                },\\n                onElUpdated: function (e) {\\n                  le.isNowTriggerFormExternal(e, f) && (m = e), p.push(e);\\n                },\\n                onBeforeElUpdated: function (t, n) {\\n                  if (le.cleanChildNodes(n, l), e.skipCIDSibling(n)) return !1;\\n                  if (le.isIgnored(t, l)) return e.trackBefore(\"updated\", t, n), le.mergeAttrs(t, n, {\\n                    isIgnored: !0\\n                  }), p.push(t), !1;\\n                  if (\"number\" === t.type && t.validity && t.validity.badInput) return !1;\\n                  if (!le.syncPendingRef(t, n, h)) return le.isUploadInput(t) && (e.trackBefore(\"updated\", t, n), p.push(t)), !1;\\n\\n                  if (le.isPhxChild(n)) {\\n                    var i = t.getAttribute(\"data-phx-session\");\\n                    return le.mergeAttrs(t, n, {\\n                      exclude: [\"data-phx-static\"]\\n                    }), \"\" !== i && t.setAttribute(\"data-phx-session\", i), t.setAttribute(\"data-phx-root-id\", e.rootID), !1;\\n                  }\\n\\n                  return le.copyPrivates(n, t), le.discardError(o, n, d), a && t.isSameNode(a) && le.isFormInput(t) && !e.forceFocusedSelectUpdate(t, n) ? (e.trackBefore(\"updated\", t, n), le.mergeFocusedInput(t, n), le.syncAttrsToProps(t), p.push(t), !1) : (le.isPhxUpdate(n, l, [\"append\", \"prepend\"]) && g.push(new de(t, n, n.getAttribute(l))), le.syncAttrsToProps(n), e.trackBefore(\"updated\", t, n), !0);\\n                }\\n              });\\n            }), n.isDebugEnabled() && function () {\\n              for (var e = new Set(), t = document.querySelectorAll(\"*[id]\"), n = 0, i = t.length; n < i; n++) e.has(t[n].id) ? console.error(\"Multiple IDs detected: \".concat(t[n].id, \". Ensure unique element ids.\")) : e.add(t[n].id);\\n            }(), g.length > 0 && n.time(\"post-morph append/prepend restoration\", function () {\\n              g.forEach(function (e) {\\n                return e.perform();\\n              });\\n            }), n.silenceEvents(function () {\\n              return le.restoreFocus(a, s, c);\\n            }), le.dispatchEvent(document, \"phx:update\"), v.forEach(function (t) {\\n              return e.trackAfter(\"added\", t);\\n            }), p.forEach(function (t) {\\n              return e.trackAfter(\"updated\", t);\\n            }), m && (n.disconnect(), m.submit()), !0;\\n          }\\n        }\\n      }, {\\n        key: \"forceFocusedSelectUpdate\",\\n        value: function (e, t) {\\n          var n = [\"select\", \"select-one\", \"select-multiple\"].find(function (t) {\\n            return t === e.type;\\n          });\\n          return !0 === e.multiple || n && e.innerHTML != t.innerHTML;\\n        }\\n      }, {\\n        key: \"isCIDPatch\",\\n        value: function () {\\n          return this.cidPatch;\\n        }\\n      }, {\\n        key: \"skipCIDSibling\",\\n        value: function (e) {\\n          return e.nodeType === Node.ELEMENT_NODE && null !== e.getAttribute(\"data-phx-skip\");\\n        }\\n      }, {\\n        key: \"targetCIDContainer\",\\n        value: function (e) {\\n          if (this.isCIDPatch()) {\\n            var t = k(le.findComponentNodeList(this.container, this.targetCID)),\\n                n = t[0];\\n            return 0 === t.slice(1).length && 1 === le.childNodeLength(e) ? n : n && n.parentNode;\\n          }\\n        }\\n      }, {\\n        key: \"buildDiffHTML\",\\n        value: function (e, t, n, i) {\\n          var r = this,\\n              o = this.isCIDPatch(),\\n              a = o && i.getAttribute(H) === this.targetCID.toString();\\n          if (!o || a) return t;\\n          var u = null,\\n              s = document.createElement(\"template\");\\n          u = le.cloneNode(i);\\n          var c = k(le.findComponentNodeList(u, this.targetCID)),\\n              l = c[0],\\n              d = c.slice(1);\\n          return s.innerHTML = t, d.forEach(function (e) {\\n            return e.remove();\\n          }), Array.from(u.childNodes).forEach(function (e) {\\n            e.id && e.nodeType === Node.ELEMENT_NODE && e.getAttribute(H) !== r.targetCID.toString() && (e.setAttribute(\"data-phx-skip\", \"\"), e.innerHTML = \"\");\\n          }), Array.from(s.content.childNodes).forEach(function (e) {\\n            return u.insertBefore(e, l);\\n          }), l.remove(), u.outerHTML;\\n        }\\n      }]), e;\\n    }(),\\n        fe = function () {\\n      function e(t, n, i, r, o) {\\n        var a = this;\\n        T(this, e), this.liveSocket = n, this.flash = o, this.parent = i, this.root = i ? i.root : this, this.el = t, this.id = this.el.id, this.view = this.el.getAttribute(O), this.ref = 0, this.childJoins = 0, this.loaderTimer = null, this.pendingDiffs = [], this.pruningCIDs = [], this.href = r, this.joinCount = this.parent ? this.parent.joinCount - 1 : 0, this.joinPending = !0, this.destroyed = !1, this.joinCallback = function () {}, this.stopCallback = function () {}, this.pendingJoinOps = this.parent ? null : [], this.viewHooks = {}, this.uploaders = {}, this.formSubmits = [], this.children = this.parent ? null : {}, this.root.children[this.id] = {}, this.channel = this.liveSocket.channel(\"lv:\".concat(this.id), function () {\\n          return {\\n            url: a.href,\\n            params: a.connectParams(),\\n            session: a.getSession(),\\n            static: a.getStatic(),\\n            flash: a.flash\\n          };\\n        }), this.showLoader(this.liveSocket.loaderTimeout), this.bindChannel();\\n      }\\n\\n      return _(e, [{\\n        key: \"isMain\",\\n        value: function () {\\n          return this.liveSocket.main === this;\\n        }\\n      }, {\\n        key: \"connectParams\",\\n        value: function () {\\n          var e = this.liveSocket.params(this.view),\\n              t = le.all(document, \"[\".concat(this.binding(\"track-static\"), \"]\")).map(function (e) {\\n            return e.src || e.href;\\n          }).filter(function (e) {\\n            return \"string\" == typeof e;\\n          });\\n          return t.length > 0 && (e._track_static = t), e._mounts = this.joinCount, e;\\n        }\\n      }, {\\n        key: \"name\",\\n        value: function () {\\n          return this.view;\\n        }\\n      }, {\\n        key: \"isConnected\",\\n        value: function () {\\n          return this.channel.canPush();\\n        }\\n      }, {\\n        key: \"getSession\",\\n        value: function () {\\n          return this.el.getAttribute(\"data-phx-session\");\\n        }\\n      }, {\\n        key: \"getStatic\",\\n        value: function () {\\n          var e = this.el.getAttribute(\"data-phx-static\");\\n          return \"\" === e ? null : e;\\n        }\\n      }, {\\n        key: \"destroy\",\\n        value: function () {\\n          var e = this,\\n              t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {};\\n          this.destroyAllChildren(), this.destroyed = !0, delete this.root.children[this.id], this.parent && delete this.root.children[this.parent.id][this.id], clearTimeout(this.loaderTimer);\\n\\n          var n = function () {\\n            for (var n in t(), e.viewHooks) e.destroyHook(e.viewHooks[n]);\\n          };\\n\\n          le.markPhxChildDestroyed(this.el), this.log(\"destroyed\", function () {\\n            return [\"the child has been removed from the parent\"];\\n          }), this.channel.leave().receive(\"ok\", n).receive(\"error\", n).receive(\"timeout\", n);\\n        }\\n      }, {\\n        key: \"setContainerClasses\",\\n        value: function () {\\n          var e;\\n          this.el.classList.remove(\"phx-connected\", \"phx-disconnected\", \"phx-error\"), (e = this.el.classList).add.apply(e, arguments);\\n        }\\n      }, {\\n        key: \"isLoading\",\\n        value: function () {\\n          return this.el.classList.contains(\"phx-disconnected\");\\n        }\\n      }, {\\n        key: \"showLoader\",\\n        value: function (e) {\\n          var t = this;\\n          if (clearTimeout(this.loaderTimer), e) this.loaderTimer = setTimeout(function () {\\n            return t.showLoader();\\n          }, e);else {\\n            for (var n in this.viewHooks) this.viewHooks[n].__disconnected();\\n\\n            this.setContainerClasses(\"phx-disconnected\");\\n          }\\n        }\\n      }, {\\n        key: \"hideLoader\",\\n        value: function () {\\n          clearTimeout(this.loaderTimer), this.setContainerClasses(\"phx-connected\");\\n        }\\n      }, {\\n        key: \"triggerReconnected\",\\n        value: function () {\\n          for (var e in this.viewHooks) this.viewHooks[e].__reconnected();\\n        }\\n      }, {\\n        key: \"log\",\\n        value: function (e, t) {\\n          this.liveSocket.log(this, e, t);\\n        }\\n      }, {\\n        key: \"withinTargets\",\\n        value: function (e, t) {\\n          var n = this;\\n\\n          if (/^(0|[1-9]\\\\d*)$/.test(e)) {\\n            var i = le.findComponentNodeList(this.el, e);\\n            0 === i.length ? z(\"no component found matching phx-target of \".concat(e)) : t(this, i[0]);\\n          } else {\\n            var r = Array.from(document.querySelectorAll(e));\\n            0 === r.length && z(\\'nothing found matching the phx-target selector \"\\'.concat(e, \\'\"\\')), r.forEach(function (e) {\\n              return n.liveSocket.owner(e, function (n) {\\n                return t(n, e);\\n              });\\n            });\\n          }\\n        }\\n      }, {\\n        key: \"applyDiff\",\\n        value: function (e, t, n) {\\n          this.log(e, function () {\\n            return [\"\", $(t)];\\n          });\\n          var i = ue.extract(t),\\n              r = i.diff,\\n              o = i.reply,\\n              a = i.events,\\n              u = i.title;\\n          return u && le.putTitle(u), n({\\n            diff: r,\\n            reply: o,\\n            events: a\\n          }), o;\\n        }\\n      }, {\\n        key: \"onJoin\",\\n        value: function (e) {\\n          var t = this,\\n              n = e.rendered;\\n          this.childJoins = 0, this.joinPending = !0, this.flash = null, ce.dropLocal(this.name(), \"consecutive-reloads\"), this.applyDiff(\"mount\", n, function (n) {\\n            var i = n.diff,\\n                r = n.events;\\n            t.rendered = new ue(t.id, i);\\n            var o = t.renderContainer(null, \"join\");\\n            t.dropPendingRefs();\\n            var a = t.formsForRecovery(o);\\n            t.joinCount++, a.length > 0 ? a.forEach(function (e, n) {\\n              t.pushFormRecovery(e, function (e) {\\n                n === a.length - 1 && t.onJoinComplete(e, o, r);\\n              });\\n            }) : t.onJoinComplete(e, o, r);\\n          });\\n        }\\n      }, {\\n        key: \"dropPendingRefs\",\\n        value: function () {\\n          le.all(this.el, \"[\".concat(F, \"]\"), function (e) {\\n            return e.removeAttribute(F);\\n          });\\n        }\\n      }, {\\n        key: \"onJoinComplete\",\\n        value: function (e, t, n) {\\n          var i = this,\\n              r = e.live_patch;\\n          if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) return this.applyJoinPatch(r, t, n);\\n          0 === le.findPhxChildrenInFragment(t, this.id).filter(function (e) {\\n            var t = e.id && i.el.querySelector(\"#\".concat(e.id)),\\n                n = t && t.getAttribute(\"data-phx-static\");\\n            return n && e.setAttribute(\"data-phx-static\", n), i.joinChild(e);\\n          }).length ? this.parent ? (this.root.pendingJoinOps.push([this, function () {\\n            return i.applyJoinPatch(r, t, n);\\n          }]), this.parent.ackJoin(this)) : (this.onAllChildJoinsComplete(), this.applyJoinPatch(r, t, n)) : this.root.pendingJoinOps.push([this, function () {\\n            return i.applyJoinPatch(r, t, n);\\n          }]);\\n        }\\n      }, {\\n        key: \"attachTrueDocEl\",\\n        value: function () {\\n          this.el = le.byId(this.id), this.el.setAttribute(\"data-phx-root-id\", this.root.id);\\n        }\\n      }, {\\n        key: \"dispatchEvents\",\\n        value: function (e) {\\n          e.forEach(function (e) {\\n            var t = x(e, 2),\\n                n = t[0],\\n                i = t[1];\\n            window.dispatchEvent(new CustomEvent(\"phx:hook:\".concat(n), {\\n              detail: i\\n            }));\\n          });\\n        }\\n      }, {\\n        key: \"applyJoinPatch\",\\n        value: function (e, t, n) {\\n          var i = this;\\n          this.attachTrueDocEl();\\n          var r = new he(this, this.el, this.id, t, null);\\n\\n          if (r.markPrunableContentForRemoval(), this.performPatch(r, !1), this.joinNewChildren(), le.all(this.el, \"[\".concat(this.binding(\"hook\"), \"], [data-phx-\").concat(\"hook\", \"]\"), function (e) {\\n            var t = i.addHook(e);\\n            t && t.__mounted();\\n          }), this.joinPending = !1, this.dispatchEvents(n), this.applyPendingUpdates(), e) {\\n            var o = e.kind,\\n                a = e.to;\\n            this.liveSocket.historyPatch(a, o);\\n          }\\n\\n          this.hideLoader(), this.joinCount > 1 && this.triggerReconnected(), this.stopCallback();\\n        }\\n      }, {\\n        key: \"triggerBeforeUpdateHook\",\\n        value: function (e, t) {\\n          this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [e, t]);\\n          var n = this.getHook(e),\\n              i = n && le.isIgnored(e, this.binding(\"update\"));\\n          if (n && !e.isEqualNode(t) && (!i || !function (e, t) {\\n            return JSON.stringify(e) === JSON.stringify(t);\\n          }(e.dataset, t.dataset))) return n.__beforeUpdate(), n;\\n        }\\n      }, {\\n        key: \"performPatch\",\\n        value: function (e, t) {\\n          var n = this,\\n              i = [],\\n              r = !1,\\n              o = new Set();\\n          return e.after(\"added\", function (e) {\\n            n.liveSocket.triggerDOM(\"onNodeAdded\", [e]);\\n            var t = n.addHook(e);\\n            t && t.__mounted();\\n          }), e.after(\"phxChildAdded\", function (e) {\\n            return r = !0;\\n          }), e.before(\"updated\", function (e, t) {\\n            n.triggerBeforeUpdateHook(e, t) && o.add(e.id);\\n          }), e.after(\"updated\", function (e) {\\n            o.has(e.id) && n.getHook(e).__updated();\\n          }), e.after(\"discarded\", function (e) {\\n            var t = n.componentID(e);\\n            \"number\" == typeof t && -1 === i.indexOf(t) && i.push(t);\\n            var r = n.getHook(e);\\n            r && n.destroyHook(r);\\n          }), e.perform(), t && this.maybePushComponentsDestroyed(i), r;\\n        }\\n      }, {\\n        key: \"joinNewChildren\",\\n        value: function () {\\n          var e = this;\\n          le.findPhxChildren(this.el, this.id).forEach(function (t) {\\n            return e.joinChild(t);\\n          });\\n        }\\n      }, {\\n        key: \"getChildById\",\\n        value: function (e) {\\n          return this.root.children[this.id][e];\\n        }\\n      }, {\\n        key: \"getDescendentByEl\",\\n        value: function (e) {\\n          return e.id === this.id ? this : this.children[e.getAttribute(\"data-phx-parent-id\")][e.id];\\n        }\\n      }, {\\n        key: \"destroyDescendent\",\\n        value: function (e) {\\n          for (var t in this.root.children) for (var n in this.root.children[t]) if (n === e) return this.root.children[t][n].destroy();\\n        }\\n      }, {\\n        key: \"joinChild\",\\n        value: function (t) {\\n          if (!this.getChildById(t.id)) {\\n            var n = new e(t, this.liveSocket, this);\\n            return this.root.children[this.id][n.id] = n, n.join(), this.childJoins++, !0;\\n          }\\n        }\\n      }, {\\n        key: \"isJoinPending\",\\n        value: function () {\\n          return this.joinPending;\\n        }\\n      }, {\\n        key: \"ackJoin\",\\n        value: function (e) {\\n          this.childJoins--, 0 === this.childJoins && (this.parent ? this.parent.ackJoin(this) : this.onAllChildJoinsComplete());\\n        }\\n      }, {\\n        key: \"onAllChildJoinsComplete\",\\n        value: function () {\\n          this.joinCallback(), this.pendingJoinOps.forEach(function (e) {\\n            var t = x(e, 2),\\n                n = t[0],\\n                i = t[1];\\n            n.isDestroyed() || i();\\n          }), this.pendingJoinOps = [];\\n        }\\n      }, {\\n        key: \"update\",\\n        value: function (e, t) {\\n          var n = this;\\n          if (this.isJoinPending() || this.liveSocket.hasPendingLink()) return this.pendingDiffs.push({\\n            diff: e,\\n            events: t\\n          });\\n          this.rendered.mergeDiff(e);\\n          var i = !1;\\n          this.rendered.isComponentOnlyDiff(e) ? this.liveSocket.time(\"component patch complete\", function () {\\n            le.findParentCIDs(n.el, n.rendered.componentCIDs(e)).forEach(function (t) {\\n              n.componentPatch(n.rendered.getComponent(e, t), t) && (i = !0);\\n            });\\n          }) : Q(e) || this.liveSocket.time(\"full patch complete\", function () {\\n            var t = n.renderContainer(e, \"update\"),\\n                r = new he(n, n.el, n.id, t, null);\\n            i = n.performPatch(r, !0);\\n          }), this.dispatchEvents(t), i && this.joinNewChildren();\\n        }\\n      }, {\\n        key: \"renderContainer\",\\n        value: function (e, t) {\\n          var n = this;\\n          return this.liveSocket.time(\"toString diff (\".concat(t, \")\"), function () {\\n            var t = n.el.tagName,\\n                i = e ? n.rendered.componentCIDs(e).concat(n.pruningCIDs) : null,\\n                r = n.rendered.toString(i);\\n            return \"<\".concat(t, \">\").concat(r, \"</\").concat(t, \">\");\\n          });\\n        }\\n      }, {\\n        key: \"componentPatch\",\\n        value: function (e, t) {\\n          if (Q(e)) return !1;\\n          var n = this.rendered.componentToString(t),\\n              i = new he(this, this.el, this.id, n, t);\\n          return this.performPatch(i, !0);\\n        }\\n      }, {\\n        key: \"getHook\",\\n        value: function (e) {\\n          return this.viewHooks[pe.elementID(e)];\\n        }\\n      }, {\\n        key: \"addHook\",\\n        value: function (e) {\\n          if (!pe.elementID(e) && e.getAttribute) {\\n            var t = e.getAttribute(\"data-phx-\".concat(\"hook\")) || e.getAttribute(this.binding(\"hook\"));\\n\\n            if (!t || this.ownsElement(e)) {\\n              var n = this.liveSocket.getHookCallbacks(t);\\n\\n              if (n) {\\n                e.id || z(\\'no DOM ID for hook \"\\'.concat(t, \\'\". Hooks require a unique ID on each element.\\'), e);\\n                var i = new pe(this, e, n);\\n                return this.viewHooks[pe.elementID(i.el)] = i, i;\\n              }\\n\\n              null !== t && z(\\'unknown hook found for \"\\'.concat(t, \\'\"\\'), e);\\n            }\\n          }\\n        }\\n      }, {\\n        key: \"destroyHook\",\\n        value: function (e) {\\n          e.__destroyed(), e.__cleanup__(), delete this.viewHooks[pe.elementID(e.el)];\\n        }\\n      }, {\\n        key: \"applyPendingUpdates\",\\n        value: function () {\\n          var e = this;\\n          this.pendingDiffs.forEach(function (t) {\\n            var n = t.diff,\\n                i = t.events;\\n            return e.update(n, i);\\n          }), this.pendingDiffs = [];\\n        }\\n      }, {\\n        key: \"onChannel\",\\n        value: function (e, t) {\\n          var n = this;\\n          this.liveSocket.onChannel(this.channel, e, function (e) {\\n            n.isJoinPending() ? n.root.pendingJoinOps.push([n, function () {\\n              return t(e);\\n            }]) : t(e);\\n          });\\n        }\\n      }, {\\n        key: \"bindChannel\",\\n        value: function () {\\n          var e = this;\\n          this.liveSocket.onChannel(this.channel, \"diff\", function (t) {\\n            e.applyDiff(\"update\", t, function (t) {\\n              var n = t.diff,\\n                  i = t.events;\\n              return e.update(n, i);\\n            });\\n          }), this.onChannel(\"redirect\", function (t) {\\n            var n = t.to,\\n                i = t.flash;\\n            return e.onRedirect({\\n              to: n,\\n              flash: i\\n            });\\n          }), this.onChannel(\"live_patch\", function (t) {\\n            return e.onLivePatch(t);\\n          }), this.onChannel(\"live_redirect\", function (t) {\\n            return e.onLiveRedirect(t);\\n          }), this.channel.onError(function (t) {\\n            return e.onError(t);\\n          }), this.channel.onClose(function (t) {\\n            return e.onClose(t);\\n          });\\n        }\\n      }, {\\n        key: \"destroyAllChildren\",\\n        value: function () {\\n          for (var e in this.root.children[this.id]) this.getChildById(e).destroy();\\n        }\\n      }, {\\n        key: \"onLiveRedirect\",\\n        value: function (e) {\\n          var t = e.to,\\n              n = e.kind,\\n              i = e.flash,\\n              r = this.expandURL(t);\\n          this.liveSocket.historyRedirect(r, n, i);\\n        }\\n      }, {\\n        key: \"onLivePatch\",\\n        value: function (e) {\\n          var t = e.to,\\n              n = e.kind;\\n          this.href = this.expandURL(t), this.liveSocket.historyPatch(t, n);\\n        }\\n      }, {\\n        key: \"expandURL\",\\n        value: function (e) {\\n          return e.startsWith(\"/\") ? \"\".concat(window.location.protocol, \"//\").concat(window.location.host).concat(e) : e;\\n        }\\n      }, {\\n        key: \"onRedirect\",\\n        value: function (e) {\\n          var t = e.to,\\n              n = e.flash;\\n          this.liveSocket.redirect(t, n);\\n        }\\n      }, {\\n        key: \"isDestroyed\",\\n        value: function () {\\n          return this.destroyed;\\n        }\\n      }, {\\n        key: \"join\",\\n        value: function (e) {\\n          var t = this;\\n          this.parent || (this.stopCallback = this.liveSocket.withPageLoading({\\n            to: this.href,\\n            kind: \"initial\"\\n          })), this.joinCallback = function () {\\n            return e && e(t, t.joinCount);\\n          }, this.liveSocket.wrapPush(this, {\\n            timeout: !1\\n          }, function () {\\n            return t.channel.join().receive(\"ok\", function (e) {\\n              return t.onJoin(e);\\n            }).receive(\"error\", function (e) {\\n              return t.onJoinError(e);\\n            }).receive(\"timeout\", function () {\\n              return t.onJoinError({\\n                reason: \"timeout\"\\n              });\\n            });\\n          });\\n        }\\n      }, {\\n        key: \"onJoinError\",\\n        value: function (e) {\\n          return (e.redirect || e.live_redirect) && (this.joinPending = !1, this.channel.leave()), e.redirect ? this.onRedirect(e.redirect) : e.live_redirect ? this.onLiveRedirect(e.live_redirect) : (this.log(\"error\", function () {\\n            return [\"unable to join\", e];\\n          }), this.liveSocket.reloadWithJitter(this));\\n        }\\n      }, {\\n        key: \"onClose\",\\n        value: function (e) {\\n          if (!this.isDestroyed()) {\\n            if (this.isJoinPending() || this.liveSocket.hasPendingLink() && \"leave\" !== e) return this.liveSocket.reloadWithJitter(this);\\n            this.destroyAllChildren(), this.liveSocket.dropActiveElement(this), document.activeElement && document.activeElement.blur(), this.liveSocket.isUnloaded() && this.showLoader(200);\\n          }\\n        }\\n      }, {\\n        key: \"onError\",\\n        value: function (e) {\\n          this.onClose(e), this.log(\"error\", function () {\\n            return [\"view crashed\", e];\\n          }), this.liveSocket.isUnloaded() || this.displayError();\\n        }\\n      }, {\\n        key: \"displayError\",\\n        value: function () {\\n          this.isMain() && le.dispatchEvent(window, \"phx:page-loading-start\", {\\n            to: this.href,\\n            kind: \"error\"\\n          }), this.showLoader(), this.setContainerClasses(\"phx-disconnected\", \"phx-error\");\\n        }\\n      }, {\\n        key: \"pushWithReply\",\\n        value: function (e, t, n) {\\n          var i = this,\\n              r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {},\\n              o = x(e ? e() : [null, []], 2),\\n              a = o[0],\\n              u = x(o[1], 1)[0],\\n              s = function () {};\\n\\n          return u && null !== u.getAttribute(this.binding(\"page-loading\")) && (s = this.liveSocket.withPageLoading({\\n            kind: \"element\",\\n            target: u\\n          })), \"number\" != typeof n.cid && delete n.cid, this.liveSocket.wrapPush(this, {\\n            timeout: !0\\n          }, function () {\\n            return i.channel.push(t, n, 3e4).receive(\"ok\", function (e) {\\n              var t = null;\\n              null !== a && i.undoRefs(a), e.diff && (t = i.applyDiff(\"update\", e.diff, function (e) {\\n                var t = e.diff,\\n                    n = e.events;\\n                i.update(t, n);\\n              })), e.redirect && i.onRedirect(e.redirect), e.live_patch && i.onLivePatch(e.live_patch), e.live_redirect && i.onLiveRedirect(e.live_redirect), s(), r(e, t);\\n            });\\n          });\\n        }\\n      }, {\\n        key: \"undoRefs\",\\n        value: function (e) {\\n          var t = this;\\n          le.all(this.el, \"[\".concat(F, \\'=\"\\').concat(e, \\'\"]\\'), function (e) {\\n            e.removeAttribute(F), null !== e.getAttribute(\"data-phx-readonly\") && (e.readOnly = !1, e.removeAttribute(\"data-phx-readonly\")), null !== e.getAttribute(\"data-phx-disabled\") && (e.disabled = !1, e.removeAttribute(\"data-phx-disabled\")), j.forEach(function (t) {\\n              return le.removeClass(e, t);\\n            });\\n            var n = e.getAttribute(\"data-phx-disable-with-restore\");\\n            null !== n && (e.innerText = n, e.removeAttribute(\"data-phx-disable-with-restore\"));\\n            var i = le.private(e, F);\\n\\n            if (i) {\\n              var r = t.triggerBeforeUpdateHook(e, i);\\n              he.patchEl(e, i, t.liveSocket.getActiveElement()), r && r.__updated(), le.deletePrivate(e, F);\\n            }\\n          });\\n        }\\n      }, {\\n        key: \"putRef\",\\n        value: function (e, t) {\\n          var n = this.ref++,\\n              i = this.binding(\"disable-with\");\\n          return e.forEach(function (e) {\\n            e.classList.add(\"phx-\".concat(t, \"-loading\")), e.setAttribute(F, n);\\n            var r = e.getAttribute(i);\\n            null !== r && (e.getAttribute(\"data-phx-disable-with-restore\") || e.setAttribute(\"data-phx-disable-with-restore\", e.innerText), e.innerText = r);\\n          }), [n, e];\\n        }\\n      }, {\\n        key: \"componentID\",\\n        value: function (e) {\\n          var t = e.getAttribute && e.getAttribute(H);\\n          return t ? parseInt(t) : null;\\n        }\\n      }, {\\n        key: \"targetComponentID\",\\n        value: function (e, t) {\\n          return e.getAttribute(this.binding(\"target\")) ? this.closestComponentID(t) : null;\\n        }\\n      }, {\\n        key: \"closestComponentID\",\\n        value: function (e) {\\n          var t = this;\\n          return e ? Z(e.closest(\"[\".concat(H, \"]\")), function (e) {\\n            return t.ownsElement(e) && t.componentID(e);\\n          }) : null;\\n        }\\n      }, {\\n        key: \"pushHookEvent\",\\n        value: function (e, t, n, i) {\\n          if (!this.isConnected()) return this.log(\"hook\", function () {\\n            return [\"unable to push hook event. LiveView not connected\", t, n];\\n          }), !1;\\n          var r = x(this.putRef([], \"hook\"), 2),\\n              o = r[0],\\n              a = r[1];\\n          return this.pushWithReply(function () {\\n            return [o, a];\\n          }, \"event\", {\\n            type: \"hook\",\\n            event: t,\\n            value: n,\\n            cid: this.closestComponentID(e)\\n          }, function (e, t) {\\n            return i(t, o);\\n          }), o;\\n        }\\n      }, {\\n        key: \"extractMeta\",\\n        value: function (e, t) {\\n          for (var n = this.binding(\"value-\"), i = 0; i < e.attributes.length; i++) {\\n            var r = e.attributes[i].name;\\n            r.startsWith(n) && (t[r.replace(n, \"\")] = e.getAttribute(r));\\n          }\\n\\n          return void 0 !== e.value && (t.value = e.value, \"INPUT\" === e.tagName && J.indexOf(e.type) >= 0 && !e.checked && delete t.value), t;\\n        }\\n      }, {\\n        key: \"pushEvent\",\\n        value: function (e, t, n, i, r) {\\n          var o = this;\\n          this.pushWithReply(function () {\\n            return o.putRef([t], e);\\n          }, \"event\", {\\n            type: e,\\n            event: i,\\n            value: this.extractMeta(t, r),\\n            cid: this.targetComponentID(t, n)\\n          });\\n        }\\n      }, {\\n        key: \"pushKey\",\\n        value: function (e, t, n, i, r) {\\n          var o = this;\\n          this.pushWithReply(function () {\\n            return o.putRef([e], n);\\n          }, \"event\", {\\n            type: n,\\n            event: i,\\n            value: this.extractMeta(e, r),\\n            cid: this.targetComponentID(e, t)\\n          });\\n        }\\n      }, {\\n        key: \"pushFileProgress\",\\n        value: function (e, t, n) {\\n          var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {};\\n          this.liveSocket.withinOwners(e.form, function (r, o) {\\n            r.pushWithReply(null, \"progress\", {\\n              event: e.getAttribute(r.binding(\"progress\")),\\n              ref: e.getAttribute(M),\\n              entry_ref: t,\\n              progress: n,\\n              cid: r.targetComponentID(e.form, o)\\n            }, i);\\n          });\\n        }\\n      }, {\\n        key: \"pushInput\",\\n        value: function (e, t, n, i, r) {\\n          var o = this,\\n              a = this.targetComponentID(e.form, t),\\n              u = function () {\\n            return o.putRef([e, e.form], \"change\");\\n          },\\n              s = ae(e.form, {\\n            _target: i.name\\n          });\\n\\n          e.files && e.files.length > 0 && ie.trackFiles(e, Array.from(e.files));\\n          var c = {\\n            type: \"form\",\\n            event: n,\\n            value: s,\\n            uploads: ie.serializeUploads(e),\\n            cid: a\\n          };\\n          this.pushWithReply(u, \"event\", c, function (n) {\\n            if (le.showError(e, o.liveSocket.binding(\"feedback-for\")), le.isUploadInput(e) && null !== e.getAttribute(\"data-phx-auto-upload\")) {\\n              if (ie.filesAwaitingPreflight(e).length > 0) {\\n                var i = x(u(), 2),\\n                    s = i[0];\\n                i[1];\\n                o.uploadFiles(e.form, t, s, a, function (t) {\\n                  r && r(n), o.triggerAwaitingSubmit(e.form);\\n                });\\n              }\\n            } else r && r(n);\\n          });\\n        }\\n      }, {\\n        key: \"triggerAwaitingSubmit\",\\n        value: function (e) {\\n          var t = this.getScheduledSubmit(e);\\n\\n          if (t) {\\n            var n = x(t, 3),\\n                i = (n[0], n[1], n[2]);\\n            this.cancelSubmit(e), i();\\n          }\\n        }\\n      }, {\\n        key: \"getScheduledSubmit\",\\n        value: function (e) {\\n          return this.formSubmits.find(function (t) {\\n            var n = x(t, 2),\\n                i = n[0];\\n            n[1];\\n            return i.isSameNode(e);\\n          });\\n        }\\n      }, {\\n        key: \"scheduleSubmit\",\\n        value: function (e, t, n) {\\n          if (this.getScheduledSubmit(e)) return !0;\\n          this.formSubmits.push([e, t, n]);\\n        }\\n      }, {\\n        key: \"cancelSubmit\",\\n        value: function (e) {\\n          var t = this;\\n          this.formSubmits = this.formSubmits.filter(function (n) {\\n            var i = x(n, 3),\\n                r = i[0],\\n                o = i[1];\\n            i[2];\\n            return !r.isSameNode(e) || (t.undoRefs(o), !1);\\n          });\\n        }\\n      }, {\\n        key: \"pushFormSubmit\",\\n        value: function (e, t, n, i) {\\n          var r = this,\\n              o = function (e) {\\n            return !(G(e, \"\".concat(r.binding(\"update\"), \"=ignore\"), e.form) || G(e, \"data-phx-update=ignore\", e.form));\\n          },\\n              a = function (e) {\\n            return e.hasAttribute(r.binding(\"disable-with\"));\\n          },\\n              u = function (e) {\\n            return \"BUTTON\" == e.tagName;\\n          },\\n              s = function (e) {\\n            return [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(e.tagName);\\n          },\\n              c = function () {\\n            var t = Array.from(e.elements),\\n                n = t.filter(a),\\n                i = t.filter(u).filter(o),\\n                c = t.filter(s).filter(o);\\n            return i.forEach(function (e) {\\n              e.setAttribute(\"data-phx-disabled\", e.disabled), e.disabled = !0;\\n            }), c.forEach(function (e) {\\n              e.setAttribute(\"data-phx-readonly\", e.readOnly), e.readOnly = !0, e.files && (e.setAttribute(\"data-phx-disabled\", e.disabled), e.disabled = !0);\\n            }), e.setAttribute(r.binding(\"page-loading\"), \"\"), r.putRef([e].concat(n).concat(i).concat(c), \"submit\");\\n          },\\n              l = this.targetComponentID(e, t);\\n\\n          if (ie.hasUploadsInProgress(e)) {\\n            var d = x(c(), 2),\\n                h = d[0];\\n            d[1];\\n            return this.scheduleSubmit(e, h, function () {\\n              return r.pushFormSubmit(e, t, n, i);\\n            });\\n          }\\n\\n          if (ie.inputsAwaitingPreflight(e).length > 0) {\\n            var f = x(c(), 2),\\n                v = f[0],\\n                p = f[1],\\n                g = function () {\\n              return [v, p];\\n            };\\n\\n            this.uploadFiles(e, t, v, l, function (t) {\\n              var o = ae(e, {});\\n              r.pushWithReply(g, \"event\", {\\n                type: \"form\",\\n                event: n,\\n                value: o,\\n                cid: l\\n              }, i);\\n            });\\n          } else {\\n            var m = ae(e);\\n            this.pushWithReply(c, \"event\", {\\n              type: \"form\",\\n              event: n,\\n              value: m,\\n              cid: l\\n            }, i);\\n          }\\n        }\\n      }, {\\n        key: \"uploadFiles\",\\n        value: function (e, t, n, i, r) {\\n          var o = this,\\n              a = this.joinCount;\\n          ie.activeFileInputs(e).forEach(function (e) {\\n            var i = new ie(e, o, r);\\n            o.uploaders[e] = i;\\n            var u = i.entries().map(function (e) {\\n              return e.toPreflightPayload();\\n            }),\\n                s = {\\n              ref: e.getAttribute(M),\\n              entries: u,\\n              cid: o.targetComponentID(e.form, t)\\n            };\\n            o.log(\"upload\", function () {\\n              return [\"sending preflight request\", s];\\n            }), o.pushWithReply(null, \"allow_upload\", s, function (e) {\\n              if (o.log(\"upload\", function () {\\n                return [\"got preflight response\", e];\\n              }), e.error) {\\n                o.undoRefs(n);\\n                var t = x(e.error, 2),\\n                    r = t[0],\\n                    u = t[1];\\n                o.log(\"upload\", function () {\\n                  return [\"error for entry \".concat(r), u];\\n                });\\n              } else {\\n                i.initAdapterUpload(e, function (e) {\\n                  o.channel.onError(function () {\\n                    o.joinCount === a && e();\\n                  });\\n                }, o.liveSocket);\\n              }\\n            });\\n          });\\n        }\\n      }, {\\n        key: \"pushFormRecovery\",\\n        value: function (e, t) {\\n          var n = this;\\n          this.liveSocket.withinOwners(e, function (i, r) {\\n            var o = e.elements[0],\\n                a = e.getAttribute(n.binding(\"auto-recover\")) || e.getAttribute(n.binding(\"change\"));\\n            i.pushInput(o, r, a, o, t);\\n          });\\n        }\\n      }, {\\n        key: \"pushLinkPatch\",\\n        value: function (e, t, n) {\\n          var i = this,\\n              r = this.liveSocket.setPendingLink(e),\\n              o = t ? function () {\\n            return i.putRef([t], \"click\");\\n          } : null;\\n          this.pushWithReply(o, \"link\", {\\n            url: e\\n          }, function (t) {\\n            t.link_redirect ? i.liveSocket.replaceMain(e, null, n, r) : i.liveSocket.commitPendingLink(r) && (i.href = e, i.applyPendingUpdates(), n && n());\\n          }).receive(\"timeout\", function () {\\n            return i.liveSocket.redirect(window.location.href);\\n          });\\n        }\\n      }, {\\n        key: \"formsForRecovery\",\\n        value: function (e) {\\n          var t = this;\\n          if (0 === this.joinCount) return [];\\n          var n = this.binding(\"change\"),\\n              i = document.createElement(\"template\");\\n          return i.innerHTML = e, le.all(this.el, \"form[\".concat(n, \"]\")).filter(function (e) {\\n            return t.ownsElement(e);\\n          }).filter(function (e) {\\n            return e.elements.length > 0;\\n          }).filter(function (e) {\\n            return \"ignore\" !== e.getAttribute(t.binding(\"auto-recover\"));\\n          }).filter(function (e) {\\n            return i.content.querySelector(\"form[\".concat(n, \\'=\"\\').concat(e.getAttribute(n), \\'\"]\\'));\\n          });\\n        }\\n      }, {\\n        key: \"maybePushComponentsDestroyed\",\\n        value: function (e) {\\n          var t,\\n              n = this,\\n              i = e.filter(function (e) {\\n            return 0 === le.findComponentNodeList(n.el, e).length;\\n          });\\n          i.length > 0 && ((t = this.pruningCIDs).push.apply(t, A(i)), this.pushWithReply(null, \"cids_will_destroy\", {\\n            cids: i\\n          }, function () {\\n            n.pruningCIDs = n.pruningCIDs.filter(function (e) {\\n              return -1 !== i.indexOf(e);\\n            });\\n            var e = i.filter(function (e) {\\n              return 0 === le.findComponentNodeList(n.el, e).length;\\n            });\\n            e.length > 0 && n.pushWithReply(null, \"cids_destroyed\", {\\n              cids: e\\n            }, function (e) {\\n              n.rendered.pruneCIDs(e.cids);\\n            });\\n          }));\\n        }\\n      }, {\\n        key: \"ownsElement\",\\n        value: function (e) {\\n          return e.getAttribute(\"data-phx-parent-id\") === this.id || Z(e.closest(U), function (e) {\\n            return e.id;\\n          }) === this.id;\\n        }\\n      }, {\\n        key: \"submitForm\",\\n        value: function (e, t, n) {\\n          var i = this;\\n          le.putPrivate(e, \"phx-has-submitted\", !0), this.liveSocket.blurActiveElement(this), this.pushFormSubmit(e, t, n, function () {\\n            i.liveSocket.restorePreviouslyActiveFocus();\\n          });\\n        }\\n      }, {\\n        key: \"binding\",\\n        value: function (e) {\\n          return this.liveSocket.binding(e);\\n        }\\n      }]), e;\\n    }(),\\n        ve = 1,\\n        pe = function () {\\n      function e(t, n, i) {\\n        for (var r in T(this, e), this.__view = t, this.__liveSocket = t.liveSocket, this.__callbacks = i, this.__listeners = new Set(), this.__isDisconnected = !1, this.el = n, this.viewName = t.name(), this.el.phxHookId = this.constructor.makeID(), this.__callbacks) this[r] = this.__callbacks[r];\\n      }\\n\\n      return _(e, null, [{\\n        key: \"makeID\",\\n        value: function () {\\n          return ve++;\\n        }\\n      }, {\\n        key: \"elementID\",\\n        value: function (e) {\\n          return e.phxHookId;\\n        }\\n      }]), _(e, [{\\n        key: \"__mounted\",\\n        value: function () {\\n          this.mounted && this.mounted();\\n        }\\n      }, {\\n        key: \"__updated\",\\n        value: function () {\\n          this.updated && this.updated();\\n        }\\n      }, {\\n        key: \"__beforeUpdate\",\\n        value: function () {\\n          this.beforeUpdate && this.beforeUpdate();\\n        }\\n      }, {\\n        key: \"__destroyed\",\\n        value: function () {\\n          this.destroyed && this.destroyed();\\n        }\\n      }, {\\n        key: \"__reconnected\",\\n        value: function () {\\n          this.__isDisconnected && (this.__isDisconnected = !1, this.reconnected && this.reconnected());\\n        }\\n      }, {\\n        key: \"__disconnected\",\\n        value: function () {\\n          this.__isDisconnected = !0, this.disconnected && this.disconnected();\\n        }\\n      }, {\\n        key: \"pushEvent\",\\n        value: function (e) {\\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\\n              n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {};\\n          return this.__view.pushHookEvent(null, e, t, n);\\n        }\\n      }, {\\n        key: \"pushEventTo\",\\n        value: function (e, t) {\\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\\n              i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {};\\n          return this.__view.withinTargets(e, function (e, r) {\\n            return e.pushHookEvent(r, t, n, i);\\n          });\\n        }\\n      }, {\\n        key: \"handleEvent\",\\n        value: function (e, t) {\\n          var n = function (n, i) {\\n            return i ? e : t(n.detail);\\n          };\\n\\n          return window.addEventListener(\"phx:hook:\".concat(e), n), this.__listeners.add(n), n;\\n        }\\n      }, {\\n        key: \"removeHandleEvent\",\\n        value: function (e) {\\n          var t = e(null, !0);\\n          window.removeEventListener(\"phx:hook:\".concat(t), e), this.__listeners.delete(e);\\n        }\\n      }, {\\n        key: \"__cleanup__\",\\n        value: function () {\\n          var e = this;\\n\\n          this.__listeners.forEach(function (t) {\\n            return e.removeHandleEvent(t);\\n          });\\n        }\\n      }]), e;\\n    }();\\n\\n    t.default = se;\\n  }, function (e, t) {\\n    var n;\\n\\n    n = function () {\\n      return this;\\n    }();\\n\\n    try {\\n      n = n || Function(\"return this\")() || (0, eval)(\"this\");\\n    } catch (e) {\\n      \"object\" == typeof window && (n = window);\\n    }\\n\\n    e.exports = n;\\n  }, function (e, t, n) {\\n    (function (t) {\\n      t.Phoenix || (t.Phoenix = {}), e.exports = t.Phoenix.LiveView = n(0);\\n    }).call(this, n(1));\\n  }]);\\n});//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9hbGVhay9zcmMvZmVlZGV4L2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvcHJpdi9zdGF0aWMvcGhvZW5peF9saXZlX3ZpZXcuanM/ZWY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLnBob2VuaXhfbGl2ZV92aWV3PXQoKTplLnBob2VuaXhfbGl2ZV92aWV3PXQoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiBuKGkpe2lmKHRbaV0pcmV0dXJuIHRbaV0uZXhwb3J0czt2YXIgcj10W2ldPXtpOmksbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtpXS5jYWxsKHIuZXhwb3J0cyxyLHIuZXhwb3J0cyxuKSxyLmw9ITAsci5leHBvcnRzfXJldHVybiBuLm09ZSxuLmM9dCxuLmQ9ZnVuY3Rpb24oZSx0LGkpe24ubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6aX0pfSxuLnI9ZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LG4ubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbi5kKHQsXCJhXCIsdCksdH0sbi5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxuLnA9XCJcIixuKG4ucz0yKX0oW2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtuLnIodCk7dmFyIGkscj0xMTt2YXIgbz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixhPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudD92b2lkIDA6ZG9jdW1lbnQsdT0hIWEmJlwiY29udGVudFwiaW4gYS5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIikscz0hIWEmJmEuY3JlYXRlUmFuZ2UmJlwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50XCJpbiBhLmNyZWF0ZVJhbmdlKCk7ZnVuY3Rpb24gYyhlKXtyZXR1cm4gZT1lLnRyaW0oKSx1P2Z1bmN0aW9uKGUpe3ZhciB0PWEuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO3JldHVybiB0LmlubmVySFRNTD1lLHQuY29udGVudC5jaGlsZE5vZGVzWzBdfShlKTpzP2Z1bmN0aW9uKGUpe3JldHVybiBpfHwoaT1hLmNyZWF0ZVJhbmdlKCkpLnNlbGVjdE5vZGUoYS5ib2R5KSxpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChlKS5jaGlsZE5vZGVzWzBdfShlKTpmdW5jdGlvbihlKXt2YXIgdD1hLmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpO3JldHVybiB0LmlubmVySFRNTD1lLHQuY2hpbGROb2Rlc1swXX0oZSl9ZnVuY3Rpb24gbChlLHQpe3ZhciBuLGkscj1lLm5vZGVOYW1lLG89dC5ub2RlTmFtZTtyZXR1cm4gcj09PW98fChuPXIuY2hhckNvZGVBdCgwKSxpPW8uY2hhckNvZGVBdCgwKSxuPD05MCYmaT49OTc/cj09PW8udG9VcHBlckNhc2UoKTppPD05MCYmbj49OTcmJm89PT1yLnRvVXBwZXJDYXNlKCkpfWZ1bmN0aW9uIGQoZSx0LG4pe2Vbbl0hPT10W25dJiYoZVtuXT10W25dLGVbbl0/ZS5zZXRBdHRyaWJ1dGUobixcIlwiKTplLnJlbW92ZUF0dHJpYnV0ZShuKSl9dmFyIGg9e09QVElPTjpmdW5jdGlvbihlLHQpe3ZhciBuPWUucGFyZW50Tm9kZTtpZihuKXt2YXIgaT1uLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XCJPUFRHUk9VUFwiPT09aSYmKGk9KG49bi5wYXJlbnROb2RlKSYmbi5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpKSxcIlNFTEVDVFwiIT09aXx8bi5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKXx8KGUuaGFzQXR0cmlidXRlKFwic2VsZWN0ZWRcIikmJiF0LnNlbGVjdGVkJiYoZS5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLFwic2VsZWN0ZWRcIiksZS5yZW1vdmVBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKSksbi5zZWxlY3RlZEluZGV4PS0xKX1kKGUsdCxcInNlbGVjdGVkXCIpfSxJTlBVVDpmdW5jdGlvbihlLHQpe2QoZSx0LFwiY2hlY2tlZFwiKSxkKGUsdCxcImRpc2FibGVkXCIpLGUudmFsdWUhPT10LnZhbHVlJiYoZS52YWx1ZT10LnZhbHVlKSx0Lmhhc0F0dHJpYnV0ZShcInZhbHVlXCIpfHxlLnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpfSxURVhUQVJFQTpmdW5jdGlvbihlLHQpe3ZhciBuPXQudmFsdWU7ZS52YWx1ZSE9PW4mJihlLnZhbHVlPW4pO3ZhciBpPWUuZmlyc3RDaGlsZDtpZihpKXt2YXIgcj1pLm5vZGVWYWx1ZTtpZihyPT1ufHwhbiYmcj09ZS5wbGFjZWhvbGRlcilyZXR1cm47aS5ub2RlVmFsdWU9bn19LFNFTEVDVDpmdW5jdGlvbihlLHQpe2lmKCF0Lmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpKXtmb3IodmFyIG4saSxyPS0xLG89MCxhPWUuZmlyc3RDaGlsZDthOylpZihcIk9QVEdST1VQXCI9PT0oaT1hLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkpKWE9KG49YSkuZmlyc3RDaGlsZDtlbHNle2lmKFwiT1BUSU9OXCI9PT1pKXtpZihhLmhhc0F0dHJpYnV0ZShcInNlbGVjdGVkXCIpKXtyPW87YnJlYWt9bysrfSEoYT1hLm5leHRTaWJsaW5nKSYmbiYmKGE9bi5uZXh0U2libGluZyxuPW51bGwpfWUuc2VsZWN0ZWRJbmRleD1yfX19LGY9MSx2PTExLHA9MyxnPTg7ZnVuY3Rpb24gbSgpe31mdW5jdGlvbiB5KGUpe2lmKGUpcmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZlLmdldEF0dHJpYnV0ZShcImlkXCIpfHxlLmlkfXZhciBiPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LG4saSl7aWYoaXx8KGk9e30pLFwic3RyaW5nXCI9PXR5cGVvZiBuKWlmKFwiI2RvY3VtZW50XCI9PT10Lm5vZGVOYW1lfHxcIkhUTUxcIj09PXQubm9kZU5hbWV8fFwiQk9EWVwiPT09dC5ub2RlTmFtZSl7dmFyIHI9bjsobj1hLmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIpKS5pbm5lckhUTUw9cn1lbHNlIG49YyhuKTt2YXIgdT1pLmdldE5vZGVLZXl8fHkscz1pLm9uQmVmb3JlTm9kZUFkZGVkfHxtLGQ9aS5vbk5vZGVBZGRlZHx8bSxiPWkub25CZWZvcmVFbFVwZGF0ZWR8fG0saz1pLm9uRWxVcGRhdGVkfHxtLHc9aS5vbkJlZm9yZU5vZGVEaXNjYXJkZWR8fG0sRT1pLm9uTm9kZURpc2NhcmRlZHx8bSxBPWkub25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZHx8bSxTPSEwPT09aS5jaGlsZHJlbk9ubHkseD1PYmplY3QuY3JlYXRlKG51bGwpLEM9W107ZnVuY3Rpb24gUChlKXtDLnB1c2goZSl9ZnVuY3Rpb24gTChlLHQsbil7ITEhPT13KGUpJiYodCYmdC5yZW1vdmVDaGlsZChlKSxFKGUpLGZ1bmN0aW9uIGUodCxuKXtpZih0Lm5vZGVUeXBlPT09Zilmb3IodmFyIGk9dC5maXJzdENoaWxkO2k7KXt2YXIgcj12b2lkIDA7biYmKHI9dShpKSk/UChyKTooRShpKSxpLmZpcnN0Q2hpbGQmJmUoaSxuKSksaT1pLm5leHRTaWJsaW5nfX0oZSxuKSl9ZnVuY3Rpb24gSShlKXtkKGUpO2Zvcih2YXIgdD1lLmZpcnN0Q2hpbGQ7dDspe3ZhciBuPXQubmV4dFNpYmxpbmcsaT11KHQpO2lmKGkpe3ZhciByPXhbaV07ciYmbCh0LHIpPyh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHIsdCksVChyLHQpKTpJKHQpfWVsc2UgSSh0KTt0PW59fWZ1bmN0aW9uIFQodCxuLGkpe3ZhciByPXUobik7aWYociYmZGVsZXRlIHhbcl0sIWkpe2lmKCExPT09Yih0LG4pKXJldHVybjtpZihlKHQsbiksayh0KSwhMT09PUEodCxuKSlyZXR1cm59XCJURVhUQVJFQVwiIT09dC5ub2RlTmFtZT9mdW5jdGlvbihlLHQpe3ZhciBuLGkscixvLGMsZD10LmZpcnN0Q2hpbGQsdj1lLmZpcnN0Q2hpbGQ7ZTpmb3IoO2Q7KXtmb3Iobz1kLm5leHRTaWJsaW5nLG49dShkKTt2Oyl7aWYocj12Lm5leHRTaWJsaW5nLGQuaXNTYW1lTm9kZSYmZC5pc1NhbWVOb2RlKHYpKXtkPW8sdj1yO2NvbnRpbnVlIGV9aT11KHYpO3ZhciBtPXYubm9kZVR5cGUseT12b2lkIDA7aWYobT09PWQubm9kZVR5cGUmJihtPT09Zj8obj9uIT09aSYmKChjPXhbbl0pP3I9PT1jP3k9ITE6KGUuaW5zZXJ0QmVmb3JlKGMsdiksaT9QKGkpOkwodixlLCEwKSx2PWMpOnk9ITEpOmkmJih5PSExKSwoeT0hMSE9PXkmJmwodixkKSkmJlQodixkKSk6bSE9PXAmJm0hPWd8fCh5PSEwLHYubm9kZVZhbHVlIT09ZC5ub2RlVmFsdWUmJih2Lm5vZGVWYWx1ZT1kLm5vZGVWYWx1ZSkpKSx5KXtkPW8sdj1yO2NvbnRpbnVlIGV9aT9QKGkpOkwodixlLCEwKSx2PXJ9aWYobiYmKGM9eFtuXSkmJmwoYyxkKSllLmFwcGVuZENoaWxkKGMpLFQoYyxkKTtlbHNle3ZhciBiPXMoZCk7ITEhPT1iJiYoYiYmKGQ9YiksZC5hY3R1YWxpemUmJihkPWQuYWN0dWFsaXplKGUub3duZXJEb2N1bWVudHx8YSkpLGUuYXBwZW5kQ2hpbGQoZCksSShkKSl9ZD1vLHY9cn0hZnVuY3Rpb24oZSx0LG4pe2Zvcig7dDspe3ZhciBpPXQubmV4dFNpYmxpbmc7KG49dSh0KSk/UChuKTpMKHQsZSwhMCksdD1pfX0oZSx2LGkpO3ZhciBrPWhbZS5ub2RlTmFtZV07ayYmayhlLHQpfSh0LG4pOmguVEVYVEFSRUEodCxuKX0hZnVuY3Rpb24gZSh0KXtpZih0Lm5vZGVUeXBlPT09Znx8dC5ub2RlVHlwZT09PXYpZm9yKHZhciBuPXQuZmlyc3RDaGlsZDtuOyl7dmFyIGk9dShuKTtpJiYoeFtpXT1uKSxlKG4pLG49bi5uZXh0U2libGluZ319KHQpO3ZhciBEPXQsXz1ELm5vZGVUeXBlLE49bi5ub2RlVHlwZTtpZighUylpZihfPT09ZilOPT09Zj9sKHQsbil8fChFKHQpLEQ9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49ZS5maXJzdENoaWxkO247KXt2YXIgaT1uLm5leHRTaWJsaW5nO3QuYXBwZW5kQ2hpbGQobiksbj1pfXJldHVybiB0fSh0LGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQmJnQhPT1vP2EuY3JlYXRlRWxlbWVudE5TKHQsZSk6YS5jcmVhdGVFbGVtZW50KGUpfShuLm5vZGVOYW1lLG4ubmFtZXNwYWNlVVJJKSkpOkQ9bjtlbHNlIGlmKF89PT1wfHxfPT09Zyl7aWYoTj09PV8pcmV0dXJuIEQubm9kZVZhbHVlIT09bi5ub2RlVmFsdWUmJihELm5vZGVWYWx1ZT1uLm5vZGVWYWx1ZSksRDtEPW59aWYoRD09PW4pRSh0KTtlbHNle2lmKG4uaXNTYW1lTm9kZSYmbi5pc1NhbWVOb2RlKEQpKXJldHVybjtpZihUKEQsbixTKSxDKWZvcih2YXIgUj0wLE89Qy5sZW5ndGg7UjxPO1IrKyl7dmFyIGo9eFtDW1JdXTtqJiZMKGosai5wYXJlbnROb2RlLCExKX19cmV0dXJuIVMmJkQhPT10JiZ0LnBhcmVudE5vZGUmJihELmFjdHVhbGl6ZSYmKEQ9RC5hY3R1YWxpemUodC5vd25lckRvY3VtZW50fHxhKSksdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChELHQpKSxEfX0oZnVuY3Rpb24oZSx0KXt2YXIgbixpLG8sYSx1PXQuYXR0cmlidXRlcztpZih0Lm5vZGVUeXBlIT09ciYmZS5ub2RlVHlwZSE9PXIpe2Zvcih2YXIgcz11Lmxlbmd0aC0xO3M+PTA7cy0tKWk9KG49dVtzXSkubmFtZSxvPW4ubmFtZXNwYWNlVVJJLGE9bi52YWx1ZSxvPyhpPW4ubG9jYWxOYW1lfHxpLGUuZ2V0QXR0cmlidXRlTlMobyxpKSE9PWEmJihcInhtbG5zXCI9PT1uLnByZWZpeCYmKGk9bi5uYW1lKSxlLnNldEF0dHJpYnV0ZU5TKG8saSxhKSkpOmUuZ2V0QXR0cmlidXRlKGkpIT09YSYmZS5zZXRBdHRyaWJ1dGUoaSxhKTtmb3IodmFyIGM9ZS5hdHRyaWJ1dGVzLGw9Yy5sZW5ndGgtMTtsPj0wO2wtLSlpPShuPWNbbF0pLm5hbWUsKG89bi5uYW1lc3BhY2VVUkkpPyhpPW4ubG9jYWxOYW1lfHxpLHQuaGFzQXR0cmlidXRlTlMobyxpKXx8ZS5yZW1vdmVBdHRyaWJ1dGVOUyhvLGkpKTp0Lmhhc0F0dHJpYnV0ZShpKXx8ZS5yZW1vdmVBdHRyaWJ1dGUoaSl9fSk7ZnVuY3Rpb24gayhlKXtyZXR1cm4gUChlKXx8UyhlKXx8TChlKXx8QygpfWZ1bmN0aW9uIHcoZSx0KXt2YXIgbj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihpPWkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSxuLnB1c2guYXBwbHkobixpKX1yZXR1cm4gbn1mdW5jdGlvbiBFKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX1mdW5jdGlvbiBBKGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBJKGUpfShlKXx8UyhlKXx8TChlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBTKGUpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpcmV0dXJuIEFycmF5LmZyb20oZSl9ZnVuY3Rpb24geChlLHQpe3JldHVybiBQKGUpfHxmdW5jdGlvbihlLHQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTeW1ib2x8fCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSkpcmV0dXJuO3ZhciBuPVtdLGk9ITAscj0hMSxvPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShpPShhPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtpPSEwKTt9Y2F0Y2goZSl7cj0hMCxvPWV9ZmluYWxseXt0cnl7aXx8bnVsbD09dS5yZXR1cm58fHUucmV0dXJuKCl9ZmluYWxseXtpZihyKXRocm93IG99fXJldHVybiBufShlLHQpfHxMKGUsdCl8fEMoKX1mdW5jdGlvbiBDKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX1mdW5jdGlvbiBQKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9ZnVuY3Rpb24gTChlLHQpe2lmKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBJKGUsdCk7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1uJiZlLmNvbnN0cnVjdG9yJiYobj1lLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1ufHxcIlNldFwiPT09bj9BcnJheS5mcm9tKGUpOlwiQXJndW1lbnRzXCI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKT9JKGUsdCk6dm9pZCAwfX1mdW5jdGlvbiBJKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciBuPTAsaT1uZXcgQXJyYXkodCk7bjx0O24rKylpW25dPWVbbl07cmV0dXJuIGl9ZnVuY3Rpb24gVChlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gRChlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxpLmtleSxpKX19ZnVuY3Rpb24gXyhlLHQsbil7cmV0dXJuIHQmJkQoZS5wcm90b3R5cGUsdCksbiYmRChlLG4pLGV9ZnVuY3Rpb24gTihlKXtcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7cmV0dXJuKE49XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfW4uZCh0LFwiZGVidWdcIixmdW5jdGlvbigpe3JldHVybiBLfSksbi5kKHQsXCJSZW5kZXJlZFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHVlfSksbi5kKHQsXCJMaXZlU29ja2V0XCIsZnVuY3Rpb24oKXtyZXR1cm4gc2V9KSxuLmQodCxcIkJyb3dzZXJcIixmdW5jdGlvbigpe3JldHVybiBjZX0pLG4uZCh0LFwiRE9NXCIsZnVuY3Rpb24oKXtyZXR1cm4gbGV9KSxuLmQodCxcIlZpZXdcIixmdW5jdGlvbigpe3JldHVybiBmZX0pO3ZhciBSPVsxZTMsM2UzXSxPPVwiZGF0YS1waHgtdmlld1wiLGo9W1wicGh4LWNsaWNrLWxvYWRpbmdcIixcInBoeC1jaGFuZ2UtbG9hZGluZ1wiLFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIsXCJwaHgta2V5ZG93bi1sb2FkaW5nXCIsXCJwaHgta2V5dXAtbG9hZGluZ1wiLFwicGh4LWJsdXItbG9hZGluZ1wiLFwicGh4LWZvY3VzLWxvYWRpbmdcIl0sSD1cImRhdGEtcGh4LWNvbXBvbmVudFwiLEY9XCJkYXRhLXBoeC1yZWZcIixNPVwiZGF0YS1waHgtdXBsb2FkLXJlZlwiLFU9XCJbXCIuY29uY2F0KE8sXCJdXCIpLEI9W1widGV4dFwiLFwidGV4dGFyZWFcIixcIm51bWJlclwiLFwiZW1haWxcIixcInBhc3N3b3JkXCIsXCJzZWFyY2hcIixcInRlbFwiLFwidXJsXCIsXCJkYXRlXCIsXCJ0aW1lXCJdLEo9W1wiY2hlY2tib3hcIixcInJhZGlvXCJdLFY9MSxXPVwicGh4LVwiLHE9e2RlYm91bmNlOjMwMCx0aHJvdHRsZTozMDB9LHo9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gY29uc29sZS5lcnJvciYmY29uc29sZS5lcnJvcihlLHQpfTt2YXIgSz1mdW5jdGlvbihlLHQsbixpKXtlLmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSYmY29uc29sZS5sb2coXCJcIi5jb25jYXQoZS5pZCxcIiBcIikuY29uY2F0KHQsXCI6IFwiKS5jb25jYXQobixcIiAtIFwiKSxpKX0sWD1mdW5jdGlvbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2U6ZnVuY3Rpb24oKXtyZXR1cm4gZX19LCQ9ZnVuY3Rpb24oZSl7cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZSkpfSxHPWZ1bmN0aW9uKGUsdCxuKXtkb3tpZihlLm1hdGNoZXMoXCJbXCIuY29uY2F0KHQsXCJdXCIpKSlyZXR1cm4gZTtlPWUucGFyZW50RWxlbWVudHx8ZS5wYXJlbnROb2RlfXdoaWxlKG51bGwhPT1lJiYxPT09ZS5ub2RlVHlwZSYmIShuJiZuLmlzU2FtZU5vZGUoZSl8fGUubWF0Y2hlcyhVKSkpO3JldHVybiBudWxsfSxZPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT09ZSYmXCJvYmplY3RcIj09PU4oZSkmJiEoZSBpbnN0YW5jZW9mIEFycmF5KX0sUT1mdW5jdGlvbihlKXtmb3IodmFyIHQgaW4gZSlyZXR1cm4hMTtyZXR1cm4hMH0sWj1mdW5jdGlvbihlLHQpe3JldHVybiBlJiZ0KGUpfSxlZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLGkpe1QodGhpcyxlKSx0aGlzLnJlZj1pZS5nZW5GaWxlUmVmKG4pLHRoaXMuZmlsZUVsPXQsdGhpcy5maWxlPW4sdGhpcy52aWV3PWksdGhpcy5tZXRhPW51bGwsdGhpcy5faXNDYW5jZWxsZWQ9ITEsdGhpcy5faXNEb25lPSExLHRoaXMuX3Byb2dyZXNzPTAsdGhpcy5fb25Eb25lPWZ1bmN0aW9uKCl7fX1yZXR1cm4gXyhlLG51bGwsW3trZXk6XCJpc0FjdGl2ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dm9pZCAwPT09dC5fcGh4UmVmLGk9ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1hY3RpdmUtcmVmc1wiKS5zcGxpdChcIixcIikuaW5kZXhPZihpZS5nZW5GaWxlUmVmKHQpKT49MDtyZXR1cm4gdC5zaXplPjAmJihufHxpKX19LHtrZXk6XCJpc1ByZWZsaWdodGVkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXByZWZsaWdodGVkLXJlZnNcIikuc3BsaXQoXCIsXCIpLmluZGV4T2YoaWUuZ2VuRmlsZVJlZih0KSk+PTA7cmV0dXJuIG4mJnRoaXMuaXNBY3RpdmUoZSx0KX19XSksXyhlLFt7a2V5OlwibWV0YWRhdGFcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1ldGF9fSx7a2V5OlwicHJvZ3Jlc3NcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3RoaXMuX3Byb2dyZXNzPU1hdGguZmxvb3IoZSksdGhpcy5fcHJvZ3Jlc3M+PTEwMD8odGhpcy5fcHJvZ3Jlc3M9MTAwLHRoaXMuX2lzRG9uZT0hMCx0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCx0aGlzLnJlZiwxMDAsZnVuY3Rpb24oKXtpZS51bnRyYWNrRmlsZSh0LmZpbGVFbCx0LmZpbGUpLHQuX29uRG9uZSgpfSkpOnRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLHRoaXMucmVmLHRoaXMuX3Byb2dyZXNzKX19LHtrZXk6XCJjYW5jZWxcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2lzQ2FuY2VsbGVkPSEwLHRoaXMuX2lzRG9uZT0hMCx0aGlzLl9vbkRvbmUoKX19LHtrZXk6XCJpc0RvbmVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0RvbmV9fSx7a2V5OlwiZXJyb3JcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpcImZhaWxlZFwiO3RoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLHRoaXMucmVmLHtlcnJvcjplfSl9fSx7a2V5Olwib25Eb25lXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fb25Eb25lPWV9fSx7a2V5OlwidG9QcmVmbGlnaHRQYXlsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm57bGFzdF9tb2RpZmllZDp0aGlzLmZpbGUubGFzdE1vZGlmaWVkLG5hbWU6dGhpcy5maWxlLm5hbWUsc2l6ZTp0aGlzLmZpbGUuc2l6ZSx0eXBlOnRoaXMuZmlsZS50eXBlLHJlZjp0aGlzLnJlZn19fSx7a2V5OlwidXBsb2FkZXJcIix2YWx1ZTpmdW5jdGlvbihlKXtpZih0aGlzLm1ldGEudXBsb2FkZXIpe3ZhciB0PWVbdGhpcy5tZXRhLnVwbG9hZGVyXXx8eihcIm5vIHVwbG9hZGVyIGNvbmZpZ3VyZWQgZm9yIFwiLmNvbmNhdCh0aGlzLm1ldGEudXBsb2FkZXIpKTtyZXR1cm57bmFtZTp0aGlzLm1ldGEudXBsb2FkZXIsY2FsbGJhY2s6dH19cmV0dXJue25hbWU6XCJjaGFubmVsXCIsY2FsbGJhY2s6cmV9fX0se2tleTpcInppcFBvc3RGbGlnaHRcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLm1ldGE9ZS5lbnRyaWVzW3RoaXMucmVmXSx0aGlzLm1ldGF8fHooXCJubyBwcmVmbGlnaHQgdXBsb2FkIHJlc3BvbnNlIHJldHVybmVkIHdpdGggcmVmIFwiLmNvbmNhdCh0aGlzLnJlZikse2lucHV0OnRoaXMuZmlsZUVsLHJlc3BvbnNlOmV9KX19XSksZX0oKSx0ZT17TGl2ZUZpbGVVcGxvYWQ6e3ByZWZsaWdodGVkUmVmczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXByZWZsaWdodGVkLXJlZnNcIil9LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnByZWZsaWdodGVkV2FzPXRoaXMucHJlZmxpZ2h0ZWRSZWZzKCl9LHVwZGF0ZWQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByZWZsaWdodGVkUmVmcygpO3RoaXMucHJlZmxpZ2h0ZWRXYXMhPT1lJiYodGhpcy5wcmVmbGlnaHRlZFdhcz1lLFwiXCI9PT1lJiZ0aGlzLl9fdmlldy5jYW5jZWxTdWJtaXQodGhpcy5lbC5mb3JtKSl9fX07dGUuTGl2ZUltZ1ByZXZpZXc9e21vdW50ZWQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucmVmPXRoaXMuZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZW50cnktcmVmXCIpLHRoaXMuaW5wdXRFbD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmVsLmdldEF0dHJpYnV0ZShNKSksaWUuZ2V0RW50cnlEYXRhVVJMKHRoaXMuaW5wdXRFbCx0aGlzLnJlZixmdW5jdGlvbih0KXtyZXR1cm4gZS5lbC5zcmM9dH0pfX07dmFyIG5lPTAsaWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixpKXtUKHRoaXMsZSksdGhpcy52aWV3PW4sdGhpcy5vbkNvbXBsZXRlPWksdGhpcy5fZW50cmllcz1BcnJheS5mcm9tKGUuZmlsZXNBd2FpdGluZ1ByZWZsaWdodCh0KXx8W10pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IGVlKHQsZSxuKX0pLHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3M9dGhpcy5fZW50cmllcy5sZW5ndGh9cmV0dXJuIF8oZSxudWxsLFt7a2V5OlwiZ2VuRmlsZVJlZlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUuX3BoeFJlZjtyZXR1cm4gdm9pZCAwIT09dD90OihlLl9waHhSZWY9KG5lKyspLnRvU3RyaW5nKCksZS5fcGh4UmVmKX19LHtrZXk6XCJnZXRFbnRyeURhdGFVUkxcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcyxyPXRoaXMuYWN0aXZlRmlsZXMoZSkuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gaS5nZW5GaWxlUmVmKGUpPT09dH0pLG89bmV3IEZpbGVSZWFkZXI7by5vbmxvYWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIG4oZS50YXJnZXQucmVzdWx0KX0sby5yZWFkQXNEYXRhVVJMKHIpfX0se2tleTpcImhhc1VwbG9hZHNJblByb2dyZXNzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9MDtyZXR1cm4gbGUuZmluZFVwbG9hZElucHV0cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtcHJlZmxpZ2h0ZWQtcmVmc1wiKSE9PWUuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZG9uZS1yZWZzXCIpJiZ0Kyt9KSx0PjB9fSx7a2V5Olwic2VyaWFsaXplVXBsb2Fkc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj17fTtyZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhlLFwic2VyaWFsaXplXCIpLmZvckVhY2goZnVuY3Rpb24oaSl7dmFyIHI9e3BhdGg6ZS5uYW1lfSxvPWUuZ2V0QXR0cmlidXRlKE0pO25bb109bltvXXx8W10sci5yZWY9dC5nZW5GaWxlUmVmKGkpLHIubmFtZT1pLm5hbWUsci50eXBlPWkudHlwZSxyLnNpemU9aS5zaXplLG5bb10ucHVzaChyKX0pLG59fSx7a2V5OlwiY2xlYXJGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2UudmFsdWU9bnVsbCxsZS5wdXRQcml2YXRlKGUsXCJmaWxlc1wiLFtdKX19LHtrZXk6XCJ1bnRyYWNrRmlsZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7bGUucHV0UHJpdmF0ZShlLFwiZmlsZXNcIixsZS5wcml2YXRlKGUsXCJmaWxlc1wiKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIU9iamVjdC5pcyhlLHQpfSkpfX0se2tleTpcInRyYWNrRmlsZXNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7aWYobnVsbCE9PWUuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikpe3ZhciBpPXQuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiFuLmFjdGl2ZUZpbGVzKGUpLmZpbmQoZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5pcyhlLHQpfSl9KTtsZS5wdXRQcml2YXRlKGUsXCJmaWxlc1wiLHRoaXMuYWN0aXZlRmlsZXMoZSkuY29uY2F0KGkpKSxlLnZhbHVlPW51bGx9ZWxzZSBsZS5wdXRQcml2YXRlKGUsXCJmaWxlc1wiLHQpfX0se2tleTpcImFjdGl2ZUZpbGVJbnB1dHNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLG49bGUuZmluZFVwbG9hZElucHV0cyhlKTtyZXR1cm4gQXJyYXkuZnJvbShuKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZmlsZXMmJnQuYWN0aXZlRmlsZXMoZSkubGVuZ3RoPjB9KX19LHtrZXk6XCJhY3RpdmVGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybihsZS5wcml2YXRlKGUsXCJmaWxlc1wiKXx8W10pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gZWUuaXNBY3RpdmUoZSx0KX0pfX0se2tleTpcImlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPWxlLmZpbmRVcGxvYWRJbnB1dHMoZSk7cmV0dXJuIEFycmF5LmZyb20obikuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB0LmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoZSkubGVuZ3RoPjB9KX19LHtrZXk6XCJmaWxlc0F3YWl0aW5nUHJlZmxpZ2h0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWN0aXZlRmlsZXMoZSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiFlZS5pc1ByZWZsaWdodGVkKGUsdCl9KX19XSksXyhlLFt7a2V5OlwiZW50cmllc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VudHJpZXN9fSx7a2V5OlwiaW5pdEFkYXB0ZXJVcGxvYWRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpczt0aGlzLl9lbnRyaWVzPXRoaXMuX2VudHJpZXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnppcFBvc3RGbGlnaHQoZSksdC5vbkRvbmUoZnVuY3Rpb24oKXtpLm51bUVudHJpZXNJblByb2dyZXNzLS0sMD09PWkubnVtRW50cmllc0luUHJvZ3Jlc3MmJmkub25Db21wbGV0ZSgpfSksdH0pO3ZhciByPXRoaXMuX2VudHJpZXMucmVkdWNlKGZ1bmN0aW9uKGUsdCl7dmFyIGk9dC51cGxvYWRlcihuLnVwbG9hZGVycykscj1pLm5hbWUsbz1pLmNhbGxiYWNrO3JldHVybiBlW3JdPWVbcl18fHtjYWxsYmFjazpvLGVudHJpZXM6W119LGVbcl0uZW50cmllcy5wdXNoKHQpLGV9LHt9KTtmb3IodmFyIG8gaW4gcil7dmFyIGE9cltvXTsoMCxhLmNhbGxiYWNrKShhLmVudHJpZXMsdCxlLG4pfX19XSksZX0oKSxyZT1mdW5jdGlvbihlLHQsbixpKXtlLmZvckVhY2goZnVuY3Rpb24oZSl7bmV3IG9lKGUsbi5jb25maWcuY2h1bmtfc2l6ZSxpKS51cGxvYWQoKX0pfSxvZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLGkpe1QodGhpcyxlKSx0aGlzLmxpdmVTb2NrZXQ9aSx0aGlzLmVudHJ5PXQsdGhpcy5vZmZzZXQ9MCx0aGlzLmNodW5rU2l6ZT1uLHRoaXMudXBsb2FkQ2hhbm5lbD1pLmNoYW5uZWwoXCJsdnU6XCIuY29uY2F0KHQucmVmKSx7dG9rZW46dC5tZXRhZGF0YSgpfSl9cmV0dXJuIF8oZSxbe2tleTpcInVwbG9hZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnVwbG9hZENoYW5uZWwuam9pbigpLnJlY2VpdmUoXCJva1wiLGZ1bmN0aW9uKHQpe3JldHVybiBlLnJlYWROZXh0Q2h1bmsoKX0pLnJlY2VpdmUoXCJlcnJvclwiLGZ1bmN0aW9uKHQpe2UudXBsb2FkQ2hhbm5lbC5sZWF2ZSgpLGUuZW50cnkuZXJyb3IoKX0pfX0se2tleTpcImlzRG9uZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0Pj10aGlzLmVudHJ5LmZpbGUuc2l6ZX19LHtrZXk6XCJyZWFkTmV4dENodW5rXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9bmV3IHdpbmRvdy5GaWxlUmVhZGVyLG49dGhpcy5lbnRyeS5maWxlLnNsaWNlKHRoaXMub2Zmc2V0LHRoaXMuY2h1bmtTaXplK3RoaXMub2Zmc2V0KTt0Lm9ubG9hZD1mdW5jdGlvbih0KXtpZihudWxsIT09dC50YXJnZXQuZXJyb3IpcmV0dXJuIHooXCJSZWFkIGVycm9yOiBcIit0LnRhcmdldC5lcnJvcik7ZS5vZmZzZXQrPXQudGFyZ2V0LnJlc3VsdC5ieXRlTGVuZ3RoLGUucHVzaENodW5rKHQudGFyZ2V0LnJlc3VsdCl9LHQucmVhZEFzQXJyYXlCdWZmZXIobil9fSx7a2V5OlwicHVzaENodW5rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aGlzLnVwbG9hZENoYW5uZWwuaXNKb2luZWQoKSYmdGhpcy51cGxvYWRDaGFubmVsLnB1c2goXCJjaHVua1wiLGUpLnJlY2VpdmUoXCJva1wiLGZ1bmN0aW9uKCl7dC5lbnRyeS5wcm9ncmVzcyh0Lm9mZnNldC90LmVudHJ5LmZpbGUuc2l6ZSoxMDApLHQuaXNEb25lKCl8fHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gdC5yZWFkTmV4dENodW5rKCl9LHQubGl2ZVNvY2tldC5nZXRMYXRlbmN5U2ltKCl8fDApfSl9fV0pLGV9KCksYWU9ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG49bmV3IEZvcm1EYXRhKGUpLGk9W107bi5mb3JFYWNoKGZ1bmN0aW9uKGUsdCxuKXtlIGluc3RhbmNlb2YgRmlsZSYmaS5wdXNoKHQpfSksaS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBuLmRlbGV0ZShlKX0pO3ZhciByLG89bmV3IFVSTFNlYXJjaFBhcmFtcyxhPWZ1bmN0aW9uKGUpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTeW1ib2x8fG51bGw9PWVbU3ltYm9sLml0ZXJhdG9yXSl7aWYoQXJyYXkuaXNBcnJheShlKXx8KGU9TChlKSkpe3ZhciB0PTAsbj1mdW5jdGlvbigpe307cmV0dXJue3M6bixuOmZ1bmN0aW9uKCl7cmV0dXJuIHQ+PWUubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTplW3QrK119fSxlOmZ1bmN0aW9uKGUpe3Rocm93IGV9LGY6bn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciBpLHIsbz0hMCxhPSExO3JldHVybntzOmZ1bmN0aW9uKCl7aT1lW1N5bWJvbC5pdGVyYXRvcl0oKX0sbjpmdW5jdGlvbigpe3ZhciBlPWkubmV4dCgpO3JldHVybiBvPWUuZG9uZSxlfSxlOmZ1bmN0aW9uKGUpe2E9ITAscj1lfSxmOmZ1bmN0aW9uKCl7dHJ5e298fG51bGw9PWkucmV0dXJufHxpLnJldHVybigpfWZpbmFsbHl7aWYoYSl0aHJvdyByfX19fShuLmVudHJpZXMoKSk7dHJ5e2ZvcihhLnMoKTshKHI9YS5uKCkpLmRvbmU7KXt2YXIgdT14KHIudmFsdWUsMikscz11WzBdLGM9dVsxXTtvLmFwcGVuZChzLGMpfX1jYXRjaChlKXthLmUoZSl9ZmluYWxseXthLmYoKX1mb3IodmFyIGwgaW4gdClvLmFwcGVuZChsLHRbbF0pO3JldHVybiBvLnRvU3RyaW5nKCl9LHVlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4pe1QodGhpcyxlKSx0aGlzLnZpZXdJZD10LHRoaXMucmVuZGVyZWQ9e30sdGhpcy5tZXJnZURpZmYobil9cmV0dXJuIF8oZSxudWxsLFt7a2V5OlwiZXh0cmFjdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUucixuPWUuZSxpPWUudDtyZXR1cm4gZGVsZXRlIGUucixkZWxldGUgZS5lLGRlbGV0ZSBlLnQse2RpZmY6ZSx0aXRsZTppLHJlcGx5OnR8fG51bGwsZXZlbnRzOm58fFtdfX19XSksXyhlLFt7a2V5OlwicGFyZW50Vmlld0lkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3SWR9fSx7a2V5OlwidG9TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWN1cnNpdmVUb1N0cmluZyh0aGlzLnJlbmRlcmVkLHRoaXMucmVuZGVyZWQuYyxlKX19LHtrZXk6XCJyZWN1cnNpdmVUb1N0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTplLmMsbj1hcmd1bWVudHMubGVuZ3RoPjI/YXJndW1lbnRzWzJdOnZvaWQgMCxpPXtidWZmZXI6XCJcIixjb21wb25lbnRzOnQsb25seUNpZHM6bj1uP25ldyBTZXQobik6bnVsbH07cmV0dXJuIHRoaXMudG9PdXRwdXRCdWZmZXIoZSxpKSxpLmJ1ZmZlcn19LHtrZXk6XCJjb21wb25lbnRDSURzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUuY3x8e30pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSl9KX19LHtrZXk6XCJpc0NvbXBvbmVudE9ubHlEaWZmXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuISFlLmMmJjE9PT1PYmplY3Qua2V5cyhlKS5sZW5ndGh9fSx7a2V5OlwiZ2V0Q29tcG9uZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jW3RdfX0se2tleTpcIm1lcmdlRGlmZlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUuYztpZihkZWxldGUgZS5jLHRoaXMucmVuZGVyZWQ9dGhpcy5yZWN1cnNpdmVNZXJnZSh0aGlzLnJlbmRlcmVkLGUpLHRoaXMucmVuZGVyZWQuYz10aGlzLnJlbmRlcmVkLmN8fHt9LHQpe3ZhciBuPXRoaXMucmVuZGVyZWQuYztmb3IodmFyIGkgaW4gdCl7dmFyIHI9dFtpXSxvPXIsYT1vLnM7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEpe2Zvcig7XCJudW1iZXJcIj09dHlwZW9mIGE7KWE9KG89YT4wP3RbYV06blstYV0pLnM7bz0kKG8pLHRoaXMuZG9SZWN1cnNpdmVNZXJnZShvLHIpLG8ucz1hfWVsc2Ugbz1uW2ldfHx7fSxvPXRoaXMucmVjdXJzaXZlTWVyZ2UobyxyKTt0W2ldPW99Zm9yKHZhciB1IGluIHQpblt1XT10W3VdO2UuYz10fX19LHtrZXk6XCJyZWN1cnNpdmVNZXJnZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMCE9PXQucz90Oih0aGlzLmRvUmVjdXJzaXZlTWVyZ2UoZSx0KSxlKX19LHtrZXk6XCJkb1JlY3Vyc2l2ZU1lcmdlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG4gaW4gdCl7dmFyIGk9dFtuXSxyPWVbbl07WShpKSYmdm9pZCAwPT09aS5zJiZZKHIpP3RoaXMuZG9SZWN1cnNpdmVNZXJnZShyLGkpOmVbbl09aX19fSx7a2V5OlwiY29tcG9uZW50VG9TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyh0aGlzLnJlbmRlcmVkLmMsZSl9fSx7a2V5OlwicHJ1bmVDSURzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztlLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGRlbGV0ZSB0LnJlbmRlcmVkLmNbZV19KX19LHtrZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlbmRlcmVkfX0se2tleTpcImlzTmV3RmluZ2VycHJpbnRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiEhKGFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSkuc319LHtrZXk6XCJ0b091dHB1dEJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoZS5kKXJldHVybiB0aGlzLmNvbXByZWhlbnNpb25Ub0J1ZmZlcihlLHQpO3ZhciBuPWUuczt0LmJ1ZmZlcis9blswXTtmb3IodmFyIGk9MTtpPG4ubGVuZ3RoO2krKyl0aGlzLmR5bmFtaWNUb0J1ZmZlcihlW2ktMV0sdCksdC5idWZmZXIrPW5baV19fSx7a2V5OlwiY29tcHJlaGVuc2lvblRvQnVmZmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49ZS5kLGk9ZS5zLHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIG89bltyXTt0LmJ1ZmZlcis9aVswXTtmb3IodmFyIGE9MTthPGkubGVuZ3RoO2ErKyl0aGlzLmR5bmFtaWNUb0J1ZmZlcihvW2EtMV0sdCksdC5idWZmZXIrPWlbYV19fX0se2tleTpcImR5bmFtaWNUb0J1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7XCJudW1iZXJcIj09dHlwZW9mIGU/dC5idWZmZXIrPXRoaXMucmVjdXJzaXZlQ0lEVG9TdHJpbmcodC5jb21wb25lbnRzLGUsdC5vbmx5Q2lkcyk6WShlKT90aGlzLnRvT3V0cHV0QnVmZmVyKGUsdCk6dC5idWZmZXIrPWV9fSx7a2V5OlwicmVjdXJzaXZlQ0lEVG9TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcyxyPWVbdF18fHooXCJubyBjb21wb25lbnQgZm9yIENJRCBcIi5jb25jYXQodCksZSksbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7by5pbm5lckhUTUw9dGhpcy5yZWN1cnNpdmVUb1N0cmluZyhyLGUsbik7dmFyIGE9by5jb250ZW50LHU9biYmIW4uaGFzKHQpLHM9eChBcnJheS5mcm9tKGEuY2hpbGROb2RlcykucmVkdWNlKGZ1bmN0aW9uKGUsbixyKXt2YXIgYT14KGUsMikscz1hWzBdLGM9YVsxXTtyZXR1cm4gbi5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFP24uZ2V0QXR0cmlidXRlKEgpP1tzLCEwXToobi5zZXRBdHRyaWJ1dGUoSCx0KSxuLmlkfHwobi5pZD1cIlwiLmNvbmNhdChpLnBhcmVudFZpZXdJZCgpLFwiLVwiKS5jb25jYXQodCxcIi1cIikuY29uY2F0KHIpKSx1JiYobi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1za2lwXCIsXCJcIiksbi5pbm5lckhUTUw9XCJcIiksWyEwLGNdKTpcIlwiIT09bi5ub2RlVmFsdWUudHJpbSgpPyh6KFwib25seSBIVE1MIGVsZW1lbnQgdGFncyBhcmUgYWxsb3dlZCBhdCB0aGUgcm9vdCBvZiBjb21wb25lbnRzLlxcblxcblwiKydnb3Q6IFwiJy5jb25jYXQobi5ub2RlVmFsdWUudHJpbSgpLCdcIlxcblxcbicpK1wid2l0aGluOlxcblwiLG8uaW5uZXJIVE1MLnRyaW0oKSksbi5yZXBsYWNlV2l0aChpLmNyZWF0ZVNwYW4obi5ub2RlVmFsdWUsdCkpLFshMCxjXSk6KG4ucmVtb3ZlKCksW3MsY10pfSxbITEsITFdKSwyKSxjPXNbMF0sbD1zWzFdO3JldHVybiBjfHxsPyFjJiZsPyh6KFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgZGlyZWN0bHkgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgb25seSBzdWJjb21wb25lbnRzIHdlcmUgZm91bmQuIEEgY29tcG9uZW50IG11c3QgcmVuZGVyIGF0IGxlYXN0IG9uZSBIVE1MIHRhZyBkaXJlY3RseSBpbnNpZGUgaXRzZWxmLlwiLG8uaW5uZXJIVE1MLnRyaW0oKSksby5pbm5lckhUTUwpOm8uaW5uZXJIVE1MOih6KFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgdGhlIGNvbXBvbmVudCBpcyBlbXB0eTpcXG5cIixvLmlubmVySFRNTC50cmltKCkpLHRoaXMuY3JlYXRlU3BhbihcIlwiLHQpLm91dGVySFRNTCl9fSx7a2V5OlwiY3JlYXRlU3BhblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7cmV0dXJuIG4uaW5uZXJUZXh0PWUsbi5zZXRBdHRyaWJ1dGUoSCx0KSxufX1dKSxlfSgpLHNlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4pe3ZhciBpPXRoaXMscj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e307aWYoVCh0aGlzLGUpLHRoaXMudW5sb2FkZWQ9ITEsIW58fFwiT2JqZWN0XCI9PT1uLmNvbnN0cnVjdG9yLm5hbWUpdGhyb3cgbmV3IEVycm9yKCdcXG4gICAgICBhIHBob2VuaXggU29ja2V0IG11c3QgYmUgcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgTGl2ZVNvY2tldCBjb25zdHJ1Y3Rvci4gRm9yIGV4YW1wbGU6XFxuXFxuICAgICAgICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXFxuICAgICAgICAgIGltcG9ydCB7TGl2ZVNvY2tldH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcXG4gICAgICAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXFxuICAgICAgJyk7dGhpcy5zb2NrZXQ9bmV3IG4odCxyKSx0aGlzLmJpbmRpbmdQcmVmaXg9ci5iaW5kaW5nUHJlZml4fHxXLHRoaXMub3B0cz1yLHRoaXMucGFyYW1zPVgoci5wYXJhbXN8fHt9KSx0aGlzLnZpZXdMb2dnZXI9ci52aWV3TG9nZ2VyLHRoaXMubWV0YWRhdGFDYWxsYmFja3M9ci5tZXRhZGF0YXx8e30sdGhpcy5kZWZhdWx0cz1PYmplY3QuYXNzaWduKCQocSksci5kZWZhdWx0c3x8e30pLHRoaXMuYWN0aXZlRWxlbWVudD1udWxsLHRoaXMucHJldkFjdGl2ZT1udWxsLHRoaXMuc2lsZW5jZWQ9ITEsdGhpcy5tYWluPW51bGwsdGhpcy5saW5rUmVmPTAsdGhpcy5yb290cz17fSx0aGlzLmhyZWY9d2luZG93LmxvY2F0aW9uLmhyZWYsdGhpcy5wZW5kaW5nTGluaz1udWxsLHRoaXMuY3VycmVudExvY2F0aW9uPSQod2luZG93LmxvY2F0aW9uKSx0aGlzLmhvb2tzPXIuaG9va3N8fHt9LHRoaXMudXBsb2FkZXJzPXIudXBsb2FkZXJzfHx7fSx0aGlzLmxvYWRlclRpbWVvdXQ9ci5sb2FkZXJUaW1lb3V0fHxWLHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cz0hMSx0aGlzLmRvbUNhbGxiYWNrcz1PYmplY3QuYXNzaWduKHtvbk5vZGVBZGRlZDpYKCksb25CZWZvcmVFbFVwZGF0ZWQ6WCgpfSxyLmRvbXx8e30pLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsZnVuY3Rpb24oZSl7aS51bmxvYWRlZD0hMH0pLHRoaXMuc29ja2V0Lm9uT3BlbihmdW5jdGlvbigpe2kuaXNVbmxvYWRlZCgpJiZ3aW5kb3cubG9jYXRpb24ucmVsb2FkKCl9KX1yZXR1cm4gXyhlLFt7a2V5OlwiaXNQcm9maWxlRW5hYmxlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJ0cnVlXCI9PT1zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwicGh4OmxpdmUtc29ja2V0OnByb2ZpbGluZ1wiKX19LHtrZXk6XCJpc0RlYnVnRW5hYmxlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJ0cnVlXCI9PT1zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwicGh4OmxpdmUtc29ja2V0OmRlYnVnXCIpfX0se2tleTpcImVuYWJsZURlYnVnXCIsdmFsdWU6ZnVuY3Rpb24oKXtzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwicGh4OmxpdmUtc29ja2V0OmRlYnVnXCIsXCJ0cnVlXCIpfX0se2tleTpcImVuYWJsZVByb2ZpbGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcInBoeDpsaXZlLXNvY2tldDpwcm9maWxpbmdcIixcInRydWVcIil9fSx7a2V5OlwiZGlzYWJsZURlYnVnXCIsdmFsdWU6ZnVuY3Rpb24oKXtzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFwicGh4OmxpdmUtc29ja2V0OmRlYnVnXCIpfX0se2tleTpcImRpc2FibGVQcm9maWxpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3Nlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oXCJwaHg6bGl2ZS1zb2NrZXQ6cHJvZmlsaW5nXCIpfX0se2tleTpcImVuYWJsZUxhdGVuY3lTaW1cIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmVuYWJsZURlYnVnKCksY29uc29sZS5sb2coXCJsYXRlbmN5IHNpbXVsYXRvciBlbmFibGVkIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBicm93c2VyIHNlc3Npb24uIENhbGwgZGlzYWJsZUxhdGVuY3lTaW0oKSB0byBkaXNhYmxlXCIpLHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJwaHg6bGl2ZS1zb2NrZXQ6bGF0ZW5jeS1zaW1cIixlKX19LHtrZXk6XCJkaXNhYmxlTGF0ZW5jeVNpbVwiLHZhbHVlOmZ1bmN0aW9uKCl7c2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShcInBoeDpsaXZlLXNvY2tldDpsYXRlbmN5LXNpbVwiKX19LHtrZXk6XCJnZXRMYXRlbmN5U2ltXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwicGh4OmxpdmUtc29ja2V0OmxhdGVuY3ktc2ltXCIpO3JldHVybiBlP3BhcnNlSW50KGUpOm51bGx9fSx7a2V5OlwiZ2V0U29ja2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zb2NrZXR9fSx7a2V5OlwiY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWZ1bmN0aW9uKCl7ZS5qb2luUm9vdFZpZXdzKCkmJihlLmJpbmRUb3BMZXZlbEV2ZW50cygpLGUuc29ja2V0LmNvbm5lY3QoKSl9O1tcImNvbXBsZXRlXCIsXCJsb2FkZWRcIixcImludGVyYWN0aXZlXCJdLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSk+PTA/dCgpOmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsZnVuY3Rpb24oKXtyZXR1cm4gdCgpfSl9fSx7a2V5OlwiZGlzY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuc29ja2V0LmRpc2Nvbm5lY3QoZSl9fSx7a2V5OlwidHJpZ2dlckRPTVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG47KG49dGhpcy5kb21DYWxsYmFja3MpW2VdLmFwcGx5KG4sQSh0KSl9fSx7a2V5OlwidGltZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoIXRoaXMuaXNQcm9maWxlRW5hYmxlZCgpfHwhY29uc29sZS50aW1lKXJldHVybiB0KCk7Y29uc29sZS50aW1lKGUpO3ZhciBuPXQoKTtyZXR1cm4gY29uc29sZS50aW1lRW5kKGUpLG59fSx7a2V5OlwibG9nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe2lmKHRoaXMudmlld0xvZ2dlcil7dmFyIGk9eChuKCksMikscj1pWzBdLG89aVsxXTt0aGlzLnZpZXdMb2dnZXIoZSx0LHIsbyl9ZWxzZSBpZih0aGlzLmlzRGVidWdFbmFibGVkKCkpe3ZhciBhPXgobigpLDIpLHU9YVswXSxzPWFbMV07SyhlLHQsdSxzKX19fSx7a2V5Olwib25DaGFubmVsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXM7ZS5vbih0LGZ1bmN0aW9uKGUpe3ZhciB0PWkuZ2V0TGF0ZW5jeVNpbSgpO3Q/KGNvbnNvbGUubG9nKFwic2ltdWxhdGluZyBcIi5jb25jYXQodCxcIm1zIG9mIGxhdGVuY3kgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50XCIpKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIG4oZSl9LHQpKTpuKGUpfSl9fSx7a2V5Olwid3JhcFB1c2hcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcyxyPXRoaXMuZ2V0TGF0ZW5jeVNpbSgpLG89ZS5qb2luQ291bnQ7aWYoIXIpcmV0dXJuIHQudGltZW91dD9uKCkucmVjZWl2ZShcInRpbWVvdXRcIixmdW5jdGlvbigpe2Uuam9pbkNvdW50PT09byYmaS5yZWxvYWRXaXRoSml0dGVyKGUsZnVuY3Rpb24oKXtpLmxvZyhlLFwidGltZW91dFwiLGZ1bmN0aW9uKCl7cmV0dXJuW1wicmVjZWl2ZWQgdGltZW91dCB3aGlsZSBjb21tdW5pY2F0aW5nIHdpdGggc2VydmVyLiBGYWxsaW5nIGJhY2sgdG8gaGFyZCByZWZyZXNoIGZvciByZWNvdmVyeVwiXX0pfSl9KTpuKCk7Y29uc29sZS5sb2coXCJzaW11bGF0aW5nIFwiLmNvbmNhdChyLFwibXMgb2YgbGF0ZW5jeSBmcm9tIGNsaWVudCB0byBzZXJ2ZXJcIikpO3ZhciBhPXtyZWNlaXZlczpbXSxyZWNlaXZlOmZ1bmN0aW9uKGUsdCl7dGhpcy5yZWNlaXZlcy5wdXNoKFtlLHRdKX19O3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5yZWNlaXZlcy5yZWR1Y2UoZnVuY3Rpb24oZSx0KXt2YXIgbj14KHQsMiksaT1uWzBdLHI9blsxXTtyZXR1cm4gZS5yZWNlaXZlKGkscil9LG4oKSl9LHIpLGF9fSx7a2V5OlwicmVsb2FkV2l0aEppdHRlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztlLmRlc3Ryb3koKSx0aGlzLmRpc2Nvbm5lY3QoKTt2YXIgaT1SWzBdLHI9UlsxXSxvPU1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSooci1pKzEpKStpLGE9Y2UudXBkYXRlTG9jYWwoZS5uYW1lKCksXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCIsMCxmdW5jdGlvbihlKXtyZXR1cm4gZSsxfSk7dD90KCk6dGhpcy5sb2coZSxcImpvaW5cIixmdW5jdGlvbigpe3JldHVybltcImVuY291bnRlcmVkIFwiLmNvbmNhdChhLFwiIGNvbnNlY3V0aXZlIHJlbG9hZHNcIildfSksYT4xMCYmKHRoaXMubG9nKGUsXCJqb2luXCIsZnVuY3Rpb24oKXtyZXR1cm5bXCJleGNlZWRlZCBcIi5jb25jYXQoMTAsXCIgY29uc2VjdXRpdmUgcmVsb2Fkcy4gRW50ZXJpbmcgZmFpbHNhZmUgbW9kZVwiKV19KSxvPTNlNCksc2V0VGltZW91dChmdW5jdGlvbigpe24uaGFzUGVuZGluZ0xpbmsoKT93aW5kb3cubG9jYXRpb249bi5wZW5kaW5nTGluazp3aW5kb3cubG9jYXRpb24ucmVsb2FkKCl9LG8pfX0se2tleTpcImdldEhvb2tDYWxsYmFja3NcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5zdGFydHNXaXRoKFwiUGhvZW5peC5cIik/dGVbZS5zcGxpdChcIi5cIilbMV1dOnRoaXMuaG9va3NbZV19fSx7a2V5OlwiaXNVbmxvYWRlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5sb2FkZWR9fSx7a2V5OlwiaXNDb25uZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpfX0se2tleTpcImdldEJpbmRpbmdQcmVmaXhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJpbmRpbmdQcmVmaXh9fSx7a2V5OlwiYmluZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwiXCIuY29uY2F0KHRoaXMuZ2V0QmluZGluZ1ByZWZpeCgpKS5jb25jYXQoZSl9fSx7a2V5OlwiY2hhbm5lbFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuc29ja2V0LmNoYW5uZWwoZSx0KX19LHtrZXk6XCJqb2luUm9vdFZpZXdzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ITE7cmV0dXJuIGxlLmFsbChkb2N1bWVudCxcIlwiLmNvbmNhdChVLFwiOm5vdChbXCIpLmNvbmNhdChcImRhdGEtcGh4LXBhcmVudC1pZFwiLFwiXSlcIiksZnVuY3Rpb24obil7aWYoIWUuZ2V0Um9vdEJ5SWQobi5pZCkpe3ZhciBpPWUuam9pblJvb3RWaWV3KG4sZS5nZXRIcmVmKCkpO2Uucm9vdD1lLnJvb3R8fGksbi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1tYWluXCIpJiYoZS5tYWluPWkpfXQ9ITB9KSx0fX0se2tleTpcInJlZGlyZWN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLmRpc2Nvbm5lY3QoKSxjZS5yZWRpcmVjdChlLHQpfX0se2tleTpcInJlcGxhY2VNYWluXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGwscj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106dGhpcy5zZXRQZW5kaW5nTGluayhlKSxvPXRoaXMubWFpbi5lbDt0aGlzLm1haW4uc2hvd0xvYWRlcih0aGlzLmxvYWRlclRpbWVvdXQpLHRoaXMubWFpbi5kZXN0cm95KCksY2UuZmV0Y2hQYWdlKGUsZnVuY3Rpb24oYSx1KXtpZigyMDAhPT1hKXJldHVybiBuLnJlZGlyZWN0KGUpO3ZhciBzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtzLmlubmVySFRNTD11O3ZhciBjPXMuY29udGVudC5jaGlsZE5vZGVzWzBdO2lmKCFjfHwhbi5pc1BoeFZpZXcoYykpcmV0dXJuIG4ucmVkaXJlY3QoZSk7bi5qb2luUm9vdFZpZXcoYyxlLHQsZnVuY3Rpb24oZSx0KXsxPT09dCYmKG4uY29tbWl0UGVuZGluZ0xpbmsocik/KG8ucmVwbGFjZVdpdGgoZS5lbCksbi5tYWluPWUsaSYmaSgpKTplLmRlc3Ryb3koKSl9KX0pfX0se2tleTpcImlzUGh4Vmlld1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZSYmbnVsbCE9PWUuZ2V0QXR0cmlidXRlKE8pfX0se2tleTpcImpvaW5Sb290Vmlld1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGkpe3ZhciByPW5ldyBmZShlLHRoaXMsbnVsbCx0LG4pO3JldHVybiB0aGlzLnJvb3RzW3IuaWRdPXIsci5qb2luKGkpLHJ9fSx7a2V5Olwib3duZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMsaT1aKGUuY2xvc2VzdChVKSxmdW5jdGlvbihlKXtyZXR1cm4gbi5nZXRWaWV3QnlFbChlKX0pO2kmJnQoaSl9fSx7a2V5Olwid2l0aGluT3duZXJzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3RoaXMub3duZXIoZSxmdW5jdGlvbihpKXt2YXIgcj1lLmdldEF0dHJpYnV0ZShuLmJpbmRpbmcoXCJ0YXJnZXRcIikpO251bGw9PT1yP3QoaSxlKTppLndpdGhpblRhcmdldHMocix0KX0pfX0se2tleTpcImdldFZpZXdCeUVsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yb290LWlkXCIpO3JldHVybiBaKHRoaXMuZ2V0Um9vdEJ5SWQodCksZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0RGVzY2VuZGVudEJ5RWwoZSl9KX19LHtrZXk6XCJnZXRSb290QnlJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJvb3RzW2VdfX0se2tleTpcImRlc3Ryb3lBbGxWaWV3c1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMucm9vdHMpdGhpcy5yb290c1tlXS5kZXN0cm95KCksZGVsZXRlIHRoaXMucm9vdHNbZV19fSx7a2V5OlwiZGVzdHJveVZpZXdCeUVsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRSb290QnlJZChlLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXJvb3QtaWRcIikpO3QmJnQuZGVzdHJveURlc2NlbmRlbnQoZS5pZCl9fSx7a2V5Olwic2V0QWN0aXZlRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYodGhpcy5hY3RpdmVFbGVtZW50IT09ZSl7dGhpcy5hY3RpdmVFbGVtZW50PWU7dmFyIG49ZnVuY3Rpb24oKXtlPT09dC5hY3RpdmVFbGVtZW50JiYodC5hY3RpdmVFbGVtZW50PW51bGwpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0KSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHQpfTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsbiksZS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIixuKX19fSx7a2V5OlwiZ2V0QWN0aXZlRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ9PT1kb2N1bWVudC5ib2R5P3RoaXMuYWN0aXZlRWxlbWVudHx8ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDpkb2N1bWVudC5hY3RpdmVFbGVtZW50fHxkb2N1bWVudC5ib2R5fX0se2tleTpcImRyb3BBY3RpdmVFbGVtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wcmV2QWN0aXZlJiZlLm93bnNFbGVtZW50KHRoaXMucHJldkFjdGl2ZSkmJih0aGlzLnByZXZBY3RpdmU9bnVsbCl9fSx7a2V5OlwicmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcmV2QWN0aXZlJiZ0aGlzLnByZXZBY3RpdmUhPT1kb2N1bWVudC5ib2R5JiZ0aGlzLnByZXZBY3RpdmUuZm9jdXMoKX19LHtrZXk6XCJibHVyQWN0aXZlRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcmV2QWN0aXZlPXRoaXMuZ2V0QWN0aXZlRWxlbWVudCgpLHRoaXMucHJldkFjdGl2ZSE9PWRvY3VtZW50LmJvZHkmJnRoaXMucHJldkFjdGl2ZS5ibHVyKCl9fSx7a2V5OlwiYmluZFRvcExldmVsRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuYm91bmRUb3BMZXZlbEV2ZW50c3x8KHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cz0hMCxkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKCl7fSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLGZ1bmN0aW9uKHQpe3QucGVyc2lzdGVkJiYoZS53aXRoUGFnZUxvYWRpbmcoe3RvOndpbmRvdy5sb2NhdGlvbi5ocmVmLGtpbmQ6XCJyZWRpcmVjdFwifSksd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpKX0pLHRoaXMuYmluZENsaWNrcygpLHRoaXMuYmluZE5hdigpLHRoaXMuYmluZEZvcm1zKCksdGhpcy5iaW5kKHtrZXl1cDpcImtleXVwXCIsa2V5ZG93bjpcImtleWRvd25cIn0sZnVuY3Rpb24odCxuLGkscixvLGEsdSl7dmFyIHM9ci5nZXRBdHRyaWJ1dGUoZS5iaW5kaW5nKFwia2V5XCIpKSxjPXQua2V5JiZ0LmtleS50b0xvd2VyQ2FzZSgpO3MmJnMudG9Mb3dlckNhc2UoKSE9PWN8fGkucHVzaEtleShyLG8sbixhLGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBuPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP3coT2JqZWN0KG4pLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe0UoZSx0LG5bdF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSk6dyhPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCkpfSl9cmV0dXJuIGV9KHtrZXk6dC5rZXl9LGUuZXZlbnRNZXRhKG4sdCxyKSkpfSksdGhpcy5iaW5kKHtibHVyOlwiZm9jdXNvdXRcIixmb2N1czpcImZvY3VzaW5cIn0sZnVuY3Rpb24odCxuLGkscixvLGEsdSl7dXx8aS5wdXNoRXZlbnQobixyLG8sYSxlLmV2ZW50TWV0YShuLHQscikpfSksdGhpcy5iaW5kKHtibHVyOlwiYmx1clwiLGZvY3VzOlwiZm9jdXNcIn0sZnVuY3Rpb24odCxuLGkscixvLGEsdSl7dSYmXCJ3aW5kb3dcIiE9PSF1JiZpLnB1c2hFdmVudChuLHIsbyxhLGUuZXZlbnRNZXRhKG4sdCxyKSl9KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsZnVuY3Rpb24oZSl7cmV0dXJuIGUucHJldmVudERlZmF1bHQoKX0pLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKTt2YXIgbj1aKEcodC50YXJnZXQsZS5iaW5kaW5nKFwiZHJvcC10YXJnZXRcIikpLGZ1bmN0aW9uKHQpe3JldHVybiB0LmdldEF0dHJpYnV0ZShlLmJpbmRpbmcoXCJkcm9wLXRhcmdldFwiKSl9KSxpPW4mJmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG4pLHI9QXJyYXkuZnJvbSh0LmRhdGFUcmFuc2Zlci5maWxlc3x8W10pO2kmJiFpLmRpc2FibGVkJiYwIT09ci5sZW5ndGgmJmkuZmlsZXMgaW5zdGFuY2VvZiBGaWxlTGlzdCYmKGllLnRyYWNrRmlsZXMoaSxyKSxpLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIix7YnViYmxlczohMH0pKSl9KSl9fSx7a2V5OlwiZXZlbnRNZXRhXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXMubWV0YWRhdGFDYWxsYmFja3NbZV07cmV0dXJuIGk/aSh0LG4pOnt9fX0se2tleTpcInNldFBlbmRpbmdMaW5rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGlua1JlZisrLHRoaXMucGVuZGluZ0xpbms9ZSx0aGlzLmxpbmtSZWZ9fSx7a2V5OlwiY29tbWl0UGVuZGluZ0xpbmtcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5saW5rUmVmPT09ZSYmKHRoaXMuaHJlZj10aGlzLnBlbmRpbmdMaW5rLHRoaXMucGVuZGluZ0xpbms9bnVsbCwhMCl9fSx7a2V5OlwiZ2V0SHJlZlwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaHJlZn19LHtrZXk6XCJoYXNQZW5kaW5nTGlua1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLnBlbmRpbmdMaW5rfX0se2tleTpcImJpbmRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMsaT1mdW5jdGlvbihpKXt2YXIgcj1lW2ldO24ub24ocixmdW5jdGlvbihlKXt2YXIgcj1uLmJpbmRpbmcoaSksbz1uLmJpbmRpbmcoXCJ3aW5kb3ctXCIuY29uY2F0KGkpKSxhPWUudGFyZ2V0LmdldEF0dHJpYnV0ZSYmZS50YXJnZXQuZ2V0QXR0cmlidXRlKHIpO2E/bi5kZWJvdW5jZShlLnRhcmdldCxlLGZ1bmN0aW9uKCl7bi53aXRoaW5Pd25lcnMoZS50YXJnZXQsZnVuY3Rpb24obixyKXt0KGUsaSxuLGUudGFyZ2V0LHIsYSxudWxsKX0pfSk6bGUuYWxsKGRvY3VtZW50LFwiW1wiLmNvbmNhdChvLFwiXVwiKSxmdW5jdGlvbihyKXt2YXIgYT1yLmdldEF0dHJpYnV0ZShvKTtuLmRlYm91bmNlKHIsZSxmdW5jdGlvbigpe24ud2l0aGluT3duZXJzKHIsZnVuY3Rpb24obixvKXt0KGUsaSxuLHIsbyxhLFwid2luZG93XCIpfSl9KX0pfSl9O2Zvcih2YXIgciBpbiBlKWkocil9fSx7a2V5OlwiYmluZENsaWNrc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5iaW5kQ2xpY2soXCJjbGlja1wiLFwiY2xpY2tcIiwhMSksdGhpcy5iaW5kQ2xpY2soXCJtb3VzZWRvd25cIixcImNhcHR1cmUtY2xpY2tcIiwhMCl9fSx7a2V5OlwiYmluZENsaWNrXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXMscj10aGlzLmJpbmRpbmcodCk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZSxmdW5jdGlvbihlKXtpZihpLmlzQ29ubmVjdGVkKCkpe3ZhciB0PW51bGwsbz0odD1uP2UudGFyZ2V0Lm1hdGNoZXMoXCJbXCIuY29uY2F0KHIsXCJdXCIpKT9lLnRhcmdldDplLnRhcmdldC5xdWVyeVNlbGVjdG9yKFwiW1wiLmNvbmNhdChyLFwiXVwiKSk6RyhlLnRhcmdldCxyKSkmJnQuZ2V0QXR0cmlidXRlKHIpO28mJihcIiNcIj09PXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSYmZS5wcmV2ZW50RGVmYXVsdCgpLGkuZGVib3VuY2UodCxlLGZ1bmN0aW9uKCl7aS53aXRoaW5Pd25lcnModCxmdW5jdGlvbihuLHIpe24ucHVzaEV2ZW50KFwiY2xpY2tcIix0LHIsbyxpLmV2ZW50TWV0YShcImNsaWNrXCIsZSx0KSl9KX0pKX19LG4pfX0se2tleTpcImJpbmROYXZcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoY2UuY2FuUHVzaFN0YXRlKCkpe2hpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24mJihoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uPVwibWFudWFsXCIpO3ZhciB0PW51bGw7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixmdW5jdGlvbihlKXtjbGVhclRpbWVvdXQodCksdD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Y2UudXBkYXRlQ3VycmVudFN0YXRlKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuYXNzaWduKGUse3Njcm9sbDp3aW5kb3cuc2Nyb2xsWX0pfSl9LDEwMCl9KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsZnVuY3Rpb24odCl7aWYoZS5yZWdpc3Rlck5ld0xvY2F0aW9uKHdpbmRvdy5sb2NhdGlvbikpe3ZhciBuPXQuc3RhdGV8fHt9LGk9bi50eXBlLHI9bi5pZCxvPW4ucm9vdCxhPW4uc2Nyb2xsLHU9d2luZG93LmxvY2F0aW9uLmhyZWY7ZS5tYWluLmlzQ29ubmVjdGVkKCkmJlwicGF0Y2hcIj09PWkmJnI9PT1lLm1haW4uaWQ/ZS5tYWluLnB1c2hMaW5rUGF0Y2godSxudWxsKTplLnJlcGxhY2VNYWluKHUsbnVsbCxmdW5jdGlvbigpe28mJmUucmVwbGFjZVJvb3RIaXN0b3J5KCksXCJudW1iZXJcIj09dHlwZW9mIGEmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXt3aW5kb3cuc2Nyb2xsVG8oMCxhKX0sMCl9KX19LCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24odCl7dmFyIG49Ryh0LnRhcmdldCxcImRhdGEtcGh4LWxpbmtcIiksaT1uJiZuLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWxpbmtcIikscj10Lm1ldGFLZXl8fHQuY3RybEtleXx8MT09PXQuYnV0dG9uO2lmKGkmJmUuaXNDb25uZWN0ZWQoKSYmZS5tYWluJiYhcil7dmFyIG89bi5ocmVmLGE9bi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1saW5rLXN0YXRlXCIpO2lmKHQucHJldmVudERlZmF1bHQoKSxlLnBlbmRpbmdMaW5rIT09bylpZihcInBhdGNoXCI9PT1pKWUucHVzaEhpc3RvcnlQYXRjaChvLGEsbik7ZWxzZXtpZihcInJlZGlyZWN0XCIhPT1pKXRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIFwiLmNvbmNhdChcImRhdGEtcGh4LWxpbmtcIiwnIHRvIGJlIFwicGF0Y2hcIiBvciBcInJlZGlyZWN0XCIsIGdvdDogJykuY29uY2F0KGkpKTtlLmhpc3RvcnlSZWRpcmVjdChvLGEpfX19LCExKX19fSx7a2V5Olwid2l0aFBhZ2VMb2FkaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtsZS5kaXNwYXRjaEV2ZW50KHdpbmRvdyxcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIixlKTt2YXIgbj1mdW5jdGlvbigpe3JldHVybiBsZS5kaXNwYXRjaEV2ZW50KHdpbmRvdyxcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLGUpfTtyZXR1cm4gdD90KG4pOm59fSx7a2V5OlwicHVzaEhpc3RvcnlQYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzO3RoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzplLGtpbmQ6XCJwYXRjaFwifSxmdW5jdGlvbihyKXtpLm1haW4ucHVzaExpbmtQYXRjaChlLG4sZnVuY3Rpb24oKXtpLmhpc3RvcnlQYXRjaChlLHQpLHIoKX0pfSl9fSx7a2V5OlwiaGlzdG9yeVBhdGNoXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtjZS5wdXNoU3RhdGUodCx7dHlwZTpcInBhdGNoXCIsaWQ6dGhpcy5tYWluLmlkfSxlKSx0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKX19LHtrZXk6XCJoaXN0b3J5UmVkaXJlY3RcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcyxyPXdpbmRvdy5zY3JvbGxZO3RoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzplLGtpbmQ6XCJyZWRpcmVjdFwifSxmdW5jdGlvbihvKXtpLnJlcGxhY2VNYWluKGUsbixmdW5jdGlvbigpe2NlLnB1c2hTdGF0ZSh0LHt0eXBlOlwicmVkaXJlY3RcIixpZDppLm1haW4uaWQsc2Nyb2xsOnJ9LGUpLGkucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pLG8oKX0pfSl9fSx7a2V5OlwicmVwbGFjZVJvb3RIaXN0b3J5XCIsdmFsdWU6ZnVuY3Rpb24oKXtjZS5wdXNoU3RhdGUoXCJyZXBsYWNlXCIse3Jvb3Q6ITAsdHlwZTpcInBhdGNoXCIsaWQ6dGhpcy5tYWluLmlkfSl9fSx7a2V5OlwicmVnaXN0ZXJOZXdMb2NhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuY3VycmVudExvY2F0aW9uO3JldHVybiB0LnBhdGhuYW1lK3Quc2VhcmNoIT09ZS5wYXRobmFtZStlLnNlYXJjaCYmKHRoaXMuY3VycmVudExvY2F0aW9uPSQoZSksITApfX0se2tleTpcImJpbmRGb3Jtc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PTA7dGhpcy5vbihcInN1Ym1pdFwiLGZ1bmN0aW9uKHQpe3ZhciBuPXQudGFyZ2V0LmdldEF0dHJpYnV0ZShlLmJpbmRpbmcoXCJzdWJtaXRcIikpO24mJih0LnByZXZlbnREZWZhdWx0KCksdC50YXJnZXQuZGlzYWJsZWQ9ITAsZS53aXRoaW5Pd25lcnModC50YXJnZXQsZnVuY3Rpb24oZSxpKXtyZXR1cm4gZS5zdWJtaXRGb3JtKHQudGFyZ2V0LGksbil9KSl9LCExKTtmb3IodmFyIG49ZnVuY3Rpb24oKXt2YXIgbj1yW2ldO2Uub24obixmdW5jdGlvbihpKXt2YXIgcj1pLnRhcmdldCxvPXIuZm9ybSYmci5mb3JtLmdldEF0dHJpYnV0ZShlLmJpbmRpbmcoXCJjaGFuZ2VcIikpO2lmKG8mJihcIm51bWJlclwiIT09ci50eXBlfHwhci52YWxpZGl0eXx8IXIudmFsaWRpdHkuYmFkSW5wdXQpKXt2YXIgYT10O3QrKzt2YXIgdT1sZS5wcml2YXRlKHIsXCJwcmV2LWl0ZXJhdGlvblwiKXx8e30scz11LmF0LGM9dS50eXBlO3M9PT1hLTEmJm4hPT1jfHwobGUucHV0UHJpdmF0ZShyLFwicHJldi1pdGVyYXRpb25cIix7YXQ6YSx0eXBlOm59KSxlLmRlYm91bmNlKHIsaSxmdW5jdGlvbigpe2Uud2l0aGluT3duZXJzKHIuZm9ybSxmdW5jdGlvbih0LG4pe2xlLnB1dFByaXZhdGUocixcInBoeC1oYXMtZm9jdXNlZFwiLCEwKSxsZS5pc1RleHR1YWxJbnB1dChyKXx8ZS5zZXRBY3RpdmVFbGVtZW50KHIpLHQucHVzaElucHV0KHIsbixvLGkudGFyZ2V0KX0pfSkpfX0sITEpfSxpPTAscj1bXCJjaGFuZ2VcIixcImlucHV0XCJdO2k8ci5sZW5ndGg7aSsrKW4oKX19LHtrZXk6XCJkZWJvdW5jZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzLmJpbmRpbmcoXCJkZWJvdW5jZVwiKSxyPXRoaXMuYmluZGluZyhcInRocm90dGxlXCIpLG89dGhpcy5kZWZhdWx0cy5kZWJvdW5jZS50b1N0cmluZygpLGE9dGhpcy5kZWZhdWx0cy50aHJvdHRsZS50b1N0cmluZygpO2xlLmRlYm91bmNlKGUsdCxpLG8scixhLG4pfX0se2tleTpcInNpbGVuY2VFdmVudHNcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnNpbGVuY2VkPSEwLGUoKSx0aGlzLnNpbGVuY2VkPSExfX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKGUsZnVuY3Rpb24oZSl7bi5zaWxlbmNlZHx8dChlKX0pfX1dKSxlfSgpLGNlPXtjYW5QdXNoU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09aGlzdG9yeS5wdXNoU3RhdGV9LGRyb3BMb2NhbDpmdW5jdGlvbihlLHQpe3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5sb2NhbEtleShlLHQpKX0sdXBkYXRlTG9jYWw6ZnVuY3Rpb24oZSx0LG4saSl7dmFyIHI9dGhpcy5nZXRMb2NhbChlLHQpLG89dGhpcy5sb2NhbEtleShlLHQpLGE9bnVsbD09PXI/bjppKHIpO3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0obyxKU09OLnN0cmluZ2lmeShhKSksYX0sZ2V0TG9jYWw6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gSlNPTi5wYXJzZSh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5sb2NhbEtleShlLHQpKSl9LGZldGNoUGFnZTpmdW5jdGlvbihlLHQpe3ZhciBuPW5ldyBYTUxIdHRwUmVxdWVzdDtuLm9wZW4oXCJHRVRcIixlLCEwKSxuLnRpbWVvdXQ9M2U0LG4uc2V0UmVxdWVzdEhlYWRlcihcImNvbnRlbnQtdHlwZVwiLFwidGV4dC9odG1sXCIpLG4uc2V0UmVxdWVzdEhlYWRlcihcImNhY2hlLWNvbnRyb2xcIixcIm1heC1hZ2U9MCwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtdXN0LXJldmFsaWRhdGUsIHBvc3QtY2hlY2s9MCwgcHJlLWNoZWNrPTBcIiksbi5zZXRSZXF1ZXN0SGVhZGVyKFwieC1yZXF1ZXN0ZWQtd2l0aFwiLFwibGl2ZS1saW5rXCIpLG4ub25lcnJvcj1mdW5jdGlvbigpe3JldHVybiB0KDQwMCl9LG4ub250aW1lb3V0PWZ1bmN0aW9uKCl7cmV0dXJuIHQoNTA0KX0sbi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZig0PT09bi5yZWFkeVN0YXRlKXt2YXIgaT1uZXcgVVJMKGUpLHI9aS5wYXRobmFtZStpLnNlYXJjaCxvPVoobi5nZXRSZXNwb25zZUhlYWRlcihcIngtcmVzcG9uc2UtdXJsXCIpfHxuLnJlc3BvbnNlVVJMLGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgVVJMKGUpfSksYT1vP28ucGF0aG5hbWUrby5zZWFyY2g6bnVsbDtyZXR1cm5cImxpdmUtbGlua1wiIT09bi5nZXRSZXNwb25zZUhlYWRlcihcIngtcmVxdWVzdGVkLXdpdGhcIik/dCg0MDApOm51bGw9PT1vfHxhIT1yP3QoMzAyKToyMDAhPT1uLnN0YXR1cz90KG4uc3RhdHVzKTp2b2lkIHQoMjAwLG4ucmVzcG9uc2VUZXh0KX19LG4uc2VuZCgpfSx1cGRhdGVDdXJyZW50U3RhdGU6ZnVuY3Rpb24oZSl7dGhpcy5jYW5QdXNoU3RhdGUoKSYmaGlzdG9yeS5yZXBsYWNlU3RhdGUoZShoaXN0b3J5LnN0YXRlfHx7fSksXCJcIix3aW5kb3cubG9jYXRpb24uaHJlZil9LHB1c2hTdGF0ZTpmdW5jdGlvbihlLHQsbil7aWYodGhpcy5jYW5QdXNoU3RhdGUoKSl7aWYobiE9PXdpbmRvdy5sb2NhdGlvbi5ocmVmKXtpZihcInJlZGlyZWN0XCI9PXQudHlwZSYmdC5zY3JvbGwpe3ZhciBpPWhpc3Rvcnkuc3RhdGV8fHt9O2kuc2Nyb2xsPXQuc2Nyb2xsLGhpc3RvcnkucmVwbGFjZVN0YXRlKGksXCJcIix3aW5kb3cubG9jYXRpb24uaHJlZil9ZGVsZXRlIHQuc2Nyb2xsLGhpc3RvcnlbZStcIlN0YXRlXCJdKHQsXCJcIixufHxudWxsKTt2YXIgcj10aGlzLmdldEhhc2hUYXJnZXRFbCh3aW5kb3cubG9jYXRpb24uaGFzaCk7cj9yLnNjcm9sbEludG9WaWV3KCk6XCJyZWRpcmVjdFwiPT09dC50eXBlJiZ3aW5kb3cuc2Nyb2xsKDAsMCl9fWVsc2UgdGhpcy5yZWRpcmVjdChuKX0sc2V0Q29va2llOmZ1bmN0aW9uKGUsdCl7ZG9jdW1lbnQuY29va2llPVwiXCIuY29uY2F0KGUsXCI9XCIpLmNvbmNhdCh0KX0sZ2V0Q29va2llOmZ1bmN0aW9uKGUpe3JldHVybiBkb2N1bWVudC5jb29raWUucmVwbGFjZShuZXcgUmVnRXhwKFwiKD86KD86XnwuKjtzKilcIi5jb25jYXQoZSxcInMqPXMqKFteO10qKS4qJCl8Xi4qJFwiKSksXCIkMVwiKX0scmVkaXJlY3Q6ZnVuY3Rpb24oZSx0KXt0JiZjZS5zZXRDb29raWUoXCJfX3Bob2VuaXhfZmxhc2hfX1wiLHQrXCI7IG1heC1hZ2U9NjAwMDA7IHBhdGg9L1wiKSx3aW5kb3cubG9jYXRpb249ZX0sbG9jYWxLZXk6ZnVuY3Rpb24oZSx0KXtyZXR1cm5cIlwiLmNvbmNhdChlLFwiLVwiKS5jb25jYXQodCl9LGdldEhhc2hUYXJnZXRFbDpmdW5jdGlvbihlKXt2YXIgdD1lLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpO2lmKFwiXCIhPT10KXJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0KXx8ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYVtuYW1lPVwiJy5jb25jYXQodCwnXCJdJykpfX0sbGU9e2J5SWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpfHx6KFwibm8gaWQgZm91bmQgZm9yIFwiLmNvbmNhdChlKSl9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGUsdCl7ZS5jbGFzc0xpc3QucmVtb3ZlKHQpLDA9PT1lLmNsYXNzTGlzdC5sZW5ndGgmJmUucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIil9LGFsbDpmdW5jdGlvbihlLHQsbil7dmFyIGk9QXJyYXkuZnJvbShlLnF1ZXJ5U2VsZWN0b3JBbGwodCkpO3JldHVybiBuP2kuZm9yRWFjaChuKTppfSxjaGlsZE5vZGVMZW5ndGg6ZnVuY3Rpb24oZSl7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO3JldHVybiB0LmlubmVySFRNTD1lLHQuY29udGVudC5jaGlsZEVsZW1lbnRDb3VudH0saXNVcGxvYWRJbnB1dDpmdW5jdGlvbihlKXtyZXR1cm5cImZpbGVcIj09PWUudHlwZSYmbnVsbCE9PWUuZ2V0QXR0cmlidXRlKE0pfSxmaW5kVXBsb2FkSW5wdXRzOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmFsbChlLCdpbnB1dFt0eXBlPVwiZmlsZVwiXVsnLmNvbmNhdChNLFwiXVwiKSl9LGZpbmRDb21wb25lbnROb2RlTGlzdDpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChlLFwiW1wiLmNvbmNhdChILCc9XCInKS5jb25jYXQodCwnXCJdJykpLGUpfSxpc1BoeERlc3Ryb3llZDpmdW5jdGlvbihlKXtyZXR1cm4hKCFlLmlkfHwhbGUucHJpdmF0ZShlLFwiZGVzdHJveWVkXCIpKX0sbWFya1BoeENoaWxkRGVzdHJveWVkOmZ1bmN0aW9uKGUpe2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1waHgtc2Vzc2lvblwiLFwiXCIpLHRoaXMucHV0UHJpdmF0ZShlLFwiZGVzdHJveWVkXCIsITApfSxmaW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50OmZ1bmN0aW9uKGUsdCl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO3JldHVybiBuLmlubmVySFRNTD1lLHRoaXMuZmluZFBoeENoaWxkcmVuKG4uY29udGVudCx0KX0saXNJZ25vcmVkOmZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJpZ25vcmVcIj09PShlLmdldEF0dHJpYnV0ZSh0KXx8ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC11cGRhdGVcIikpfSxpc1BoeFVwZGF0ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZuLmluZGV4T2YoZS5nZXRBdHRyaWJ1dGUodCkpPj0wfSxmaW5kUGh4Q2hpbGRyZW46ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hbGwoZSxcIlwiLmNvbmNhdChVLFwiW1wiKS5jb25jYXQoXCJkYXRhLXBoeC1wYXJlbnQtaWRcIiwnPVwiJykuY29uY2F0KHQsJ1wiXScpKX0sZmluZFBhcmVudENJRHM6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLGk9bmV3IFNldCh0KTtyZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24odCxpKXt2YXIgcj1cIltcIi5jb25jYXQoSCwnPVwiJykuY29uY2F0KGksJ1wiXSBbJykuY29uY2F0KEgsXCJdXCIpO3JldHVybiBuLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyhuLmFsbChlLHIpLGUpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZS5nZXRBdHRyaWJ1dGUoSCkpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5kZWxldGUoZSl9KSx0fSxpKX0sZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3OmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdC5xdWVyeVNlbGVjdG9yKFUpP2UuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBuLndpdGhpblNhbWVMaXZlVmlldyhlLHQpfSk6ZX0sd2l0aGluU2FtZUxpdmVWaWV3OmZ1bmN0aW9uKGUsdCl7Zm9yKDtlPWUucGFyZW50Tm9kZTspe2lmKGUuaXNTYW1lTm9kZSh0KSlyZXR1cm4hMDtpZihlLmdldEF0dHJpYnV0ZShPKSlyZXR1cm4hMX19LHByaXZhdGU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5waHhQcml2YXRlJiZlLnBoeFByaXZhdGVbdF19LGRlbGV0ZVByaXZhdGU6ZnVuY3Rpb24oZSx0KXtlLnBoeFByaXZhdGUmJmRlbGV0ZSBlLnBoeFByaXZhdGVbdF19LHB1dFByaXZhdGU6ZnVuY3Rpb24oZSx0LG4pe2UucGh4UHJpdmF0ZXx8KGUucGh4UHJpdmF0ZT17fSksZS5waHhQcml2YXRlW3RdPW59LGNvcHlQcml2YXRlczpmdW5jdGlvbihlLHQpe3QucGh4UHJpdmF0ZSYmKGUucGh4UHJpdmF0ZT0kKHQucGh4UHJpdmF0ZSkpfSxwdXRUaXRsZTpmdW5jdGlvbihlKXt2YXIgdD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGl0bGVcIikuZGF0YXNldCxuPXQucHJlZml4LGk9dC5zdWZmaXg7ZG9jdW1lbnQudGl0bGU9XCJcIi5jb25jYXQobnx8XCJcIikuY29uY2F0KGUpLmNvbmNhdChpfHxcIlwiKX0sZGVib3VuY2U6ZnVuY3Rpb24oZSx0LG4saSxyLG8sYSl7dmFyIHU9dGhpcyxzPWUuZ2V0QXR0cmlidXRlKG4pLGM9ZS5nZXRBdHRyaWJ1dGUocik7XCJcIj09PXMmJihzPWkpLFwiXCI9PT1jJiYoYz1vKTt2YXIgbD1zfHxjO3N3aXRjaChsKXtjYXNlIG51bGw6cmV0dXJuIGEoKTtjYXNlXCJibHVyXCI6cmV0dXJuIHZvaWQodGhpcy5vbmNlKGUsXCJkZWJvdW5jZS1ibHVyXCIpJiZlLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsZnVuY3Rpb24oKXtyZXR1cm4gYSgpfSkpO2RlZmF1bHQ6dmFyIGQ9cGFyc2VJbnQobCksaD10aGlzLmluY0N5Y2xlKGUsXCJkZWJvdW5jZS10cmlnZ2VyXCIsZnVuY3Rpb24oKXtyZXR1cm4gYz91LmRlbGV0ZVByaXZhdGUoZSxcInRocm90dGxlZFwiKTphKCl9KTtpZihpc05hTihkKSlyZXR1cm4geihcImludmFsaWQgdGhyb3R0bGUvZGVib3VuY2UgdmFsdWU6IFwiLmNvbmNhdChsKSk7aWYoYyl7dmFyIGY9ITE7aWYoXCJrZXlkb3duXCI9PT10LnR5cGUpe3ZhciB2PXRoaXMucHJpdmF0ZShlLFwiZGVib3VuY2UtcHJldi1rZXlcIik7dGhpcy5wdXRQcml2YXRlKGUsXCJkZWJvdW5jZS1wcmV2LWtleVwiLHQua2V5KSxmPXYhPT10LmtleX1pZighZiYmdGhpcy5wcml2YXRlKGUsXCJ0aHJvdHRsZWRcIikpcmV0dXJuITE7YSgpLHRoaXMucHV0UHJpdmF0ZShlLFwidGhyb3R0bGVkXCIsITApLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gdS50cmlnZ2VyQ3ljbGUoZSxcImRlYm91bmNlLXRyaWdnZXJcIil9LGQpfWVsc2Ugc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiB1LnRyaWdnZXJDeWNsZShlLFwiZGVib3VuY2UtdHJpZ2dlclwiLGgpfSxkKTtlLmZvcm0mJnRoaXMub25jZShlLmZvcm0sXCJiaW5kLWRlYm91bmNlXCIpJiZlLmZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLGZ1bmN0aW9uKHQpe0FycmF5LmZyb20obmV3IEZvcm1EYXRhKGUuZm9ybSkuZW50cmllcygpLGZ1bmN0aW9uKHQpe3ZhciBuPXgodCwyKSxpPW5bMF0scj0oblsxXSxlLmZvcm0ucXVlcnlTZWxlY3RvcignW25hbWU9XCInLmNvbmNhdChpLCdcIl0nKSkpO3UuaW5jQ3ljbGUocixcImRlYm91bmNlLXRyaWdnZXJcIiksdS5kZWxldGVQcml2YXRlKHIsXCJ0aHJvdHRsZWRcIil9KX0pLHRoaXMub25jZShlLFwiYmluZC1kZWJvdW5jZVwiKSYmZS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLGZ1bmN0aW9uKHQpe3JldHVybiB1LnRyaWdnZXJDeWNsZShlLFwiZGVib3VuY2UtdHJpZ2dlclwiKX0pfX0sdHJpZ2dlckN5Y2xlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT14KHRoaXMucHJpdmF0ZShlLHQpLDIpLHI9aVswXSxvPWlbMV07bnx8KG49ciksbj09PXImJih0aGlzLmluY0N5Y2xlKGUsdCksbygpKX0sb25jZTpmdW5jdGlvbihlLHQpe3JldHVybiEwIT09dGhpcy5wcml2YXRlKGUsdCkmJih0aGlzLnB1dFByaXZhdGUoZSx0LCEwKSwhMCl9LGluY0N5Y2xlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOmZ1bmN0aW9uKCl7fSxpPXgodGhpcy5wcml2YXRlKGUsdCl8fFswLG5dLDIpLHI9aVswXTtpWzFdO3JldHVybiByKyssdGhpcy5wdXRQcml2YXRlKGUsdCxbcixuXSkscn0sZGlzY2FyZEVycm9yOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10LmdldEF0dHJpYnV0ZSYmdC5nZXRBdHRyaWJ1dGUobikscj1pJiZlLnF1ZXJ5U2VsZWN0b3IoJ1tpZD1cIicuY29uY2F0KGksJ1wiXSwgW25hbWU9XCInKS5jb25jYXQoaSwnXCJdJykpO3ImJih0aGlzLnByaXZhdGUocixcInBoeC1oYXMtZm9jdXNlZFwiKXx8dGhpcy5wcml2YXRlKHIuZm9ybSxcInBoeC1oYXMtc3VibWl0dGVkXCIpfHx0LmNsYXNzTGlzdC5hZGQoXCJwaHgtbm8tZmVlZGJhY2tcIikpfSxzaG93RXJyb3I6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzOyhlLmlkfHxlLm5hbWUpJiZ0aGlzLmFsbChlLmZvcm0sXCJbXCIuY29uY2F0KHQsJz1cIicpLmNvbmNhdChlLmlkLCdcIl0sIFsnKS5jb25jYXQodCwnPVwiJykuY29uY2F0KGUubmFtZSwnXCJdJyksZnVuY3Rpb24oZSl7bi5yZW1vdmVDbGFzcyhlLFwicGh4LW5vLWZlZWRiYWNrXCIpfSl9LGlzUGh4Q2hpbGQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZlLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXBhcmVudC1pZFwiKX0sZGlzcGF0Y2hFdmVudDpmdW5jdGlvbihlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fSxpPW5ldyBDdXN0b21FdmVudCh0LHtidWJibGVzOiEwLGNhbmNlbGFibGU6ITAsZGV0YWlsOm59KTtlLmRpc3BhdGNoRXZlbnQoaSl9LGNsb25lTm9kZTpmdW5jdGlvbihlLHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIGUuY2xvbmVOb2RlKCEwKTt2YXIgbj1lLmNsb25lTm9kZSghMSk7cmV0dXJuIG4uaW5uZXJIVE1MPXQsbn0sbWVyZ2VBdHRyczpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30saT1uLmV4Y2x1ZGV8fFtdLHI9bi5pc0lnbm9yZWQsbz10LmF0dHJpYnV0ZXMsYT1vLmxlbmd0aC0xO2E+PTA7YS0tKXt2YXIgdT1vW2FdLm5hbWU7aS5pbmRleE9mKHUpPDAmJmUuc2V0QXR0cmlidXRlKHUsdC5nZXRBdHRyaWJ1dGUodSkpfWZvcih2YXIgcz1lLmF0dHJpYnV0ZXMsYz1zLmxlbmd0aC0xO2M+PTA7Yy0tKXt2YXIgbD1zW2NdLm5hbWU7cj9sLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSYmIXQuaGFzQXR0cmlidXRlKGwpJiZlLnJlbW92ZUF0dHJpYnV0ZShsKTp0Lmhhc0F0dHJpYnV0ZShsKXx8ZS5yZW1vdmVBdHRyaWJ1dGUobCl9fSxtZXJnZUZvY3VzZWRJbnB1dDpmdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudHx8bGUubWVyZ2VBdHRycyhlLHQse2V4Y2VwdDpbXCJ2YWx1ZVwiXX0pLHQucmVhZE9ubHk/ZS5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCEwKTplLnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpfSxoYXNTZWxlY3Rpb25SYW5nZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5zZXRTZWxlY3Rpb25SYW5nZSYmKFwidGV4dFwiPT09ZS50eXBlfHxcInRleHRhcmVhXCI9PT1lLnR5cGUpfSxyZXN0b3JlRm9jdXM6ZnVuY3Rpb24oZSx0LG4pe2lmKGxlLmlzVGV4dHVhbElucHV0KGUpKXt2YXIgaT1lLm1hdGNoZXMoXCI6Zm9jdXNcIik7ZS5yZWFkT25seSYmZS5ibHVyKCksaXx8ZS5mb2N1cygpLHRoaXMuaGFzU2VsZWN0aW9uUmFuZ2UoZSkmJmUuc2V0U2VsZWN0aW9uUmFuZ2UodCxuKX19LGlzRm9ybUlucHV0OmZ1bmN0aW9uKGUpe3JldHVybi9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KGUudGFnTmFtZSkmJlwiYnV0dG9uXCIhPT1lLnR5cGV9LHN5bmNBdHRyc1RvUHJvcHM6ZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJkouaW5kZXhPZihlLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSk+PTAmJihlLmNoZWNrZWQ9bnVsbCE9PWUuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSl9LGlzVGV4dHVhbElucHV0OmZ1bmN0aW9uKGUpe3JldHVybiBCLmluZGV4T2YoZS50eXBlKT49MH0saXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZudWxsIT09ZS5nZXRBdHRyaWJ1dGUodCl9LHN5bmNQZW5kaW5nUmVmOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT1lLmdldEF0dHJpYnV0ZShGKTtyZXR1cm4gbnVsbD09PWl8fChsZS5pc0Zvcm1JbnB1dChlKXx8bnVsbCE9PWUuZ2V0QXR0cmlidXRlKG4pPyhsZS5pc1VwbG9hZElucHV0KGUpJiZsZS5tZXJnZUF0dHJzKGUsdCx7aXNJZ25vcmVkOiEwfSksbGUucHV0UHJpdmF0ZShlLEYsdCksITEpOihqLmZvckVhY2goZnVuY3Rpb24obil7ZS5jbGFzc0xpc3QuY29udGFpbnMobikmJnQuY2xhc3NMaXN0LmFkZChuKX0pLHQuc2V0QXR0cmlidXRlKEYsaSksITApKX0sY2xlYW5DaGlsZE5vZGVzOmZ1bmN0aW9uKGUsdCl7aWYobGUuaXNQaHhVcGRhdGUoZSx0LFtcImFwcGVuZFwiLFwicHJlcGVuZFwiXSkpe3ZhciBuPVtdO2UuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuaWR8fChlLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUmJlwiXCI9PT1lLm5vZGVWYWx1ZS50cmltKCl8fHooXCJvbmx5IEhUTUwgZWxlbWVudCB0YWdzIHdpdGggYW4gaWQgYXJlIGFsbG93ZWQgaW5zaWRlIGNvbnRhaW5lcnMgd2l0aCBwaHgtdXBkYXRlLlxcblxcblwiKydyZW1vdmluZyBpbGxlZ2FsIG5vZGU6IFwiJy5jb25jYXQoKGUub3V0ZXJIVE1MfHxlLm5vZGVWYWx1ZSkudHJpbSgpLCdcIlxcblxcbicpKSxuLnB1c2goZSkpfSksbi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlbW92ZSgpfSl9fX0sZGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixpKXtUKHRoaXMsZSk7dmFyIHI9bmV3IFNldCxvPW5ldyBTZXQoQShuLmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWR9KSksYT1bXTtBcnJheS5mcm9tKHQuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoZS5pZCYmKHIuYWRkKGUuaWQpLG8uaGFzKGUuaWQpKSl7dmFyIHQ9ZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nJiZlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQ7YS5wdXNoKHtlbGVtZW50SWQ6ZS5pZCxwcmV2aW91c0VsZW1lbnRJZDp0fSl9fSksdGhpcy5jb250YWluZXJJZD1uLmlkLHRoaXMudXBkYXRlVHlwZT1pLHRoaXMuZWxlbWVudHNUb01vZGlmeT1hLHRoaXMuZWxlbWVudElkc1RvQWRkPUEobykuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiFyLmhhcyhlKX0pfXJldHVybiBfKGUsW3trZXk6XCJwZXJmb3JtXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1sZS5ieUlkKHRoaXMuY29udGFpbmVySWQpO3RoaXMuZWxlbWVudHNUb01vZGlmeS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucHJldmlvdXNFbGVtZW50SWQ/Wihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0LnByZXZpb3VzRWxlbWVudElkKSxmdW5jdGlvbihlKXtaKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQuZWxlbWVudElkKSxmdW5jdGlvbih0KXt0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcmJnQucHJldmlvdXNFbGVtZW50U2libGluZy5pZD09ZS5pZHx8ZS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmVuZFwiLHQpfSl9KTpaKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQuZWxlbWVudElkKSxmdW5jdGlvbih0KXtudWxsPT10LnByZXZpb3VzRWxlbWVudFNpYmxpbmd8fGUuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLHQpfSl9KSxcInByZXBlbmRcIj09dGhpcy51cGRhdGVUeXBlJiZ0aGlzLmVsZW1lbnRJZHNUb0FkZC5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbih0KXtaKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQpLGZ1bmN0aW9uKHQpe3JldHVybiBlLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIix0KX0pfSl9fV0pLGV9KCksaGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixpLHIsbyl7VCh0aGlzLGUpLHRoaXMudmlldz10LHRoaXMubGl2ZVNvY2tldD10LmxpdmVTb2NrZXQsdGhpcy5jb250YWluZXI9bix0aGlzLmlkPWksdGhpcy5yb290SUQ9dC5yb290LmlkLHRoaXMuaHRtbD1yLHRoaXMudGFyZ2V0Q0lEPW8sdGhpcy5jaWRQYXRjaD1cIm51bWJlclwiPT10eXBlb2YgdGhpcy50YXJnZXRDSUQsdGhpcy5jYWxsYmFja3M9e2JlZm9yZWFkZGVkOltdLGJlZm9yZXVwZGF0ZWQ6W10sYmVmb3JlcGh4Q2hpbGRBZGRlZDpbXSxhZnRlcmFkZGVkOltdLGFmdGVydXBkYXRlZDpbXSxhZnRlcmRpc2NhcmRlZDpbXSxhZnRlcnBoeENoaWxkQWRkZWQ6W119fXJldHVybiBfKGUsbnVsbCxbe2tleTpcInBhdGNoRWxcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7YihlLHQse2NoaWxkcmVuT25seTohMSxvbkJlZm9yZUVsVXBkYXRlZDpmdW5jdGlvbihlLHQpe2lmKG4mJm4uaXNTYW1lTm9kZShlKSYmbGUuaXNGb3JtSW5wdXQoZSkpcmV0dXJuIGxlLm1lcmdlRm9jdXNlZElucHV0KGUsdCksITF9fSl9fV0pLF8oZSxbe2tleTpcImJlZm9yZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5jYWxsYmFja3NbXCJiZWZvcmVcIi5jb25jYXQoZSldLnB1c2godCl9fSx7a2V5OlwiYWZ0ZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuY2FsbGJhY2tzW1wiYWZ0ZXJcIi5jb25jYXQoZSldLnB1c2godCl9fSx7a2V5OlwidHJhY2tCZWZvcmVcIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0PjE/dC0xOjApLGk9MTtpPHQ7aSsrKW5baS0xXT1hcmd1bWVudHNbaV07dGhpcy5jYWxsYmFja3NbXCJiZWZvcmVcIi5jb25jYXQoZSldLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXBwbHkodm9pZCAwLG4pfSl9fSx7a2V5OlwidHJhY2tBZnRlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCksaT0xO2k8dDtpKyspbltpLTFdPWFyZ3VtZW50c1tpXTt0aGlzLmNhbGxiYWNrc1tcImFmdGVyXCIuY29uY2F0KGUpXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFwcGx5KHZvaWQgMCxuKX0pfX0se2tleTpcIm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsXCIsdmFsdWU6ZnVuY3Rpb24oKXtsZS5hbGwodGhpcy5jb250YWluZXIsXCJbcGh4LXVwZGF0ZT1hcHBlbmRdID4gKiwgW3BoeC11cGRhdGU9cHJlcGVuZF0gPiAqXCIsZnVuY3Rpb24oZSl7ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yZW1vdmVcIixcIlwiKX0pfX0se2tleTpcInBlcmZvcm1cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLnZpZXcsbj10aGlzLmxpdmVTb2NrZXQsaT10aGlzLmNvbnRhaW5lcixyPXRoaXMuaHRtbCxvPXRoaXMuaXNDSURQYXRjaCgpP3RoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKHIpOmk7aWYoIXRoaXMuaXNDSURQYXRjaCgpfHxvKXt2YXIgYT1uLmdldEFjdGl2ZUVsZW1lbnQoKSx1PWEmJmxlLmhhc1NlbGVjdGlvblJhbmdlKGEpP2E6e30scz11LnNlbGVjdGlvblN0YXJ0LGM9dS5zZWxlY3Rpb25FbmQsbD1uLmJpbmRpbmcoXCJ1cGRhdGVcIiksZD1uLmJpbmRpbmcoXCJmZWVkYmFjay1mb3JcIiksaD1uLmJpbmRpbmcoXCJkaXNhYmxlLXdpdGhcIiksZj1uLmJpbmRpbmcoXCJ0cmlnZ2VyLWFjdGlvblwiKSx2PVtdLHA9W10sZz1bXSxtPW51bGwseT1uLnRpbWUoXCJwcmVtb3JwaCBjb250YWluZXIgcHJlcFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYnVpbGREaWZmSFRNTChpLHIsbCxvKX0pO3JldHVybiB0aGlzLnRyYWNrQmVmb3JlKFwiYWRkZWRcIixpKSx0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLGksaSksbi50aW1lKFwibW9ycGhkb21cIixmdW5jdGlvbigpe2Iobyx5LHtjaGlsZHJlbk9ubHk6bnVsbD09PW8uZ2V0QXR0cmlidXRlKEgpLGdldE5vZGVLZXk6ZnVuY3Rpb24oZSl7cmV0dXJuIGxlLmlzUGh4RGVzdHJveWVkKGUpP251bGw6ZS5pZH0sb25CZWZvcmVOb2RlQWRkZWQ6ZnVuY3Rpb24odCl7cmV0dXJuIGxlLmRpc2NhcmRFcnJvcihvLHQsZCksZS50cmFja0JlZm9yZShcImFkZGVkXCIsdCksdH0sb25Ob2RlQWRkZWQ6ZnVuY3Rpb24obil7bGUuaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKG4sZikmJihtPW4pLGxlLmlzUGh4Q2hpbGQobikmJnQub3duc0VsZW1lbnQobikmJmUudHJhY2tBZnRlcihcInBoeENoaWxkQWRkZWRcIixuKSx2LnB1c2gobil9LG9uTm9kZURpc2NhcmRlZDpmdW5jdGlvbih0KXtsZS5pc1BoeENoaWxkKHQpJiZuLmRlc3Ryb3lWaWV3QnlFbCh0KSxlLnRyYWNrQWZ0ZXIoXCJkaXNjYXJkZWRcIix0KX0sb25CZWZvcmVOb2RlRGlzY2FyZGVkOmZ1bmN0aW9uKHQpe3JldHVybiEoIXQuZ2V0QXR0cmlidXRlfHxudWxsPT09dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yZW1vdmVcIikpfHwobnVsbD09PXQucGFyZW50Tm9kZXx8IWxlLmlzUGh4VXBkYXRlKHQucGFyZW50Tm9kZSxsLFtcImFwcGVuZFwiLFwicHJlcGVuZFwiXSl8fCF0LmlkKSYmIWUuc2tpcENJRFNpYmxpbmcodCl9LG9uRWxVcGRhdGVkOmZ1bmN0aW9uKGUpe2xlLmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlLGYpJiYobT1lKSxwLnB1c2goZSl9LG9uQmVmb3JlRWxVcGRhdGVkOmZ1bmN0aW9uKHQsbil7aWYobGUuY2xlYW5DaGlsZE5vZGVzKG4sbCksZS5za2lwQ0lEU2libGluZyhuKSlyZXR1cm4hMTtpZihsZS5pc0lnbm9yZWQodCxsKSlyZXR1cm4gZS50cmFja0JlZm9yZShcInVwZGF0ZWRcIix0LG4pLGxlLm1lcmdlQXR0cnModCxuLHtpc0lnbm9yZWQ6ITB9KSxwLnB1c2godCksITE7aWYoXCJudW1iZXJcIj09PXQudHlwZSYmdC52YWxpZGl0eSYmdC52YWxpZGl0eS5iYWRJbnB1dClyZXR1cm4hMTtpZighbGUuc3luY1BlbmRpbmdSZWYodCxuLGgpKXJldHVybiBsZS5pc1VwbG9hZElucHV0KHQpJiYoZS50cmFja0JlZm9yZShcInVwZGF0ZWRcIix0LG4pLHAucHVzaCh0KSksITE7aWYobGUuaXNQaHhDaGlsZChuKSl7dmFyIGk9dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1zZXNzaW9uXCIpO3JldHVybiBsZS5tZXJnZUF0dHJzKHQsbix7ZXhjbHVkZTpbXCJkYXRhLXBoeC1zdGF0aWNcIl19KSxcIlwiIT09aSYmdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1zZXNzaW9uXCIsaSksdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yb290LWlkXCIsZS5yb290SUQpLCExfXJldHVybiBsZS5jb3B5UHJpdmF0ZXMobix0KSxsZS5kaXNjYXJkRXJyb3IobyxuLGQpLGEmJnQuaXNTYW1lTm9kZShhKSYmbGUuaXNGb3JtSW5wdXQodCkmJiFlLmZvcmNlRm9jdXNlZFNlbGVjdFVwZGF0ZSh0LG4pPyhlLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLHQsbiksbGUubWVyZ2VGb2N1c2VkSW5wdXQodCxuKSxsZS5zeW5jQXR0cnNUb1Byb3BzKHQpLHAucHVzaCh0KSwhMSk6KGxlLmlzUGh4VXBkYXRlKG4sbCxbXCJhcHBlbmRcIixcInByZXBlbmRcIl0pJiZnLnB1c2gobmV3IGRlKHQsbixuLmdldEF0dHJpYnV0ZShsKSkpLGxlLnN5bmNBdHRyc1RvUHJvcHMobiksZS50cmFja0JlZm9yZShcInVwZGF0ZWRcIix0LG4pLCEwKX19KX0pLG4uaXNEZWJ1Z0VuYWJsZWQoKSYmZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IFNldCx0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKSxuPTAsaT10Lmxlbmd0aDtuPGk7bisrKWUuaGFzKHRbbl0uaWQpP2NvbnNvbGUuZXJyb3IoXCJNdWx0aXBsZSBJRHMgZGV0ZWN0ZWQ6IFwiLmNvbmNhdCh0W25dLmlkLFwiLiBFbnN1cmUgdW5pcXVlIGVsZW1lbnQgaWRzLlwiKSk6ZS5hZGQodFtuXS5pZCl9KCksZy5sZW5ndGg+MCYmbi50aW1lKFwicG9zdC1tb3JwaCBhcHBlbmQvcHJlcGVuZCByZXN0b3JhdGlvblwiLGZ1bmN0aW9uKCl7Zy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnBlcmZvcm0oKX0pfSksbi5zaWxlbmNlRXZlbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIGxlLnJlc3RvcmVGb2N1cyhhLHMsYyl9KSxsZS5kaXNwYXRjaEV2ZW50KGRvY3VtZW50LFwicGh4OnVwZGF0ZVwiKSx2LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUudHJhY2tBZnRlcihcImFkZGVkXCIsdCl9KSxwLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUudHJhY2tBZnRlcihcInVwZGF0ZWRcIix0KX0pLG0mJihuLmRpc2Nvbm5lY3QoKSxtLnN1Ym1pdCgpKSwhMH19fSx7a2V5OlwiZm9yY2VGb2N1c2VkU2VsZWN0VXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1bXCJzZWxlY3RcIixcInNlbGVjdC1vbmVcIixcInNlbGVjdC1tdWx0aXBsZVwiXS5maW5kKGZ1bmN0aW9uKHQpe3JldHVybiB0PT09ZS50eXBlfSk7cmV0dXJuITA9PT1lLm11bHRpcGxlfHxuJiZlLmlubmVySFRNTCE9dC5pbm5lckhUTUx9fSx7a2V5OlwiaXNDSURQYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2lkUGF0Y2h9fSx7a2V5Olwic2tpcENJRFNpYmxpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZudWxsIT09ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1za2lwXCIpfX0se2tleTpcInRhcmdldENJRENvbnRhaW5lclwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKHRoaXMuaXNDSURQYXRjaCgpKXt2YXIgdD1rKGxlLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmNvbnRhaW5lcix0aGlzLnRhcmdldENJRCkpLG49dFswXTtyZXR1cm4gMD09PXQuc2xpY2UoMSkubGVuZ3RoJiYxPT09bGUuY2hpbGROb2RlTGVuZ3RoKGUpP246biYmbi5wYXJlbnROb2RlfX19LHtrZXk6XCJidWlsZERpZmZIVE1MXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSl7dmFyIHI9dGhpcyxvPXRoaXMuaXNDSURQYXRjaCgpLGE9byYmaS5nZXRBdHRyaWJ1dGUoSCk9PT10aGlzLnRhcmdldENJRC50b1N0cmluZygpO2lmKCFvfHxhKXJldHVybiB0O3ZhciB1PW51bGwscz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7dT1sZS5jbG9uZU5vZGUoaSk7dmFyIGM9ayhsZS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodSx0aGlzLnRhcmdldENJRCkpLGw9Y1swXSxkPWMuc2xpY2UoMSk7cmV0dXJuIHMuaW5uZXJIVE1MPXQsZC5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlbW92ZSgpfSksQXJyYXkuZnJvbSh1LmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5pZCYmZS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZlLmdldEF0dHJpYnV0ZShIKSE9PXIudGFyZ2V0Q0lELnRvU3RyaW5nKCkmJihlLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LXNraXBcIixcIlwiKSxlLmlubmVySFRNTD1cIlwiKX0pLEFycmF5LmZyb20ocy5jb250ZW50LmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHUuaW5zZXJ0QmVmb3JlKGUsbCl9KSxsLnJlbW92ZSgpLHUub3V0ZXJIVE1MfX1dKSxlfSgpLGZlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4saSxyLG8pe3ZhciBhPXRoaXM7VCh0aGlzLGUpLHRoaXMubGl2ZVNvY2tldD1uLHRoaXMuZmxhc2g9byx0aGlzLnBhcmVudD1pLHRoaXMucm9vdD1pP2kucm9vdDp0aGlzLHRoaXMuZWw9dCx0aGlzLmlkPXRoaXMuZWwuaWQsdGhpcy52aWV3PXRoaXMuZWwuZ2V0QXR0cmlidXRlKE8pLHRoaXMucmVmPTAsdGhpcy5jaGlsZEpvaW5zPTAsdGhpcy5sb2FkZXJUaW1lcj1udWxsLHRoaXMucGVuZGluZ0RpZmZzPVtdLHRoaXMucHJ1bmluZ0NJRHM9W10sdGhpcy5ocmVmPXIsdGhpcy5qb2luQ291bnQ9dGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQuam9pbkNvdW50LTE6MCx0aGlzLmpvaW5QZW5kaW5nPSEwLHRoaXMuZGVzdHJveWVkPSExLHRoaXMuam9pbkNhbGxiYWNrPWZ1bmN0aW9uKCl7fSx0aGlzLnN0b3BDYWxsYmFjaz1mdW5jdGlvbigpe30sdGhpcy5wZW5kaW5nSm9pbk9wcz10aGlzLnBhcmVudD9udWxsOltdLHRoaXMudmlld0hvb2tzPXt9LHRoaXMudXBsb2FkZXJzPXt9LHRoaXMuZm9ybVN1Ym1pdHM9W10sdGhpcy5jaGlsZHJlbj10aGlzLnBhcmVudD9udWxsOnt9LHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXT17fSx0aGlzLmNoYW5uZWw9dGhpcy5saXZlU29ja2V0LmNoYW5uZWwoXCJsdjpcIi5jb25jYXQodGhpcy5pZCksZnVuY3Rpb24oKXtyZXR1cm57dXJsOmEuaHJlZixwYXJhbXM6YS5jb25uZWN0UGFyYW1zKCksc2Vzc2lvbjphLmdldFNlc3Npb24oKSxzdGF0aWM6YS5nZXRTdGF0aWMoKSxmbGFzaDphLmZsYXNofX0pLHRoaXMuc2hvd0xvYWRlcih0aGlzLmxpdmVTb2NrZXQubG9hZGVyVGltZW91dCksdGhpcy5iaW5kQ2hhbm5lbCgpfXJldHVybiBfKGUsW3trZXk6XCJpc01haW5cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpdmVTb2NrZXQubWFpbj09PXRoaXN9fSx7a2V5OlwiY29ubmVjdFBhcmFtc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5saXZlU29ja2V0LnBhcmFtcyh0aGlzLnZpZXcpLHQ9bGUuYWxsKGRvY3VtZW50LFwiW1wiLmNvbmNhdCh0aGlzLmJpbmRpbmcoXCJ0cmFjay1zdGF0aWNcIiksXCJdXCIpKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3JjfHxlLmhyZWZ9KS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGV9KTtyZXR1cm4gdC5sZW5ndGg+MCYmKGUuX3RyYWNrX3N0YXRpYz10KSxlLl9tb3VudHM9dGhpcy5qb2luQ291bnQsZX19LHtrZXk6XCJuYW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3fX0se2tleTpcImlzQ29ubmVjdGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGFubmVsLmNhblB1c2goKX19LHtrZXk6XCJnZXRTZXNzaW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1zZXNzaW9uXCIpfX0se2tleTpcImdldFN0YXRpY1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1zdGF0aWNcIik7cmV0dXJuXCJcIj09PWU/bnVsbDplfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06ZnVuY3Rpb24oKXt9O3RoaXMuZGVzdHJveUFsbENoaWxkcmVuKCksdGhpcy5kZXN0cm95ZWQ9ITAsZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSx0aGlzLnBhcmVudCYmZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLnBhcmVudC5pZF1bdGhpcy5pZF0sY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpO3ZhciBuPWZ1bmN0aW9uKCl7Zm9yKHZhciBuIGluIHQoKSxlLnZpZXdIb29rcyllLmRlc3Ryb3lIb29rKGUudmlld0hvb2tzW25dKX07bGUubWFya1BoeENoaWxkRGVzdHJveWVkKHRoaXMuZWwpLHRoaXMubG9nKFwiZGVzdHJveWVkXCIsZnVuY3Rpb24oKXtyZXR1cm5bXCJ0aGUgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnRcIl19KSx0aGlzLmNoYW5uZWwubGVhdmUoKS5yZWNlaXZlKFwib2tcIixuKS5yZWNlaXZlKFwiZXJyb3JcIixuKS5yZWNlaXZlKFwidGltZW91dFwiLG4pfX0se2tleTpcInNldENvbnRhaW5lckNsYXNzZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlO3RoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcInBoeC1jb25uZWN0ZWRcIixcInBoeC1kaXNjb25uZWN0ZWRcIixcInBoeC1lcnJvclwiKSwoZT10aGlzLmVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KGUsYXJndW1lbnRzKX19LHtrZXk6XCJpc0xvYWRpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucyhcInBoeC1kaXNjb25uZWN0ZWRcIil9fSx7a2V5Olwic2hvd0xvYWRlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYoY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpLGUpdGhpcy5sb2FkZXJUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2hvd0xvYWRlcigpfSxlKTtlbHNle2Zvcih2YXIgbiBpbiB0aGlzLnZpZXdIb29rcyl0aGlzLnZpZXdIb29rc1tuXS5fX2Rpc2Nvbm5lY3RlZCgpO3RoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhcInBoeC1kaXNjb25uZWN0ZWRcIil9fX0se2tleTpcImhpZGVMb2FkZXJcIix2YWx1ZTpmdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKSx0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoXCJwaHgtY29ubmVjdGVkXCIpfX0se2tleTpcInRyaWdnZXJSZWNvbm5lY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMudmlld0hvb2tzKXRoaXMudmlld0hvb2tzW2VdLl9fcmVjb25uZWN0ZWQoKX19LHtrZXk6XCJsb2dcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMubGl2ZVNvY2tldC5sb2codGhpcyxlLHQpfX0se2tleTpcIndpdGhpblRhcmdldHNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7aWYoL14oMHxbMS05XVxcZCopJC8udGVzdChlKSl7dmFyIGk9bGUuZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsZSk7MD09PWkubGVuZ3RoP3ooXCJubyBjb21wb25lbnQgZm91bmQgbWF0Y2hpbmcgcGh4LXRhcmdldCBvZiBcIi5jb25jYXQoZSkpOnQodGhpcyxpWzBdKX1lbHNle3ZhciByPUFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKSk7MD09PXIubGVuZ3RoJiZ6KCdub3RoaW5nIGZvdW5kIG1hdGNoaW5nIHRoZSBwaHgtdGFyZ2V0IHNlbGVjdG9yIFwiJy5jb25jYXQoZSwnXCInKSksci5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBuLmxpdmVTb2NrZXQub3duZXIoZSxmdW5jdGlvbihuKXtyZXR1cm4gdChuLGUpfSl9KX19fSx7a2V5OlwiYXBwbHlEaWZmXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3RoaXMubG9nKGUsZnVuY3Rpb24oKXtyZXR1cm5bXCJcIiwkKHQpXX0pO3ZhciBpPXVlLmV4dHJhY3QodCkscj1pLmRpZmYsbz1pLnJlcGx5LGE9aS5ldmVudHMsdT1pLnRpdGxlO3JldHVybiB1JiZsZS5wdXRUaXRsZSh1KSxuKHtkaWZmOnIscmVwbHk6byxldmVudHM6YX0pLG99fSx7a2V5Olwib25Kb2luXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPWUucmVuZGVyZWQ7dGhpcy5jaGlsZEpvaW5zPTAsdGhpcy5qb2luUGVuZGluZz0hMCx0aGlzLmZsYXNoPW51bGwsY2UuZHJvcExvY2FsKHRoaXMubmFtZSgpLFwiY29uc2VjdXRpdmUtcmVsb2Fkc1wiKSx0aGlzLmFwcGx5RGlmZihcIm1vdW50XCIsbixmdW5jdGlvbihuKXt2YXIgaT1uLmRpZmYscj1uLmV2ZW50czt0LnJlbmRlcmVkPW5ldyB1ZSh0LmlkLGkpO3ZhciBvPXQucmVuZGVyQ29udGFpbmVyKG51bGwsXCJqb2luXCIpO3QuZHJvcFBlbmRpbmdSZWZzKCk7dmFyIGE9dC5mb3Jtc0ZvclJlY292ZXJ5KG8pO3Quam9pbkNvdW50KyssYS5sZW5ndGg+MD9hLmZvckVhY2goZnVuY3Rpb24oZSxuKXt0LnB1c2hGb3JtUmVjb3ZlcnkoZSxmdW5jdGlvbihlKXtuPT09YS5sZW5ndGgtMSYmdC5vbkpvaW5Db21wbGV0ZShlLG8scil9KX0pOnQub25Kb2luQ29tcGxldGUoZSxvLHIpfSl9fSx7a2V5OlwiZHJvcFBlbmRpbmdSZWZzXCIsdmFsdWU6ZnVuY3Rpb24oKXtsZS5hbGwodGhpcy5lbCxcIltcIi5jb25jYXQoRixcIl1cIiksZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVtb3ZlQXR0cmlidXRlKEYpfSl9fSx7a2V5Olwib25Kb2luQ29tcGxldGVcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcyxyPWUubGl2ZV9wYXRjaDtpZih0aGlzLmpvaW5Db3VudD4xfHx0aGlzLnBhcmVudCYmIXRoaXMucGFyZW50LmlzSm9pblBlbmRpbmcoKSlyZXR1cm4gdGhpcy5hcHBseUpvaW5QYXRjaChyLHQsbik7MD09PWxlLmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQodCx0aGlzLmlkKS5maWx0ZXIoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5pZCYmaS5lbC5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChlLmlkKSksbj10JiZ0LmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXN0YXRpY1wiKTtyZXR1cm4gbiYmZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1zdGF0aWNcIixuKSxpLmpvaW5DaGlsZChlKX0pLmxlbmd0aD90aGlzLnBhcmVudD8odGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsZnVuY3Rpb24oKXtyZXR1cm4gaS5hcHBseUpvaW5QYXRjaChyLHQsbil9XSksdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKSk6KHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKSx0aGlzLmFwcGx5Sm9pblBhdGNoKHIsdCxuKSk6dGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsZnVuY3Rpb24oKXtyZXR1cm4gaS5hcHBseUpvaW5QYXRjaChyLHQsbil9XSl9fSx7a2V5OlwiYXR0YWNoVHJ1ZURvY0VsXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmVsPWxlLmJ5SWQodGhpcy5pZCksdGhpcy5lbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yb290LWlkXCIsdGhpcy5yb290LmlkKX19LHtrZXk6XCJkaXNwYXRjaEV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2UuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD14KGUsMiksbj10WzBdLGk9dFsxXTt3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6aG9vazpcIi5jb25jYXQobikse2RldGFpbDppfSkpfSl9fSx7a2V5OlwiYXBwbHlKb2luUGF0Y2hcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpczt0aGlzLmF0dGFjaFRydWVEb2NFbCgpO3ZhciByPW5ldyBoZSh0aGlzLHRoaXMuZWwsdGhpcy5pZCx0LG51bGwpO2lmKHIubWFya1BydW5hYmxlQ29udGVudEZvclJlbW92YWwoKSx0aGlzLnBlcmZvcm1QYXRjaChyLCExKSx0aGlzLmpvaW5OZXdDaGlsZHJlbigpLGxlLmFsbCh0aGlzLmVsLFwiW1wiLmNvbmNhdCh0aGlzLmJpbmRpbmcoXCJob29rXCIpLFwiXSwgW2RhdGEtcGh4LVwiKS5jb25jYXQoXCJob29rXCIsXCJdXCIpLGZ1bmN0aW9uKGUpe3ZhciB0PWkuYWRkSG9vayhlKTt0JiZ0Ll9fbW91bnRlZCgpfSksdGhpcy5qb2luUGVuZGluZz0hMSx0aGlzLmRpc3BhdGNoRXZlbnRzKG4pLHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpLGUpe3ZhciBvPWUua2luZCxhPWUudG87dGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaChhLG8pfXRoaXMuaGlkZUxvYWRlcigpLHRoaXMuam9pbkNvdW50PjEmJnRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCksdGhpcy5zdG9wQ2FsbGJhY2soKX19LHtrZXk6XCJ0cmlnZ2VyQmVmb3JlVXBkYXRlSG9va1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbkJlZm9yZUVsVXBkYXRlZFwiLFtlLHRdKTt2YXIgbj10aGlzLmdldEhvb2soZSksaT1uJiZsZS5pc0lnbm9yZWQoZSx0aGlzLmJpbmRpbmcoXCJ1cGRhdGVcIikpO2lmKG4mJiFlLmlzRXF1YWxOb2RlKHQpJiYoIWl8fCFmdW5jdGlvbihlLHQpe3JldHVybiBKU09OLnN0cmluZ2lmeShlKT09PUpTT04uc3RyaW5naWZ5KHQpfShlLmRhdGFzZXQsdC5kYXRhc2V0KSkpcmV0dXJuIG4uX19iZWZvcmVVcGRhdGUoKSxufX0se2tleTpcInBlcmZvcm1QYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcyxpPVtdLHI9ITEsbz1uZXcgU2V0O3JldHVybiBlLmFmdGVyKFwiYWRkZWRcIixmdW5jdGlvbihlKXtuLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsW2VdKTt2YXIgdD1uLmFkZEhvb2soZSk7dCYmdC5fX21vdW50ZWQoKX0pLGUuYWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHI9ITB9KSxlLmJlZm9yZShcInVwZGF0ZWRcIixmdW5jdGlvbihlLHQpe24udHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZSx0KSYmby5hZGQoZS5pZCl9KSxlLmFmdGVyKFwidXBkYXRlZFwiLGZ1bmN0aW9uKGUpe28uaGFzKGUuaWQpJiZuLmdldEhvb2soZSkuX191cGRhdGVkKCl9KSxlLmFmdGVyKFwiZGlzY2FyZGVkXCIsZnVuY3Rpb24oZSl7dmFyIHQ9bi5jb21wb25lbnRJRChlKTtcIm51bWJlclwiPT10eXBlb2YgdCYmLTE9PT1pLmluZGV4T2YodCkmJmkucHVzaCh0KTt2YXIgcj1uLmdldEhvb2soZSk7ciYmbi5kZXN0cm95SG9vayhyKX0pLGUucGVyZm9ybSgpLHQmJnRoaXMubWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChpKSxyfX0se2tleTpcImpvaW5OZXdDaGlsZHJlblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztsZS5maW5kUGh4Q2hpbGRyZW4odGhpcy5lbCx0aGlzLmlkKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBlLmpvaW5DaGlsZCh0KX0pfX0se2tleTpcImdldENoaWxkQnlJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bZV19fSx7a2V5OlwiZ2V0RGVzY2VuZGVudEJ5RWxcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PXRoaXMuaWQ/dGhpczp0aGlzLmNoaWxkcmVuW2UuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtcGFyZW50LWlkXCIpXVtlLmlkXX19LHtrZXk6XCJkZXN0cm95RGVzY2VuZGVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pZm9yKHZhciBuIGluIHRoaXMucm9vdC5jaGlsZHJlblt0XSlpZihuPT09ZSlyZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3RdW25dLmRlc3Ryb3koKX19LHtrZXk6XCJqb2luQ2hpbGRcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighdGhpcy5nZXRDaGlsZEJ5SWQodC5pZCkpe3ZhciBuPW5ldyBlKHQsdGhpcy5saXZlU29ja2V0LHRoaXMpO3JldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bbi5pZF09bixuLmpvaW4oKSx0aGlzLmNoaWxkSm9pbnMrKywhMH19fSx7a2V5OlwiaXNKb2luUGVuZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuam9pblBlbmRpbmd9fSx7a2V5OlwiYWNrSm9pblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuY2hpbGRKb2lucy0tLDA9PT10aGlzLmNoaWxkSm9pbnMmJih0aGlzLnBhcmVudD90aGlzLnBhcmVudC5hY2tKb2luKHRoaXMpOnRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKSl9fSx7a2V5Olwib25BbGxDaGlsZEpvaW5zQ29tcGxldGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuam9pbkNhbGxiYWNrKCksdGhpcy5wZW5kaW5nSm9pbk9wcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXgoZSwyKSxuPXRbMF0saT10WzFdO24uaXNEZXN0cm95ZWQoKXx8aSgpfSksdGhpcy5wZW5kaW5nSm9pbk9wcz1bXX19LHtrZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7aWYodGhpcy5pc0pvaW5QZW5kaW5nKCl8fHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpKXJldHVybiB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKHtkaWZmOmUsZXZlbnRzOnR9KTt0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihlKTt2YXIgaT0hMTt0aGlzLnJlbmRlcmVkLmlzQ29tcG9uZW50T25seURpZmYoZSk/dGhpcy5saXZlU29ja2V0LnRpbWUoXCJjb21wb25lbnQgcGF0Y2ggY29tcGxldGVcIixmdW5jdGlvbigpe2xlLmZpbmRQYXJlbnRDSURzKG4uZWwsbi5yZW5kZXJlZC5jb21wb25lbnRDSURzKGUpKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe24uY29tcG9uZW50UGF0Y2gobi5yZW5kZXJlZC5nZXRDb21wb25lbnQoZSx0KSx0KSYmKGk9ITApfSl9KTpRKGUpfHx0aGlzLmxpdmVTb2NrZXQudGltZShcImZ1bGwgcGF0Y2ggY29tcGxldGVcIixmdW5jdGlvbigpe3ZhciB0PW4ucmVuZGVyQ29udGFpbmVyKGUsXCJ1cGRhdGVcIikscj1uZXcgaGUobixuLmVsLG4uaWQsdCxudWxsKTtpPW4ucGVyZm9ybVBhdGNoKHIsITApfSksdGhpcy5kaXNwYXRjaEV2ZW50cyh0KSxpJiZ0aGlzLmpvaW5OZXdDaGlsZHJlbigpfX0se2tleTpcInJlbmRlckNvbnRhaW5lclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy5saXZlU29ja2V0LnRpbWUoXCJ0b1N0cmluZyBkaWZmIChcIi5jb25jYXQodCxcIilcIiksZnVuY3Rpb24oKXt2YXIgdD1uLmVsLnRhZ05hbWUsaT1lP24ucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhlKS5jb25jYXQobi5wcnVuaW5nQ0lEcyk6bnVsbCxyPW4ucmVuZGVyZWQudG9TdHJpbmcoaSk7cmV0dXJuXCI8XCIuY29uY2F0KHQsXCI+XCIpLmNvbmNhdChyLFwiPC9cIikuY29uY2F0KHQsXCI+XCIpfSl9fSx7a2V5OlwiY29tcG9uZW50UGF0Y2hcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKFEoZSkpcmV0dXJuITE7dmFyIG49dGhpcy5yZW5kZXJlZC5jb21wb25lbnRUb1N0cmluZyh0KSxpPW5ldyBoZSh0aGlzLHRoaXMuZWwsdGhpcy5pZCxuLHQpO3JldHVybiB0aGlzLnBlcmZvcm1QYXRjaChpLCEwKX19LHtrZXk6XCJnZXRIb29rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudmlld0hvb2tzW3BlLmVsZW1lbnRJRChlKV19fSx7a2V5OlwiYWRkSG9va1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFwZS5lbGVtZW50SUQoZSkmJmUuZ2V0QXR0cmlidXRlKXt2YXIgdD1lLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LVwiLmNvbmNhdChcImhvb2tcIikpfHxlLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJob29rXCIpKTtpZighdHx8dGhpcy5vd25zRWxlbWVudChlKSl7dmFyIG49dGhpcy5saXZlU29ja2V0LmdldEhvb2tDYWxsYmFja3ModCk7aWYobil7ZS5pZHx8eignbm8gRE9NIElEIGZvciBob29rIFwiJy5jb25jYXQodCwnXCIuIEhvb2tzIHJlcXVpcmUgYSB1bmlxdWUgSUQgb24gZWFjaCBlbGVtZW50LicpLGUpO3ZhciBpPW5ldyBwZSh0aGlzLGUsbik7cmV0dXJuIHRoaXMudmlld0hvb2tzW3BlLmVsZW1lbnRJRChpLmVsKV09aSxpfW51bGwhPT10JiZ6KCd1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJy5jb25jYXQodCwnXCInKSxlKX19fX0se2tleTpcImRlc3Ryb3lIb29rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS5fX2Rlc3Ryb3llZCgpLGUuX19jbGVhbnVwX18oKSxkZWxldGUgdGhpcy52aWV3SG9va3NbcGUuZWxlbWVudElEKGUuZWwpXX19LHtrZXk6XCJhcHBseVBlbmRpbmdVcGRhdGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49dC5kaWZmLGk9dC5ldmVudHM7cmV0dXJuIGUudXBkYXRlKG4saSl9KSx0aGlzLnBlbmRpbmdEaWZmcz1bXX19LHtrZXk6XCJvbkNoYW5uZWxcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7dGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsZSxmdW5jdGlvbihlKXtuLmlzSm9pblBlbmRpbmcoKT9uLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbbixmdW5jdGlvbigpe3JldHVybiB0KGUpfV0pOnQoZSl9KX19LHtrZXk6XCJiaW5kQ2hhbm5lbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLmxpdmVTb2NrZXQub25DaGFubmVsKHRoaXMuY2hhbm5lbCxcImRpZmZcIixmdW5jdGlvbih0KXtlLmFwcGx5RGlmZihcInVwZGF0ZVwiLHQsZnVuY3Rpb24odCl7dmFyIG49dC5kaWZmLGk9dC5ldmVudHM7cmV0dXJuIGUudXBkYXRlKG4saSl9KX0pLHRoaXMub25DaGFubmVsKFwicmVkaXJlY3RcIixmdW5jdGlvbih0KXt2YXIgbj10LnRvLGk9dC5mbGFzaDtyZXR1cm4gZS5vblJlZGlyZWN0KHt0bzpuLGZsYXNoOml9KX0pLHRoaXMub25DaGFubmVsKFwibGl2ZV9wYXRjaFwiLGZ1bmN0aW9uKHQpe3JldHVybiBlLm9uTGl2ZVBhdGNoKHQpfSksdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsZnVuY3Rpb24odCl7cmV0dXJuIGUub25MaXZlUmVkaXJlY3QodCl9KSx0aGlzLmNoYW5uZWwub25FcnJvcihmdW5jdGlvbih0KXtyZXR1cm4gZS5vbkVycm9yKHQpfSksdGhpcy5jaGFubmVsLm9uQ2xvc2UoZnVuY3Rpb24odCl7cmV0dXJuIGUub25DbG9zZSh0KX0pfX0se2tleTpcImRlc3Ryb3lBbGxDaGlsZHJlblwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSl0aGlzLmdldENoaWxkQnlJZChlKS5kZXN0cm95KCl9fSx7a2V5Olwib25MaXZlUmVkaXJlY3RcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnRvLG49ZS5raW5kLGk9ZS5mbGFzaCxyPXRoaXMuZXhwYW5kVVJMKHQpO3RoaXMubGl2ZVNvY2tldC5oaXN0b3J5UmVkaXJlY3QocixuLGkpfX0se2tleTpcIm9uTGl2ZVBhdGNoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50byxuPWUua2luZDt0aGlzLmhyZWY9dGhpcy5leHBhbmRVUkwodCksdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaCh0LG4pfX0se2tleTpcImV4cGFuZFVSTFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlLnN0YXJ0c1dpdGgoXCIvXCIpP1wiXCIuY29uY2F0KHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCxcIi8vXCIpLmNvbmNhdCh3aW5kb3cubG9jYXRpb24uaG9zdCkuY29uY2F0KGUpOmV9fSx7a2V5Olwib25SZWRpcmVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUudG8sbj1lLmZsYXNoO3RoaXMubGl2ZVNvY2tldC5yZWRpcmVjdCh0LG4pfX0se2tleTpcImlzRGVzdHJveWVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZXN0cm95ZWR9fSx7a2V5Olwiam9pblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy5wYXJlbnR8fCh0aGlzLnN0b3BDYWxsYmFjaz10aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHt0bzp0aGlzLmhyZWYsa2luZDpcImluaXRpYWxcIn0pKSx0aGlzLmpvaW5DYWxsYmFjaz1mdW5jdGlvbigpe3JldHVybiBlJiZlKHQsdC5qb2luQ291bnQpfSx0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcyx7dGltZW91dDohMX0sZnVuY3Rpb24oKXtyZXR1cm4gdC5jaGFubmVsLmpvaW4oKS5yZWNlaXZlKFwib2tcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5vbkpvaW4oZSl9KS5yZWNlaXZlKFwiZXJyb3JcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5vbkpvaW5FcnJvcihlKX0pLnJlY2VpdmUoXCJ0aW1lb3V0XCIsZnVuY3Rpb24oKXtyZXR1cm4gdC5vbkpvaW5FcnJvcih7cmVhc29uOlwidGltZW91dFwifSl9KX0pfX0se2tleTpcIm9uSm9pbkVycm9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuKGUucmVkaXJlY3R8fGUubGl2ZV9yZWRpcmVjdCkmJih0aGlzLmpvaW5QZW5kaW5nPSExLHRoaXMuY2hhbm5lbC5sZWF2ZSgpKSxlLnJlZGlyZWN0P3RoaXMub25SZWRpcmVjdChlLnJlZGlyZWN0KTplLmxpdmVfcmVkaXJlY3Q/dGhpcy5vbkxpdmVSZWRpcmVjdChlLmxpdmVfcmVkaXJlY3QpOih0aGlzLmxvZyhcImVycm9yXCIsZnVuY3Rpb24oKXtyZXR1cm5bXCJ1bmFibGUgdG8gam9pblwiLGVdfSksdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcykpfX0se2tleTpcIm9uQ2xvc2VcIix2YWx1ZTpmdW5jdGlvbihlKXtpZighdGhpcy5pc0Rlc3Ryb3llZCgpKXtpZih0aGlzLmlzSm9pblBlbmRpbmcoKXx8dGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkmJlwibGVhdmVcIiE9PWUpcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpO3RoaXMuZGVzdHJveUFsbENoaWxkcmVuKCksdGhpcy5saXZlU29ja2V0LmRyb3BBY3RpdmVFbGVtZW50KHRoaXMpLGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQmJmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpLHRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkmJnRoaXMuc2hvd0xvYWRlcigyMDApfX19LHtrZXk6XCJvbkVycm9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5vbkNsb3NlKGUpLHRoaXMubG9nKFwiZXJyb3JcIixmdW5jdGlvbigpe3JldHVybltcInZpZXcgY3Jhc2hlZFwiLGVdfSksdGhpcy5saXZlU29ja2V0LmlzVW5sb2FkZWQoKXx8dGhpcy5kaXNwbGF5RXJyb3IoKX19LHtrZXk6XCJkaXNwbGF5RXJyb3JcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaXNNYWluKCkmJmxlLmRpc3BhdGNoRXZlbnQod2luZG93LFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLHt0bzp0aGlzLmhyZWYsa2luZDpcImVycm9yXCJ9KSx0aGlzLnNob3dMb2FkZXIoKSx0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoXCJwaHgtZGlzY29ubmVjdGVkXCIsXCJwaHgtZXJyb3JcIil9fSx7a2V5OlwicHVzaFdpdGhSZXBseVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzLHI9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOmZ1bmN0aW9uKCl7fSxvPXgoZT9lKCk6W251bGwsW11dLDIpLGE9b1swXSx1PXgob1sxXSwxKVswXSxzPWZ1bmN0aW9uKCl7fTtyZXR1cm4gdSYmbnVsbCE9PXUuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInBhZ2UtbG9hZGluZ1wiKSkmJihzPXRoaXMubGl2ZVNvY2tldC53aXRoUGFnZUxvYWRpbmcoe2tpbmQ6XCJlbGVtZW50XCIsdGFyZ2V0OnV9KSksXCJudW1iZXJcIiE9dHlwZW9mIG4uY2lkJiZkZWxldGUgbi5jaWQsdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMse3RpbWVvdXQ6ITB9LGZ1bmN0aW9uKCl7cmV0dXJuIGkuY2hhbm5lbC5wdXNoKHQsbiwzZTQpLnJlY2VpdmUoXCJva1wiLGZ1bmN0aW9uKGUpe3ZhciB0PW51bGw7bnVsbCE9PWEmJmkudW5kb1JlZnMoYSksZS5kaWZmJiYodD1pLmFwcGx5RGlmZihcInVwZGF0ZVwiLGUuZGlmZixmdW5jdGlvbihlKXt2YXIgdD1lLmRpZmYsbj1lLmV2ZW50cztpLnVwZGF0ZSh0LG4pfSkpLGUucmVkaXJlY3QmJmkub25SZWRpcmVjdChlLnJlZGlyZWN0KSxlLmxpdmVfcGF0Y2gmJmkub25MaXZlUGF0Y2goZS5saXZlX3BhdGNoKSxlLmxpdmVfcmVkaXJlY3QmJmkub25MaXZlUmVkaXJlY3QoZS5saXZlX3JlZGlyZWN0KSxzKCkscihlLHQpfSl9KX19LHtrZXk6XCJ1bmRvUmVmc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7bGUuYWxsKHRoaXMuZWwsXCJbXCIuY29uY2F0KEYsJz1cIicpLmNvbmNhdChlLCdcIl0nKSxmdW5jdGlvbihlKXtlLnJlbW92ZUF0dHJpYnV0ZShGKSxudWxsIT09ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yZWFkb25seVwiKSYmKGUucmVhZE9ubHk9ITEsZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yZWFkb25seVwiKSksbnVsbCE9PWUuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZGlzYWJsZWRcIikmJihlLmRpc2FibGVkPSExLGUucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1waHgtZGlzYWJsZWRcIikpLGouZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gbGUucmVtb3ZlQ2xhc3MoZSx0KX0pO3ZhciBuPWUuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIik7bnVsbCE9PW4mJihlLmlubmVyVGV4dD1uLGUucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIikpO3ZhciBpPWxlLnByaXZhdGUoZSxGKTtpZihpKXt2YXIgcj10LnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGUsaSk7aGUucGF0Y2hFbChlLGksdC5saXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKSksciYmci5fX3VwZGF0ZWQoKSxsZS5kZWxldGVQcml2YXRlKGUsRil9fSl9fSx7a2V5OlwicHV0UmVmXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLnJlZisrLGk9dGhpcy5iaW5kaW5nKFwiZGlzYWJsZS13aXRoXCIpO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5jbGFzc0xpc3QuYWRkKFwicGh4LVwiLmNvbmNhdCh0LFwiLWxvYWRpbmdcIikpLGUuc2V0QXR0cmlidXRlKEYsbik7dmFyIHI9ZS5nZXRBdHRyaWJ1dGUoaSk7bnVsbCE9PXImJihlLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCIpfHxlLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCIsZS5pbm5lclRleHQpLGUuaW5uZXJUZXh0PXIpfSksW24sZV19fSx7a2V5OlwiY29tcG9uZW50SURcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLmdldEF0dHJpYnV0ZSYmZS5nZXRBdHRyaWJ1dGUoSCk7cmV0dXJuIHQ/cGFyc2VJbnQodCk6bnVsbH19LHtrZXk6XCJ0YXJnZXRDb21wb25lbnRJRFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInRhcmdldFwiKSk/dGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodCk6bnVsbH19LHtrZXk6XCJjbG9zZXN0Q29tcG9uZW50SURcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlP1ooZS5jbG9zZXN0KFwiW1wiLmNvbmNhdChILFwiXVwiKSksZnVuY3Rpb24oZSl7cmV0dXJuIHQub3duc0VsZW1lbnQoZSkmJnQuY29tcG9uZW50SUQoZSl9KTpudWxsfX0se2tleTpcInB1c2hIb29rRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpKXtpZighdGhpcy5pc0Nvbm5lY3RlZCgpKXJldHVybiB0aGlzLmxvZyhcImhvb2tcIixmdW5jdGlvbigpe3JldHVybltcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIix0LG5dfSksITE7dmFyIHI9eCh0aGlzLnB1dFJlZihbXSxcImhvb2tcIiksMiksbz1yWzBdLGE9clsxXTtyZXR1cm4gdGhpcy5wdXNoV2l0aFJlcGx5KGZ1bmN0aW9uKCl7cmV0dXJuW28sYV19LFwiZXZlbnRcIix7dHlwZTpcImhvb2tcIixldmVudDp0LHZhbHVlOm4sY2lkOnRoaXMuY2xvc2VzdENvbXBvbmVudElEKGUpfSxmdW5jdGlvbihlLHQpe3JldHVybiBpKHQsbyl9KSxvfX0se2tleTpcImV4dHJhY3RNZXRhXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49dGhpcy5iaW5kaW5nKFwidmFsdWUtXCIpLGk9MDtpPGUuYXR0cmlidXRlcy5sZW5ndGg7aSsrKXt2YXIgcj1lLmF0dHJpYnV0ZXNbaV0ubmFtZTtyLnN0YXJ0c1dpdGgobikmJih0W3IucmVwbGFjZShuLFwiXCIpXT1lLmdldEF0dHJpYnV0ZShyKSl9cmV0dXJuIHZvaWQgMCE9PWUudmFsdWUmJih0LnZhbHVlPWUudmFsdWUsXCJJTlBVVFwiPT09ZS50YWdOYW1lJiZKLmluZGV4T2YoZS50eXBlKT49MCYmIWUuY2hlY2tlZCYmZGVsZXRlIHQudmFsdWUpLHR9fSx7a2V5OlwicHVzaEV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxyKXt2YXIgbz10aGlzO3RoaXMucHVzaFdpdGhSZXBseShmdW5jdGlvbigpe3JldHVybiBvLnB1dFJlZihbdF0sZSl9LFwiZXZlbnRcIix7dHlwZTplLGV2ZW50OmksdmFsdWU6dGhpcy5leHRyYWN0TWV0YSh0LHIpLGNpZDp0aGlzLnRhcmdldENvbXBvbmVudElEKHQsbil9KX19LHtrZXk6XCJwdXNoS2V5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxyKXt2YXIgbz10aGlzO3RoaXMucHVzaFdpdGhSZXBseShmdW5jdGlvbigpe3JldHVybiBvLnB1dFJlZihbZV0sbil9LFwiZXZlbnRcIix7dHlwZTpuLGV2ZW50OmksdmFsdWU6dGhpcy5leHRyYWN0TWV0YShlLHIpLGNpZDp0aGlzLnRhcmdldENvbXBvbmVudElEKGUsdCl9KX19LHtrZXk6XCJwdXNoRmlsZVByb2dyZXNzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpmdW5jdGlvbigpe307dGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhlLmZvcm0sZnVuY3Rpb24ocixvKXtyLnB1c2hXaXRoUmVwbHkobnVsbCxcInByb2dyZXNzXCIse2V2ZW50OmUuZ2V0QXR0cmlidXRlKHIuYmluZGluZyhcInByb2dyZXNzXCIpKSxyZWY6ZS5nZXRBdHRyaWJ1dGUoTSksZW50cnlfcmVmOnQscHJvZ3Jlc3M6bixjaWQ6ci50YXJnZXRDb21wb25lbnRJRChlLmZvcm0sbyl9LGkpfSl9fSx7a2V5OlwicHVzaElucHV0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxyKXt2YXIgbz10aGlzLGE9dGhpcy50YXJnZXRDb21wb25lbnRJRChlLmZvcm0sdCksdT1mdW5jdGlvbigpe3JldHVybiBvLnB1dFJlZihbZSxlLmZvcm1dLFwiY2hhbmdlXCIpfSxzPWFlKGUuZm9ybSx7X3RhcmdldDppLm5hbWV9KTtlLmZpbGVzJiZlLmZpbGVzLmxlbmd0aD4wJiZpZS50cmFja0ZpbGVzKGUsQXJyYXkuZnJvbShlLmZpbGVzKSk7dmFyIGM9e3R5cGU6XCJmb3JtXCIsZXZlbnQ6bix2YWx1ZTpzLHVwbG9hZHM6aWUuc2VyaWFsaXplVXBsb2FkcyhlKSxjaWQ6YX07dGhpcy5wdXNoV2l0aFJlcGx5KHUsXCJldmVudFwiLGMsZnVuY3Rpb24obil7aWYobGUuc2hvd0Vycm9yKGUsby5saXZlU29ja2V0LmJpbmRpbmcoXCJmZWVkYmFjay1mb3JcIikpLGxlLmlzVXBsb2FkSW5wdXQoZSkmJm51bGwhPT1lLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWF1dG8tdXBsb2FkXCIpKXtpZihpZS5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGUpLmxlbmd0aD4wKXt2YXIgaT14KHUoKSwyKSxzPWlbMF07aVsxXTtvLnVwbG9hZEZpbGVzKGUuZm9ybSx0LHMsYSxmdW5jdGlvbih0KXtyJiZyKG4pLG8udHJpZ2dlckF3YWl0aW5nU3VibWl0KGUuZm9ybSl9KX19ZWxzZSByJiZyKG4pfSl9fSx7a2V5OlwidHJpZ2dlckF3YWl0aW5nU3VibWl0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZSk7aWYodCl7dmFyIG49eCh0LDMpLGk9KG5bMF0sblsxXSxuWzJdKTt0aGlzLmNhbmNlbFN1Ym1pdChlKSxpKCl9fX0se2tleTpcImdldFNjaGVkdWxlZFN1Ym1pdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmZvcm1TdWJtaXRzLmZpbmQoZnVuY3Rpb24odCl7dmFyIG49eCh0LDIpLGk9blswXTtuWzFdO3JldHVybiBpLmlzU2FtZU5vZGUoZSl9KX19LHtrZXk6XCJzY2hlZHVsZVN1Ym1pdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtpZih0aGlzLmdldFNjaGVkdWxlZFN1Ym1pdChlKSlyZXR1cm4hMDt0aGlzLmZvcm1TdWJtaXRzLnB1c2goW2UsdCxuXSl9fSx7a2V5OlwiY2FuY2VsU3VibWl0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aGlzLmZvcm1TdWJtaXRzPXRoaXMuZm9ybVN1Ym1pdHMuZmlsdGVyKGZ1bmN0aW9uKG4pe3ZhciBpPXgobiwzKSxyPWlbMF0sbz1pWzFdO2lbMl07cmV0dXJuIXIuaXNTYW1lTm9kZShlKXx8KHQudW5kb1JlZnMobyksITEpfSl9fSx7a2V5OlwicHVzaEZvcm1TdWJtaXRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpKXt2YXIgcj10aGlzLG89ZnVuY3Rpb24oZSl7cmV0dXJuIShHKGUsXCJcIi5jb25jYXQoci5iaW5kaW5nKFwidXBkYXRlXCIpLFwiPWlnbm9yZVwiKSxlLmZvcm0pfHxHKGUsXCJkYXRhLXBoeC11cGRhdGU9aWdub3JlXCIsZS5mb3JtKSl9LGE9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuaGFzQXR0cmlidXRlKHIuYmluZGluZyhcImRpc2FibGUtd2l0aFwiKSl9LHU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJCVVRUT05cIj09ZS50YWdOYW1lfSxzPWZ1bmN0aW9uKGUpe3JldHVybltcIklOUFVUXCIsXCJURVhUQVJFQVwiLFwiU0VMRUNUXCJdLmluY2x1ZGVzKGUudGFnTmFtZSl9LGM9ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5mcm9tKGUuZWxlbWVudHMpLG49dC5maWx0ZXIoYSksaT10LmZpbHRlcih1KS5maWx0ZXIobyksYz10LmZpbHRlcihzKS5maWx0ZXIobyk7cmV0dXJuIGkuZm9yRWFjaChmdW5jdGlvbihlKXtlLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWRpc2FibGVkXCIsZS5kaXNhYmxlZCksZS5kaXNhYmxlZD0hMH0pLGMuZm9yRWFjaChmdW5jdGlvbihlKXtlLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LXJlYWRvbmx5XCIsZS5yZWFkT25seSksZS5yZWFkT25seT0hMCxlLmZpbGVzJiYoZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1kaXNhYmxlZFwiLGUuZGlzYWJsZWQpLGUuZGlzYWJsZWQ9ITApfSksZS5zZXRBdHRyaWJ1dGUoci5iaW5kaW5nKFwicGFnZS1sb2FkaW5nXCIpLFwiXCIpLHIucHV0UmVmKFtlXS5jb25jYXQobikuY29uY2F0KGkpLmNvbmNhdChjKSxcInN1Ym1pdFwiKX0sbD10aGlzLnRhcmdldENvbXBvbmVudElEKGUsdCk7aWYoaWUuaGFzVXBsb2Fkc0luUHJvZ3Jlc3MoZSkpe3ZhciBkPXgoYygpLDIpLGg9ZFswXTtkWzFdO3JldHVybiB0aGlzLnNjaGVkdWxlU3VibWl0KGUsaCxmdW5jdGlvbigpe3JldHVybiByLnB1c2hGb3JtU3VibWl0KGUsdCxuLGkpfSl9aWYoaWUuaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZSkubGVuZ3RoPjApe3ZhciBmPXgoYygpLDIpLHY9ZlswXSxwPWZbMV0sZz1mdW5jdGlvbigpe3JldHVyblt2LHBdfTt0aGlzLnVwbG9hZEZpbGVzKGUsdCx2LGwsZnVuY3Rpb24odCl7dmFyIG89YWUoZSx7fSk7ci5wdXNoV2l0aFJlcGx5KGcsXCJldmVudFwiLHt0eXBlOlwiZm9ybVwiLGV2ZW50Om4sdmFsdWU6byxjaWQ6bH0saSl9KX1lbHNle3ZhciBtPWFlKGUpO3RoaXMucHVzaFdpdGhSZXBseShjLFwiZXZlbnRcIix7dHlwZTpcImZvcm1cIixldmVudDpuLHZhbHVlOm0sY2lkOmx9LGkpfX19LHtrZXk6XCJ1cGxvYWRGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGkscil7dmFyIG89dGhpcyxhPXRoaXMuam9pbkNvdW50O2llLmFjdGl2ZUZpbGVJbnB1dHMoZSkuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgaT1uZXcgaWUoZSxvLHIpO28udXBsb2FkZXJzW2VdPWk7dmFyIHU9aS5lbnRyaWVzKCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRvUHJlZmxpZ2h0UGF5bG9hZCgpfSkscz17cmVmOmUuZ2V0QXR0cmlidXRlKE0pLGVudHJpZXM6dSxjaWQ6by50YXJnZXRDb21wb25lbnRJRChlLmZvcm0sdCl9O28ubG9nKFwidXBsb2FkXCIsZnVuY3Rpb24oKXtyZXR1cm5bXCJzZW5kaW5nIHByZWZsaWdodCByZXF1ZXN0XCIsc119KSxvLnB1c2hXaXRoUmVwbHkobnVsbCxcImFsbG93X3VwbG9hZFwiLHMsZnVuY3Rpb24oZSl7aWYoby5sb2coXCJ1cGxvYWRcIixmdW5jdGlvbigpe3JldHVybltcImdvdCBwcmVmbGlnaHQgcmVzcG9uc2VcIixlXX0pLGUuZXJyb3Ipe28udW5kb1JlZnMobik7dmFyIHQ9eChlLmVycm9yLDIpLHI9dFswXSx1PXRbMV07by5sb2coXCJ1cGxvYWRcIixmdW5jdGlvbigpe3JldHVybltcImVycm9yIGZvciBlbnRyeSBcIi5jb25jYXQociksdV19KX1lbHNle2kuaW5pdEFkYXB0ZXJVcGxvYWQoZSxmdW5jdGlvbihlKXtvLmNoYW5uZWwub25FcnJvcihmdW5jdGlvbigpe28uam9pbkNvdW50PT09YSYmZSgpfSl9LG8ubGl2ZVNvY2tldCl9fSl9KX19LHtrZXk6XCJwdXNoRm9ybVJlY292ZXJ5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3RoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZSxmdW5jdGlvbihpLHIpe3ZhciBvPWUuZWxlbWVudHNbMF0sYT1lLmdldEF0dHJpYnV0ZShuLmJpbmRpbmcoXCJhdXRvLXJlY292ZXJcIikpfHxlLmdldEF0dHJpYnV0ZShuLmJpbmRpbmcoXCJjaGFuZ2VcIikpO2kucHVzaElucHV0KG8scixhLG8sdCl9KX19LHtrZXk6XCJwdXNoTGlua1BhdGNoXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXMscj10aGlzLmxpdmVTb2NrZXQuc2V0UGVuZGluZ0xpbmsoZSksbz10P2Z1bmN0aW9uKCl7cmV0dXJuIGkucHV0UmVmKFt0XSxcImNsaWNrXCIpfTpudWxsO3RoaXMucHVzaFdpdGhSZXBseShvLFwibGlua1wiLHt1cmw6ZX0sZnVuY3Rpb24odCl7dC5saW5rX3JlZGlyZWN0P2kubGl2ZVNvY2tldC5yZXBsYWNlTWFpbihlLG51bGwsbixyKTppLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsocikmJihpLmhyZWY9ZSxpLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKSxuJiZuKCkpfSkucmVjZWl2ZShcInRpbWVvdXRcIixmdW5jdGlvbigpe3JldHVybiBpLmxpdmVTb2NrZXQucmVkaXJlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpfSl9fSx7a2V5OlwiZm9ybXNGb3JSZWNvdmVyeVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYoMD09PXRoaXMuam9pbkNvdW50KXJldHVybltdO3ZhciBuPXRoaXMuYmluZGluZyhcImNoYW5nZVwiKSxpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtyZXR1cm4gaS5pbm5lckhUTUw9ZSxsZS5hbGwodGhpcy5lbCxcImZvcm1bXCIuY29uY2F0KG4sXCJdXCIpKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHQub3duc0VsZW1lbnQoZSl9KS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZWxlbWVudHMubGVuZ3RoPjB9KS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuXCJpZ25vcmVcIiE9PWUuZ2V0QXR0cmlidXRlKHQuYmluZGluZyhcImF1dG8tcmVjb3ZlclwiKSl9KS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGkuY29udGVudC5xdWVyeVNlbGVjdG9yKFwiZm9ybVtcIi5jb25jYXQobiwnPVwiJykuY29uY2F0KGUuZ2V0QXR0cmlidXRlKG4pLCdcIl0nKSl9KX19LHtrZXk6XCJtYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQsbj10aGlzLGk9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIDA9PT1sZS5maW5kQ29tcG9uZW50Tm9kZUxpc3Qobi5lbCxlKS5sZW5ndGh9KTtpLmxlbmd0aD4wJiYoKHQ9dGhpcy5wcnVuaW5nQ0lEcykucHVzaC5hcHBseSh0LEEoaSkpLHRoaXMucHVzaFdpdGhSZXBseShudWxsLFwiY2lkc193aWxsX2Rlc3Ryb3lcIix7Y2lkczppfSxmdW5jdGlvbigpe24ucHJ1bmluZ0NJRHM9bi5wcnVuaW5nQ0lEcy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuLTEhPT1pLmluZGV4T2YoZSl9KTt2YXIgZT1pLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gMD09PWxlLmZpbmRDb21wb25lbnROb2RlTGlzdChuLmVsLGUpLmxlbmd0aH0pO2UubGVuZ3RoPjAmJm4ucHVzaFdpdGhSZXBseShudWxsLFwiY2lkc19kZXN0cm95ZWRcIix7Y2lkczplfSxmdW5jdGlvbihlKXtuLnJlbmRlcmVkLnBydW5lQ0lEcyhlLmNpZHMpfSl9KSl9fSx7a2V5Olwib3duc0VsZW1lbnRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1wYXJlbnQtaWRcIik9PT10aGlzLmlkfHxaKGUuY2xvc2VzdChVKSxmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pPT09dGhpcy5pZH19LHtrZXk6XCJzdWJtaXRGb3JtXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXM7bGUucHV0UHJpdmF0ZShlLFwicGh4LWhhcy1zdWJtaXR0ZWRcIiwhMCksdGhpcy5saXZlU29ja2V0LmJsdXJBY3RpdmVFbGVtZW50KHRoaXMpLHRoaXMucHVzaEZvcm1TdWJtaXQoZSx0LG4sZnVuY3Rpb24oKXtpLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpfSl9fSx7a2V5OlwiYmluZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhlKX19XSksZX0oKSx2ZT0xLHBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4saSl7Zm9yKHZhciByIGluIFQodGhpcyxlKSx0aGlzLl9fdmlldz10LHRoaXMuX19saXZlU29ja2V0PXQubGl2ZVNvY2tldCx0aGlzLl9fY2FsbGJhY2tzPWksdGhpcy5fX2xpc3RlbmVycz1uZXcgU2V0LHRoaXMuX19pc0Rpc2Nvbm5lY3RlZD0hMSx0aGlzLmVsPW4sdGhpcy52aWV3TmFtZT10Lm5hbWUoKSx0aGlzLmVsLnBoeEhvb2tJZD10aGlzLmNvbnN0cnVjdG9yLm1ha2VJRCgpLHRoaXMuX19jYWxsYmFja3MpdGhpc1tyXT10aGlzLl9fY2FsbGJhY2tzW3JdfXJldHVybiBfKGUsbnVsbCxbe2tleTpcIm1ha2VJRFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHZlKyt9fSx7a2V5OlwiZWxlbWVudElEXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucGh4SG9va0lkfX1dKSxfKGUsW3trZXk6XCJfX21vdW50ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubW91bnRlZCYmdGhpcy5tb3VudGVkKCl9fSx7a2V5OlwiX191cGRhdGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZWQmJnRoaXMudXBkYXRlZCgpfX0se2tleTpcIl9fYmVmb3JlVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmJlZm9yZVVwZGF0ZSYmdGhpcy5iZWZvcmVVcGRhdGUoKX19LHtrZXk6XCJfX2Rlc3Ryb3llZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kZXN0cm95ZWQmJnRoaXMuZGVzdHJveWVkKCl9fSx7a2V5OlwiX19yZWNvbm5lY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fX2lzRGlzY29ubmVjdGVkJiYodGhpcy5fX2lzRGlzY29ubmVjdGVkPSExLHRoaXMucmVjb25uZWN0ZWQmJnRoaXMucmVjb25uZWN0ZWQoKSl9fSx7a2V5OlwiX19kaXNjb25uZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX19pc0Rpc2Nvbm5lY3RlZD0hMCx0aGlzLmRpc2Nvbm5lY3RlZCYmdGhpcy5kaXNjb25uZWN0ZWQoKX19LHtrZXk6XCJwdXNoRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06ZnVuY3Rpb24oKXt9O3JldHVybiB0aGlzLl9fdmlldy5wdXNoSG9va0V2ZW50KG51bGwsZSx0LG4pfX0se2tleTpcInB1c2hFdmVudFRvXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30saT1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106ZnVuY3Rpb24oKXt9O3JldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKGUsZnVuY3Rpb24oZSxyKXtyZXR1cm4gZS5wdXNoSG9va0V2ZW50KHIsdCxuLGkpfSl9fSx7a2V5OlwiaGFuZGxlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWZ1bmN0aW9uKG4saSl7cmV0dXJuIGk/ZTp0KG4uZGV0YWlsKX07cmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4Omhvb2s6XCIuY29uY2F0KGUpLG4pLHRoaXMuX19saXN0ZW5lcnMuYWRkKG4pLG59fSx7a2V5OlwicmVtb3ZlSGFuZGxlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lKG51bGwsITApO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGh4Omhvb2s6XCIuY29uY2F0KHQpLGUpLHRoaXMuX19saXN0ZW5lcnMuZGVsZXRlKGUpfX0se2tleTpcIl9fY2xlYW51cF9fXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuX19saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5yZW1vdmVIYW5kbGVFdmVudCh0KX0pfX1dKSxlfSgpO3QuZGVmYXVsdD1zZX0sZnVuY3Rpb24oZSx0KXt2YXIgbjtuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e249bnx8RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfHwoMCxldmFsKShcInRoaXNcIil9Y2F0Y2goZSl7XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmKG49d2luZG93KX1lLmV4cG9ydHM9bn0sZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbih0KXt0LlBob2VuaXh8fCh0LlBob2VuaXg9e30pLGUuZXhwb3J0cz10LlBob2VuaXguTGl2ZVZpZXc9bigwKX0pLmNhbGwodGhpcyxuKDEpKX1dKX0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///2\\n')},function(n,t,e){n.exports=e(6)},function(module,exports,__webpack_require__){eval(\"// extracted by mini-css-extract-plugin//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2Nzcy9hcHAuc2Nzcz80NjY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///4\\n\")},function(module,exports,__webpack_require__){\"use strict\";eval('\\n\\n(function () {\\n  var PolyfillEvent = eventConstructor();\\n\\n  function eventConstructor() {\\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent; // IE<=9 Support\\n\\n    function CustomEvent(event, params) {\\n      params = params || {\\n        bubbles: false,\\n        cancelable: false,\\n        detail: undefined\\n      };\\n      var evt = document.createEvent(\\'CustomEvent\\');\\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\\n      return evt;\\n    }\\n\\n    CustomEvent.prototype = window.Event.prototype;\\n    return CustomEvent;\\n  }\\n\\n  function buildHiddenInput(name, value) {\\n    var input = document.createElement(\"input\");\\n    input.type = \"hidden\";\\n    input.name = name;\\n    input.value = value;\\n    return input;\\n  }\\n\\n  function handleClick(element) {\\n    var to = element.getAttribute(\"data-to\"),\\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\\n        form = document.createElement(\"form\"),\\n        target = element.getAttribute(\"target\");\\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\\n    form.action = to;\\n    form.style.display = \"hidden\";\\n    if (target) form.target = target;\\n    form.appendChild(csrf);\\n    form.appendChild(method);\\n    document.body.appendChild(form);\\n    form.submit();\\n  }\\n\\n  window.addEventListener(\"click\", function (e) {\\n    var element = e.target;\\n\\n    while (element && element.getAttribute) {\\n      var phoenixLinkEvent = new PolyfillEvent(\\'phoenix.link.click\\', {\\n        \"bubbles\": true,\\n        \"cancelable\": true\\n      });\\n\\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\\n        e.preventDefault();\\n        e.stopImmediatePropagation();\\n        return false;\\n      }\\n\\n      if (element.getAttribute(\"data-method\")) {\\n        handleClick(element);\\n        e.preventDefault();\\n        return false;\\n      } else {\\n        element = element.parentNode;\\n      }\\n    }\\n  }, false);\\n  window.addEventListener(\\'phoenix.link.click\\', function (e) {\\n    var message = e.target.getAttribute(\"data-confirm\");\\n\\n    if (message && !window.confirm(message)) {\\n      e.preventDefault();\\n    }\\n  }, false);\\n})();//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9hbGVhay9zcmMvZmVlZGV4L2RlcHMvcGhvZW5peF9odG1sL3ByaXYvc3RhdGljL3Bob2VuaXhfaHRtbC5qcz9lMDQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQb2x5ZmlsbEV2ZW50ID0gZXZlbnRDb25zdHJ1Y3RvcigpO1xuXG4gIGZ1bmN0aW9uIGV2ZW50Q29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHdpbmRvdy5DdXN0b21FdmVudDtcbiAgICAvLyBJRTw9OSBTdXBwb3J0XG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgIHJldHVybiBDdXN0b21FdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSGlkZGVuSW5wdXQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgaW5wdXQubmFtZSA9IG5hbWU7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlbGVtZW50KSB7XG4gICAgdmFyIHRvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvXCIpLFxuICAgICAgICBtZXRob2QgPSBidWlsZEhpZGRlbklucHV0KFwiX21ldGhvZFwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSxcbiAgICAgICAgY3NyZiA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfY3NyZl90b2tlblwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY3NyZlwiKSksXG4gICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgdGFyZ2V0ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XG5cbiAgICBmb3JtLm1ldGhvZCA9IChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpID09PSBcImdldFwiKSA/IFwiZ2V0XCIgOiBcInBvc3RcIjtcbiAgICBmb3JtLmFjdGlvbiA9IHRvO1xuICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9IFwiaGlkZGVuXCI7XG5cbiAgICBpZiAodGFyZ2V0KSBmb3JtLnRhcmdldCA9IHRhcmdldDtcblxuICAgIGZvcm0uYXBwZW5kQ2hpbGQoY3NyZik7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChtZXRob2QpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgZm9ybS5zdWJtaXQoKTtcbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS50YXJnZXQ7XG5cbiAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHBob2VuaXhMaW5rRXZlbnQgPSBuZXcgUG9seWZpbGxFdmVudCgncGhvZW5peC5saW5rLmNsaWNrJywge1xuICAgICAgICBcImJ1YmJsZXNcIjogdHJ1ZSwgXCJjYW5jZWxhYmxlXCI6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWVsZW1lbnQuZGlzcGF0Y2hFdmVudChwaG9lbml4TGlua0V2ZW50KSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikpIHtcbiAgICAgICAgaGFuZGxlQ2xpY2soZWxlbWVudCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIGZhbHNlKTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGhvZW5peC5saW5rLmNsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtY29uZmlybVwiKTtcbiAgICBpZihtZXNzYWdlICYmICF3aW5kb3cuY29uZmlybShtZXNzYWdlKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSwgZmFsc2UpO1xufSkoKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///5\\n')},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\nvar lib_namespaceObject = {};\\n__webpack_require__.r(lib_namespaceObject);\\n__webpack_require__.d(lib_namespaceObject, \\\"top\\\", function() { return enums_top; });\\n__webpack_require__.d(lib_namespaceObject, \\\"bottom\\\", function() { return bottom; });\\n__webpack_require__.d(lib_namespaceObject, \\\"right\\\", function() { return right; });\\n__webpack_require__.d(lib_namespaceObject, \\\"left\\\", function() { return left; });\\n__webpack_require__.d(lib_namespaceObject, \\\"auto\\\", function() { return auto; });\\n__webpack_require__.d(lib_namespaceObject, \\\"basePlacements\\\", function() { return basePlacements; });\\n__webpack_require__.d(lib_namespaceObject, \\\"start\\\", function() { return start; });\\n__webpack_require__.d(lib_namespaceObject, \\\"end\\\", function() { return end; });\\n__webpack_require__.d(lib_namespaceObject, \\\"clippingParents\\\", function() { return enums_clippingParents; });\\n__webpack_require__.d(lib_namespaceObject, \\\"viewport\\\", function() { return viewport; });\\n__webpack_require__.d(lib_namespaceObject, \\\"popper\\\", function() { return enums_popper; });\\n__webpack_require__.d(lib_namespaceObject, \\\"reference\\\", function() { return enums_reference; });\\n__webpack_require__.d(lib_namespaceObject, \\\"variationPlacements\\\", function() { return variationPlacements; });\\n__webpack_require__.d(lib_namespaceObject, \\\"placements\\\", function() { return enums_placements; });\\n__webpack_require__.d(lib_namespaceObject, \\\"beforeRead\\\", function() { return beforeRead; });\\n__webpack_require__.d(lib_namespaceObject, \\\"read\\\", function() { return read; });\\n__webpack_require__.d(lib_namespaceObject, \\\"afterRead\\\", function() { return afterRead; });\\n__webpack_require__.d(lib_namespaceObject, \\\"beforeMain\\\", function() { return beforeMain; });\\n__webpack_require__.d(lib_namespaceObject, \\\"main\\\", function() { return main; });\\n__webpack_require__.d(lib_namespaceObject, \\\"afterMain\\\", function() { return afterMain; });\\n__webpack_require__.d(lib_namespaceObject, \\\"beforeWrite\\\", function() { return beforeWrite; });\\n__webpack_require__.d(lib_namespaceObject, \\\"write\\\", function() { return write; });\\n__webpack_require__.d(lib_namespaceObject, \\\"afterWrite\\\", function() { return afterWrite; });\\n__webpack_require__.d(lib_namespaceObject, \\\"modifierPhases\\\", function() { return modifierPhases; });\\n__webpack_require__.d(lib_namespaceObject, \\\"applyStyles\\\", function() { return modifiers_applyStyles; });\\n__webpack_require__.d(lib_namespaceObject, \\\"arrow\\\", function() { return modifiers_arrow; });\\n__webpack_require__.d(lib_namespaceObject, \\\"computeStyles\\\", function() { return modifiers_computeStyles; });\\n__webpack_require__.d(lib_namespaceObject, \\\"eventListeners\\\", function() { return eventListeners; });\\n__webpack_require__.d(lib_namespaceObject, \\\"flip\\\", function() { return modifiers_flip; });\\n__webpack_require__.d(lib_namespaceObject, \\\"hide\\\", function() { return modifiers_hide; });\\n__webpack_require__.d(lib_namespaceObject, \\\"offset\\\", function() { return modifiers_offset; });\\n__webpack_require__.d(lib_namespaceObject, \\\"popperOffsets\\\", function() { return modifiers_popperOffsets; });\\n__webpack_require__.d(lib_namespaceObject, \\\"preventOverflow\\\", function() { return modifiers_preventOverflow; });\\n__webpack_require__.d(lib_namespaceObject, \\\"popperGenerator\\\", function() { return popperGenerator; });\\n__webpack_require__.d(lib_namespaceObject, \\\"detectOverflow\\\", function() { return detectOverflow; });\\n__webpack_require__.d(lib_namespaceObject, \\\"createPopperBase\\\", function() { return createPopper_createPopper; });\\n__webpack_require__.d(lib_namespaceObject, \\\"createPopper\\\", function() { return popper_createPopper; });\\n__webpack_require__.d(lib_namespaceObject, \\\"createPopperLite\\\", function() { return popper_lite_createPopper; });\\n\\n// EXTERNAL MODULE: ./css/app.scss\\nvar app = __webpack_require__(4);\\n\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/enums.js\\nvar enums_top = 'top';\\nvar bottom = 'bottom';\\nvar right = 'right';\\nvar left = 'left';\\nvar auto = 'auto';\\nvar basePlacements = [enums_top, bottom, right, left];\\nvar start = 'start';\\nvar end = 'end';\\nvar enums_clippingParents = 'clippingParents';\\nvar viewport = 'viewport';\\nvar enums_popper = 'popper';\\nvar enums_reference = 'reference';\\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\\n  return acc.concat([placement + \\\"-\\\" + start, placement + \\\"-\\\" + end]);\\n}, []);\\nvar enums_placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\\n  return acc.concat([placement, placement + \\\"-\\\" + start, placement + \\\"-\\\" + end]);\\n}, []); // modifiers that need to read the DOM\\n\\nvar beforeRead = 'beforeRead';\\nvar read = 'read';\\nvar afterRead = 'afterRead'; // pure-logic modifiers\\n\\nvar beforeMain = 'beforeMain';\\nvar main = 'main';\\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\\n\\nvar beforeWrite = 'beforeWrite';\\nvar write = 'write';\\nvar afterWrite = 'afterWrite';\\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\\nfunction getNodeName(element) {\\n  return element ? (element.nodeName || '').toLowerCase() : null;\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\\nfunction getWindow(node) {\\n  if (node == null) {\\n    return window;\\n  }\\n\\n  if (node.toString() !== '[object Window]') {\\n    var ownerDocument = node.ownerDocument;\\n    return ownerDocument ? ownerDocument.defaultView || window : window;\\n  }\\n\\n  return node;\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\\n\\n\\nfunction isElement(node) {\\n  var OwnElement = getWindow(node).Element;\\n  return node instanceof OwnElement || node instanceof Element;\\n}\\n\\nfunction isHTMLElement(node) {\\n  var OwnElement = getWindow(node).HTMLElement;\\n  return node instanceof OwnElement || node instanceof HTMLElement;\\n}\\n\\nfunction isShadowRoot(node) {\\n  // IE 11 has no ShadowRoot\\n  if (typeof ShadowRoot === 'undefined') {\\n    return false;\\n  }\\n\\n  var OwnElement = getWindow(node).ShadowRoot;\\n  return node instanceof OwnElement || node instanceof ShadowRoot;\\n}\\n\\n\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\\n\\n // This modifier takes the styles prepared by the `computeStyles` modifier\\n// and applies them to the HTMLElements such as popper and arrow\\n\\nfunction applyStyles(_ref) {\\n  var state = _ref.state;\\n  Object.keys(state.elements).forEach(function (name) {\\n    var style = state.styles[name] || {};\\n    var attributes = state.attributes[name] || {};\\n    var element = state.elements[name]; // arrow is optional + virtual elements\\n\\n    if (!isHTMLElement(element) || !getNodeName(element)) {\\n      return;\\n    } // Flow doesn't support to extend this property, but it's the most\\n    // effective way to apply styles to an HTMLElement\\n    // $FlowFixMe[cannot-write]\\n\\n\\n    Object.assign(element.style, style);\\n    Object.keys(attributes).forEach(function (name) {\\n      var value = attributes[name];\\n\\n      if (value === false) {\\n        element.removeAttribute(name);\\n      } else {\\n        element.setAttribute(name, value === true ? '' : value);\\n      }\\n    });\\n  });\\n}\\n\\nfunction effect(_ref2) {\\n  var state = _ref2.state;\\n  var initialStyles = {\\n    popper: {\\n      position: state.options.strategy,\\n      left: '0',\\n      top: '0',\\n      margin: '0'\\n    },\\n    arrow: {\\n      position: 'absolute'\\n    },\\n    reference: {}\\n  };\\n  Object.assign(state.elements.popper.style, initialStyles.popper);\\n  state.styles = initialStyles;\\n\\n  if (state.elements.arrow) {\\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\\n  }\\n\\n  return function () {\\n    Object.keys(state.elements).forEach(function (name) {\\n      var element = state.elements[name];\\n      var attributes = state.attributes[name] || {};\\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\\n\\n      var style = styleProperties.reduce(function (style, property) {\\n        style[property] = '';\\n        return style;\\n      }, {}); // arrow is optional + virtual elements\\n\\n      if (!isHTMLElement(element) || !getNodeName(element)) {\\n        return;\\n      }\\n\\n      Object.assign(element.style, style);\\n      Object.keys(attributes).forEach(function (attribute) {\\n        element.removeAttribute(attribute);\\n      });\\n    });\\n  };\\n} // eslint-disable-next-line import/no-unused-modules\\n\\n\\n/* harmony default export */ var modifiers_applyStyles = ({\\n  name: 'applyStyles',\\n  enabled: true,\\n  phase: 'write',\\n  fn: applyStyles,\\n  effect: effect,\\n  requires: ['computeStyles']\\n});\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\\n\\nfunction getBasePlacement(placement) {\\n  return placement.split('-')[0];\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\\nfunction getBoundingClientRect(element) {\\n  var rect = element.getBoundingClientRect();\\n  return {\\n    width: rect.width,\\n    height: rect.height,\\n    top: rect.top,\\n    right: rect.right,\\n    bottom: rect.bottom,\\n    left: rect.left,\\n    x: rect.left,\\n    y: rect.top\\n  };\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\\n // Returns the layout rect of an element relative to its offsetParent. Layout\\n// means it doesn't take into account transforms.\\n\\nfunction getLayoutRect(element) {\\n  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\\n\\n  var width = element.offsetWidth;\\n  var height = element.offsetHeight;\\n\\n  if (Math.abs(clientRect.width - width) <= 1) {\\n    width = clientRect.width;\\n  }\\n\\n  if (Math.abs(clientRect.height - height) <= 1) {\\n    height = clientRect.height;\\n  }\\n\\n  return {\\n    x: element.offsetLeft,\\n    y: element.offsetTop,\\n    width: width,\\n    height: height\\n  };\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/contains.js\\n\\nfunction contains(parent, child) {\\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\\n\\n  if (parent.contains(child)) {\\n    return true;\\n  } // then fallback to custom implementation with Shadow DOM support\\n  else if (rootNode && isShadowRoot(rootNode)) {\\n      var next = child;\\n\\n      do {\\n        if (next && parent.isSameNode(next)) {\\n          return true;\\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\\n\\n\\n        next = next.parentNode || next.host;\\n      } while (next);\\n    } // Give up, the result is false\\n\\n\\n  return false;\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\\n\\nfunction getComputedStyle_getComputedStyle(element) {\\n  return getWindow(element).getComputedStyle(element);\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\\n\\nfunction isTableElement(element) {\\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\\n\\nfunction getDocumentElement(element) {\\n  // $FlowFixMe[incompatible-return]: assume body is always available\\n  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\\n  element.document) || window.document).documentElement;\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\\n\\n\\n\\nfunction getParentNode(element) {\\n  if (getNodeName(element) === 'html') {\\n    return element;\\n  }\\n\\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\\n    // $FlowFixMe[incompatible-return]\\n    // $FlowFixMe[prop-missing]\\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\\n    element.parentNode || ( // DOM Element detected\\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\\n    getDocumentElement(element) // fallback\\n\\n  );\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\\n\\n\\n\\n\\n\\n\\n\\nfunction getTrueOffsetParent(element) {\\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\\n  getComputedStyle_getComputedStyle(element).position === 'fixed') {\\n    return null;\\n  }\\n\\n  return element.offsetParent;\\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\\n// return the containing block\\n\\n\\nfunction getContainingBlock(element) {\\n  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\\n  var currentNode = getParentNode(element);\\n\\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\\n    var css = getComputedStyle_getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\\n    // create a containing block.\\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\\n\\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\\n      return currentNode;\\n    } else {\\n      currentNode = currentNode.parentNode;\\n    }\\n  }\\n\\n  return null;\\n} // Gets the closest ancestor positioned element. Handles some edge cases,\\n// such as table ancestors and cross browser bugs.\\n\\n\\nfunction getOffsetParent(element) {\\n  var window = getWindow(element);\\n  var offsetParent = getTrueOffsetParent(element);\\n\\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle_getComputedStyle(offsetParent).position === 'static') {\\n    offsetParent = getTrueOffsetParent(offsetParent);\\n  }\\n\\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle_getComputedStyle(offsetParent).position === 'static')) {\\n    return window;\\n  }\\n\\n  return offsetParent || getContainingBlock(element) || window;\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\\nfunction getMainAxisFromPlacement(placement) {\\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/math.js\\nvar math_max = Math.max;\\nvar math_min = Math.min;\\nvar round = Math.round;\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/within.js\\n\\nfunction within(min, value, max) {\\n  return math_max(min, math_min(value, max));\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\\nfunction getFreshSideObject() {\\n  return {\\n    top: 0,\\n    right: 0,\\n    bottom: 0,\\n    left: 0\\n  };\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\\n\\nfunction mergePaddingObject(paddingObject) {\\n  return Object.assign({}, getFreshSideObject(), paddingObject);\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\\nfunction expandToHashMap(value, keys) {\\n  return keys.reduce(function (hashMap, key) {\\n    hashMap[key] = value;\\n    return hashMap;\\n  }, {});\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/arrow.js\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n // eslint-disable-next-line import/no-unused-modules\\n\\nvar arrow_toPaddingObject = function toPaddingObject(padding, state) {\\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\\n    placement: state.placement\\n  })) : padding;\\n  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\\n};\\n\\nfunction arrow(_ref) {\\n  var _state$modifiersData$;\\n\\n  var state = _ref.state,\\n      name = _ref.name,\\n      options = _ref.options;\\n  var arrowElement = state.elements.arrow;\\n  var popperOffsets = state.modifiersData.popperOffsets;\\n  var basePlacement = getBasePlacement(state.placement);\\n  var axis = getMainAxisFromPlacement(basePlacement);\\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\\n  var len = isVertical ? 'height' : 'width';\\n\\n  if (!arrowElement || !popperOffsets) {\\n    return;\\n  }\\n\\n  var paddingObject = arrow_toPaddingObject(options.padding, state);\\n  var arrowRect = getLayoutRect(arrowElement);\\n  var minProp = axis === 'y' ? enums_top : left;\\n  var maxProp = axis === 'y' ? bottom : right;\\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\\n  var arrowOffsetParent = getOffsetParent(arrowElement);\\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\\n  // outside of the popper bounds\\n\\n  var min = paddingObject[minProp];\\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\\n\\n  var axisProp = axis;\\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\\n}\\n\\nfunction arrow_effect(_ref2) {\\n  var state = _ref2.state,\\n      options = _ref2.options;\\n  var _options$element = options.element,\\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\\n\\n  if (arrowElement == null) {\\n    return;\\n  } // CSS selector\\n\\n\\n  if (typeof arrowElement === 'string') {\\n    arrowElement = state.elements.popper.querySelector(arrowElement);\\n\\n    if (!arrowElement) {\\n      return;\\n    }\\n  }\\n\\n  if (false) {}\\n\\n  if (!contains(state.elements.popper, arrowElement)) {\\n    if (false) {}\\n\\n    return;\\n  }\\n\\n  state.elements.arrow = arrowElement;\\n} // eslint-disable-next-line import/no-unused-modules\\n\\n\\n/* harmony default export */ var modifiers_arrow = ({\\n  name: 'arrow',\\n  enabled: true,\\n  phase: 'main',\\n  fn: arrow,\\n  effect: arrow_effect,\\n  requires: ['popperOffsets'],\\n  requiresIfExists: ['preventOverflow']\\n});\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\\n\\n\\n\\n\\n\\n\\n // eslint-disable-next-line import/no-unused-modules\\n\\nvar unsetSides = {\\n  top: 'auto',\\n  right: 'auto',\\n  bottom: 'auto',\\n  left: 'auto'\\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\\n// Zooming can change the DPR, but it seems to report a value that will\\n// cleanly divide the values into the appropriate subpixels.\\n\\nfunction roundOffsetsByDPR(_ref) {\\n  var x = _ref.x,\\n      y = _ref.y;\\n  var win = window;\\n  var dpr = win.devicePixelRatio || 1;\\n  return {\\n    x: round(round(x * dpr) / dpr) || 0,\\n    y: round(round(y * dpr) / dpr) || 0\\n  };\\n}\\n\\nfunction mapToStyles(_ref2) {\\n  var _Object$assign2;\\n\\n  var popper = _ref2.popper,\\n      popperRect = _ref2.popperRect,\\n      placement = _ref2.placement,\\n      offsets = _ref2.offsets,\\n      position = _ref2.position,\\n      gpuAcceleration = _ref2.gpuAcceleration,\\n      adaptive = _ref2.adaptive,\\n      roundOffsets = _ref2.roundOffsets;\\n\\n  var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,\\n      _ref3$x = _ref3.x,\\n      x = _ref3$x === void 0 ? 0 : _ref3$x,\\n      _ref3$y = _ref3.y,\\n      y = _ref3$y === void 0 ? 0 : _ref3$y;\\n\\n  var hasX = offsets.hasOwnProperty('x');\\n  var hasY = offsets.hasOwnProperty('y');\\n  var sideX = left;\\n  var sideY = enums_top;\\n  var win = window;\\n\\n  if (adaptive) {\\n    var offsetParent = getOffsetParent(popper);\\n    var heightProp = 'clientHeight';\\n    var widthProp = 'clientWidth';\\n\\n    if (offsetParent === getWindow(popper)) {\\n      offsetParent = getDocumentElement(popper);\\n\\n      if (getComputedStyle_getComputedStyle(offsetParent).position !== 'static') {\\n        heightProp = 'scrollHeight';\\n        widthProp = 'scrollWidth';\\n      }\\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\\n\\n\\n    offsetParent = offsetParent;\\n\\n    if (placement === enums_top) {\\n      sideY = bottom; // $FlowFixMe[prop-missing]\\n\\n      y -= offsetParent[heightProp] - popperRect.height;\\n      y *= gpuAcceleration ? 1 : -1;\\n    }\\n\\n    if (placement === left) {\\n      sideX = right; // $FlowFixMe[prop-missing]\\n\\n      x -= offsetParent[widthProp] - popperRect.width;\\n      x *= gpuAcceleration ? 1 : -1;\\n    }\\n  }\\n\\n  var commonStyles = Object.assign({\\n    position: position\\n  }, adaptive && unsetSides);\\n\\n  if (gpuAcceleration) {\\n    var _Object$assign;\\n\\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \\\"translate(\\\" + x + \\\"px, \\\" + y + \\\"px)\\\" : \\\"translate3d(\\\" + x + \\\"px, \\\" + y + \\\"px, 0)\\\", _Object$assign));\\n  }\\n\\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \\\"px\\\" : '', _Object$assign2[sideX] = hasX ? x + \\\"px\\\" : '', _Object$assign2.transform = '', _Object$assign2));\\n}\\n\\nfunction computeStyles(_ref4) {\\n  var state = _ref4.state,\\n      options = _ref4.options;\\n  var _options$gpuAccelerat = options.gpuAcceleration,\\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\\n      _options$adaptive = options.adaptive,\\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\\n      _options$roundOffsets = options.roundOffsets,\\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\\n\\n  if (false) { var transitionProperty; }\\n\\n  var commonStyles = {\\n    placement: getBasePlacement(state.placement),\\n    popper: state.elements.popper,\\n    popperRect: state.rects.popper,\\n    gpuAcceleration: gpuAcceleration\\n  };\\n\\n  if (state.modifiersData.popperOffsets != null) {\\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\\n      offsets: state.modifiersData.popperOffsets,\\n      position: state.options.strategy,\\n      adaptive: adaptive,\\n      roundOffsets: roundOffsets\\n    })));\\n  }\\n\\n  if (state.modifiersData.arrow != null) {\\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\\n      offsets: state.modifiersData.arrow,\\n      position: 'absolute',\\n      adaptive: false,\\n      roundOffsets: roundOffsets\\n    })));\\n  }\\n\\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\\n    'data-popper-placement': state.placement\\n  });\\n} // eslint-disable-next-line import/no-unused-modules\\n\\n\\n/* harmony default export */ var modifiers_computeStyles = ({\\n  name: 'computeStyles',\\n  enabled: true,\\n  phase: 'beforeWrite',\\n  fn: computeStyles,\\n  data: {}\\n});\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\\n // eslint-disable-next-line import/no-unused-modules\\n\\nvar passive = {\\n  passive: true\\n};\\n\\nfunction eventListeners_effect(_ref) {\\n  var state = _ref.state,\\n      instance = _ref.instance,\\n      options = _ref.options;\\n  var _options$scroll = options.scroll,\\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\\n      _options$resize = options.resize,\\n      resize = _options$resize === void 0 ? true : _options$resize;\\n  var window = getWindow(state.elements.popper);\\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\\n\\n  if (scroll) {\\n    scrollParents.forEach(function (scrollParent) {\\n      scrollParent.addEventListener('scroll', instance.update, passive);\\n    });\\n  }\\n\\n  if (resize) {\\n    window.addEventListener('resize', instance.update, passive);\\n  }\\n\\n  return function () {\\n    if (scroll) {\\n      scrollParents.forEach(function (scrollParent) {\\n        scrollParent.removeEventListener('scroll', instance.update, passive);\\n      });\\n    }\\n\\n    if (resize) {\\n      window.removeEventListener('resize', instance.update, passive);\\n    }\\n  };\\n} // eslint-disable-next-line import/no-unused-modules\\n\\n\\n/* harmony default export */ var eventListeners = ({\\n  name: 'eventListeners',\\n  enabled: true,\\n  phase: 'write',\\n  fn: function fn() {},\\n  effect: eventListeners_effect,\\n  data: {}\\n});\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\\nvar hash = {\\n  left: 'right',\\n  right: 'left',\\n  bottom: 'top',\\n  top: 'bottom'\\n};\\nfunction getOppositePlacement(placement) {\\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\\n    return hash[matched];\\n  });\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\\nvar getOppositeVariationPlacement_hash = {\\n  start: 'end',\\n  end: 'start'\\n};\\nfunction getOppositeVariationPlacement(placement) {\\n  return placement.replace(/start|end/g, function (matched) {\\n    return getOppositeVariationPlacement_hash[matched];\\n  });\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\\n\\nfunction getWindowScroll(node) {\\n  var win = getWindow(node);\\n  var scrollLeft = win.pageXOffset;\\n  var scrollTop = win.pageYOffset;\\n  return {\\n    scrollLeft: scrollLeft,\\n    scrollTop: scrollTop\\n  };\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\\n\\n\\n\\nfunction getWindowScrollBarX(element) {\\n  // If <html> has a CSS width greater than the viewport, then this will be\\n  // incorrect for RTL.\\n  // Popper 1 is broken in this case and never had a bug report so let's assume\\n  // it's not an issue. I don't think anyone ever specifies width on <html>\\n  // anyway.\\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\\n  // this (e.g. Edge 2019, IE11, Safari)\\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\\n\\n\\n\\nfunction getViewportRect(element) {\\n  var win = getWindow(element);\\n  var html = getDocumentElement(element);\\n  var visualViewport = win.visualViewport;\\n  var width = html.clientWidth;\\n  var height = html.clientHeight;\\n  var x = 0;\\n  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\\n  // can be obscured underneath it.\\n  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\\n  // if it isn't open, so if this isn't available, the popper will be detected\\n  // to overflow the bottom of the screen too early.\\n\\n  if (visualViewport) {\\n    width = visualViewport.width;\\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\\n    // errors due to floating point numbers, so we need to check precision.\\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\\n    // Feature detection fails in mobile emulation mode in Chrome.\\n    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\\n    // 0.001\\n    // Fallback here: \\\"Not Safari\\\" userAgent\\n\\n    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\\n      x = visualViewport.offsetLeft;\\n      y = visualViewport.offsetTop;\\n    }\\n  }\\n\\n  return {\\n    width: width,\\n    height: height,\\n    x: x + getWindowScrollBarX(element),\\n    y: y\\n  };\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\\n\\n\\n\\n\\n // Gets the entire size of the scrollable document area, even extending outside\\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\\n\\nfunction getDocumentRect(element) {\\n  var _element$ownerDocumen;\\n\\n  var html = getDocumentElement(element);\\n  var winScroll = getWindowScroll(element);\\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\\n  var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\\n  var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\\n  var y = -winScroll.scrollTop;\\n\\n  if (getComputedStyle_getComputedStyle(body || html).direction === 'rtl') {\\n    x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;\\n  }\\n\\n  return {\\n    width: width,\\n    height: height,\\n    x: x,\\n    y: y\\n  };\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\\n\\nfunction isScrollParent(element) {\\n  // Firefox wants us to check `-x` and `-y` variations as well\\n  var _getComputedStyle = getComputedStyle_getComputedStyle(element),\\n      overflow = _getComputedStyle.overflow,\\n      overflowX = _getComputedStyle.overflowX,\\n      overflowY = _getComputedStyle.overflowY;\\n\\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\\n\\n\\n\\n\\nfunction getScrollParent(node) {\\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\\n    // $FlowFixMe[incompatible-return]: assume body is always available\\n    return node.ownerDocument.body;\\n  }\\n\\n  if (isHTMLElement(node) && isScrollParent(node)) {\\n    return node;\\n  }\\n\\n  return getScrollParent(getParentNode(node));\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\\n\\n\\n\\n\\n/*\\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\\nuntil we get to the top window object. This list is what we attach scroll listeners\\nto, because if any of these parent elements scroll, we'll need to re-calculate the\\nreference element's position.\\n*/\\n\\nfunction listScrollParents(element, list) {\\n  var _element$ownerDocumen;\\n\\n  if (list === void 0) {\\n    list = [];\\n  }\\n\\n  var scrollParent = getScrollParent(element);\\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\\n  var win = getWindow(scrollParent);\\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\\n  var updatedList = list.concat(target);\\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\\n  updatedList.concat(listScrollParents(getParentNode(target)));\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\\nfunction rectToClientRect(rect) {\\n  return Object.assign({}, rect, {\\n    left: rect.x,\\n    top: rect.y,\\n    right: rect.x + rect.width,\\n    bottom: rect.y + rect.height\\n  });\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfunction getInnerBoundingClientRect(element) {\\n  var rect = getBoundingClientRect(element);\\n  rect.top = rect.top + element.clientTop;\\n  rect.left = rect.left + element.clientLeft;\\n  rect.bottom = rect.top + element.clientHeight;\\n  rect.right = rect.left + element.clientWidth;\\n  rect.width = element.clientWidth;\\n  rect.height = element.clientHeight;\\n  rect.x = rect.left;\\n  rect.y = rect.top;\\n  return rect;\\n}\\n\\nfunction getClientRectFromMixedType(element, clippingParent) {\\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\\n} // A \\\"clipping parent\\\" is an overflowable container with the characteristic of\\n// clipping (or hiding) overflowing elements with a position different from\\n// `initial`\\n\\n\\nfunction getClippingParents(element) {\\n  var clippingParents = listScrollParents(getParentNode(element));\\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle_getComputedStyle(element).position) >= 0;\\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\\n\\n  if (!isElement(clipperElement)) {\\n    return [];\\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\\n\\n\\n  return clippingParents.filter(function (clippingParent) {\\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\\n  });\\n} // Gets the maximum area that the element is visible in due to any number of\\n// clipping parents\\n\\n\\nfunction getClippingRect(element, boundary, rootBoundary) {\\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\\n  var firstClippingParent = clippingParents[0];\\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\\n    var rect = getClientRectFromMixedType(element, clippingParent);\\n    accRect.top = math_max(rect.top, accRect.top);\\n    accRect.right = math_min(rect.right, accRect.right);\\n    accRect.bottom = math_min(rect.bottom, accRect.bottom);\\n    accRect.left = math_max(rect.left, accRect.left);\\n    return accRect;\\n  }, getClientRectFromMixedType(element, firstClippingParent));\\n  clippingRect.width = clippingRect.right - clippingRect.left;\\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\\n  clippingRect.x = clippingRect.left;\\n  clippingRect.y = clippingRect.top;\\n  return clippingRect;\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getVariation.js\\nfunction getVariation(placement) {\\n  return placement.split('-')[1];\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeOffsets.js\\n\\n\\n\\n\\nfunction computeOffsets(_ref) {\\n  var reference = _ref.reference,\\n      element = _ref.element,\\n      placement = _ref.placement;\\n  var basePlacement = placement ? getBasePlacement(placement) : null;\\n  var variation = placement ? getVariation(placement) : null;\\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\\n  var offsets;\\n\\n  switch (basePlacement) {\\n    case enums_top:\\n      offsets = {\\n        x: commonX,\\n        y: reference.y - element.height\\n      };\\n      break;\\n\\n    case bottom:\\n      offsets = {\\n        x: commonX,\\n        y: reference.y + reference.height\\n      };\\n      break;\\n\\n    case right:\\n      offsets = {\\n        x: reference.x + reference.width,\\n        y: commonY\\n      };\\n      break;\\n\\n    case left:\\n      offsets = {\\n        x: reference.x - element.width,\\n        y: commonY\\n      };\\n      break;\\n\\n    default:\\n      offsets = {\\n        x: reference.x,\\n        y: reference.y\\n      };\\n  }\\n\\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\\n\\n  if (mainAxis != null) {\\n    var len = mainAxis === 'y' ? 'height' : 'width';\\n\\n    switch (variation) {\\n      case start:\\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\\n        break;\\n\\n      case end:\\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\\n        break;\\n\\n      default:\\n    }\\n  }\\n\\n  return offsets;\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/detectOverflow.js\\n\\n\\n\\n\\n\\n\\n\\n\\n // eslint-disable-next-line import/no-unused-modules\\n\\nfunction detectOverflow(state, options) {\\n  if (options === void 0) {\\n    options = {};\\n  }\\n\\n  var _options = options,\\n      _options$placement = _options.placement,\\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\\n      _options$boundary = _options.boundary,\\n      boundary = _options$boundary === void 0 ? enums_clippingParents : _options$boundary,\\n      _options$rootBoundary = _options.rootBoundary,\\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\\n      _options$elementConte = _options.elementContext,\\n      elementContext = _options$elementConte === void 0 ? enums_popper : _options$elementConte,\\n      _options$altBoundary = _options.altBoundary,\\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\\n      _options$padding = _options.padding,\\n      padding = _options$padding === void 0 ? 0 : _options$padding;\\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\\n  var altContext = elementContext === enums_popper ? enums_reference : enums_popper;\\n  var referenceElement = state.elements.reference;\\n  var popperRect = state.rects.popper;\\n  var element = state.elements[altBoundary ? altContext : elementContext];\\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\\n  var referenceClientRect = getBoundingClientRect(referenceElement);\\n  var popperOffsets = computeOffsets({\\n    reference: referenceClientRect,\\n    element: popperRect,\\n    strategy: 'absolute',\\n    placement: placement\\n  });\\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\\n  var elementClientRect = elementContext === enums_popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\\n  // 0 or negative = within the clipping rect\\n\\n  var overflowOffsets = {\\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\\n  };\\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\\n\\n  if (elementContext === enums_popper && offsetData) {\\n    var offset = offsetData[placement];\\n    Object.keys(overflowOffsets).forEach(function (key) {\\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\\n      var axis = [enums_top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\\n      overflowOffsets[key] += offset[axis] * multiply;\\n    });\\n  }\\n\\n  return overflowOffsets;\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\\n\\n\\n\\n\\nfunction computeAutoPlacement(state, options) {\\n  if (options === void 0) {\\n    options = {};\\n  }\\n\\n  var _options = options,\\n      placement = _options.placement,\\n      boundary = _options.boundary,\\n      rootBoundary = _options.rootBoundary,\\n      padding = _options.padding,\\n      flipVariations = _options.flipVariations,\\n      _options$allowedAutoP = _options.allowedAutoPlacements,\\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;\\n  var variation = getVariation(placement);\\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\\n    return getVariation(placement) === variation;\\n  }) : basePlacements;\\n  var allowedPlacements = placements.filter(function (placement) {\\n    return allowedAutoPlacements.indexOf(placement) >= 0;\\n  });\\n\\n  if (allowedPlacements.length === 0) {\\n    allowedPlacements = placements;\\n\\n    if (false) {}\\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\\n\\n\\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\\n    acc[placement] = detectOverflow(state, {\\n      placement: placement,\\n      boundary: boundary,\\n      rootBoundary: rootBoundary,\\n      padding: padding\\n    })[getBasePlacement(placement)];\\n    return acc;\\n  }, {});\\n  return Object.keys(overflows).sort(function (a, b) {\\n    return overflows[a] - overflows[b];\\n  });\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/flip.js\\n\\n\\n\\n\\n\\n\\n // eslint-disable-next-line import/no-unused-modules\\n\\nfunction getExpandedFallbackPlacements(placement) {\\n  if (getBasePlacement(placement) === auto) {\\n    return [];\\n  }\\n\\n  var oppositePlacement = getOppositePlacement(placement);\\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\\n}\\n\\nfunction flip(_ref) {\\n  var state = _ref.state,\\n      options = _ref.options,\\n      name = _ref.name;\\n\\n  if (state.modifiersData[name]._skip) {\\n    return;\\n  }\\n\\n  var _options$mainAxis = options.mainAxis,\\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\\n      _options$altAxis = options.altAxis,\\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\\n      specifiedFallbackPlacements = options.fallbackPlacements,\\n      padding = options.padding,\\n      boundary = options.boundary,\\n      rootBoundary = options.rootBoundary,\\n      altBoundary = options.altBoundary,\\n      _options$flipVariatio = options.flipVariations,\\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\\n      allowedAutoPlacements = options.allowedAutoPlacements;\\n  var preferredPlacement = state.options.placement;\\n  var basePlacement = getBasePlacement(preferredPlacement);\\n  var isBasePlacement = basePlacement === preferredPlacement;\\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\\n      placement: placement,\\n      boundary: boundary,\\n      rootBoundary: rootBoundary,\\n      padding: padding,\\n      flipVariations: flipVariations,\\n      allowedAutoPlacements: allowedAutoPlacements\\n    }) : placement);\\n  }, []);\\n  var referenceRect = state.rects.reference;\\n  var popperRect = state.rects.popper;\\n  var checksMap = new Map();\\n  var makeFallbackChecks = true;\\n  var firstFittingPlacement = placements[0];\\n\\n  for (var i = 0; i < placements.length; i++) {\\n    var placement = placements[i];\\n\\n    var _basePlacement = getBasePlacement(placement);\\n\\n    var isStartVariation = getVariation(placement) === start;\\n    var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;\\n    var len = isVertical ? 'width' : 'height';\\n    var overflow = detectOverflow(state, {\\n      placement: placement,\\n      boundary: boundary,\\n      rootBoundary: rootBoundary,\\n      altBoundary: altBoundary,\\n      padding: padding\\n    });\\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;\\n\\n    if (referenceRect[len] > popperRect[len]) {\\n      mainVariationSide = getOppositePlacement(mainVariationSide);\\n    }\\n\\n    var altVariationSide = getOppositePlacement(mainVariationSide);\\n    var checks = [];\\n\\n    if (checkMainAxis) {\\n      checks.push(overflow[_basePlacement] <= 0);\\n    }\\n\\n    if (checkAltAxis) {\\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\\n    }\\n\\n    if (checks.every(function (check) {\\n      return check;\\n    })) {\\n      firstFittingPlacement = placement;\\n      makeFallbackChecks = false;\\n      break;\\n    }\\n\\n    checksMap.set(placement, checks);\\n  }\\n\\n  if (makeFallbackChecks) {\\n    // `2` may be desired in some cases – research later\\n    var numberOfChecks = flipVariations ? 3 : 1;\\n\\n    var _loop = function _loop(_i) {\\n      var fittingPlacement = placements.find(function (placement) {\\n        var checks = checksMap.get(placement);\\n\\n        if (checks) {\\n          return checks.slice(0, _i).every(function (check) {\\n            return check;\\n          });\\n        }\\n      });\\n\\n      if (fittingPlacement) {\\n        firstFittingPlacement = fittingPlacement;\\n        return \\\"break\\\";\\n      }\\n    };\\n\\n    for (var _i = numberOfChecks; _i > 0; _i--) {\\n      var _ret = _loop(_i);\\n\\n      if (_ret === \\\"break\\\") break;\\n    }\\n  }\\n\\n  if (state.placement !== firstFittingPlacement) {\\n    state.modifiersData[name]._skip = true;\\n    state.placement = firstFittingPlacement;\\n    state.reset = true;\\n  }\\n} // eslint-disable-next-line import/no-unused-modules\\n\\n\\n/* harmony default export */ var modifiers_flip = ({\\n  name: 'flip',\\n  enabled: true,\\n  phase: 'main',\\n  fn: flip,\\n  requiresIfExists: ['offset'],\\n  data: {\\n    _skip: false\\n  }\\n});\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/hide.js\\n\\n\\n\\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\\n  if (preventedOffsets === void 0) {\\n    preventedOffsets = {\\n      x: 0,\\n      y: 0\\n    };\\n  }\\n\\n  return {\\n    top: overflow.top - rect.height - preventedOffsets.y,\\n    right: overflow.right - rect.width + preventedOffsets.x,\\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\\n    left: overflow.left - rect.width - preventedOffsets.x\\n  };\\n}\\n\\nfunction isAnySideFullyClipped(overflow) {\\n  return [enums_top, right, bottom, left].some(function (side) {\\n    return overflow[side] >= 0;\\n  });\\n}\\n\\nfunction hide(_ref) {\\n  var state = _ref.state,\\n      name = _ref.name;\\n  var referenceRect = state.rects.reference;\\n  var popperRect = state.rects.popper;\\n  var preventedOffsets = state.modifiersData.preventOverflow;\\n  var referenceOverflow = detectOverflow(state, {\\n    elementContext: 'reference'\\n  });\\n  var popperAltOverflow = detectOverflow(state, {\\n    altBoundary: true\\n  });\\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\\n  state.modifiersData[name] = {\\n    referenceClippingOffsets: referenceClippingOffsets,\\n    popperEscapeOffsets: popperEscapeOffsets,\\n    isReferenceHidden: isReferenceHidden,\\n    hasPopperEscaped: hasPopperEscaped\\n  };\\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\\n    'data-popper-reference-hidden': isReferenceHidden,\\n    'data-popper-escaped': hasPopperEscaped\\n  });\\n} // eslint-disable-next-line import/no-unused-modules\\n\\n\\n/* harmony default export */ var modifiers_hide = ({\\n  name: 'hide',\\n  enabled: true,\\n  phase: 'main',\\n  requiresIfExists: ['preventOverflow'],\\n  fn: hide\\n});\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/offset.js\\n\\n\\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\\n  var basePlacement = getBasePlacement(placement);\\n  var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;\\n\\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\\n    placement: placement\\n  })) : offset,\\n      skidding = _ref[0],\\n      distance = _ref[1];\\n\\n  skidding = skidding || 0;\\n  distance = (distance || 0) * invertDistance;\\n  return [left, right].indexOf(basePlacement) >= 0 ? {\\n    x: distance,\\n    y: skidding\\n  } : {\\n    x: skidding,\\n    y: distance\\n  };\\n}\\n\\nfunction offset_offset(_ref2) {\\n  var state = _ref2.state,\\n      options = _ref2.options,\\n      name = _ref2.name;\\n  var _options$offset = options.offset,\\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\\n  var data = enums_placements.reduce(function (acc, placement) {\\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\\n    return acc;\\n  }, {});\\n  var _data$state$placement = data[state.placement],\\n      x = _data$state$placement.x,\\n      y = _data$state$placement.y;\\n\\n  if (state.modifiersData.popperOffsets != null) {\\n    state.modifiersData.popperOffsets.x += x;\\n    state.modifiersData.popperOffsets.y += y;\\n  }\\n\\n  state.modifiersData[name] = data;\\n} // eslint-disable-next-line import/no-unused-modules\\n\\n\\n/* harmony default export */ var modifiers_offset = ({\\n  name: 'offset',\\n  enabled: true,\\n  phase: 'main',\\n  requires: ['popperOffsets'],\\n  fn: offset_offset\\n});\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\\n\\n\\nfunction popperOffsets_popperOffsets(_ref) {\\n  var state = _ref.state,\\n      name = _ref.name;\\n  // Offsets are the actual position the popper needs to have to be\\n  // properly positioned near its reference element\\n  // This is the most basic placement, and will be adjusted by\\n  // the modifiers in the next step\\n  state.modifiersData[name] = computeOffsets({\\n    reference: state.rects.reference,\\n    element: state.rects.popper,\\n    strategy: 'absolute',\\n    placement: state.placement\\n  });\\n} // eslint-disable-next-line import/no-unused-modules\\n\\n\\n/* harmony default export */ var modifiers_popperOffsets = ({\\n  name: 'popperOffsets',\\n  enabled: true,\\n  phase: 'read',\\n  fn: popperOffsets_popperOffsets,\\n  data: {}\\n});\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getAltAxis.js\\nfunction getAltAxis(axis) {\\n  return axis === 'x' ? 'y' : 'x';\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfunction preventOverflow(_ref) {\\n  var state = _ref.state,\\n      options = _ref.options,\\n      name = _ref.name;\\n  var _options$mainAxis = options.mainAxis,\\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\\n      _options$altAxis = options.altAxis,\\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\\n      boundary = options.boundary,\\n      rootBoundary = options.rootBoundary,\\n      altBoundary = options.altBoundary,\\n      padding = options.padding,\\n      _options$tether = options.tether,\\n      tether = _options$tether === void 0 ? true : _options$tether,\\n      _options$tetherOffset = options.tetherOffset,\\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\\n  var overflow = detectOverflow(state, {\\n    boundary: boundary,\\n    rootBoundary: rootBoundary,\\n    padding: padding,\\n    altBoundary: altBoundary\\n  });\\n  var basePlacement = getBasePlacement(state.placement);\\n  var variation = getVariation(state.placement);\\n  var isBasePlacement = !variation;\\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\\n  var altAxis = getAltAxis(mainAxis);\\n  var popperOffsets = state.modifiersData.popperOffsets;\\n  var referenceRect = state.rects.reference;\\n  var popperRect = state.rects.popper;\\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\\n    placement: state.placement\\n  })) : tetherOffset;\\n  var data = {\\n    x: 0,\\n    y: 0\\n  };\\n\\n  if (!popperOffsets) {\\n    return;\\n  }\\n\\n  if (checkMainAxis || checkAltAxis) {\\n    var mainSide = mainAxis === 'y' ? enums_top : left;\\n    var altSide = mainAxis === 'y' ? bottom : right;\\n    var len = mainAxis === 'y' ? 'height' : 'width';\\n    var offset = popperOffsets[mainAxis];\\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\\n    var max = popperOffsets[mainAxis] - overflow[altSide];\\n    var additive = tether ? -popperRect[len] / 2 : 0;\\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\\n    // outside the reference bounds\\n\\n    var arrowElement = state.elements.arrow;\\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\\n      width: 0,\\n      height: 0\\n    };\\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\\n    // to include its full size in the calculation. If the reference is small\\n    // and near the edge of a boundary, the popper can overflow even if the\\n    // reference is not overflowing as well (e.g. virtual elements with no\\n    // width or height)\\n\\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\\n\\n    if (checkMainAxis) {\\n      var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);\\n      popperOffsets[mainAxis] = preventedOffset;\\n      data[mainAxis] = preventedOffset - offset;\\n    }\\n\\n    if (checkAltAxis) {\\n      var _mainSide = mainAxis === 'x' ? enums_top : left;\\n\\n      var _altSide = mainAxis === 'x' ? bottom : right;\\n\\n      var _offset = popperOffsets[altAxis];\\n\\n      var _min = _offset + overflow[_mainSide];\\n\\n      var _max = _offset - overflow[_altSide];\\n\\n      var _preventedOffset = within(tether ? math_min(_min, tetherMin) : _min, _offset, tether ? math_max(_max, tetherMax) : _max);\\n\\n      popperOffsets[altAxis] = _preventedOffset;\\n      data[altAxis] = _preventedOffset - _offset;\\n    }\\n  }\\n\\n  state.modifiersData[name] = data;\\n} // eslint-disable-next-line import/no-unused-modules\\n\\n\\n/* harmony default export */ var modifiers_preventOverflow = ({\\n  name: 'preventOverflow',\\n  enabled: true,\\n  phase: 'main',\\n  fn: preventOverflow,\\n  requiresIfExists: ['offset']\\n});\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/index.js\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\\nfunction getHTMLElementScroll(element) {\\n  return {\\n    scrollLeft: element.scrollLeft,\\n    scrollTop: element.scrollTop\\n  };\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\\n\\n\\n\\n\\nfunction getNodeScroll(node) {\\n  if (node === getWindow(node) || !isHTMLElement(node)) {\\n    return getWindowScroll(node);\\n  } else {\\n    return getHTMLElementScroll(node);\\n  }\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\\n\\n\\n\\n\\n\\n\\n // Returns the composite rect of an element relative to its offsetParent.\\n// Composite means it takes into account transforms as well as layout.\\n\\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\\n  if (isFixed === void 0) {\\n    isFixed = false;\\n  }\\n\\n  var documentElement = getDocumentElement(offsetParent);\\n  var rect = getBoundingClientRect(elementOrVirtualElement);\\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\\n  var scroll = {\\n    scrollLeft: 0,\\n    scrollTop: 0\\n  };\\n  var offsets = {\\n    x: 0,\\n    y: 0\\n  };\\n\\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\\n    isScrollParent(documentElement)) {\\n      scroll = getNodeScroll(offsetParent);\\n    }\\n\\n    if (isHTMLElement(offsetParent)) {\\n      offsets = getBoundingClientRect(offsetParent);\\n      offsets.x += offsetParent.clientLeft;\\n      offsets.y += offsetParent.clientTop;\\n    } else if (documentElement) {\\n      offsets.x = getWindowScrollBarX(documentElement);\\n    }\\n  }\\n\\n  return {\\n    x: rect.left + scroll.scrollLeft - offsets.x,\\n    y: rect.top + scroll.scrollTop - offsets.y,\\n    width: rect.width,\\n    height: rect.height\\n  };\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/orderModifiers.js\\n // source: https://stackoverflow.com/questions/49875255\\n\\nfunction order(modifiers) {\\n  var map = new Map();\\n  var visited = new Set();\\n  var result = [];\\n  modifiers.forEach(function (modifier) {\\n    map.set(modifier.name, modifier);\\n  }); // On visiting object, check for its dependencies and visit them recursively\\n\\n  function sort(modifier) {\\n    visited.add(modifier.name);\\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\\n    requires.forEach(function (dep) {\\n      if (!visited.has(dep)) {\\n        var depModifier = map.get(dep);\\n\\n        if (depModifier) {\\n          sort(depModifier);\\n        }\\n      }\\n    });\\n    result.push(modifier);\\n  }\\n\\n  modifiers.forEach(function (modifier) {\\n    if (!visited.has(modifier.name)) {\\n      // check for visited object\\n      sort(modifier);\\n    }\\n  });\\n  return result;\\n}\\n\\nfunction orderModifiers(modifiers) {\\n  // order based on dependencies\\n  var orderedModifiers = order(modifiers); // order based on phase\\n\\n  return modifierPhases.reduce(function (acc, phase) {\\n    return acc.concat(orderedModifiers.filter(function (modifier) {\\n      return modifier.phase === phase;\\n    }));\\n  }, []);\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/debounce.js\\nfunction debounce(fn) {\\n  var pending;\\n  return function () {\\n    if (!pending) {\\n      pending = new Promise(function (resolve) {\\n        Promise.resolve().then(function () {\\n          pending = undefined;\\n          resolve(fn());\\n        });\\n      });\\n    }\\n\\n    return pending;\\n  };\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergeByName.js\\nfunction mergeByName(modifiers) {\\n  var merged = modifiers.reduce(function (merged, current) {\\n    var existing = merged[current.name];\\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\\n      options: Object.assign({}, existing.options, current.options),\\n      data: Object.assign({}, existing.data, current.data)\\n    }) : current;\\n    return merged;\\n  }, {}); // IE11 does not support Object.values\\n\\n  return Object.keys(merged).map(function (key) {\\n    return merged[key];\\n  });\\n}\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/createPopper.js\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\\nvar DEFAULT_OPTIONS = {\\n  placement: 'bottom',\\n  modifiers: [],\\n  strategy: 'absolute'\\n};\\n\\nfunction areValidElements() {\\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\\n    args[_key] = arguments[_key];\\n  }\\n\\n  return !args.some(function (element) {\\n    return !(element && typeof element.getBoundingClientRect === 'function');\\n  });\\n}\\n\\nfunction popperGenerator(generatorOptions) {\\n  if (generatorOptions === void 0) {\\n    generatorOptions = {};\\n  }\\n\\n  var _generatorOptions = generatorOptions,\\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\\n  return function createPopper(reference, popper, options) {\\n    if (options === void 0) {\\n      options = defaultOptions;\\n    }\\n\\n    var state = {\\n      placement: 'bottom',\\n      orderedModifiers: [],\\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\\n      modifiersData: {},\\n      elements: {\\n        reference: reference,\\n        popper: popper\\n      },\\n      attributes: {},\\n      styles: {}\\n    };\\n    var effectCleanupFns = [];\\n    var isDestroyed = false;\\n    var instance = {\\n      state: state,\\n      setOptions: function setOptions(options) {\\n        cleanupModifierEffects();\\n        state.options = Object.assign({}, defaultOptions, state.options, options);\\n        state.scrollParents = {\\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\\n          popper: listScrollParents(popper)\\n        }; // Orders the modifiers based on their dependencies and `phase`\\n        // properties\\n\\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\\n\\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\\n          return m.enabled;\\n        }); // Validate the provided modifiers so that the consumer will get warned\\n        // if one of the modifiers is invalid for any reason\\n\\n        if (false) { var _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, flipModifier, modifiers; }\\n\\n        runModifierEffects();\\n        return instance.update();\\n      },\\n      // Sync update – it will always be executed, even if not necessary. This\\n      // is useful for low frequency updates where sync behavior simplifies the\\n      // logic.\\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\\n      // prefer the async Popper#update method\\n      forceUpdate: function forceUpdate() {\\n        if (isDestroyed) {\\n          return;\\n        }\\n\\n        var _state$elements = state.elements,\\n            reference = _state$elements.reference,\\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\\n        // anymore\\n\\n        if (!areValidElements(reference, popper)) {\\n          if (false) {}\\n\\n          return;\\n        } // Store the reference and popper rects to be read by modifiers\\n\\n\\n        state.rects = {\\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\\n          popper: getLayoutRect(popper)\\n        }; // Modifiers have the ability to reset the current update cycle. The\\n        // most common use case for this is the `flip` modifier changing the\\n        // placement, which then needs to re-run all the modifiers, because the\\n        // logic was previously ran for the previous placement and is therefore\\n        // stale/incorrect\\n\\n        state.reset = false;\\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\\n        // is filled with the initial data specified by the modifier. This means\\n        // it doesn't persist and is fresh on each update.\\n        // To ensure persistent data, use `${name}#persistent`\\n\\n        state.orderedModifiers.forEach(function (modifier) {\\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\\n        });\\n        var __debug_loops__ = 0;\\n\\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\\n          if (false) {}\\n\\n          if (state.reset === true) {\\n            state.reset = false;\\n            index = -1;\\n            continue;\\n          }\\n\\n          var _state$orderedModifie = state.orderedModifiers[index],\\n              fn = _state$orderedModifie.fn,\\n              _state$orderedModifie2 = _state$orderedModifie.options,\\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\\n              name = _state$orderedModifie.name;\\n\\n          if (typeof fn === 'function') {\\n            state = fn({\\n              state: state,\\n              options: _options,\\n              name: name,\\n              instance: instance\\n            }) || state;\\n          }\\n        }\\n      },\\n      // Async and optimistically optimized update – it will not be executed if\\n      // not necessary (debounced to run at most once-per-tick)\\n      update: debounce(function () {\\n        return new Promise(function (resolve) {\\n          instance.forceUpdate();\\n          resolve(state);\\n        });\\n      }),\\n      destroy: function destroy() {\\n        cleanupModifierEffects();\\n        isDestroyed = true;\\n      }\\n    };\\n\\n    if (!areValidElements(reference, popper)) {\\n      if (false) {}\\n\\n      return instance;\\n    }\\n\\n    instance.setOptions(options).then(function (state) {\\n      if (!isDestroyed && options.onFirstUpdate) {\\n        options.onFirstUpdate(state);\\n      }\\n    }); // Modifiers have the ability to execute arbitrary code before the first\\n    // update cycle runs. They will be executed in the same order as the update\\n    // cycle. This is useful when a modifier adds some persistent data that\\n    // other modifiers need to use, but the modifier is run after the dependent\\n    // one.\\n\\n    function runModifierEffects() {\\n      state.orderedModifiers.forEach(function (_ref3) {\\n        var name = _ref3.name,\\n            _ref3$options = _ref3.options,\\n            options = _ref3$options === void 0 ? {} : _ref3$options,\\n            effect = _ref3.effect;\\n\\n        if (typeof effect === 'function') {\\n          var cleanupFn = effect({\\n            state: state,\\n            name: name,\\n            instance: instance,\\n            options: options\\n          });\\n\\n          var noopFn = function noopFn() {};\\n\\n          effectCleanupFns.push(cleanupFn || noopFn);\\n        }\\n      });\\n    }\\n\\n    function cleanupModifierEffects() {\\n      effectCleanupFns.forEach(function (fn) {\\n        return fn();\\n      });\\n      effectCleanupFns = [];\\n    }\\n\\n    return instance;\\n  };\\n}\\nvar createPopper_createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\\n\\n\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/popper.js\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar popper_defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];\\nvar popper_createPopper = /*#__PURE__*/popperGenerator({\\n  defaultModifiers: popper_defaultModifiers\\n}); // eslint-disable-next-line import/no-unused-modules\\n\\n // eslint-disable-next-line import/no-unused-modules\\n\\n // eslint-disable-next-line import/no-unused-modules\\n\\n\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/popper-lite.js\\n\\n\\n\\n\\n\\nvar popper_lite_defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles];\\nvar popper_lite_createPopper = /*#__PURE__*/popperGenerator({\\n  defaultModifiers: popper_lite_defaultModifiers\\n}); // eslint-disable-next-line import/no-unused-modules\\n\\n\\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/index.js\\n\\n // eslint-disable-next-line import/no-unused-modules\\n\\n // eslint-disable-next-line import/no-unused-modules\\n\\n // eslint-disable-next-line import/no-unused-modules\\n\\n\\n// CONCATENATED MODULE: ./node_modules/bootstrap/dist/js/bootstrap.esm.js\\n/*!\\n  * Bootstrap v5.0.0-beta3 (https://getbootstrap.com/)\\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n  */\\n\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): util/index.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\nconst MAX_UID = 1000000;\\nconst MILLISECONDS_MULTIPLIER = 1000;\\nconst TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\\n\\nconst toType = obj => {\\n  if (obj === null || obj === undefined) {\\n    return `${obj}`;\\n  }\\n\\n  return {}.toString.call(obj).match(/\\\\s([a-z]+)/i)[1].toLowerCase();\\n};\\n/**\\n * --------------------------------------------------------------------------\\n * Public Util Api\\n * --------------------------------------------------------------------------\\n */\\n\\n\\nconst getUID = prefix => {\\n  do {\\n    prefix += Math.floor(Math.random() * MAX_UID);\\n  } while (document.getElementById(prefix));\\n\\n  return prefix;\\n};\\n\\nconst getSelector = element => {\\n  let selector = element.getAttribute('data-bs-target');\\n\\n  if (!selector || selector === '#') {\\n    let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,\\n    // so everything starting with `#` or `.`. If a \\\"real\\\" URL is used as the selector,\\n    // `document.querySelector` will rightfully complain it is invalid.\\n    // See https://github.com/twbs/bootstrap/issues/32273\\n\\n    if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {\\n      return null;\\n    } // Just in case some CMS puts out a full URL with the anchor appended\\n\\n\\n    if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {\\n      hrefAttr = '#' + hrefAttr.split('#')[1];\\n    }\\n\\n    selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;\\n  }\\n\\n  return selector;\\n};\\n\\nconst getSelectorFromElement = element => {\\n  const selector = getSelector(element);\\n\\n  if (selector) {\\n    return document.querySelector(selector) ? selector : null;\\n  }\\n\\n  return null;\\n};\\n\\nconst getElementFromSelector = element => {\\n  const selector = getSelector(element);\\n  return selector ? document.querySelector(selector) : null;\\n};\\n\\nconst getTransitionDurationFromElement = element => {\\n  if (!element) {\\n    return 0;\\n  } // Get transition-duration of the element\\n\\n\\n  let {\\n    transitionDuration,\\n    transitionDelay\\n  } = window.getComputedStyle(element);\\n  const floatTransitionDuration = Number.parseFloat(transitionDuration);\\n  const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\\n\\n  if (!floatTransitionDuration && !floatTransitionDelay) {\\n    return 0;\\n  } // If multiple durations are defined, take the first\\n\\n\\n  transitionDuration = transitionDuration.split(',')[0];\\n  transitionDelay = transitionDelay.split(',')[0];\\n  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\\n};\\n\\nconst triggerTransitionEnd = element => {\\n  element.dispatchEvent(new Event(TRANSITION_END));\\n};\\n\\nconst bootstrap_esm_isElement = obj => (obj[0] || obj).nodeType;\\n\\nconst emulateTransitionEnd = (element, duration) => {\\n  let called = false;\\n  const durationPadding = 5;\\n  const emulatedDuration = duration + durationPadding;\\n\\n  function listener() {\\n    called = true;\\n    element.removeEventListener(TRANSITION_END, listener);\\n  }\\n\\n  element.addEventListener(TRANSITION_END, listener);\\n  setTimeout(() => {\\n    if (!called) {\\n      triggerTransitionEnd(element);\\n    }\\n  }, emulatedDuration);\\n};\\n\\nconst typeCheckConfig = (componentName, config, configTypes) => {\\n  Object.keys(configTypes).forEach(property => {\\n    const expectedTypes = configTypes[property];\\n    const value = config[property];\\n    const valueType = value && bootstrap_esm_isElement(value) ? 'element' : toType(value);\\n\\n    if (!new RegExp(expectedTypes).test(valueType)) {\\n      throw new TypeError(`${componentName.toUpperCase()}: ` + `Option \\\"${property}\\\" provided type \\\"${valueType}\\\" ` + `but expected type \\\"${expectedTypes}\\\".`);\\n    }\\n  });\\n};\\n\\nconst isVisible = element => {\\n  if (!element) {\\n    return false;\\n  }\\n\\n  if (element.style && element.parentNode && element.parentNode.style) {\\n    const elementStyle = getComputedStyle(element);\\n    const parentNodeStyle = getComputedStyle(element.parentNode);\\n    return elementStyle.display !== 'none' && parentNodeStyle.display !== 'none' && elementStyle.visibility !== 'hidden';\\n  }\\n\\n  return false;\\n};\\n\\nconst isDisabled = element => {\\n  if (!element || element.nodeType !== Node.ELEMENT_NODE) {\\n    return true;\\n  }\\n\\n  if (element.classList.contains('disabled')) {\\n    return true;\\n  }\\n\\n  if (typeof element.disabled !== 'undefined') {\\n    return element.disabled;\\n  }\\n\\n  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\\n};\\n\\nconst findShadowRoot = element => {\\n  if (!document.documentElement.attachShadow) {\\n    return null;\\n  } // Can find the shadow root otherwise it'll return the document\\n\\n\\n  if (typeof element.getRootNode === 'function') {\\n    const root = element.getRootNode();\\n    return root instanceof ShadowRoot ? root : null;\\n  }\\n\\n  if (element instanceof ShadowRoot) {\\n    return element;\\n  } // when we don't find a shadow root\\n\\n\\n  if (!element.parentNode) {\\n    return null;\\n  }\\n\\n  return findShadowRoot(element.parentNode);\\n};\\n\\nconst noop = () => function () {};\\n\\nconst reflow = element => element.offsetHeight;\\n\\nconst getjQuery = () => {\\n  const {\\n    jQuery\\n  } = window;\\n\\n  if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\\n    return jQuery;\\n  }\\n\\n  return null;\\n};\\n\\nconst onDOMContentLoaded = callback => {\\n  if (document.readyState === 'loading') {\\n    document.addEventListener('DOMContentLoaded', callback);\\n  } else {\\n    callback();\\n  }\\n};\\n\\nconst isRTL = () => document.documentElement.dir === 'rtl';\\n\\nconst defineJQueryPlugin = (name, plugin) => {\\n  onDOMContentLoaded(() => {\\n    const $ = getjQuery();\\n    /* istanbul ignore if */\\n\\n    if ($) {\\n      const JQUERY_NO_CONFLICT = $.fn[name];\\n      $.fn[name] = plugin.jQueryInterface;\\n      $.fn[name].Constructor = plugin;\\n\\n      $.fn[name].noConflict = () => {\\n        $.fn[name] = JQUERY_NO_CONFLICT;\\n        return plugin.jQueryInterface;\\n      };\\n    }\\n  });\\n};\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): dom/data.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\nconst elementMap = new Map();\\nvar Data = {\\n  set(element, key, instance) {\\n    if (!elementMap.has(element)) {\\n      elementMap.set(element, new Map());\\n    }\\n\\n    const instanceMap = elementMap.get(element); // make it clear we only want one instance per element\\n    // can be removed later when multiple key/instances are fine to be used\\n\\n    if (!instanceMap.has(key) && instanceMap.size !== 0) {\\n      // eslint-disable-next-line no-console\\n      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\\n      return;\\n    }\\n\\n    instanceMap.set(key, instance);\\n  },\\n\\n  get(element, key) {\\n    if (elementMap.has(element)) {\\n      return elementMap.get(element).get(key) || null;\\n    }\\n\\n    return null;\\n  },\\n\\n  remove(element, key) {\\n    if (!elementMap.has(element)) {\\n      return;\\n    }\\n\\n    const instanceMap = elementMap.get(element);\\n    instanceMap.delete(key); // free up element references if there are no instances left for an element\\n\\n    if (instanceMap.size === 0) {\\n      elementMap.delete(element);\\n    }\\n  }\\n\\n};\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): dom/event-handler.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst namespaceRegex = /[^.]*(?=\\\\..*)\\\\.|.*/;\\nconst stripNameRegex = /\\\\..*/;\\nconst stripUidRegex = /::\\\\d+$/;\\nconst eventRegistry = {}; // Events storage\\n\\nlet uidEvent = 1;\\nconst customEvents = {\\n  mouseenter: 'mouseover',\\n  mouseleave: 'mouseout'\\n};\\nconst nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\\n/**\\n * ------------------------------------------------------------------------\\n * Private methods\\n * ------------------------------------------------------------------------\\n */\\n\\nfunction getUidEvent(element, uid) {\\n  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\\n}\\n\\nfunction getEvent(element) {\\n  const uid = getUidEvent(element);\\n  element.uidEvent = uid;\\n  eventRegistry[uid] = eventRegistry[uid] || {};\\n  return eventRegistry[uid];\\n}\\n\\nfunction bootstrapHandler(element, fn) {\\n  return function handler(event) {\\n    event.delegateTarget = element;\\n\\n    if (handler.oneOff) {\\n      EventHandler.off(element, event.type, fn);\\n    }\\n\\n    return fn.apply(element, [event]);\\n  };\\n}\\n\\nfunction bootstrapDelegationHandler(element, selector, fn) {\\n  return function handler(event) {\\n    const domElements = element.querySelectorAll(selector);\\n\\n    for (let {\\n      target\\n    } = event; target && target !== this; target = target.parentNode) {\\n      for (let i = domElements.length; i--;) {\\n        if (domElements[i] === target) {\\n          event.delegateTarget = target;\\n\\n          if (handler.oneOff) {\\n            // eslint-disable-next-line unicorn/consistent-destructuring\\n            EventHandler.off(element, event.type, fn);\\n          }\\n\\n          return fn.apply(target, [event]);\\n        }\\n      }\\n    } // To please ESLint\\n\\n\\n    return null;\\n  };\\n}\\n\\nfunction findHandler(events, handler, delegationSelector = null) {\\n  const uidEventList = Object.keys(events);\\n\\n  for (let i = 0, len = uidEventList.length; i < len; i++) {\\n    const event = events[uidEventList[i]];\\n\\n    if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {\\n      return event;\\n    }\\n  }\\n\\n  return null;\\n}\\n\\nfunction normalizeParams(originalTypeEvent, handler, delegationFn) {\\n  const delegation = typeof handler === 'string';\\n  const originalHandler = delegation ? delegationFn : handler; // allow to get the native events from namespaced events ('click.bs.button' --\\x3e 'click')\\n\\n  let typeEvent = originalTypeEvent.replace(stripNameRegex, '');\\n  const custom = customEvents[typeEvent];\\n\\n  if (custom) {\\n    typeEvent = custom;\\n  }\\n\\n  const isNative = nativeEvents.has(typeEvent);\\n\\n  if (!isNative) {\\n    typeEvent = originalTypeEvent;\\n  }\\n\\n  return [delegation, originalHandler, typeEvent];\\n}\\n\\nfunction addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {\\n  if (typeof originalTypeEvent !== 'string' || !element) {\\n    return;\\n  }\\n\\n  if (!handler) {\\n    handler = delegationFn;\\n    delegationFn = null;\\n  }\\n\\n  const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);\\n  const events = getEvent(element);\\n  const handlers = events[typeEvent] || (events[typeEvent] = {});\\n  const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);\\n\\n  if (previousFn) {\\n    previousFn.oneOff = previousFn.oneOff && oneOff;\\n    return;\\n  }\\n\\n  const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ''));\\n  const fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);\\n  fn.delegationSelector = delegation ? handler : null;\\n  fn.originalHandler = originalHandler;\\n  fn.oneOff = oneOff;\\n  fn.uidEvent = uid;\\n  handlers[uid] = fn;\\n  element.addEventListener(typeEvent, fn, delegation);\\n}\\n\\nfunction removeHandler(element, events, typeEvent, handler, delegationSelector) {\\n  const fn = findHandler(events[typeEvent], handler, delegationSelector);\\n\\n  if (!fn) {\\n    return;\\n  }\\n\\n  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\\n  delete events[typeEvent][fn.uidEvent];\\n}\\n\\nfunction removeNamespacedHandlers(element, events, typeEvent, namespace) {\\n  const storeElementEvent = events[typeEvent] || {};\\n  Object.keys(storeElementEvent).forEach(handlerKey => {\\n    if (handlerKey.includes(namespace)) {\\n      const event = storeElementEvent[handlerKey];\\n      removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);\\n    }\\n  });\\n}\\n\\nconst EventHandler = {\\n  on(element, event, handler, delegationFn) {\\n    addHandler(element, event, handler, delegationFn, false);\\n  },\\n\\n  one(element, event, handler, delegationFn) {\\n    addHandler(element, event, handler, delegationFn, true);\\n  },\\n\\n  off(element, originalTypeEvent, handler, delegationFn) {\\n    if (typeof originalTypeEvent !== 'string' || !element) {\\n      return;\\n    }\\n\\n    const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);\\n    const inNamespace = typeEvent !== originalTypeEvent;\\n    const events = getEvent(element);\\n    const isNamespace = originalTypeEvent.startsWith('.');\\n\\n    if (typeof originalHandler !== 'undefined') {\\n      // Simplest case: handler is passed, remove that listener ONLY.\\n      if (!events || !events[typeEvent]) {\\n        return;\\n      }\\n\\n      removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);\\n      return;\\n    }\\n\\n    if (isNamespace) {\\n      Object.keys(events).forEach(elementEvent => {\\n        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\\n      });\\n    }\\n\\n    const storeElementEvent = events[typeEvent] || {};\\n    Object.keys(storeElementEvent).forEach(keyHandlers => {\\n      const handlerKey = keyHandlers.replace(stripUidRegex, '');\\n\\n      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\\n        const event = storeElementEvent[keyHandlers];\\n        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);\\n      }\\n    });\\n  },\\n\\n  trigger(element, event, args) {\\n    if (typeof event !== 'string' || !element) {\\n      return null;\\n    }\\n\\n    const $ = getjQuery();\\n    const typeEvent = event.replace(stripNameRegex, '');\\n    const inNamespace = event !== typeEvent;\\n    const isNative = nativeEvents.has(typeEvent);\\n    let jQueryEvent;\\n    let bubbles = true;\\n    let nativeDispatch = true;\\n    let defaultPrevented = false;\\n    let evt = null;\\n\\n    if (inNamespace && $) {\\n      jQueryEvent = $.Event(event, args);\\n      $(element).trigger(jQueryEvent);\\n      bubbles = !jQueryEvent.isPropagationStopped();\\n      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\\n      defaultPrevented = jQueryEvent.isDefaultPrevented();\\n    }\\n\\n    if (isNative) {\\n      evt = document.createEvent('HTMLEvents');\\n      evt.initEvent(typeEvent, bubbles, true);\\n    } else {\\n      evt = new CustomEvent(event, {\\n        bubbles,\\n        cancelable: true\\n      });\\n    } // merge custom information in our event\\n\\n\\n    if (typeof args !== 'undefined') {\\n      Object.keys(args).forEach(key => {\\n        Object.defineProperty(evt, key, {\\n          get() {\\n            return args[key];\\n          }\\n\\n        });\\n      });\\n    }\\n\\n    if (defaultPrevented) {\\n      evt.preventDefault();\\n    }\\n\\n    if (nativeDispatch) {\\n      element.dispatchEvent(evt);\\n    }\\n\\n    if (evt.defaultPrevented && typeof jQueryEvent !== 'undefined') {\\n      jQueryEvent.preventDefault();\\n    }\\n\\n    return evt;\\n  }\\n\\n};\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): base-component.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst VERSION = '5.0.0-beta3';\\n\\nclass BaseComponent {\\n  constructor(element) {\\n    element = typeof element === 'string' ? document.querySelector(element) : element;\\n\\n    if (!element) {\\n      return;\\n    }\\n\\n    this._element = element;\\n    Data.set(this._element, this.constructor.DATA_KEY, this);\\n  }\\n\\n  dispose() {\\n    Data.remove(this._element, this.constructor.DATA_KEY);\\n    this._element = null;\\n  }\\n  /** Static */\\n\\n\\n  static getInstance(element) {\\n    return Data.get(element, this.DATA_KEY);\\n  }\\n\\n  static get VERSION() {\\n    return VERSION;\\n  }\\n\\n}\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): alert.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$b = 'alert';\\nconst DATA_KEY$b = 'bs.alert';\\nconst EVENT_KEY$b = `.${DATA_KEY$b}`;\\nconst DATA_API_KEY$8 = '.data-api';\\nconst SELECTOR_DISMISS = '[data-bs-dismiss=\\\"alert\\\"]';\\nconst EVENT_CLOSE = `close${EVENT_KEY$b}`;\\nconst EVENT_CLOSED = `closed${EVENT_KEY$b}`;\\nconst EVENT_CLICK_DATA_API$7 = `click${EVENT_KEY$b}${DATA_API_KEY$8}`;\\nconst CLASS_NAME_ALERT = 'alert';\\nconst CLASS_NAME_FADE$5 = 'fade';\\nconst CLASS_NAME_SHOW$8 = 'show';\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass Alert extends BaseComponent {\\n  // Getters\\n  static get DATA_KEY() {\\n    return DATA_KEY$b;\\n  } // Public\\n\\n\\n  close(element) {\\n    const rootElement = element ? this._getRootElement(element) : this._element;\\n\\n    const customEvent = this._triggerCloseEvent(rootElement);\\n\\n    if (customEvent === null || customEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    this._removeElement(rootElement);\\n  } // Private\\n\\n\\n  _getRootElement(element) {\\n    return getElementFromSelector(element) || element.closest(`.${CLASS_NAME_ALERT}`);\\n  }\\n\\n  _triggerCloseEvent(element) {\\n    return EventHandler.trigger(element, EVENT_CLOSE);\\n  }\\n\\n  _removeElement(element) {\\n    element.classList.remove(CLASS_NAME_SHOW$8);\\n\\n    if (!element.classList.contains(CLASS_NAME_FADE$5)) {\\n      this._destroyElement(element);\\n\\n      return;\\n    }\\n\\n    const transitionDuration = getTransitionDurationFromElement(element);\\n    EventHandler.one(element, 'transitionend', () => this._destroyElement(element));\\n    emulateTransitionEnd(element, transitionDuration);\\n  }\\n\\n  _destroyElement(element) {\\n    if (element.parentNode) {\\n      element.parentNode.removeChild(element);\\n    }\\n\\n    EventHandler.trigger(element, EVENT_CLOSED);\\n  } // Static\\n\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      let data = Data.get(this, DATA_KEY$b);\\n\\n      if (!data) {\\n        data = new Alert(this);\\n      }\\n\\n      if (config === 'close') {\\n        data[config](this);\\n      }\\n    });\\n  }\\n\\n  static handleDismiss(alertInstance) {\\n    return function (event) {\\n      if (event) {\\n        event.preventDefault();\\n      }\\n\\n      alertInstance.close(this);\\n    };\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * Data Api implementation\\n * ------------------------------------------------------------------------\\n */\\n\\n\\nEventHandler.on(document, EVENT_CLICK_DATA_API$7, SELECTOR_DISMISS, Alert.handleDismiss(new Alert()));\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .Alert to jQuery only if jQuery is present\\n */\\n\\ndefineJQueryPlugin(NAME$b, Alert);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): button.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$a = 'button';\\nconst DATA_KEY$a = 'bs.button';\\nconst EVENT_KEY$a = `.${DATA_KEY$a}`;\\nconst DATA_API_KEY$7 = '.data-api';\\nconst CLASS_NAME_ACTIVE$3 = 'active';\\nconst SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\\\"button\\\"]';\\nconst EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$7}`;\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass Button extends BaseComponent {\\n  // Getters\\n  static get DATA_KEY() {\\n    return DATA_KEY$a;\\n  } // Public\\n\\n\\n  toggle() {\\n    // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\\n    this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\\n  } // Static\\n\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      let data = Data.get(this, DATA_KEY$a);\\n\\n      if (!data) {\\n        data = new Button(this);\\n      }\\n\\n      if (config === 'toggle') {\\n        data[config]();\\n      }\\n    });\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * Data Api implementation\\n * ------------------------------------------------------------------------\\n */\\n\\n\\nEventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {\\n  event.preventDefault();\\n  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\\n  let data = Data.get(button, DATA_KEY$a);\\n\\n  if (!data) {\\n    data = new Button(button);\\n  }\\n\\n  data.toggle();\\n});\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .Button to jQuery only if jQuery is present\\n */\\n\\ndefineJQueryPlugin(NAME$a, Button);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): dom/manipulator.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\nfunction normalizeData(val) {\\n  if (val === 'true') {\\n    return true;\\n  }\\n\\n  if (val === 'false') {\\n    return false;\\n  }\\n\\n  if (val === Number(val).toString()) {\\n    return Number(val);\\n  }\\n\\n  if (val === '' || val === 'null') {\\n    return null;\\n  }\\n\\n  return val;\\n}\\n\\nfunction normalizeDataKey(key) {\\n  return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);\\n}\\n\\nconst Manipulator = {\\n  setDataAttribute(element, key, value) {\\n    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\\n  },\\n\\n  removeDataAttribute(element, key) {\\n    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\\n  },\\n\\n  getDataAttributes(element) {\\n    if (!element) {\\n      return {};\\n    }\\n\\n    const attributes = {};\\n    Object.keys(element.dataset).filter(key => key.startsWith('bs')).forEach(key => {\\n      let pureKey = key.replace(/^bs/, '');\\n      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\\n      attributes[pureKey] = normalizeData(element.dataset[key]);\\n    });\\n    return attributes;\\n  },\\n\\n  getDataAttribute(element, key) {\\n    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\\n  },\\n\\n  offset(element) {\\n    const rect = element.getBoundingClientRect();\\n    return {\\n      top: rect.top + document.body.scrollTop,\\n      left: rect.left + document.body.scrollLeft\\n    };\\n  },\\n\\n  position(element) {\\n    return {\\n      top: element.offsetTop,\\n      left: element.offsetLeft\\n    };\\n  }\\n\\n};\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): dom/selector-engine.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\nconst NODE_TEXT = 3;\\nconst SelectorEngine = {\\n  find(selector, element = document.documentElement) {\\n    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\\n  },\\n\\n  findOne(selector, element = document.documentElement) {\\n    return Element.prototype.querySelector.call(element, selector);\\n  },\\n\\n  children(element, selector) {\\n    return [].concat(...element.children).filter(child => child.matches(selector));\\n  },\\n\\n  parents(element, selector) {\\n    const parents = [];\\n    let ancestor = element.parentNode;\\n\\n    while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {\\n      if (ancestor.matches(selector)) {\\n        parents.push(ancestor);\\n      }\\n\\n      ancestor = ancestor.parentNode;\\n    }\\n\\n    return parents;\\n  },\\n\\n  prev(element, selector) {\\n    let previous = element.previousElementSibling;\\n\\n    while (previous) {\\n      if (previous.matches(selector)) {\\n        return [previous];\\n      }\\n\\n      previous = previous.previousElementSibling;\\n    }\\n\\n    return [];\\n  },\\n\\n  next(element, selector) {\\n    let next = element.nextElementSibling;\\n\\n    while (next) {\\n      if (next.matches(selector)) {\\n        return [next];\\n      }\\n\\n      next = next.nextElementSibling;\\n    }\\n\\n    return [];\\n  }\\n\\n};\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): carousel.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$9 = 'carousel';\\nconst DATA_KEY$9 = 'bs.carousel';\\nconst EVENT_KEY$9 = `.${DATA_KEY$9}`;\\nconst DATA_API_KEY$6 = '.data-api';\\nconst ARROW_LEFT_KEY = 'ArrowLeft';\\nconst ARROW_RIGHT_KEY = 'ArrowRight';\\nconst TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\\n\\nconst SWIPE_THRESHOLD = 40;\\nconst Default$8 = {\\n  interval: 5000,\\n  keyboard: true,\\n  slide: false,\\n  pause: 'hover',\\n  wrap: true,\\n  touch: true\\n};\\nconst DefaultType$8 = {\\n  interval: '(number|boolean)',\\n  keyboard: 'boolean',\\n  slide: '(boolean|string)',\\n  pause: '(string|boolean)',\\n  wrap: 'boolean',\\n  touch: 'boolean'\\n};\\nconst ORDER_NEXT = 'next';\\nconst ORDER_PREV = 'prev';\\nconst DIRECTION_LEFT = 'left';\\nconst DIRECTION_RIGHT = 'right';\\nconst EVENT_SLIDE = `slide${EVENT_KEY$9}`;\\nconst EVENT_SLID = `slid${EVENT_KEY$9}`;\\nconst EVENT_KEYDOWN = `keydown${EVENT_KEY$9}`;\\nconst EVENT_MOUSEENTER = `mouseenter${EVENT_KEY$9}`;\\nconst EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY$9}`;\\nconst EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\\nconst EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\\nconst EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\\nconst EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\\nconst EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\\nconst EVENT_DRAG_START = `dragstart${EVENT_KEY$9}`;\\nconst EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$9}${DATA_API_KEY$6}`;\\nconst EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$9}${DATA_API_KEY$6}`;\\nconst CLASS_NAME_CAROUSEL = 'carousel';\\nconst CLASS_NAME_ACTIVE$2 = 'active';\\nconst CLASS_NAME_SLIDE = 'slide';\\nconst CLASS_NAME_END = 'carousel-item-end';\\nconst CLASS_NAME_START = 'carousel-item-start';\\nconst CLASS_NAME_NEXT = 'carousel-item-next';\\nconst CLASS_NAME_PREV = 'carousel-item-prev';\\nconst CLASS_NAME_POINTER_EVENT = 'pointer-event';\\nconst SELECTOR_ACTIVE$1 = '.active';\\nconst SELECTOR_ACTIVE_ITEM = '.active.carousel-item';\\nconst SELECTOR_ITEM = '.carousel-item';\\nconst SELECTOR_ITEM_IMG = '.carousel-item img';\\nconst SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';\\nconst SELECTOR_INDICATORS = '.carousel-indicators';\\nconst SELECTOR_INDICATOR = '[data-bs-target]';\\nconst SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\\nconst SELECTOR_DATA_RIDE = '[data-bs-ride=\\\"carousel\\\"]';\\nconst POINTER_TYPE_TOUCH = 'touch';\\nconst POINTER_TYPE_PEN = 'pen';\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass Carousel extends BaseComponent {\\n  constructor(element, config) {\\n    super(element);\\n    this._items = null;\\n    this._interval = null;\\n    this._activeElement = null;\\n    this._isPaused = false;\\n    this._isSliding = false;\\n    this.touchTimeout = null;\\n    this.touchStartX = 0;\\n    this.touchDeltaX = 0;\\n    this._config = this._getConfig(config);\\n    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\\n    this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\\n    this._pointerEvent = Boolean(window.PointerEvent);\\n\\n    this._addEventListeners();\\n  } // Getters\\n\\n\\n  static get Default() {\\n    return Default$8;\\n  }\\n\\n  static get DATA_KEY() {\\n    return DATA_KEY$9;\\n  } // Public\\n\\n\\n  next() {\\n    if (!this._isSliding) {\\n      this._slide(ORDER_NEXT);\\n    }\\n  }\\n\\n  nextWhenVisible() {\\n    // Don't call next when the page isn't visible\\n    // or the carousel or its parent isn't visible\\n    if (!document.hidden && isVisible(this._element)) {\\n      this.next();\\n    }\\n  }\\n\\n  prev() {\\n    if (!this._isSliding) {\\n      this._slide(ORDER_PREV);\\n    }\\n  }\\n\\n  pause(event) {\\n    if (!event) {\\n      this._isPaused = true;\\n    }\\n\\n    if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {\\n      triggerTransitionEnd(this._element);\\n      this.cycle(true);\\n    }\\n\\n    clearInterval(this._interval);\\n    this._interval = null;\\n  }\\n\\n  cycle(event) {\\n    if (!event) {\\n      this._isPaused = false;\\n    }\\n\\n    if (this._interval) {\\n      clearInterval(this._interval);\\n      this._interval = null;\\n    }\\n\\n    if (this._config && this._config.interval && !this._isPaused) {\\n      this._updateInterval();\\n\\n      this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\\n    }\\n  }\\n\\n  to(index) {\\n    this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\\n\\n    const activeIndex = this._getItemIndex(this._activeElement);\\n\\n    if (index > this._items.length - 1 || index < 0) {\\n      return;\\n    }\\n\\n    if (this._isSliding) {\\n      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\\n      return;\\n    }\\n\\n    if (activeIndex === index) {\\n      this.pause();\\n      this.cycle();\\n      return;\\n    }\\n\\n    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\\n\\n    this._slide(order, this._items[index]);\\n  }\\n\\n  dispose() {\\n    EventHandler.off(this._element, EVENT_KEY$9);\\n    this._items = null;\\n    this._config = null;\\n    this._interval = null;\\n    this._isPaused = null;\\n    this._isSliding = null;\\n    this._activeElement = null;\\n    this._indicatorsElement = null;\\n    super.dispose();\\n  } // Private\\n\\n\\n  _getConfig(config) {\\n    config = { ...Default$8,\\n      ...config\\n    };\\n    typeCheckConfig(NAME$9, config, DefaultType$8);\\n    return config;\\n  }\\n\\n  _handleSwipe() {\\n    const absDeltax = Math.abs(this.touchDeltaX);\\n\\n    if (absDeltax <= SWIPE_THRESHOLD) {\\n      return;\\n    }\\n\\n    const direction = absDeltax / this.touchDeltaX;\\n    this.touchDeltaX = 0;\\n\\n    if (!direction) {\\n      return;\\n    }\\n\\n    this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);\\n  }\\n\\n  _addEventListeners() {\\n    if (this._config.keyboard) {\\n      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\\n    }\\n\\n    if (this._config.pause === 'hover') {\\n      EventHandler.on(this._element, EVENT_MOUSEENTER, event => this.pause(event));\\n      EventHandler.on(this._element, EVENT_MOUSELEAVE, event => this.cycle(event));\\n    }\\n\\n    if (this._config.touch && this._touchSupported) {\\n      this._addTouchEventListeners();\\n    }\\n  }\\n\\n  _addTouchEventListeners() {\\n    const start = event => {\\n      if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\\n        this.touchStartX = event.clientX;\\n      } else if (!this._pointerEvent) {\\n        this.touchStartX = event.touches[0].clientX;\\n      }\\n    };\\n\\n    const move = event => {\\n      // ensure swiping with one touch and not pinching\\n      this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;\\n    };\\n\\n    const end = event => {\\n      if (this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\\n        this.touchDeltaX = event.clientX - this.touchStartX;\\n      }\\n\\n      this._handleSwipe();\\n\\n      if (this._config.pause === 'hover') {\\n        // If it's a touch-enabled device, mouseenter/leave are fired as\\n        // part of the mouse compatibility events on first tap - the carousel\\n        // would stop cycling until user tapped out of it;\\n        // here, we listen for touchend, explicitly pause the carousel\\n        // (as if it's the second time we tap on it, mouseenter compat event\\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\\n        // events to fire) we explicitly restart cycling\\n        this.pause();\\n\\n        if (this.touchTimeout) {\\n          clearTimeout(this.touchTimeout);\\n        }\\n\\n        this.touchTimeout = setTimeout(event => this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\\n      }\\n    };\\n\\n    SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(itemImg => {\\n      EventHandler.on(itemImg, EVENT_DRAG_START, e => e.preventDefault());\\n    });\\n\\n    if (this._pointerEvent) {\\n      EventHandler.on(this._element, EVENT_POINTERDOWN, event => start(event));\\n      EventHandler.on(this._element, EVENT_POINTERUP, event => end(event));\\n\\n      this._element.classList.add(CLASS_NAME_POINTER_EVENT);\\n    } else {\\n      EventHandler.on(this._element, EVENT_TOUCHSTART, event => start(event));\\n      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => move(event));\\n      EventHandler.on(this._element, EVENT_TOUCHEND, event => end(event));\\n    }\\n  }\\n\\n  _keydown(event) {\\n    if (/input|textarea/i.test(event.target.tagName)) {\\n      return;\\n    }\\n\\n    if (event.key === ARROW_LEFT_KEY) {\\n      event.preventDefault();\\n\\n      this._slide(DIRECTION_LEFT);\\n    } else if (event.key === ARROW_RIGHT_KEY) {\\n      event.preventDefault();\\n\\n      this._slide(DIRECTION_RIGHT);\\n    }\\n  }\\n\\n  _getItemIndex(element) {\\n    this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];\\n    return this._items.indexOf(element);\\n  }\\n\\n  _getItemByOrder(order, activeElement) {\\n    const isNext = order === ORDER_NEXT;\\n    const isPrev = order === ORDER_PREV;\\n\\n    const activeIndex = this._getItemIndex(activeElement);\\n\\n    const lastItemIndex = this._items.length - 1;\\n    const isGoingToWrap = isPrev && activeIndex === 0 || isNext && activeIndex === lastItemIndex;\\n\\n    if (isGoingToWrap && !this._config.wrap) {\\n      return activeElement;\\n    }\\n\\n    const delta = isPrev ? -1 : 1;\\n    const itemIndex = (activeIndex + delta) % this._items.length;\\n    return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\\n  }\\n\\n  _triggerSlideEvent(relatedTarget, eventDirectionName) {\\n    const targetIndex = this._getItemIndex(relatedTarget);\\n\\n    const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));\\n\\n    return EventHandler.trigger(this._element, EVENT_SLIDE, {\\n      relatedTarget,\\n      direction: eventDirectionName,\\n      from: fromIndex,\\n      to: targetIndex\\n    });\\n  }\\n\\n  _setActiveIndicatorElement(element) {\\n    if (this._indicatorsElement) {\\n      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);\\n      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\\n      activeIndicator.removeAttribute('aria-current');\\n      const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);\\n\\n      for (let i = 0; i < indicators.length; i++) {\\n        if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {\\n          indicators[i].classList.add(CLASS_NAME_ACTIVE$2);\\n          indicators[i].setAttribute('aria-current', 'true');\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  _updateInterval() {\\n    const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\\n\\n    if (!element) {\\n      return;\\n    }\\n\\n    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\\n\\n    if (elementInterval) {\\n      this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\\n      this._config.interval = elementInterval;\\n    } else {\\n      this._config.interval = this._config.defaultInterval || this._config.interval;\\n    }\\n  }\\n\\n  _slide(directionOrOrder, element) {\\n    const order = this._directionToOrder(directionOrOrder);\\n\\n    const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\\n\\n    const activeElementIndex = this._getItemIndex(activeElement);\\n\\n    const nextElement = element || this._getItemByOrder(order, activeElement);\\n\\n    const nextElementIndex = this._getItemIndex(nextElement);\\n\\n    const isCycling = Boolean(this._interval);\\n    const isNext = order === ORDER_NEXT;\\n    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\\n    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\\n\\n    const eventDirectionName = this._orderToDirection(order);\\n\\n    if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) {\\n      this._isSliding = false;\\n      return;\\n    }\\n\\n    const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\\n\\n    if (slideEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    if (!activeElement || !nextElement) {\\n      // Some weirdness is happening, so we bail\\n      return;\\n    }\\n\\n    this._isSliding = true;\\n\\n    if (isCycling) {\\n      this.pause();\\n    }\\n\\n    this._setActiveIndicatorElement(nextElement);\\n\\n    this._activeElement = nextElement;\\n\\n    if (this._element.classList.contains(CLASS_NAME_SLIDE)) {\\n      nextElement.classList.add(orderClassName);\\n      reflow(nextElement);\\n      activeElement.classList.add(directionalClassName);\\n      nextElement.classList.add(directionalClassName);\\n      const transitionDuration = getTransitionDurationFromElement(activeElement);\\n      EventHandler.one(activeElement, 'transitionend', () => {\\n        nextElement.classList.remove(directionalClassName, orderClassName);\\n        nextElement.classList.add(CLASS_NAME_ACTIVE$2);\\n        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\\n        this._isSliding = false;\\n        setTimeout(() => {\\n          EventHandler.trigger(this._element, EVENT_SLID, {\\n            relatedTarget: nextElement,\\n            direction: eventDirectionName,\\n            from: activeElementIndex,\\n            to: nextElementIndex\\n          });\\n        }, 0);\\n      });\\n      emulateTransitionEnd(activeElement, transitionDuration);\\n    } else {\\n      activeElement.classList.remove(CLASS_NAME_ACTIVE$2);\\n      nextElement.classList.add(CLASS_NAME_ACTIVE$2);\\n      this._isSliding = false;\\n      EventHandler.trigger(this._element, EVENT_SLID, {\\n        relatedTarget: nextElement,\\n        direction: eventDirectionName,\\n        from: activeElementIndex,\\n        to: nextElementIndex\\n      });\\n    }\\n\\n    if (isCycling) {\\n      this.cycle();\\n    }\\n  }\\n\\n  _directionToOrder(direction) {\\n    if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {\\n      return direction;\\n    }\\n\\n    if (isRTL()) {\\n      return direction === DIRECTION_RIGHT ? ORDER_PREV : ORDER_NEXT;\\n    }\\n\\n    return direction === DIRECTION_RIGHT ? ORDER_NEXT : ORDER_PREV;\\n  }\\n\\n  _orderToDirection(order) {\\n    if (![ORDER_NEXT, ORDER_PREV].includes(order)) {\\n      return order;\\n    }\\n\\n    if (isRTL()) {\\n      return order === ORDER_NEXT ? DIRECTION_LEFT : DIRECTION_RIGHT;\\n    }\\n\\n    return order === ORDER_NEXT ? DIRECTION_RIGHT : DIRECTION_LEFT;\\n  } // Static\\n\\n\\n  static carouselInterface(element, config) {\\n    let data = Data.get(element, DATA_KEY$9);\\n    let _config = { ...Default$8,\\n      ...Manipulator.getDataAttributes(element)\\n    };\\n\\n    if (typeof config === 'object') {\\n      _config = { ..._config,\\n        ...config\\n      };\\n    }\\n\\n    const action = typeof config === 'string' ? config : _config.slide;\\n\\n    if (!data) {\\n      data = new Carousel(element, _config);\\n    }\\n\\n    if (typeof config === 'number') {\\n      data.to(config);\\n    } else if (typeof action === 'string') {\\n      if (typeof data[action] === 'undefined') {\\n        throw new TypeError(`No method named \\\"${action}\\\"`);\\n      }\\n\\n      data[action]();\\n    } else if (_config.interval && _config.ride) {\\n      data.pause();\\n      data.cycle();\\n    }\\n  }\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      Carousel.carouselInterface(this, config);\\n    });\\n  }\\n\\n  static dataApiClickHandler(event) {\\n    const target = getElementFromSelector(this);\\n\\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\\n      return;\\n    }\\n\\n    const config = { ...Manipulator.getDataAttributes(target),\\n      ...Manipulator.getDataAttributes(this)\\n    };\\n    const slideIndex = this.getAttribute('data-bs-slide-to');\\n\\n    if (slideIndex) {\\n      config.interval = false;\\n    }\\n\\n    Carousel.carouselInterface(target, config);\\n\\n    if (slideIndex) {\\n      Data.get(target, DATA_KEY$9).to(slideIndex);\\n    }\\n\\n    event.preventDefault();\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * Data Api implementation\\n * ------------------------------------------------------------------------\\n */\\n\\n\\nEventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);\\nEventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {\\n  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\\n\\n  for (let i = 0, len = carousels.length; i < len; i++) {\\n    Carousel.carouselInterface(carousels[i], Data.get(carousels[i], DATA_KEY$9));\\n  }\\n});\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .Carousel to jQuery only if jQuery is present\\n */\\n\\ndefineJQueryPlugin(NAME$9, Carousel);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): collapse.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$8 = 'collapse';\\nconst DATA_KEY$8 = 'bs.collapse';\\nconst EVENT_KEY$8 = `.${DATA_KEY$8}`;\\nconst DATA_API_KEY$5 = '.data-api';\\nconst Default$7 = {\\n  toggle: true,\\n  parent: ''\\n};\\nconst DefaultType$7 = {\\n  toggle: 'boolean',\\n  parent: '(string|element)'\\n};\\nconst EVENT_SHOW$5 = `show${EVENT_KEY$8}`;\\nconst EVENT_SHOWN$5 = `shown${EVENT_KEY$8}`;\\nconst EVENT_HIDE$5 = `hide${EVENT_KEY$8}`;\\nconst EVENT_HIDDEN$5 = `hidden${EVENT_KEY$8}`;\\nconst EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\\nconst CLASS_NAME_SHOW$7 = 'show';\\nconst CLASS_NAME_COLLAPSE = 'collapse';\\nconst CLASS_NAME_COLLAPSING = 'collapsing';\\nconst CLASS_NAME_COLLAPSED = 'collapsed';\\nconst WIDTH = 'width';\\nconst HEIGHT = 'height';\\nconst SELECTOR_ACTIVES = '.show, .collapsing';\\nconst SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\\\"collapse\\\"]';\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass Collapse extends BaseComponent {\\n  constructor(element, config) {\\n    super(element);\\n    this._isTransitioning = false;\\n    this._config = this._getConfig(config);\\n    this._triggerArray = SelectorEngine.find(`${SELECTOR_DATA_TOGGLE$4}[href=\\\"#${this._element.id}\\\"],` + `${SELECTOR_DATA_TOGGLE$4}[data-bs-target=\\\"#${this._element.id}\\\"]`);\\n    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\\n\\n    for (let i = 0, len = toggleList.length; i < len; i++) {\\n      const elem = toggleList[i];\\n      const selector = getSelectorFromElement(elem);\\n      const filterElement = SelectorEngine.find(selector).filter(foundElem => foundElem === this._element);\\n\\n      if (selector !== null && filterElement.length) {\\n        this._selector = selector;\\n\\n        this._triggerArray.push(elem);\\n      }\\n    }\\n\\n    this._parent = this._config.parent ? this._getParent() : null;\\n\\n    if (!this._config.parent) {\\n      this._addAriaAndCollapsedClass(this._element, this._triggerArray);\\n    }\\n\\n    if (this._config.toggle) {\\n      this.toggle();\\n    }\\n  } // Getters\\n\\n\\n  static get Default() {\\n    return Default$7;\\n  }\\n\\n  static get DATA_KEY() {\\n    return DATA_KEY$8;\\n  } // Public\\n\\n\\n  toggle() {\\n    if (this._element.classList.contains(CLASS_NAME_SHOW$7)) {\\n      this.hide();\\n    } else {\\n      this.show();\\n    }\\n  }\\n\\n  show() {\\n    if (this._isTransitioning || this._element.classList.contains(CLASS_NAME_SHOW$7)) {\\n      return;\\n    }\\n\\n    let actives;\\n    let activesData;\\n\\n    if (this._parent) {\\n      actives = SelectorEngine.find(SELECTOR_ACTIVES, this._parent).filter(elem => {\\n        if (typeof this._config.parent === 'string') {\\n          return elem.getAttribute('data-bs-parent') === this._config.parent;\\n        }\\n\\n        return elem.classList.contains(CLASS_NAME_COLLAPSE);\\n      });\\n\\n      if (actives.length === 0) {\\n        actives = null;\\n      }\\n    }\\n\\n    const container = SelectorEngine.findOne(this._selector);\\n\\n    if (actives) {\\n      const tempActiveData = actives.find(elem => container !== elem);\\n      activesData = tempActiveData ? Data.get(tempActiveData, DATA_KEY$8) : null;\\n\\n      if (activesData && activesData._isTransitioning) {\\n        return;\\n      }\\n    }\\n\\n    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);\\n\\n    if (startEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    if (actives) {\\n      actives.forEach(elemActive => {\\n        if (container !== elemActive) {\\n          Collapse.collapseInterface(elemActive, 'hide');\\n        }\\n\\n        if (!activesData) {\\n          Data.set(elemActive, DATA_KEY$8, null);\\n        }\\n      });\\n    }\\n\\n    const dimension = this._getDimension();\\n\\n    this._element.classList.remove(CLASS_NAME_COLLAPSE);\\n\\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\\n\\n    this._element.style[dimension] = 0;\\n\\n    if (this._triggerArray.length) {\\n      this._triggerArray.forEach(element => {\\n        element.classList.remove(CLASS_NAME_COLLAPSED);\\n        element.setAttribute('aria-expanded', true);\\n      });\\n    }\\n\\n    this.setTransitioning(true);\\n\\n    const complete = () => {\\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\\n\\n      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\\n\\n      this._element.style[dimension] = '';\\n      this.setTransitioning(false);\\n      EventHandler.trigger(this._element, EVENT_SHOWN$5);\\n    };\\n\\n    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\\n    const scrollSize = `scroll${capitalizedDimension}`;\\n    const transitionDuration = getTransitionDurationFromElement(this._element);\\n    EventHandler.one(this._element, 'transitionend', complete);\\n    emulateTransitionEnd(this._element, transitionDuration);\\n    this._element.style[dimension] = `${this._element[scrollSize]}px`;\\n  }\\n\\n  hide() {\\n    if (this._isTransitioning || !this._element.classList.contains(CLASS_NAME_SHOW$7)) {\\n      return;\\n    }\\n\\n    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5);\\n\\n    if (startEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    const dimension = this._getDimension();\\n\\n    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\\n    reflow(this._element);\\n\\n    this._element.classList.add(CLASS_NAME_COLLAPSING);\\n\\n    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\\n\\n    const triggerArrayLength = this._triggerArray.length;\\n\\n    if (triggerArrayLength > 0) {\\n      for (let i = 0; i < triggerArrayLength; i++) {\\n        const trigger = this._triggerArray[i];\\n        const elem = getElementFromSelector(trigger);\\n\\n        if (elem && !elem.classList.contains(CLASS_NAME_SHOW$7)) {\\n          trigger.classList.add(CLASS_NAME_COLLAPSED);\\n          trigger.setAttribute('aria-expanded', false);\\n        }\\n      }\\n    }\\n\\n    this.setTransitioning(true);\\n\\n    const complete = () => {\\n      this.setTransitioning(false);\\n\\n      this._element.classList.remove(CLASS_NAME_COLLAPSING);\\n\\n      this._element.classList.add(CLASS_NAME_COLLAPSE);\\n\\n      EventHandler.trigger(this._element, EVENT_HIDDEN$5);\\n    };\\n\\n    this._element.style[dimension] = '';\\n    const transitionDuration = getTransitionDurationFromElement(this._element);\\n    EventHandler.one(this._element, 'transitionend', complete);\\n    emulateTransitionEnd(this._element, transitionDuration);\\n  }\\n\\n  setTransitioning(isTransitioning) {\\n    this._isTransitioning = isTransitioning;\\n  }\\n\\n  dispose() {\\n    super.dispose();\\n    this._config = null;\\n    this._parent = null;\\n    this._triggerArray = null;\\n    this._isTransitioning = null;\\n  } // Private\\n\\n\\n  _getConfig(config) {\\n    config = { ...Default$7,\\n      ...config\\n    };\\n    config.toggle = Boolean(config.toggle); // Coerce string values\\n\\n    typeCheckConfig(NAME$8, config, DefaultType$7);\\n    return config;\\n  }\\n\\n  _getDimension() {\\n    return this._element.classList.contains(WIDTH) ? WIDTH : HEIGHT;\\n  }\\n\\n  _getParent() {\\n    let {\\n      parent\\n    } = this._config;\\n\\n    if (bootstrap_esm_isElement(parent)) {\\n      // it's a jQuery object\\n      if (typeof parent.jquery !== 'undefined' || typeof parent[0] !== 'undefined') {\\n        parent = parent[0];\\n      }\\n    } else {\\n      parent = SelectorEngine.findOne(parent);\\n    }\\n\\n    const selector = `${SELECTOR_DATA_TOGGLE$4}[data-bs-parent=\\\"${parent}\\\"]`;\\n    SelectorEngine.find(selector, parent).forEach(element => {\\n      const selected = getElementFromSelector(element);\\n\\n      this._addAriaAndCollapsedClass(selected, [element]);\\n    });\\n    return parent;\\n  }\\n\\n  _addAriaAndCollapsedClass(element, triggerArray) {\\n    if (!element || !triggerArray.length) {\\n      return;\\n    }\\n\\n    const isOpen = element.classList.contains(CLASS_NAME_SHOW$7);\\n    triggerArray.forEach(elem => {\\n      if (isOpen) {\\n        elem.classList.remove(CLASS_NAME_COLLAPSED);\\n      } else {\\n        elem.classList.add(CLASS_NAME_COLLAPSED);\\n      }\\n\\n      elem.setAttribute('aria-expanded', isOpen);\\n    });\\n  } // Static\\n\\n\\n  static collapseInterface(element, config) {\\n    let data = Data.get(element, DATA_KEY$8);\\n    const _config = { ...Default$7,\\n      ...Manipulator.getDataAttributes(element),\\n      ...(typeof config === 'object' && config ? config : {})\\n    };\\n\\n    if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {\\n      _config.toggle = false;\\n    }\\n\\n    if (!data) {\\n      data = new Collapse(element, _config);\\n    }\\n\\n    if (typeof config === 'string') {\\n      if (typeof data[config] === 'undefined') {\\n        throw new TypeError(`No method named \\\"${config}\\\"`);\\n      }\\n\\n      data[config]();\\n    }\\n  }\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      Collapse.collapseInterface(this, config);\\n    });\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * Data Api implementation\\n * ------------------------------------------------------------------------\\n */\\n\\n\\nEventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\\n  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\\n  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\\n    event.preventDefault();\\n  }\\n\\n  const triggerData = Manipulator.getDataAttributes(this);\\n  const selector = getSelectorFromElement(this);\\n  const selectorElements = SelectorEngine.find(selector);\\n  selectorElements.forEach(element => {\\n    const data = Data.get(element, DATA_KEY$8);\\n    let config;\\n\\n    if (data) {\\n      // update parent attribute\\n      if (data._parent === null && typeof triggerData.parent === 'string') {\\n        data._config.parent = triggerData.parent;\\n        data._parent = data._getParent();\\n      }\\n\\n      config = 'toggle';\\n    } else {\\n      config = triggerData;\\n    }\\n\\n    Collapse.collapseInterface(element, config);\\n  });\\n});\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .Collapse to jQuery only if jQuery is present\\n */\\n\\ndefineJQueryPlugin(NAME$8, Collapse);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): dropdown.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$7 = 'dropdown';\\nconst DATA_KEY$7 = 'bs.dropdown';\\nconst EVENT_KEY$7 = `.${DATA_KEY$7}`;\\nconst DATA_API_KEY$4 = '.data-api';\\nconst ESCAPE_KEY$2 = 'Escape';\\nconst SPACE_KEY = 'Space';\\nconst TAB_KEY = 'Tab';\\nconst ARROW_UP_KEY = 'ArrowUp';\\nconst ARROW_DOWN_KEY = 'ArrowDown';\\nconst RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\\n\\nconst REGEXP_KEYDOWN = new RegExp(`${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY$2}`);\\nconst EVENT_HIDE$4 = `hide${EVENT_KEY$7}`;\\nconst EVENT_HIDDEN$4 = `hidden${EVENT_KEY$7}`;\\nconst EVENT_SHOW$4 = `show${EVENT_KEY$7}`;\\nconst EVENT_SHOWN$4 = `shown${EVENT_KEY$7}`;\\nconst EVENT_CLICK = `click${EVENT_KEY$7}`;\\nconst EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\\nconst EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$7}${DATA_API_KEY$4}`;\\nconst EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$7}${DATA_API_KEY$4}`;\\nconst CLASS_NAME_DISABLED = 'disabled';\\nconst CLASS_NAME_SHOW$6 = 'show';\\nconst CLASS_NAME_DROPUP = 'dropup';\\nconst CLASS_NAME_DROPEND = 'dropend';\\nconst CLASS_NAME_DROPSTART = 'dropstart';\\nconst CLASS_NAME_NAVBAR = 'navbar';\\nconst SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\\\"dropdown\\\"]';\\nconst SELECTOR_MENU = '.dropdown-menu';\\nconst SELECTOR_NAVBAR_NAV = '.navbar-nav';\\nconst SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\\nconst PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\\nconst PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\\nconst PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\\nconst PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\\nconst PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\\nconst PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\\nconst Default$6 = {\\n  offset: [0, 2],\\n  boundary: 'clippingParents',\\n  reference: 'toggle',\\n  display: 'dynamic',\\n  popperConfig: null\\n};\\nconst DefaultType$6 = {\\n  offset: '(array|string|function)',\\n  boundary: '(string|element)',\\n  reference: '(string|element|object)',\\n  display: 'string',\\n  popperConfig: '(null|object|function)'\\n};\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass bootstrap_esm_Dropdown extends BaseComponent {\\n  constructor(element, config) {\\n    super(element);\\n    this._popper = null;\\n    this._config = this._getConfig(config);\\n    this._menu = this._getMenuElement();\\n    this._inNavbar = this._detectNavbar();\\n\\n    this._addEventListeners();\\n  } // Getters\\n\\n\\n  static get Default() {\\n    return Default$6;\\n  }\\n\\n  static get DefaultType() {\\n    return DefaultType$6;\\n  }\\n\\n  static get DATA_KEY() {\\n    return DATA_KEY$7;\\n  } // Public\\n\\n\\n  toggle() {\\n    if (this._element.disabled || this._element.classList.contains(CLASS_NAME_DISABLED)) {\\n      return;\\n    }\\n\\n    const isActive = this._element.classList.contains(CLASS_NAME_SHOW$6);\\n\\n    bootstrap_esm_Dropdown.clearMenus();\\n\\n    if (isActive) {\\n      return;\\n    }\\n\\n    this.show();\\n  }\\n\\n  show() {\\n    if (this._element.disabled || this._element.classList.contains(CLASS_NAME_DISABLED) || this._menu.classList.contains(CLASS_NAME_SHOW$6)) {\\n      return;\\n    }\\n\\n    const parent = bootstrap_esm_Dropdown.getParentFromElement(this._element);\\n    const relatedTarget = {\\n      relatedTarget: this._element\\n    };\\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);\\n\\n    if (showEvent.defaultPrevented) {\\n      return;\\n    } // Totally disable Popper for Dropdowns in Navbar\\n\\n\\n    if (this._inNavbar) {\\n      Manipulator.setDataAttribute(this._menu, 'popper', 'none');\\n    } else {\\n      if (typeof lib_namespaceObject === 'undefined') {\\n        throw new TypeError('Bootstrap\\\\'s dropdowns require Popper (https://popper.js.org)');\\n      }\\n\\n      let referenceElement = this._element;\\n\\n      if (this._config.reference === 'parent') {\\n        referenceElement = parent;\\n      } else if (bootstrap_esm_isElement(this._config.reference)) {\\n        referenceElement = this._config.reference; // Check if it's jQuery element\\n\\n        if (typeof this._config.reference.jquery !== 'undefined') {\\n          referenceElement = this._config.reference[0];\\n        }\\n      } else if (typeof this._config.reference === 'object') {\\n        referenceElement = this._config.reference;\\n      }\\n\\n      const popperConfig = this._getPopperConfig();\\n\\n      const isDisplayStatic = popperConfig.modifiers.find(modifier => modifier.name === 'applyStyles' && modifier.enabled === false);\\n      this._popper = popper_createPopper(referenceElement, this._menu, popperConfig);\\n\\n      if (isDisplayStatic) {\\n        Manipulator.setDataAttribute(this._menu, 'popper', 'static');\\n      }\\n    } // If this is a touch-enabled device we add extra\\n    // empty mouseover listeners to the body's immediate children;\\n    // only needed because of broken event delegation on iOS\\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\\n\\n\\n    if ('ontouchstart' in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {\\n      [].concat(...document.body.children).forEach(elem => EventHandler.on(elem, 'mouseover', null, noop()));\\n    }\\n\\n    this._element.focus();\\n\\n    this._element.setAttribute('aria-expanded', true);\\n\\n    this._menu.classList.toggle(CLASS_NAME_SHOW$6);\\n\\n    this._element.classList.toggle(CLASS_NAME_SHOW$6);\\n\\n    EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);\\n  }\\n\\n  hide() {\\n    if (this._element.disabled || this._element.classList.contains(CLASS_NAME_DISABLED) || !this._menu.classList.contains(CLASS_NAME_SHOW$6)) {\\n      return;\\n    }\\n\\n    const relatedTarget = {\\n      relatedTarget: this._element\\n    };\\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);\\n\\n    if (hideEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    if (this._popper) {\\n      this._popper.destroy();\\n    }\\n\\n    this._menu.classList.toggle(CLASS_NAME_SHOW$6);\\n\\n    this._element.classList.toggle(CLASS_NAME_SHOW$6);\\n\\n    Manipulator.removeDataAttribute(this._menu, 'popper');\\n    EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);\\n  }\\n\\n  dispose() {\\n    EventHandler.off(this._element, EVENT_KEY$7);\\n    this._menu = null;\\n\\n    if (this._popper) {\\n      this._popper.destroy();\\n\\n      this._popper = null;\\n    }\\n\\n    super.dispose();\\n  }\\n\\n  update() {\\n    this._inNavbar = this._detectNavbar();\\n\\n    if (this._popper) {\\n      this._popper.update();\\n    }\\n  } // Private\\n\\n\\n  _addEventListeners() {\\n    EventHandler.on(this._element, EVENT_CLICK, event => {\\n      event.preventDefault();\\n      this.toggle();\\n    });\\n  }\\n\\n  _getConfig(config) {\\n    config = { ...this.constructor.Default,\\n      ...Manipulator.getDataAttributes(this._element),\\n      ...config\\n    };\\n    typeCheckConfig(NAME$7, config, this.constructor.DefaultType);\\n\\n    if (typeof config.reference === 'object' && !bootstrap_esm_isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\\n      // Popper virtual elements require a getBoundingClientRect method\\n      throw new TypeError(`${NAME$7.toUpperCase()}: Option \\\"reference\\\" provided type \\\"object\\\" without a required \\\"getBoundingClientRect\\\" method.`);\\n    }\\n\\n    return config;\\n  }\\n\\n  _getMenuElement() {\\n    return SelectorEngine.next(this._element, SELECTOR_MENU)[0];\\n  }\\n\\n  _getPlacement() {\\n    const parentDropdown = this._element.parentNode;\\n\\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\\n      return PLACEMENT_RIGHT;\\n    }\\n\\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\\n      return PLACEMENT_LEFT;\\n    } // We need to trim the value because custom properties can also include spaces\\n\\n\\n    const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\\n\\n    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\\n      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\\n    }\\n\\n    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\\n  }\\n\\n  _detectNavbar() {\\n    return this._element.closest(`.${CLASS_NAME_NAVBAR}`) !== null;\\n  }\\n\\n  _getOffset() {\\n    const {\\n      offset\\n    } = this._config;\\n\\n    if (typeof offset === 'string') {\\n      return offset.split(',').map(val => Number.parseInt(val, 10));\\n    }\\n\\n    if (typeof offset === 'function') {\\n      return popperData => offset(popperData, this._element);\\n    }\\n\\n    return offset;\\n  }\\n\\n  _getPopperConfig() {\\n    const defaultBsPopperConfig = {\\n      placement: this._getPlacement(),\\n      modifiers: [{\\n        name: 'preventOverflow',\\n        options: {\\n          boundary: this._config.boundary\\n        }\\n      }, {\\n        name: 'offset',\\n        options: {\\n          offset: this._getOffset()\\n        }\\n      }]\\n    }; // Disable Popper if we have a static display\\n\\n    if (this._config.display === 'static') {\\n      defaultBsPopperConfig.modifiers = [{\\n        name: 'applyStyles',\\n        enabled: false\\n      }];\\n    }\\n\\n    return { ...defaultBsPopperConfig,\\n      ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)\\n    };\\n  } // Static\\n\\n\\n  static dropdownInterface(element, config) {\\n    let data = Data.get(element, DATA_KEY$7);\\n\\n    const _config = typeof config === 'object' ? config : null;\\n\\n    if (!data) {\\n      data = new bootstrap_esm_Dropdown(element, _config);\\n    }\\n\\n    if (typeof config === 'string') {\\n      if (typeof data[config] === 'undefined') {\\n        throw new TypeError(`No method named \\\"${config}\\\"`);\\n      }\\n\\n      data[config]();\\n    }\\n  }\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      bootstrap_esm_Dropdown.dropdownInterface(this, config);\\n    });\\n  }\\n\\n  static clearMenus(event) {\\n    if (event) {\\n      if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY) {\\n        return;\\n      }\\n\\n      if (/input|select|textarea|form/i.test(event.target.tagName)) {\\n        return;\\n      }\\n    }\\n\\n    const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);\\n\\n    for (let i = 0, len = toggles.length; i < len; i++) {\\n      const context = Data.get(toggles[i], DATA_KEY$7);\\n      const relatedTarget = {\\n        relatedTarget: toggles[i]\\n      };\\n\\n      if (event && event.type === 'click') {\\n        relatedTarget.clickEvent = event;\\n      }\\n\\n      if (!context) {\\n        continue;\\n      }\\n\\n      const dropdownMenu = context._menu;\\n\\n      if (!toggles[i].classList.contains(CLASS_NAME_SHOW$6)) {\\n        continue;\\n      }\\n\\n      if (event) {\\n        // Don't close the menu if the clicked element or one of its parents is the dropdown button\\n        if ([context._element].some(element => event.composedPath().includes(element))) {\\n          continue;\\n        } // Tab navigation through the dropdown menu shouldn't close the menu\\n\\n\\n        if (event.type === 'keyup' && event.key === TAB_KEY && dropdownMenu.contains(event.target)) {\\n          continue;\\n        }\\n      }\\n\\n      const hideEvent = EventHandler.trigger(toggles[i], EVENT_HIDE$4, relatedTarget);\\n\\n      if (hideEvent.defaultPrevented) {\\n        continue;\\n      } // If this is a touch-enabled device we remove the extra\\n      // empty mouseover listeners we added for iOS support\\n\\n\\n      if ('ontouchstart' in document.documentElement) {\\n        [].concat(...document.body.children).forEach(elem => EventHandler.off(elem, 'mouseover', null, noop()));\\n      }\\n\\n      toggles[i].setAttribute('aria-expanded', 'false');\\n\\n      if (context._popper) {\\n        context._popper.destroy();\\n      }\\n\\n      dropdownMenu.classList.remove(CLASS_NAME_SHOW$6);\\n      toggles[i].classList.remove(CLASS_NAME_SHOW$6);\\n      Manipulator.removeDataAttribute(dropdownMenu, 'popper');\\n      EventHandler.trigger(toggles[i], EVENT_HIDDEN$4, relatedTarget);\\n    }\\n  }\\n\\n  static getParentFromElement(element) {\\n    return getElementFromSelector(element) || element.parentNode;\\n  }\\n\\n  static dataApiKeydownHandler(event) {\\n    // If not input/textarea:\\n    //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\\n    // If input/textarea:\\n    //  - If space key => not a dropdown command\\n    //  - If key is other than escape\\n    //    - If key is not up or down => not a dropdown command\\n    //    - If trigger inside the menu => not a dropdown command\\n    if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {\\n      return;\\n    }\\n\\n    event.preventDefault();\\n    event.stopPropagation();\\n\\n    if (this.disabled || this.classList.contains(CLASS_NAME_DISABLED)) {\\n      return;\\n    }\\n\\n    const parent = bootstrap_esm_Dropdown.getParentFromElement(this);\\n    const isActive = this.classList.contains(CLASS_NAME_SHOW$6);\\n\\n    if (event.key === ESCAPE_KEY$2) {\\n      const button = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];\\n      button.focus();\\n      bootstrap_esm_Dropdown.clearMenus();\\n      return;\\n    }\\n\\n    if (!isActive && (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY)) {\\n      const button = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];\\n      button.click();\\n      return;\\n    }\\n\\n    if (!isActive || event.key === SPACE_KEY) {\\n      bootstrap_esm_Dropdown.clearMenus();\\n      return;\\n    }\\n\\n    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, parent).filter(isVisible);\\n\\n    if (!items.length) {\\n      return;\\n    }\\n\\n    let index = items.indexOf(event.target); // Up\\n\\n    if (event.key === ARROW_UP_KEY && index > 0) {\\n      index--;\\n    } // Down\\n\\n\\n    if (event.key === ARROW_DOWN_KEY && index < items.length - 1) {\\n      index++;\\n    } // index is -1 if the first keydown is an ArrowUp\\n\\n\\n    index = index === -1 ? 0 : index;\\n    items[index].focus();\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * Data Api implementation\\n * ------------------------------------------------------------------------\\n */\\n\\n\\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, bootstrap_esm_Dropdown.dataApiKeydownHandler);\\nEventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, bootstrap_esm_Dropdown.dataApiKeydownHandler);\\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, bootstrap_esm_Dropdown.clearMenus);\\nEventHandler.on(document, EVENT_KEYUP_DATA_API, bootstrap_esm_Dropdown.clearMenus);\\nEventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\\n  event.preventDefault();\\n  bootstrap_esm_Dropdown.dropdownInterface(this);\\n});\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .Dropdown to jQuery only if jQuery is present\\n */\\n\\ndefineJQueryPlugin(NAME$7, bootstrap_esm_Dropdown);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): modal.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$6 = 'modal';\\nconst DATA_KEY$6 = 'bs.modal';\\nconst EVENT_KEY$6 = `.${DATA_KEY$6}`;\\nconst DATA_API_KEY$3 = '.data-api';\\nconst ESCAPE_KEY$1 = 'Escape';\\nconst Default$5 = {\\n  backdrop: true,\\n  keyboard: true,\\n  focus: true\\n};\\nconst DefaultType$5 = {\\n  backdrop: '(boolean|string)',\\n  keyboard: 'boolean',\\n  focus: 'boolean'\\n};\\nconst EVENT_HIDE$3 = `hide${EVENT_KEY$6}`;\\nconst EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$6}`;\\nconst EVENT_HIDDEN$3 = `hidden${EVENT_KEY$6}`;\\nconst EVENT_SHOW$3 = `show${EVENT_KEY$6}`;\\nconst EVENT_SHOWN$3 = `shown${EVENT_KEY$6}`;\\nconst EVENT_FOCUSIN$1 = `focusin${EVENT_KEY$6}`;\\nconst EVENT_RESIZE = `resize${EVENT_KEY$6}`;\\nconst EVENT_CLICK_DISMISS$2 = `click.dismiss${EVENT_KEY$6}`;\\nconst EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$6}`;\\nconst EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY$6}`;\\nconst EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$6}`;\\nconst EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\\nconst CLASS_NAME_SCROLLBAR_MEASURER = 'modal-scrollbar-measure';\\nconst CLASS_NAME_BACKDROP = 'modal-backdrop';\\nconst CLASS_NAME_OPEN = 'modal-open';\\nconst CLASS_NAME_FADE$4 = 'fade';\\nconst CLASS_NAME_SHOW$5 = 'show';\\nconst CLASS_NAME_STATIC = 'modal-static';\\nconst SELECTOR_DIALOG = '.modal-dialog';\\nconst SELECTOR_MODAL_BODY = '.modal-body';\\nconst SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\\\"modal\\\"]';\\nconst SELECTOR_DATA_DISMISS$2 = '[data-bs-dismiss=\\\"modal\\\"]';\\nconst SELECTOR_FIXED_CONTENT$1 = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\\nconst SELECTOR_STICKY_CONTENT$1 = '.sticky-top';\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass Modal extends BaseComponent {\\n  constructor(element, config) {\\n    super(element);\\n    this._config = this._getConfig(config);\\n    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\\n    this._backdrop = null;\\n    this._isShown = false;\\n    this._isBodyOverflowing = false;\\n    this._ignoreBackdropClick = false;\\n    this._isTransitioning = false;\\n    this._scrollbarWidth = 0;\\n  } // Getters\\n\\n\\n  static get Default() {\\n    return Default$5;\\n  }\\n\\n  static get DATA_KEY() {\\n    return DATA_KEY$6;\\n  } // Public\\n\\n\\n  toggle(relatedTarget) {\\n    return this._isShown ? this.hide() : this.show(relatedTarget);\\n  }\\n\\n  show(relatedTarget) {\\n    if (this._isShown || this._isTransitioning) {\\n      return;\\n    }\\n\\n    if (this._isAnimated()) {\\n      this._isTransitioning = true;\\n    }\\n\\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\\n      relatedTarget\\n    });\\n\\n    if (this._isShown || showEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    this._isShown = true;\\n\\n    this._checkScrollbar();\\n\\n    this._setScrollbar();\\n\\n    this._adjustDialog();\\n\\n    this._setEscapeEvent();\\n\\n    this._setResizeEvent();\\n\\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, SELECTOR_DATA_DISMISS$2, event => this.hide(event));\\n    EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => {\\n      EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, event => {\\n        if (event.target === this._element) {\\n          this._ignoreBackdropClick = true;\\n        }\\n      });\\n    });\\n\\n    this._showBackdrop(() => this._showElement(relatedTarget));\\n  }\\n\\n  hide(event) {\\n    if (event) {\\n      event.preventDefault();\\n    }\\n\\n    if (!this._isShown || this._isTransitioning) {\\n      return;\\n    }\\n\\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\\n\\n    if (hideEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    this._isShown = false;\\n\\n    const isAnimated = this._isAnimated();\\n\\n    if (isAnimated) {\\n      this._isTransitioning = true;\\n    }\\n\\n    this._setEscapeEvent();\\n\\n    this._setResizeEvent();\\n\\n    EventHandler.off(document, EVENT_FOCUSIN$1);\\n\\n    this._element.classList.remove(CLASS_NAME_SHOW$5);\\n\\n    EventHandler.off(this._element, EVENT_CLICK_DISMISS$2);\\n    EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);\\n\\n    if (isAnimated) {\\n      const transitionDuration = getTransitionDurationFromElement(this._element);\\n      EventHandler.one(this._element, 'transitionend', event => this._hideModal(event));\\n      emulateTransitionEnd(this._element, transitionDuration);\\n    } else {\\n      this._hideModal();\\n    }\\n  }\\n\\n  dispose() {\\n    [window, this._element, this._dialog].forEach(htmlElement => EventHandler.off(htmlElement, EVENT_KEY$6));\\n    super.dispose();\\n    /**\\n     * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`\\n     * Do not move `document` in `htmlElements` array\\n     * It will remove `EVENT_CLICK_DATA_API` event that should remain\\n     */\\n\\n    EventHandler.off(document, EVENT_FOCUSIN$1);\\n    this._config = null;\\n    this._dialog = null;\\n    this._backdrop = null;\\n    this._isShown = null;\\n    this._isBodyOverflowing = null;\\n    this._ignoreBackdropClick = null;\\n    this._isTransitioning = null;\\n    this._scrollbarWidth = null;\\n  }\\n\\n  handleUpdate() {\\n    this._adjustDialog();\\n  } // Private\\n\\n\\n  _getConfig(config) {\\n    config = { ...Default$5,\\n      ...config\\n    };\\n    typeCheckConfig(NAME$6, config, DefaultType$5);\\n    return config;\\n  }\\n\\n  _showElement(relatedTarget) {\\n    const isAnimated = this._isAnimated();\\n\\n    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\\n\\n    if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\\n      // Don't move modal's DOM position\\n      document.body.appendChild(this._element);\\n    }\\n\\n    this._element.style.display = 'block';\\n\\n    this._element.removeAttribute('aria-hidden');\\n\\n    this._element.setAttribute('aria-modal', true);\\n\\n    this._element.setAttribute('role', 'dialog');\\n\\n    this._element.scrollTop = 0;\\n\\n    if (modalBody) {\\n      modalBody.scrollTop = 0;\\n    }\\n\\n    if (isAnimated) {\\n      reflow(this._element);\\n    }\\n\\n    this._element.classList.add(CLASS_NAME_SHOW$5);\\n\\n    if (this._config.focus) {\\n      this._enforceFocus();\\n    }\\n\\n    const transitionComplete = () => {\\n      if (this._config.focus) {\\n        this._element.focus();\\n      }\\n\\n      this._isTransitioning = false;\\n      EventHandler.trigger(this._element, EVENT_SHOWN$3, {\\n        relatedTarget\\n      });\\n    };\\n\\n    if (isAnimated) {\\n      const transitionDuration = getTransitionDurationFromElement(this._dialog);\\n      EventHandler.one(this._dialog, 'transitionend', transitionComplete);\\n      emulateTransitionEnd(this._dialog, transitionDuration);\\n    } else {\\n      transitionComplete();\\n    }\\n  }\\n\\n  _enforceFocus() {\\n    EventHandler.off(document, EVENT_FOCUSIN$1); // guard against infinite focus loop\\n\\n    EventHandler.on(document, EVENT_FOCUSIN$1, event => {\\n      if (document !== event.target && this._element !== event.target && !this._element.contains(event.target)) {\\n        this._element.focus();\\n      }\\n    });\\n  }\\n\\n  _setEscapeEvent() {\\n    if (this._isShown) {\\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {\\n        if (this._config.keyboard && event.key === ESCAPE_KEY$1) {\\n          event.preventDefault();\\n          this.hide();\\n        } else if (!this._config.keyboard && event.key === ESCAPE_KEY$1) {\\n          this._triggerBackdropTransition();\\n        }\\n      });\\n    } else {\\n      EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS);\\n    }\\n  }\\n\\n  _setResizeEvent() {\\n    if (this._isShown) {\\n      EventHandler.on(window, EVENT_RESIZE, () => this._adjustDialog());\\n    } else {\\n      EventHandler.off(window, EVENT_RESIZE);\\n    }\\n  }\\n\\n  _hideModal() {\\n    this._element.style.display = 'none';\\n\\n    this._element.setAttribute('aria-hidden', true);\\n\\n    this._element.removeAttribute('aria-modal');\\n\\n    this._element.removeAttribute('role');\\n\\n    this._isTransitioning = false;\\n\\n    this._showBackdrop(() => {\\n      document.body.classList.remove(CLASS_NAME_OPEN);\\n\\n      this._resetAdjustments();\\n\\n      this._resetScrollbar();\\n\\n      EventHandler.trigger(this._element, EVENT_HIDDEN$3);\\n    });\\n  }\\n\\n  _removeBackdrop() {\\n    this._backdrop.parentNode.removeChild(this._backdrop);\\n\\n    this._backdrop = null;\\n  }\\n\\n  _showBackdrop(callback) {\\n    const isAnimated = this._isAnimated();\\n\\n    if (this._isShown && this._config.backdrop) {\\n      this._backdrop = document.createElement('div');\\n      this._backdrop.className = CLASS_NAME_BACKDROP;\\n\\n      if (isAnimated) {\\n        this._backdrop.classList.add(CLASS_NAME_FADE$4);\\n      }\\n\\n      document.body.appendChild(this._backdrop);\\n      EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, event => {\\n        if (this._ignoreBackdropClick) {\\n          this._ignoreBackdropClick = false;\\n          return;\\n        }\\n\\n        if (event.target !== event.currentTarget) {\\n          return;\\n        }\\n\\n        if (this._config.backdrop === 'static') {\\n          this._triggerBackdropTransition();\\n        } else {\\n          this.hide();\\n        }\\n      });\\n\\n      if (isAnimated) {\\n        reflow(this._backdrop);\\n      }\\n\\n      this._backdrop.classList.add(CLASS_NAME_SHOW$5);\\n\\n      if (!isAnimated) {\\n        callback();\\n        return;\\n      }\\n\\n      const backdropTransitionDuration = getTransitionDurationFromElement(this._backdrop);\\n      EventHandler.one(this._backdrop, 'transitionend', callback);\\n      emulateTransitionEnd(this._backdrop, backdropTransitionDuration);\\n    } else if (!this._isShown && this._backdrop) {\\n      this._backdrop.classList.remove(CLASS_NAME_SHOW$5);\\n\\n      const callbackRemove = () => {\\n        this._removeBackdrop();\\n\\n        callback();\\n      };\\n\\n      if (isAnimated) {\\n        const backdropTransitionDuration = getTransitionDurationFromElement(this._backdrop);\\n        EventHandler.one(this._backdrop, 'transitionend', callbackRemove);\\n        emulateTransitionEnd(this._backdrop, backdropTransitionDuration);\\n      } else {\\n        callbackRemove();\\n      }\\n    } else {\\n      callback();\\n    }\\n  }\\n\\n  _isAnimated() {\\n    return this._element.classList.contains(CLASS_NAME_FADE$4);\\n  }\\n\\n  _triggerBackdropTransition() {\\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\\n\\n    if (hideEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\\n\\n    if (!isModalOverflowing) {\\n      this._element.style.overflowY = 'hidden';\\n    }\\n\\n    this._element.classList.add(CLASS_NAME_STATIC);\\n\\n    const modalTransitionDuration = getTransitionDurationFromElement(this._dialog);\\n    EventHandler.off(this._element, 'transitionend');\\n    EventHandler.one(this._element, 'transitionend', () => {\\n      this._element.classList.remove(CLASS_NAME_STATIC);\\n\\n      if (!isModalOverflowing) {\\n        EventHandler.one(this._element, 'transitionend', () => {\\n          this._element.style.overflowY = '';\\n        });\\n        emulateTransitionEnd(this._element, modalTransitionDuration);\\n      }\\n    });\\n    emulateTransitionEnd(this._element, modalTransitionDuration);\\n\\n    this._element.focus();\\n  } // ----------------------------------------------------------------------\\n  // the following methods are used to handle overflowing modals\\n  // ----------------------------------------------------------------------\\n\\n\\n  _adjustDialog() {\\n    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\\n\\n    if (!this._isBodyOverflowing && isModalOverflowing && !isRTL() || this._isBodyOverflowing && !isModalOverflowing && isRTL()) {\\n      this._element.style.paddingLeft = `${this._scrollbarWidth}px`;\\n    }\\n\\n    if (this._isBodyOverflowing && !isModalOverflowing && !isRTL() || !this._isBodyOverflowing && isModalOverflowing && isRTL()) {\\n      this._element.style.paddingRight = `${this._scrollbarWidth}px`;\\n    }\\n  }\\n\\n  _resetAdjustments() {\\n    this._element.style.paddingLeft = '';\\n    this._element.style.paddingRight = '';\\n  }\\n\\n  _checkScrollbar() {\\n    const rect = document.body.getBoundingClientRect();\\n    this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;\\n    this._scrollbarWidth = this._getScrollbarWidth();\\n  }\\n\\n  _setScrollbar() {\\n    if (this._isBodyOverflowing) {\\n      this._setElementAttributes(SELECTOR_FIXED_CONTENT$1, 'paddingRight', calculatedValue => calculatedValue + this._scrollbarWidth);\\n\\n      this._setElementAttributes(SELECTOR_STICKY_CONTENT$1, 'marginRight', calculatedValue => calculatedValue - this._scrollbarWidth);\\n\\n      this._setElementAttributes('body', 'paddingRight', calculatedValue => calculatedValue + this._scrollbarWidth);\\n    }\\n\\n    document.body.classList.add(CLASS_NAME_OPEN);\\n  }\\n\\n  _setElementAttributes(selector, styleProp, callback) {\\n    SelectorEngine.find(selector).forEach(element => {\\n      if (element !== document.body && window.innerWidth > element.clientWidth + this._scrollbarWidth) {\\n        return;\\n      }\\n\\n      const actualValue = element.style[styleProp];\\n      const calculatedValue = window.getComputedStyle(element)[styleProp];\\n      Manipulator.setDataAttribute(element, styleProp, actualValue);\\n      element.style[styleProp] = callback(Number.parseFloat(calculatedValue)) + 'px';\\n    });\\n  }\\n\\n  _resetScrollbar() {\\n    this._resetElementAttributes(SELECTOR_FIXED_CONTENT$1, 'paddingRight');\\n\\n    this._resetElementAttributes(SELECTOR_STICKY_CONTENT$1, 'marginRight');\\n\\n    this._resetElementAttributes('body', 'paddingRight');\\n  }\\n\\n  _resetElementAttributes(selector, styleProp) {\\n    SelectorEngine.find(selector).forEach(element => {\\n      const value = Manipulator.getDataAttribute(element, styleProp);\\n\\n      if (typeof value === 'undefined' && element === document.body) {\\n        element.style[styleProp] = '';\\n      } else {\\n        Manipulator.removeDataAttribute(element, styleProp);\\n        element.style[styleProp] = value;\\n      }\\n    });\\n  }\\n\\n  _getScrollbarWidth() {\\n    // thx d.walsh\\n    const scrollDiv = document.createElement('div');\\n    scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;\\n    document.body.appendChild(scrollDiv);\\n    const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\\n    document.body.removeChild(scrollDiv);\\n    return scrollbarWidth;\\n  } // Static\\n\\n\\n  static jQueryInterface(config, relatedTarget) {\\n    return this.each(function () {\\n      let data = Data.get(this, DATA_KEY$6);\\n      const _config = { ...Default$5,\\n        ...Manipulator.getDataAttributes(this),\\n        ...(typeof config === 'object' && config ? config : {})\\n      };\\n\\n      if (!data) {\\n        data = new Modal(this, _config);\\n      }\\n\\n      if (typeof config === 'string') {\\n        if (typeof data[config] === 'undefined') {\\n          throw new TypeError(`No method named \\\"${config}\\\"`);\\n        }\\n\\n        data[config](relatedTarget);\\n      }\\n    });\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * Data Api implementation\\n * ------------------------------------------------------------------------\\n */\\n\\n\\nEventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\\n  const target = getElementFromSelector(this);\\n\\n  if (this.tagName === 'A' || this.tagName === 'AREA') {\\n    event.preventDefault();\\n  }\\n\\n  EventHandler.one(target, EVENT_SHOW$3, showEvent => {\\n    if (showEvent.defaultPrevented) {\\n      // only register focus restorer if modal will actually get shown\\n      return;\\n    }\\n\\n    EventHandler.one(target, EVENT_HIDDEN$3, () => {\\n      if (isVisible(this)) {\\n        this.focus();\\n      }\\n    });\\n  });\\n  let data = Data.get(target, DATA_KEY$6);\\n\\n  if (!data) {\\n    const config = { ...Manipulator.getDataAttributes(target),\\n      ...Manipulator.getDataAttributes(this)\\n    };\\n    data = new Modal(target, config);\\n  }\\n\\n  data.toggle(this);\\n});\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .Modal to jQuery only if jQuery is present\\n */\\n\\ndefineJQueryPlugin(NAME$6, Modal);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): util/scrollBar.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\nconst SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed';\\nconst SELECTOR_STICKY_CONTENT = '.sticky-top';\\n\\nconst getWidth = () => {\\n  // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\\n  const documentWidth = document.documentElement.clientWidth;\\n  return Math.abs(window.innerWidth - documentWidth);\\n};\\n\\nconst bootstrap_esm_hide = (width = getWidth()) => {\\n  document.body.style.overflow = 'hidden';\\n\\n  _setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', calculatedValue => calculatedValue + width);\\n\\n  _setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', calculatedValue => calculatedValue - width);\\n\\n  _setElementAttributes('body', 'paddingRight', calculatedValue => calculatedValue + width);\\n};\\n\\nconst _setElementAttributes = (selector, styleProp, callback) => {\\n  const scrollbarWidth = getWidth();\\n  SelectorEngine.find(selector).forEach(element => {\\n    if (element !== document.body && window.innerWidth > element.clientWidth + scrollbarWidth) {\\n      return;\\n    }\\n\\n    const actualValue = element.style[styleProp];\\n    const calculatedValue = window.getComputedStyle(element)[styleProp];\\n    Manipulator.setDataAttribute(element, styleProp, actualValue);\\n    element.style[styleProp] = callback(Number.parseFloat(calculatedValue)) + 'px';\\n  });\\n};\\n\\nconst bootstrap_esm_reset = () => {\\n  document.body.style.overflow = 'auto';\\n\\n  _resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');\\n\\n  _resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');\\n\\n  _resetElementAttributes('body', 'paddingRight');\\n};\\n\\nconst _resetElementAttributes = (selector, styleProp) => {\\n  SelectorEngine.find(selector).forEach(element => {\\n    const value = Manipulator.getDataAttribute(element, styleProp);\\n\\n    if (typeof value === 'undefined' && element === document.body) {\\n      element.style.removeProperty(styleProp);\\n    } else {\\n      Manipulator.removeDataAttribute(element, styleProp);\\n      element.style[styleProp] = value;\\n    }\\n  });\\n};\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): offcanvas.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$5 = 'offcanvas';\\nconst DATA_KEY$5 = 'bs.offcanvas';\\nconst EVENT_KEY$5 = `.${DATA_KEY$5}`;\\nconst DATA_API_KEY$2 = '.data-api';\\nconst EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$5}${DATA_API_KEY$2}`;\\nconst ESCAPE_KEY = 'Escape';\\nconst Default$4 = {\\n  backdrop: true,\\n  keyboard: true,\\n  scroll: false\\n};\\nconst DefaultType$4 = {\\n  backdrop: 'boolean',\\n  keyboard: 'boolean',\\n  scroll: 'boolean'\\n};\\nconst CLASS_NAME_BACKDROP_BODY = 'offcanvas-backdrop';\\nconst CLASS_NAME_SHOW$4 = 'show';\\nconst CLASS_NAME_TOGGLING = 'offcanvas-toggling';\\nconst OPEN_SELECTOR = '.offcanvas.show';\\nconst ACTIVE_SELECTOR = `${OPEN_SELECTOR}, .${CLASS_NAME_TOGGLING}`;\\nconst EVENT_SHOW$2 = `show${EVENT_KEY$5}`;\\nconst EVENT_SHOWN$2 = `shown${EVENT_KEY$5}`;\\nconst EVENT_HIDE$2 = `hide${EVENT_KEY$5}`;\\nconst EVENT_HIDDEN$2 = `hidden${EVENT_KEY$5}`;\\nconst EVENT_FOCUSIN = `focusin${EVENT_KEY$5}`;\\nconst EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$5}${DATA_API_KEY$2}`;\\nconst EVENT_CLICK_DISMISS$1 = `click.dismiss${EVENT_KEY$5}`;\\nconst SELECTOR_DATA_DISMISS$1 = '[data-bs-dismiss=\\\"offcanvas\\\"]';\\nconst SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\\\"offcanvas\\\"]';\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass Offcanvas extends BaseComponent {\\n  constructor(element, config) {\\n    super(element);\\n    this._config = this._getConfig(config);\\n    this._isShown = false;\\n\\n    this._addEventListeners();\\n  } // Getters\\n\\n\\n  static get Default() {\\n    return Default$4;\\n  }\\n\\n  static get DATA_KEY() {\\n    return DATA_KEY$5;\\n  } // Public\\n\\n\\n  toggle(relatedTarget) {\\n    return this._isShown ? this.hide() : this.show(relatedTarget);\\n  }\\n\\n  show(relatedTarget) {\\n    if (this._isShown) {\\n      return;\\n    }\\n\\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {\\n      relatedTarget\\n    });\\n\\n    if (showEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    this._isShown = true;\\n    this._element.style.visibility = 'visible';\\n\\n    if (this._config.backdrop) {\\n      document.body.classList.add(CLASS_NAME_BACKDROP_BODY);\\n    }\\n\\n    if (!this._config.scroll) {\\n      bootstrap_esm_hide();\\n    }\\n\\n    this._element.classList.add(CLASS_NAME_TOGGLING);\\n\\n    this._element.removeAttribute('aria-hidden');\\n\\n    this._element.setAttribute('aria-modal', true);\\n\\n    this._element.setAttribute('role', 'dialog');\\n\\n    this._element.classList.add(CLASS_NAME_SHOW$4);\\n\\n    const completeCallBack = () => {\\n      this._element.classList.remove(CLASS_NAME_TOGGLING);\\n\\n      EventHandler.trigger(this._element, EVENT_SHOWN$2, {\\n        relatedTarget\\n      });\\n\\n      this._enforceFocusOnElement(this._element);\\n    };\\n\\n    setTimeout(completeCallBack, getTransitionDurationFromElement(this._element));\\n  }\\n\\n  hide() {\\n    if (!this._isShown) {\\n      return;\\n    }\\n\\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);\\n\\n    if (hideEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    this._element.classList.add(CLASS_NAME_TOGGLING);\\n\\n    EventHandler.off(document, EVENT_FOCUSIN);\\n\\n    this._element.blur();\\n\\n    this._isShown = false;\\n\\n    this._element.classList.remove(CLASS_NAME_SHOW$4);\\n\\n    const completeCallback = () => {\\n      this._element.setAttribute('aria-hidden', true);\\n\\n      this._element.removeAttribute('aria-modal');\\n\\n      this._element.removeAttribute('role');\\n\\n      this._element.style.visibility = 'hidden';\\n\\n      if (this._config.backdrop) {\\n        document.body.classList.remove(CLASS_NAME_BACKDROP_BODY);\\n      }\\n\\n      if (!this._config.scroll) {\\n        bootstrap_esm_reset();\\n      }\\n\\n      EventHandler.trigger(this._element, EVENT_HIDDEN$2);\\n\\n      this._element.classList.remove(CLASS_NAME_TOGGLING);\\n    };\\n\\n    setTimeout(completeCallback, getTransitionDurationFromElement(this._element));\\n  } // Private\\n\\n\\n  _getConfig(config) {\\n    config = { ...Default$4,\\n      ...Manipulator.getDataAttributes(this._element),\\n      ...(typeof config === 'object' ? config : {})\\n    };\\n    typeCheckConfig(NAME$5, config, DefaultType$4);\\n    return config;\\n  }\\n\\n  _enforceFocusOnElement(element) {\\n    EventHandler.off(document, EVENT_FOCUSIN); // guard against infinite focus loop\\n\\n    EventHandler.on(document, EVENT_FOCUSIN, event => {\\n      if (document !== event.target && element !== event.target && !element.contains(event.target)) {\\n        element.focus();\\n      }\\n    });\\n    element.focus();\\n  }\\n\\n  _addEventListeners() {\\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, () => this.hide());\\n    EventHandler.on(document, 'keydown', event => {\\n      if (this._config.keyboard && event.key === ESCAPE_KEY) {\\n        this.hide();\\n      }\\n    });\\n    EventHandler.on(document, EVENT_CLICK_DATA_API$1, event => {\\n      const target = SelectorEngine.findOne(getSelectorFromElement(event.target));\\n\\n      if (!this._element.contains(event.target) && target !== this._element) {\\n        this.hide();\\n      }\\n    });\\n  } // Static\\n\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      const data = Data.get(this, DATA_KEY$5) || new Offcanvas(this, typeof config === 'object' ? config : {});\\n\\n      if (typeof config !== 'string') {\\n        return;\\n      }\\n\\n      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\\n        throw new TypeError(`No method named \\\"${config}\\\"`);\\n      }\\n\\n      data[config](this);\\n    });\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * Data Api implementation\\n * ------------------------------------------------------------------------\\n */\\n\\n\\nEventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\\n  const target = getElementFromSelector(this);\\n\\n  if (['A', 'AREA'].includes(this.tagName)) {\\n    event.preventDefault();\\n  }\\n\\n  if (isDisabled(this)) {\\n    return;\\n  }\\n\\n  EventHandler.one(target, EVENT_HIDDEN$2, () => {\\n    // focus on trigger when it is closed\\n    if (isVisible(this)) {\\n      this.focus();\\n    }\\n  }); // avoid conflict when clicking a toggler of an offcanvas, while another is open\\n\\n  const allReadyOpen = SelectorEngine.findOne(ACTIVE_SELECTOR);\\n\\n  if (allReadyOpen && allReadyOpen !== target) {\\n    return;\\n  }\\n\\n  const data = Data.get(target, DATA_KEY$5) || new Offcanvas(target);\\n  data.toggle(this);\\n});\\nEventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {\\n  SelectorEngine.find(OPEN_SELECTOR).forEach(el => (Data.get(el, DATA_KEY$5) || new Offcanvas(el)).show());\\n});\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n */\\n\\ndefineJQueryPlugin(NAME$5, Offcanvas);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): util/sanitizer.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\nconst uriAttrs = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\\\w-]*$/i;\\n/**\\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\\n *\\n * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\\n */\\n\\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i;\\n/**\\n * A pattern that matches safe data URLs. Only matches image, video and audio types.\\n *\\n * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\\n */\\n\\nconst DATA_URL_PATTERN = /^data:(?:image\\\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\\\/(?:mpeg|mp4|ogg|webm)|audio\\\\/(?:mp3|oga|ogg|opus));base64,[\\\\d+/a-z]+=*$/i;\\n\\nconst allowedAttribute = (attr, allowedAttributeList) => {\\n  const attrName = attr.nodeName.toLowerCase();\\n\\n  if (allowedAttributeList.includes(attrName)) {\\n    if (uriAttrs.has(attrName)) {\\n      return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));\\n    }\\n\\n    return true;\\n  }\\n\\n  const regExp = allowedAttributeList.filter(attrRegex => attrRegex instanceof RegExp); // Check if a regular expression validates the attribute.\\n\\n  for (let i = 0, len = regExp.length; i < len; i++) {\\n    if (regExp[i].test(attrName)) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n\\nconst DefaultAllowlist = {\\n  // Global attributes allowed on any supplied element below.\\n  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\\n  a: ['target', 'href', 'title', 'rel'],\\n  area: [],\\n  b: [],\\n  br: [],\\n  col: [],\\n  code: [],\\n  div: [],\\n  em: [],\\n  hr: [],\\n  h1: [],\\n  h2: [],\\n  h3: [],\\n  h4: [],\\n  h5: [],\\n  h6: [],\\n  i: [],\\n  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\\n  li: [],\\n  ol: [],\\n  p: [],\\n  pre: [],\\n  s: [],\\n  small: [],\\n  span: [],\\n  sub: [],\\n  sup: [],\\n  strong: [],\\n  u: [],\\n  ul: []\\n};\\nfunction sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {\\n  if (!unsafeHtml.length) {\\n    return unsafeHtml;\\n  }\\n\\n  if (sanitizeFn && typeof sanitizeFn === 'function') {\\n    return sanitizeFn(unsafeHtml);\\n  }\\n\\n  const domParser = new window.DOMParser();\\n  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\\n  const allowlistKeys = Object.keys(allowList);\\n  const elements = [].concat(...createdDocument.body.querySelectorAll('*'));\\n\\n  for (let i = 0, len = elements.length; i < len; i++) {\\n    const el = elements[i];\\n    const elName = el.nodeName.toLowerCase();\\n\\n    if (!allowlistKeys.includes(elName)) {\\n      el.parentNode.removeChild(el);\\n      continue;\\n    }\\n\\n    const attributeList = [].concat(...el.attributes);\\n    const allowedAttributes = [].concat(allowList['*'] || [], allowList[elName] || []);\\n    attributeList.forEach(attr => {\\n      if (!allowedAttribute(attr, allowedAttributes)) {\\n        el.removeAttribute(attr.nodeName);\\n      }\\n    });\\n  }\\n\\n  return createdDocument.body.innerHTML;\\n}\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): tooltip.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$4 = 'tooltip';\\nconst DATA_KEY$4 = 'bs.tooltip';\\nconst EVENT_KEY$4 = `.${DATA_KEY$4}`;\\nconst CLASS_PREFIX$1 = 'bs-tooltip';\\nconst BSCLS_PREFIX_REGEX$1 = new RegExp(`(^|\\\\\\\\s)${CLASS_PREFIX$1}\\\\\\\\S+`, 'g');\\nconst DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\\nconst DefaultType$3 = {\\n  animation: 'boolean',\\n  template: 'string',\\n  title: '(string|element|function)',\\n  trigger: 'string',\\n  delay: '(number|object)',\\n  html: 'boolean',\\n  selector: '(string|boolean)',\\n  placement: '(string|function)',\\n  offset: '(array|string|function)',\\n  container: '(string|element|boolean)',\\n  fallbackPlacements: 'array',\\n  boundary: '(string|element)',\\n  customClass: '(string|function)',\\n  sanitize: 'boolean',\\n  sanitizeFn: '(null|function)',\\n  allowList: 'object',\\n  popperConfig: '(null|object|function)'\\n};\\nconst AttachmentMap = {\\n  AUTO: 'auto',\\n  TOP: 'top',\\n  RIGHT: isRTL() ? 'left' : 'right',\\n  BOTTOM: 'bottom',\\n  LEFT: isRTL() ? 'right' : 'left'\\n};\\nconst Default$3 = {\\n  animation: true,\\n  template: '<div class=\\\"tooltip\\\" role=\\\"tooltip\\\">' + '<div class=\\\"tooltip-arrow\\\"></div>' + '<div class=\\\"tooltip-inner\\\"></div>' + '</div>',\\n  trigger: 'hover focus',\\n  title: '',\\n  delay: 0,\\n  html: false,\\n  selector: false,\\n  placement: 'top',\\n  offset: [0, 0],\\n  container: false,\\n  fallbackPlacements: ['top', 'right', 'bottom', 'left'],\\n  boundary: 'clippingParents',\\n  customClass: '',\\n  sanitize: true,\\n  sanitizeFn: null,\\n  allowList: DefaultAllowlist,\\n  popperConfig: null\\n};\\nconst Event$2 = {\\n  HIDE: `hide${EVENT_KEY$4}`,\\n  HIDDEN: `hidden${EVENT_KEY$4}`,\\n  SHOW: `show${EVENT_KEY$4}`,\\n  SHOWN: `shown${EVENT_KEY$4}`,\\n  INSERTED: `inserted${EVENT_KEY$4}`,\\n  CLICK: `click${EVENT_KEY$4}`,\\n  FOCUSIN: `focusin${EVENT_KEY$4}`,\\n  FOCUSOUT: `focusout${EVENT_KEY$4}`,\\n  MOUSEENTER: `mouseenter${EVENT_KEY$4}`,\\n  MOUSELEAVE: `mouseleave${EVENT_KEY$4}`\\n};\\nconst CLASS_NAME_FADE$3 = 'fade';\\nconst CLASS_NAME_MODAL = 'modal';\\nconst CLASS_NAME_SHOW$3 = 'show';\\nconst HOVER_STATE_SHOW = 'show';\\nconst HOVER_STATE_OUT = 'out';\\nconst SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\\nconst TRIGGER_HOVER = 'hover';\\nconst TRIGGER_FOCUS = 'focus';\\nconst TRIGGER_CLICK = 'click';\\nconst TRIGGER_MANUAL = 'manual';\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass bootstrap_esm_Tooltip extends BaseComponent {\\n  constructor(element, config) {\\n    if (typeof lib_namespaceObject === 'undefined') {\\n      throw new TypeError('Bootstrap\\\\'s tooltips require Popper (https://popper.js.org)');\\n    }\\n\\n    super(element); // private\\n\\n    this._isEnabled = true;\\n    this._timeout = 0;\\n    this._hoverState = '';\\n    this._activeTrigger = {};\\n    this._popper = null; // Protected\\n\\n    this.config = this._getConfig(config);\\n    this.tip = null;\\n\\n    this._setListeners();\\n  } // Getters\\n\\n\\n  static get Default() {\\n    return Default$3;\\n  }\\n\\n  static get NAME() {\\n    return NAME$4;\\n  }\\n\\n  static get DATA_KEY() {\\n    return DATA_KEY$4;\\n  }\\n\\n  static get Event() {\\n    return Event$2;\\n  }\\n\\n  static get EVENT_KEY() {\\n    return EVENT_KEY$4;\\n  }\\n\\n  static get DefaultType() {\\n    return DefaultType$3;\\n  } // Public\\n\\n\\n  enable() {\\n    this._isEnabled = true;\\n  }\\n\\n  disable() {\\n    this._isEnabled = false;\\n  }\\n\\n  toggleEnabled() {\\n    this._isEnabled = !this._isEnabled;\\n  }\\n\\n  toggle(event) {\\n    if (!this._isEnabled) {\\n      return;\\n    }\\n\\n    if (event) {\\n      const context = this._initializeOnDelegatedTarget(event);\\n\\n      context._activeTrigger.click = !context._activeTrigger.click;\\n\\n      if (context._isWithActiveTrigger()) {\\n        context._enter(null, context);\\n      } else {\\n        context._leave(null, context);\\n      }\\n    } else {\\n      if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$3)) {\\n        this._leave(null, this);\\n\\n        return;\\n      }\\n\\n      this._enter(null, this);\\n    }\\n  }\\n\\n  dispose() {\\n    clearTimeout(this._timeout);\\n    EventHandler.off(this._element, this.constructor.EVENT_KEY);\\n    EventHandler.off(this._element.closest(`.${CLASS_NAME_MODAL}`), 'hide.bs.modal', this._hideModalHandler);\\n\\n    if (this.tip && this.tip.parentNode) {\\n      this.tip.parentNode.removeChild(this.tip);\\n    }\\n\\n    this._isEnabled = null;\\n    this._timeout = null;\\n    this._hoverState = null;\\n    this._activeTrigger = null;\\n\\n    if (this._popper) {\\n      this._popper.destroy();\\n    }\\n\\n    this._popper = null;\\n    this.config = null;\\n    this.tip = null;\\n    super.dispose();\\n  }\\n\\n  show() {\\n    if (this._element.style.display === 'none') {\\n      throw new Error('Please use show on visible elements');\\n    }\\n\\n    if (!(this.isWithContent() && this._isEnabled)) {\\n      return;\\n    }\\n\\n    const showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);\\n    const shadowRoot = findShadowRoot(this._element);\\n    const isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);\\n\\n    if (showEvent.defaultPrevented || !isInTheDom) {\\n      return;\\n    }\\n\\n    const tip = this.getTipElement();\\n    const tipId = getUID(this.constructor.NAME);\\n    tip.setAttribute('id', tipId);\\n\\n    this._element.setAttribute('aria-describedby', tipId);\\n\\n    this.setContent();\\n\\n    if (this.config.animation) {\\n      tip.classList.add(CLASS_NAME_FADE$3);\\n    }\\n\\n    const placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this._element) : this.config.placement;\\n\\n    const attachment = this._getAttachment(placement);\\n\\n    this._addAttachmentClass(attachment);\\n\\n    const container = this._getContainer();\\n\\n    Data.set(tip, this.constructor.DATA_KEY, this);\\n\\n    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\\n      container.appendChild(tip);\\n      EventHandler.trigger(this._element, this.constructor.Event.INSERTED);\\n    }\\n\\n    if (this._popper) {\\n      this._popper.update();\\n    } else {\\n      this._popper = popper_createPopper(this._element, tip, this._getPopperConfig(attachment));\\n    }\\n\\n    tip.classList.add(CLASS_NAME_SHOW$3);\\n    const customClass = typeof this.config.customClass === 'function' ? this.config.customClass() : this.config.customClass;\\n\\n    if (customClass) {\\n      tip.classList.add(...customClass.split(' '));\\n    } // If this is a touch-enabled device we add extra\\n    // empty mouseover listeners to the body's immediate children;\\n    // only needed because of broken event delegation on iOS\\n    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\\n\\n\\n    if ('ontouchstart' in document.documentElement) {\\n      [].concat(...document.body.children).forEach(element => {\\n        EventHandler.on(element, 'mouseover', noop());\\n      });\\n    }\\n\\n    const complete = () => {\\n      const prevHoverState = this._hoverState;\\n      this._hoverState = null;\\n      EventHandler.trigger(this._element, this.constructor.Event.SHOWN);\\n\\n      if (prevHoverState === HOVER_STATE_OUT) {\\n        this._leave(null, this);\\n      }\\n    };\\n\\n    if (this.tip.classList.contains(CLASS_NAME_FADE$3)) {\\n      const transitionDuration = getTransitionDurationFromElement(this.tip);\\n      EventHandler.one(this.tip, 'transitionend', complete);\\n      emulateTransitionEnd(this.tip, transitionDuration);\\n    } else {\\n      complete();\\n    }\\n  }\\n\\n  hide() {\\n    if (!this._popper) {\\n      return;\\n    }\\n\\n    const tip = this.getTipElement();\\n\\n    const complete = () => {\\n      if (this._isWithActiveTrigger()) {\\n        return;\\n      }\\n\\n      if (this._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {\\n        tip.parentNode.removeChild(tip);\\n      }\\n\\n      this._cleanTipClass();\\n\\n      this._element.removeAttribute('aria-describedby');\\n\\n      EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);\\n\\n      if (this._popper) {\\n        this._popper.destroy();\\n\\n        this._popper = null;\\n      }\\n    };\\n\\n    const hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);\\n\\n    if (hideEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    tip.classList.remove(CLASS_NAME_SHOW$3); // If this is a touch-enabled device we remove the extra\\n    // empty mouseover listeners we added for iOS support\\n\\n    if ('ontouchstart' in document.documentElement) {\\n      [].concat(...document.body.children).forEach(element => EventHandler.off(element, 'mouseover', noop));\\n    }\\n\\n    this._activeTrigger[TRIGGER_CLICK] = false;\\n    this._activeTrigger[TRIGGER_FOCUS] = false;\\n    this._activeTrigger[TRIGGER_HOVER] = false;\\n\\n    if (this.tip.classList.contains(CLASS_NAME_FADE$3)) {\\n      const transitionDuration = getTransitionDurationFromElement(tip);\\n      EventHandler.one(tip, 'transitionend', complete);\\n      emulateTransitionEnd(tip, transitionDuration);\\n    } else {\\n      complete();\\n    }\\n\\n    this._hoverState = '';\\n  }\\n\\n  update() {\\n    if (this._popper !== null) {\\n      this._popper.update();\\n    }\\n  } // Protected\\n\\n\\n  isWithContent() {\\n    return Boolean(this.getTitle());\\n  }\\n\\n  getTipElement() {\\n    if (this.tip) {\\n      return this.tip;\\n    }\\n\\n    const element = document.createElement('div');\\n    element.innerHTML = this.config.template;\\n    this.tip = element.children[0];\\n    return this.tip;\\n  }\\n\\n  setContent() {\\n    const tip = this.getTipElement();\\n    this.setElementContent(SelectorEngine.findOne(SELECTOR_TOOLTIP_INNER, tip), this.getTitle());\\n    tip.classList.remove(CLASS_NAME_FADE$3, CLASS_NAME_SHOW$3);\\n  }\\n\\n  setElementContent(element, content) {\\n    if (element === null) {\\n      return;\\n    }\\n\\n    if (typeof content === 'object' && bootstrap_esm_isElement(content)) {\\n      if (content.jquery) {\\n        content = content[0];\\n      } // content is a DOM node or a jQuery\\n\\n\\n      if (this.config.html) {\\n        if (content.parentNode !== element) {\\n          element.innerHTML = '';\\n          element.appendChild(content);\\n        }\\n      } else {\\n        element.textContent = content.textContent;\\n      }\\n\\n      return;\\n    }\\n\\n    if (this.config.html) {\\n      if (this.config.sanitize) {\\n        content = sanitizeHtml(content, this.config.allowList, this.config.sanitizeFn);\\n      }\\n\\n      element.innerHTML = content;\\n    } else {\\n      element.textContent = content;\\n    }\\n  }\\n\\n  getTitle() {\\n    let title = this._element.getAttribute('data-bs-original-title');\\n\\n    if (!title) {\\n      title = typeof this.config.title === 'function' ? this.config.title.call(this._element) : this.config.title;\\n    }\\n\\n    return title;\\n  }\\n\\n  updateAttachment(attachment) {\\n    if (attachment === 'right') {\\n      return 'end';\\n    }\\n\\n    if (attachment === 'left') {\\n      return 'start';\\n    }\\n\\n    return attachment;\\n  } // Private\\n\\n\\n  _initializeOnDelegatedTarget(event, context) {\\n    const dataKey = this.constructor.DATA_KEY;\\n    context = context || Data.get(event.delegateTarget, dataKey);\\n\\n    if (!context) {\\n      context = new this.constructor(event.delegateTarget, this._getDelegateConfig());\\n      Data.set(event.delegateTarget, dataKey, context);\\n    }\\n\\n    return context;\\n  }\\n\\n  _getOffset() {\\n    const {\\n      offset\\n    } = this.config;\\n\\n    if (typeof offset === 'string') {\\n      return offset.split(',').map(val => Number.parseInt(val, 10));\\n    }\\n\\n    if (typeof offset === 'function') {\\n      return popperData => offset(popperData, this._element);\\n    }\\n\\n    return offset;\\n  }\\n\\n  _getPopperConfig(attachment) {\\n    const defaultBsPopperConfig = {\\n      placement: attachment,\\n      modifiers: [{\\n        name: 'flip',\\n        options: {\\n          altBoundary: true,\\n          fallbackPlacements: this.config.fallbackPlacements\\n        }\\n      }, {\\n        name: 'offset',\\n        options: {\\n          offset: this._getOffset()\\n        }\\n      }, {\\n        name: 'preventOverflow',\\n        options: {\\n          boundary: this.config.boundary\\n        }\\n      }, {\\n        name: 'arrow',\\n        options: {\\n          element: `.${this.constructor.NAME}-arrow`\\n        }\\n      }, {\\n        name: 'onChange',\\n        enabled: true,\\n        phase: 'afterWrite',\\n        fn: data => this._handlePopperPlacementChange(data)\\n      }],\\n      onFirstUpdate: data => {\\n        if (data.options.placement !== data.placement) {\\n          this._handlePopperPlacementChange(data);\\n        }\\n      }\\n    };\\n    return { ...defaultBsPopperConfig,\\n      ...(typeof this.config.popperConfig === 'function' ? this.config.popperConfig(defaultBsPopperConfig) : this.config.popperConfig)\\n    };\\n  }\\n\\n  _addAttachmentClass(attachment) {\\n    this.getTipElement().classList.add(`${CLASS_PREFIX$1}-${this.updateAttachment(attachment)}`);\\n  }\\n\\n  _getContainer() {\\n    if (this.config.container === false) {\\n      return document.body;\\n    }\\n\\n    if (bootstrap_esm_isElement(this.config.container)) {\\n      return this.config.container;\\n    }\\n\\n    return SelectorEngine.findOne(this.config.container);\\n  }\\n\\n  _getAttachment(placement) {\\n    return AttachmentMap[placement.toUpperCase()];\\n  }\\n\\n  _setListeners() {\\n    const triggers = this.config.trigger.split(' ');\\n    triggers.forEach(trigger => {\\n      if (trigger === 'click') {\\n        EventHandler.on(this._element, this.constructor.Event.CLICK, this.config.selector, event => this.toggle(event));\\n      } else if (trigger !== TRIGGER_MANUAL) {\\n        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;\\n        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\\n        EventHandler.on(this._element, eventIn, this.config.selector, event => this._enter(event));\\n        EventHandler.on(this._element, eventOut, this.config.selector, event => this._leave(event));\\n      }\\n    });\\n\\n    this._hideModalHandler = () => {\\n      if (this._element) {\\n        this.hide();\\n      }\\n    };\\n\\n    EventHandler.on(this._element.closest(`.${CLASS_NAME_MODAL}`), 'hide.bs.modal', this._hideModalHandler);\\n\\n    if (this.config.selector) {\\n      this.config = { ...this.config,\\n        trigger: 'manual',\\n        selector: ''\\n      };\\n    } else {\\n      this._fixTitle();\\n    }\\n  }\\n\\n  _fixTitle() {\\n    const title = this._element.getAttribute('title');\\n\\n    const originalTitleType = typeof this._element.getAttribute('data-bs-original-title');\\n\\n    if (title || originalTitleType !== 'string') {\\n      this._element.setAttribute('data-bs-original-title', title || '');\\n\\n      if (title && !this._element.getAttribute('aria-label') && !this._element.textContent) {\\n        this._element.setAttribute('aria-label', title);\\n      }\\n\\n      this._element.setAttribute('title', '');\\n    }\\n  }\\n\\n  _enter(event, context) {\\n    context = this._initializeOnDelegatedTarget(event, context);\\n\\n    if (event) {\\n      context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\\n    }\\n\\n    if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {\\n      context._hoverState = HOVER_STATE_SHOW;\\n      return;\\n    }\\n\\n    clearTimeout(context._timeout);\\n    context._hoverState = HOVER_STATE_SHOW;\\n\\n    if (!context.config.delay || !context.config.delay.show) {\\n      context.show();\\n      return;\\n    }\\n\\n    context._timeout = setTimeout(() => {\\n      if (context._hoverState === HOVER_STATE_SHOW) {\\n        context.show();\\n      }\\n    }, context.config.delay.show);\\n  }\\n\\n  _leave(event, context) {\\n    context = this._initializeOnDelegatedTarget(event, context);\\n\\n    if (event) {\\n      context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\\n    }\\n\\n    if (context._isWithActiveTrigger()) {\\n      return;\\n    }\\n\\n    clearTimeout(context._timeout);\\n    context._hoverState = HOVER_STATE_OUT;\\n\\n    if (!context.config.delay || !context.config.delay.hide) {\\n      context.hide();\\n      return;\\n    }\\n\\n    context._timeout = setTimeout(() => {\\n      if (context._hoverState === HOVER_STATE_OUT) {\\n        context.hide();\\n      }\\n    }, context.config.delay.hide);\\n  }\\n\\n  _isWithActiveTrigger() {\\n    for (const trigger in this._activeTrigger) {\\n      if (this._activeTrigger[trigger]) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  _getConfig(config) {\\n    const dataAttributes = Manipulator.getDataAttributes(this._element);\\n    Object.keys(dataAttributes).forEach(dataAttr => {\\n      if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {\\n        delete dataAttributes[dataAttr];\\n      }\\n    });\\n\\n    if (config && typeof config.container === 'object' && config.container.jquery) {\\n      config.container = config.container[0];\\n    }\\n\\n    config = { ...this.constructor.Default,\\n      ...dataAttributes,\\n      ...(typeof config === 'object' && config ? config : {})\\n    };\\n\\n    if (typeof config.delay === 'number') {\\n      config.delay = {\\n        show: config.delay,\\n        hide: config.delay\\n      };\\n    }\\n\\n    if (typeof config.title === 'number') {\\n      config.title = config.title.toString();\\n    }\\n\\n    if (typeof config.content === 'number') {\\n      config.content = config.content.toString();\\n    }\\n\\n    typeCheckConfig(NAME$4, config, this.constructor.DefaultType);\\n\\n    if (config.sanitize) {\\n      config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);\\n    }\\n\\n    return config;\\n  }\\n\\n  _getDelegateConfig() {\\n    const config = {};\\n\\n    if (this.config) {\\n      for (const key in this.config) {\\n        if (this.constructor.Default[key] !== this.config[key]) {\\n          config[key] = this.config[key];\\n        }\\n      }\\n    }\\n\\n    return config;\\n  }\\n\\n  _cleanTipClass() {\\n    const tip = this.getTipElement();\\n    const tabClass = tip.getAttribute('class').match(BSCLS_PREFIX_REGEX$1);\\n\\n    if (tabClass !== null && tabClass.length > 0) {\\n      tabClass.map(token => token.trim()).forEach(tClass => tip.classList.remove(tClass));\\n    }\\n  }\\n\\n  _handlePopperPlacementChange(popperData) {\\n    const {\\n      state\\n    } = popperData;\\n\\n    if (!state) {\\n      return;\\n    }\\n\\n    this.tip = state.elements.popper;\\n\\n    this._cleanTipClass();\\n\\n    this._addAttachmentClass(this._getAttachment(state.placement));\\n  } // Static\\n\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      let data = Data.get(this, DATA_KEY$4);\\n\\n      const _config = typeof config === 'object' && config;\\n\\n      if (!data && /dispose|hide/.test(config)) {\\n        return;\\n      }\\n\\n      if (!data) {\\n        data = new bootstrap_esm_Tooltip(this, _config);\\n      }\\n\\n      if (typeof config === 'string') {\\n        if (typeof data[config] === 'undefined') {\\n          throw new TypeError(`No method named \\\"${config}\\\"`);\\n        }\\n\\n        data[config]();\\n      }\\n    });\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .Tooltip to jQuery only if jQuery is present\\n */\\n\\n\\ndefineJQueryPlugin(NAME$4, bootstrap_esm_Tooltip);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): popover.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$3 = 'popover';\\nconst DATA_KEY$3 = 'bs.popover';\\nconst EVENT_KEY$3 = `.${DATA_KEY$3}`;\\nconst CLASS_PREFIX = 'bs-popover';\\nconst BSCLS_PREFIX_REGEX = new RegExp(`(^|\\\\\\\\s)${CLASS_PREFIX}\\\\\\\\S+`, 'g');\\nconst Default$2 = { ...bootstrap_esm_Tooltip.Default,\\n  placement: 'right',\\n  offset: [0, 8],\\n  trigger: 'click',\\n  content: '',\\n  template: '<div class=\\\"popover\\\" role=\\\"tooltip\\\">' + '<div class=\\\"popover-arrow\\\"></div>' + '<h3 class=\\\"popover-header\\\"></h3>' + '<div class=\\\"popover-body\\\"></div>' + '</div>'\\n};\\nconst DefaultType$2 = { ...bootstrap_esm_Tooltip.DefaultType,\\n  content: '(string|element|function)'\\n};\\nconst Event$1 = {\\n  HIDE: `hide${EVENT_KEY$3}`,\\n  HIDDEN: `hidden${EVENT_KEY$3}`,\\n  SHOW: `show${EVENT_KEY$3}`,\\n  SHOWN: `shown${EVENT_KEY$3}`,\\n  INSERTED: `inserted${EVENT_KEY$3}`,\\n  CLICK: `click${EVENT_KEY$3}`,\\n  FOCUSIN: `focusin${EVENT_KEY$3}`,\\n  FOCUSOUT: `focusout${EVENT_KEY$3}`,\\n  MOUSEENTER: `mouseenter${EVENT_KEY$3}`,\\n  MOUSELEAVE: `mouseleave${EVENT_KEY$3}`\\n};\\nconst CLASS_NAME_FADE$2 = 'fade';\\nconst CLASS_NAME_SHOW$2 = 'show';\\nconst SELECTOR_TITLE = '.popover-header';\\nconst SELECTOR_CONTENT = '.popover-body';\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass Popover extends bootstrap_esm_Tooltip {\\n  // Getters\\n  static get Default() {\\n    return Default$2;\\n  }\\n\\n  static get NAME() {\\n    return NAME$3;\\n  }\\n\\n  static get DATA_KEY() {\\n    return DATA_KEY$3;\\n  }\\n\\n  static get Event() {\\n    return Event$1;\\n  }\\n\\n  static get EVENT_KEY() {\\n    return EVENT_KEY$3;\\n  }\\n\\n  static get DefaultType() {\\n    return DefaultType$2;\\n  } // Overrides\\n\\n\\n  isWithContent() {\\n    return this.getTitle() || this._getContent();\\n  }\\n\\n  setContent() {\\n    const tip = this.getTipElement(); // we use append for html objects to maintain js events\\n\\n    this.setElementContent(SelectorEngine.findOne(SELECTOR_TITLE, tip), this.getTitle());\\n\\n    let content = this._getContent();\\n\\n    if (typeof content === 'function') {\\n      content = content.call(this._element);\\n    }\\n\\n    this.setElementContent(SelectorEngine.findOne(SELECTOR_CONTENT, tip), content);\\n    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\\n  } // Private\\n\\n\\n  _addAttachmentClass(attachment) {\\n    this.getTipElement().classList.add(`${CLASS_PREFIX}-${this.updateAttachment(attachment)}`);\\n  }\\n\\n  _getContent() {\\n    return this._element.getAttribute('data-bs-content') || this.config.content;\\n  }\\n\\n  _cleanTipClass() {\\n    const tip = this.getTipElement();\\n    const tabClass = tip.getAttribute('class').match(BSCLS_PREFIX_REGEX);\\n\\n    if (tabClass !== null && tabClass.length > 0) {\\n      tabClass.map(token => token.trim()).forEach(tClass => tip.classList.remove(tClass));\\n    }\\n  } // Static\\n\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      let data = Data.get(this, DATA_KEY$3);\\n\\n      const _config = typeof config === 'object' ? config : null;\\n\\n      if (!data && /dispose|hide/.test(config)) {\\n        return;\\n      }\\n\\n      if (!data) {\\n        data = new Popover(this, _config);\\n        Data.set(this, DATA_KEY$3, data);\\n      }\\n\\n      if (typeof config === 'string') {\\n        if (typeof data[config] === 'undefined') {\\n          throw new TypeError(`No method named \\\"${config}\\\"`);\\n        }\\n\\n        data[config]();\\n      }\\n    });\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .Popover to jQuery only if jQuery is present\\n */\\n\\n\\ndefineJQueryPlugin(NAME$3, Popover);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): scrollspy.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$2 = 'scrollspy';\\nconst DATA_KEY$2 = 'bs.scrollspy';\\nconst EVENT_KEY$2 = `.${DATA_KEY$2}`;\\nconst DATA_API_KEY$1 = '.data-api';\\nconst Default$1 = {\\n  offset: 10,\\n  method: 'auto',\\n  target: ''\\n};\\nconst DefaultType$1 = {\\n  offset: 'number',\\n  method: 'string',\\n  target: '(string|element)'\\n};\\nconst EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\\nconst EVENT_SCROLL = `scroll${EVENT_KEY$2}`;\\nconst EVENT_LOAD_DATA_API = `load${EVENT_KEY$2}${DATA_API_KEY$1}`;\\nconst CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\\nconst CLASS_NAME_ACTIVE$1 = 'active';\\nconst SELECTOR_DATA_SPY = '[data-bs-spy=\\\"scroll\\\"]';\\nconst SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group';\\nconst SELECTOR_NAV_LINKS = '.nav-link';\\nconst SELECTOR_NAV_ITEMS = '.nav-item';\\nconst SELECTOR_LIST_ITEMS = '.list-group-item';\\nconst SELECTOR_DROPDOWN$1 = '.dropdown';\\nconst SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\\nconst METHOD_OFFSET = 'offset';\\nconst METHOD_POSITION = 'position';\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass ScrollSpy extends BaseComponent {\\n  constructor(element, config) {\\n    super(element);\\n    this._scrollElement = this._element.tagName === 'BODY' ? window : this._element;\\n    this._config = this._getConfig(config);\\n    this._selector = `${this._config.target} ${SELECTOR_NAV_LINKS}, ${this._config.target} ${SELECTOR_LIST_ITEMS}, ${this._config.target} .${CLASS_NAME_DROPDOWN_ITEM}`;\\n    this._offsets = [];\\n    this._targets = [];\\n    this._activeTarget = null;\\n    this._scrollHeight = 0;\\n    EventHandler.on(this._scrollElement, EVENT_SCROLL, () => this._process());\\n    this.refresh();\\n\\n    this._process();\\n  } // Getters\\n\\n\\n  static get Default() {\\n    return Default$1;\\n  }\\n\\n  static get DATA_KEY() {\\n    return DATA_KEY$2;\\n  } // Public\\n\\n\\n  refresh() {\\n    const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;\\n    const offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\\n    const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;\\n    this._offsets = [];\\n    this._targets = [];\\n    this._scrollHeight = this._getScrollHeight();\\n    const targets = SelectorEngine.find(this._selector);\\n    targets.map(element => {\\n      const targetSelector = getSelectorFromElement(element);\\n      const target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;\\n\\n      if (target) {\\n        const targetBCR = target.getBoundingClientRect();\\n\\n        if (targetBCR.width || targetBCR.height) {\\n          return [Manipulator[offsetMethod](target).top + offsetBase, targetSelector];\\n        }\\n      }\\n\\n      return null;\\n    }).filter(item => item).sort((a, b) => a[0] - b[0]).forEach(item => {\\n      this._offsets.push(item[0]);\\n\\n      this._targets.push(item[1]);\\n    });\\n  }\\n\\n  dispose() {\\n    super.dispose();\\n    EventHandler.off(this._scrollElement, EVENT_KEY$2);\\n    this._scrollElement = null;\\n    this._config = null;\\n    this._selector = null;\\n    this._offsets = null;\\n    this._targets = null;\\n    this._activeTarget = null;\\n    this._scrollHeight = null;\\n  } // Private\\n\\n\\n  _getConfig(config) {\\n    config = { ...Default$1,\\n      ...(typeof config === 'object' && config ? config : {})\\n    };\\n\\n    if (typeof config.target !== 'string' && bootstrap_esm_isElement(config.target)) {\\n      let {\\n        id\\n      } = config.target;\\n\\n      if (!id) {\\n        id = getUID(NAME$2);\\n        config.target.id = id;\\n      }\\n\\n      config.target = `#${id}`;\\n    }\\n\\n    typeCheckConfig(NAME$2, config, DefaultType$1);\\n    return config;\\n  }\\n\\n  _getScrollTop() {\\n    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\\n  }\\n\\n  _getScrollHeight() {\\n    return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\\n  }\\n\\n  _getOffsetHeight() {\\n    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\\n  }\\n\\n  _process() {\\n    const scrollTop = this._getScrollTop() + this._config.offset;\\n\\n    const scrollHeight = this._getScrollHeight();\\n\\n    const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\\n\\n    if (this._scrollHeight !== scrollHeight) {\\n      this.refresh();\\n    }\\n\\n    if (scrollTop >= maxScroll) {\\n      const target = this._targets[this._targets.length - 1];\\n\\n      if (this._activeTarget !== target) {\\n        this._activate(target);\\n      }\\n\\n      return;\\n    }\\n\\n    if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\\n      this._activeTarget = null;\\n\\n      this._clear();\\n\\n      return;\\n    }\\n\\n    for (let i = this._offsets.length; i--;) {\\n      const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\\n\\n      if (isActiveTarget) {\\n        this._activate(this._targets[i]);\\n      }\\n    }\\n  }\\n\\n  _activate(target) {\\n    this._activeTarget = target;\\n\\n    this._clear();\\n\\n    const queries = this._selector.split(',').map(selector => `${selector}[data-bs-target=\\\"${target}\\\"],${selector}[href=\\\"${target}\\\"]`);\\n\\n    const link = SelectorEngine.findOne(queries.join(','));\\n\\n    if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\\n      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1);\\n      link.classList.add(CLASS_NAME_ACTIVE$1);\\n    } else {\\n      // Set triggered link as active\\n      link.classList.add(CLASS_NAME_ACTIVE$1);\\n      SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach(listGroup => {\\n        // Set triggered links parents as active\\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\\n        SelectorEngine.prev(listGroup, `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`).forEach(item => item.classList.add(CLASS_NAME_ACTIVE$1)); // Handle special case when .nav-link is inside .nav-item\\n\\n        SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach(navItem => {\\n          SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach(item => item.classList.add(CLASS_NAME_ACTIVE$1));\\n        });\\n      });\\n    }\\n\\n    EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {\\n      relatedTarget: target\\n    });\\n  }\\n\\n  _clear() {\\n    SelectorEngine.find(this._selector).filter(node => node.classList.contains(CLASS_NAME_ACTIVE$1)).forEach(node => node.classList.remove(CLASS_NAME_ACTIVE$1));\\n  } // Static\\n\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      let data = Data.get(this, DATA_KEY$2);\\n\\n      const _config = typeof config === 'object' && config;\\n\\n      if (!data) {\\n        data = new ScrollSpy(this, _config);\\n      }\\n\\n      if (typeof config === 'string') {\\n        if (typeof data[config] === 'undefined') {\\n          throw new TypeError(`No method named \\\"${config}\\\"`);\\n        }\\n\\n        data[config]();\\n      }\\n    });\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * Data Api implementation\\n * ------------------------------------------------------------------------\\n */\\n\\n\\nEventHandler.on(window, EVENT_LOAD_DATA_API, () => {\\n  SelectorEngine.find(SELECTOR_DATA_SPY).forEach(spy => new ScrollSpy(spy, Manipulator.getDataAttributes(spy)));\\n});\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .ScrollSpy to jQuery only if jQuery is present\\n */\\n\\ndefineJQueryPlugin(NAME$2, ScrollSpy);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): tab.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME$1 = 'tab';\\nconst DATA_KEY$1 = 'bs.tab';\\nconst EVENT_KEY$1 = `.${DATA_KEY$1}`;\\nconst DATA_API_KEY = '.data-api';\\nconst EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\\nconst EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\\nconst EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\\nconst EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\\nconst EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}${DATA_API_KEY}`;\\nconst CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';\\nconst CLASS_NAME_ACTIVE = 'active';\\nconst CLASS_NAME_FADE$1 = 'fade';\\nconst CLASS_NAME_SHOW$1 = 'show';\\nconst SELECTOR_DROPDOWN = '.dropdown';\\nconst SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\\nconst SELECTOR_ACTIVE = '.active';\\nconst SELECTOR_ACTIVE_UL = ':scope > li > .active';\\nconst SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\\\"tab\\\"], [data-bs-toggle=\\\"pill\\\"], [data-bs-toggle=\\\"list\\\"]';\\nconst SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\\nconst SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active';\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass Tab extends BaseComponent {\\n  // Getters\\n  static get DATA_KEY() {\\n    return DATA_KEY$1;\\n  } // Public\\n\\n\\n  show() {\\n    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE) || isDisabled(this._element)) {\\n      return;\\n    }\\n\\n    let previous;\\n    const target = getElementFromSelector(this._element);\\n\\n    const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);\\n\\n    if (listElement) {\\n      const itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;\\n      previous = SelectorEngine.find(itemSelector, listElement);\\n      previous = previous[previous.length - 1];\\n    }\\n\\n    const hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {\\n      relatedTarget: this._element\\n    }) : null;\\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {\\n      relatedTarget: previous\\n    });\\n\\n    if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    this._activate(this._element, listElement);\\n\\n    const complete = () => {\\n      EventHandler.trigger(previous, EVENT_HIDDEN$1, {\\n        relatedTarget: this._element\\n      });\\n      EventHandler.trigger(this._element, EVENT_SHOWN$1, {\\n        relatedTarget: previous\\n      });\\n    };\\n\\n    if (target) {\\n      this._activate(target, target.parentNode, complete);\\n    } else {\\n      complete();\\n    }\\n  } // Private\\n\\n\\n  _activate(element, container, callback) {\\n    const activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);\\n    const active = activeElements[0];\\n    const isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE$1);\\n\\n    const complete = () => this._transitionComplete(element, active, callback);\\n\\n    if (active && isTransitioning) {\\n      const transitionDuration = getTransitionDurationFromElement(active);\\n      active.classList.remove(CLASS_NAME_SHOW$1);\\n      EventHandler.one(active, 'transitionend', complete);\\n      emulateTransitionEnd(active, transitionDuration);\\n    } else {\\n      complete();\\n    }\\n  }\\n\\n  _transitionComplete(element, active, callback) {\\n    if (active) {\\n      active.classList.remove(CLASS_NAME_ACTIVE);\\n      const dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);\\n\\n      if (dropdownChild) {\\n        dropdownChild.classList.remove(CLASS_NAME_ACTIVE);\\n      }\\n\\n      if (active.getAttribute('role') === 'tab') {\\n        active.setAttribute('aria-selected', false);\\n      }\\n    }\\n\\n    element.classList.add(CLASS_NAME_ACTIVE);\\n\\n    if (element.getAttribute('role') === 'tab') {\\n      element.setAttribute('aria-selected', true);\\n    }\\n\\n    reflow(element);\\n\\n    if (element.classList.contains(CLASS_NAME_FADE$1)) {\\n      element.classList.add(CLASS_NAME_SHOW$1);\\n    }\\n\\n    if (element.parentNode && element.parentNode.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {\\n      const dropdownElement = element.closest(SELECTOR_DROPDOWN);\\n\\n      if (dropdownElement) {\\n        SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE).forEach(dropdown => dropdown.classList.add(CLASS_NAME_ACTIVE));\\n      }\\n\\n      element.setAttribute('aria-expanded', true);\\n    }\\n\\n    if (callback) {\\n      callback();\\n    }\\n  } // Static\\n\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      const data = Data.get(this, DATA_KEY$1) || new Tab(this);\\n\\n      if (typeof config === 'string') {\\n        if (typeof data[config] === 'undefined') {\\n          throw new TypeError(`No method named \\\"${config}\\\"`);\\n        }\\n\\n        data[config]();\\n      }\\n    });\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * Data Api implementation\\n * ------------------------------------------------------------------------\\n */\\n\\n\\nEventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\\n  event.preventDefault();\\n  const data = Data.get(this, DATA_KEY$1) || new Tab(this);\\n  data.show();\\n});\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .Tab to jQuery only if jQuery is present\\n */\\n\\ndefineJQueryPlugin(NAME$1, Tab);\\n\\n/**\\n * --------------------------------------------------------------------------\\n * Bootstrap (v5.0.0-beta3): toast.js\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\\n * --------------------------------------------------------------------------\\n */\\n/**\\n * ------------------------------------------------------------------------\\n * Constants\\n * ------------------------------------------------------------------------\\n */\\n\\nconst NAME = 'toast';\\nconst DATA_KEY = 'bs.toast';\\nconst EVENT_KEY = `.${DATA_KEY}`;\\nconst EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY}`;\\nconst EVENT_HIDE = `hide${EVENT_KEY}`;\\nconst EVENT_HIDDEN = `hidden${EVENT_KEY}`;\\nconst EVENT_SHOW = `show${EVENT_KEY}`;\\nconst EVENT_SHOWN = `shown${EVENT_KEY}`;\\nconst CLASS_NAME_FADE = 'fade';\\nconst CLASS_NAME_HIDE = 'hide';\\nconst CLASS_NAME_SHOW = 'show';\\nconst CLASS_NAME_SHOWING = 'showing';\\nconst DefaultType = {\\n  animation: 'boolean',\\n  autohide: 'boolean',\\n  delay: 'number'\\n};\\nconst Default = {\\n  animation: true,\\n  autohide: true,\\n  delay: 5000\\n};\\nconst SELECTOR_DATA_DISMISS = '[data-bs-dismiss=\\\"toast\\\"]';\\n/**\\n * ------------------------------------------------------------------------\\n * Class Definition\\n * ------------------------------------------------------------------------\\n */\\n\\nclass Toast extends BaseComponent {\\n  constructor(element, config) {\\n    super(element);\\n    this._config = this._getConfig(config);\\n    this._timeout = null;\\n\\n    this._setListeners();\\n  } // Getters\\n\\n\\n  static get DefaultType() {\\n    return DefaultType;\\n  }\\n\\n  static get Default() {\\n    return Default;\\n  }\\n\\n  static get DATA_KEY() {\\n    return DATA_KEY;\\n  } // Public\\n\\n\\n  show() {\\n    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\\n\\n    if (showEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    this._clearTimeout();\\n\\n    if (this._config.animation) {\\n      this._element.classList.add(CLASS_NAME_FADE);\\n    }\\n\\n    const complete = () => {\\n      this._element.classList.remove(CLASS_NAME_SHOWING);\\n\\n      this._element.classList.add(CLASS_NAME_SHOW);\\n\\n      EventHandler.trigger(this._element, EVENT_SHOWN);\\n\\n      if (this._config.autohide) {\\n        this._timeout = setTimeout(() => {\\n          this.hide();\\n        }, this._config.delay);\\n      }\\n    };\\n\\n    this._element.classList.remove(CLASS_NAME_HIDE);\\n\\n    reflow(this._element);\\n\\n    this._element.classList.add(CLASS_NAME_SHOWING);\\n\\n    if (this._config.animation) {\\n      const transitionDuration = getTransitionDurationFromElement(this._element);\\n      EventHandler.one(this._element, 'transitionend', complete);\\n      emulateTransitionEnd(this._element, transitionDuration);\\n    } else {\\n      complete();\\n    }\\n  }\\n\\n  hide() {\\n    if (!this._element.classList.contains(CLASS_NAME_SHOW)) {\\n      return;\\n    }\\n\\n    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\\n\\n    if (hideEvent.defaultPrevented) {\\n      return;\\n    }\\n\\n    const complete = () => {\\n      this._element.classList.add(CLASS_NAME_HIDE);\\n\\n      EventHandler.trigger(this._element, EVENT_HIDDEN);\\n    };\\n\\n    this._element.classList.remove(CLASS_NAME_SHOW);\\n\\n    if (this._config.animation) {\\n      const transitionDuration = getTransitionDurationFromElement(this._element);\\n      EventHandler.one(this._element, 'transitionend', complete);\\n      emulateTransitionEnd(this._element, transitionDuration);\\n    } else {\\n      complete();\\n    }\\n  }\\n\\n  dispose() {\\n    this._clearTimeout();\\n\\n    if (this._element.classList.contains(CLASS_NAME_SHOW)) {\\n      this._element.classList.remove(CLASS_NAME_SHOW);\\n    }\\n\\n    EventHandler.off(this._element, EVENT_CLICK_DISMISS);\\n    super.dispose();\\n    this._config = null;\\n  } // Private\\n\\n\\n  _getConfig(config) {\\n    config = { ...Default,\\n      ...Manipulator.getDataAttributes(this._element),\\n      ...(typeof config === 'object' && config ? config : {})\\n    };\\n    typeCheckConfig(NAME, config, this.constructor.DefaultType);\\n    return config;\\n  }\\n\\n  _setListeners() {\\n    EventHandler.on(this._element, EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, () => this.hide());\\n  }\\n\\n  _clearTimeout() {\\n    clearTimeout(this._timeout);\\n    this._timeout = null;\\n  } // Static\\n\\n\\n  static jQueryInterface(config) {\\n    return this.each(function () {\\n      let data = Data.get(this, DATA_KEY);\\n\\n      const _config = typeof config === 'object' && config;\\n\\n      if (!data) {\\n        data = new Toast(this, _config);\\n      }\\n\\n      if (typeof config === 'string') {\\n        if (typeof data[config] === 'undefined') {\\n          throw new TypeError(`No method named \\\"${config}\\\"`);\\n        }\\n\\n        data[config](this);\\n      }\\n    });\\n  }\\n\\n}\\n/**\\n * ------------------------------------------------------------------------\\n * jQuery\\n * ------------------------------------------------------------------------\\n * add .Toast to jQuery only if jQuery is present\\n */\\n\\n\\ndefineJQueryPlugin(NAME, Toast);\\n\\n\\n//# sourceMappingURL=bootstrap.esm.js.map\\n\\n// EXTERNAL MODULE: /home/aleak/src/feedex/deps/phoenix_html/priv/static/phoenix_html.js\\nvar phoenix_html = __webpack_require__(5);\\n\\n// EXTERNAL MODULE: /home/aleak/src/feedex/deps/phoenix/priv/static/phoenix.js\\nvar phoenix = __webpack_require__(1);\\n\\n// EXTERNAL MODULE: ./node_modules/nprogress/nprogress.js\\nvar nprogress = __webpack_require__(0);\\nvar nprogress_default = /*#__PURE__*/__webpack_require__.n(nprogress);\\n\\n// EXTERNAL MODULE: /home/aleak/src/feedex/deps/phoenix_live_view/priv/static/phoenix_live_view.js\\nvar phoenix_live_view = __webpack_require__(2);\\n\\n// CONCATENATED MODULE: ./js/app.js\\n// We need to import the CSS so that webpack will load it.\\n// The MiniCssExtractPlugin is used to separate it out into\\n// its own CSS file.\\n\\n // webpack automatically bundles all modules in your\\n// entry points. Those entry points can be configured\\n// in \\\"webpack.config.js\\\".\\n//\\n// Import deps with the dep name or local files with a relative path, for example:\\n//\\n//     import {Socket} from \\\"phoenix\\\"\\n//     import socket from \\\"./socket\\\"\\n//\\n\\n\\n\\n\\n\\nvar csrfToken = document.querySelector(\\\"meta[name='csrf-token']\\\").getAttribute(\\\"content\\\");\\nvar liveSocket = new phoenix_live_view[\\\"LiveSocket\\\"](\\\"/live\\\", phoenix[\\\"Socket\\\"], {\\n  params: {\\n    _csrf_token: csrfToken\\n  }\\n}); // Show progress bar on live navigation and form submits\\n\\nwindow.addEventListener(\\\"phx:page-loading-start\\\", function (info) {\\n  return nprogress_default.a.start();\\n});\\nwindow.addEventListener(\\\"phx:page-loading-stop\\\", function (info) {\\n  return nprogress_default.a.done();\\n}); // connect if there are any LiveViews on the page\\n\\nliveSocket.connect(); // expose liveSocket on window for web console debug logs and latency simulation:\\n// >> liveSocket.enableDebug()\\n// >> liveSocket.enableLatencySim(1000)  // enabled for duration of browser session\\n// >> liveSocket.disableLatencySim()\\n\\nwindow.liveSocket = liveSocket;//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/NzdmOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcz81Nzg4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcz8xZmMwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanM/Mjc2NyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcz8wYWI0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcz9iNTBlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcz8wZjg4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanM/ZTJlOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcz83ZjM3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanM/YjUxOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcz9iNDUxIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcz9lZjUyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanM/MjhiZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanM/YjYyYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcz9hZDlkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcz84NGM2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzP2U0M2YiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanM/MzVmNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcz9kMzliIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzPzk4NTIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXJyb3cuanM/MDkyOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzPzdjZGEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanM/YWQ2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzPzUyMzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcz81MDBiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcz9hMzIxIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanM/NjEyNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanM/N2M3MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanM/M2U3OSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcz9hZTZjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcz85ZDBlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzP2VhMWEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzPzdiY2YiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzPzlkZTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanM/M2Q4ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzPzVkN2UiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcz9iNjE3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanM/NDNjZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzP2VjYjIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcz8xZDZjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qcz85ODM1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanM/MTM0YSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanM/ZjJlMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanM/OTQzNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9pbmRleC5qcz8xZTc2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzPzVmZTYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZVNjcm9sbC5qcz8xOTlhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanM/ZDExNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzP2I5ZTYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcz9iMWUyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanM/MmEzNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcz82Y2VlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzPzM5YzMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXItbGl0ZS5qcz80NWQxIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvaW5kZXguanM/MTIzNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmVzbS5qcz83YjE3Iiwid2VicGFjazovLy8uL2pzL2FwcC5qcz83NDczIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICByaWdodDogcmVjdC5yaWdodCxcbiAgICBib3R0b206IHJlY3QuYm90dG9tLFxuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB4OiByZWN0LmxlZnQsXG4gICAgeTogcmVjdC50b3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiOyAvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRMYXlvdXRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcblxuICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3Qud2lkdGggLSB3aWR0aCkgPD0gMSkge1xuICAgIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aDtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xuICAgIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXG4gICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59IiwiaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFsndGFibGUnLCAndGQnLCAndGgnXS5pbmRleE9mKGdldE5vZGVOYW1lKGVsZW1lbnQpKSA+PSAwO1xufSIsImltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuICgvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgaXNTaGFkb3dSb290KGVsZW1lbnQpID8gZWxlbWVudC5ob3N0IDogbnVsbCkgfHwgLy8gU2hhZG93Um9vdCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG4gIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn0iLCJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgd2l0aGluIGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgYXJyb3dFbGVtZW50ID0gX29wdGlvbnMkZWxlbWVudCA9PT0gdm9pZCAwID8gJ1tkYXRhLXBvcHBlci1hcnJvd10nIDogX29wdGlvbnMkZWxlbWVudDtcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCAnVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcycsICd0aGUgYXJyb3cuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgJ2VsZW1lbnQuJ10uam9pbignICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGFycm93LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59OyIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJ1xufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHJvdW5kKHggKiBkcHIpIC8gZHByKSB8fCAwLFxuICAgIHk6IHJvdW5kKHJvdW5kKHkgKiBkcHIpIC8gZHByKSB8fCAwXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHM7XG5cbiAgdmFyIF9yZWYzID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIob2Zmc2V0cykgOiB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKG9mZnNldHMpIDogb2Zmc2V0cyxcbiAgICAgIF9yZWYzJHggPSBfcmVmMy54LFxuICAgICAgeCA9IF9yZWYzJHggPT09IHZvaWQgMCA/IDAgOiBfcmVmMyR4LFxuICAgICAgX3JlZjMkeSA9IF9yZWYzLnksXG4gICAgICB5ID0gX3JlZjMkeSA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJHk7XG5cbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3ApIHtcbiAgICAgIHNpZGVZID0gYm90dG9tOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICAgICAgeSAtPSBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF0gLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gICAgICB4IC09IG9mZnNldFBhcmVudFt3aWR0aFByb3BdIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDwgMiA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNCkge1xuICB2YXIgc3RhdGUgPSBfcmVmNC5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNC5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgJ1xcblxcbicsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcblxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb25cbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiLCJ2YXIgaGFzaCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwOyAvLyBOQjogVGhpcyBpc24ndCBzdXBwb3J0ZWQgb24gaU9TIDw9IDEyLiBJZiB0aGUga2V5Ym9hcmQgaXMgb3BlbiwgdGhlIHBvcHBlclxuICAvLyBjYW4gYmUgb2JzY3VyZWQgdW5kZXJuZWF0aCBpdC5cbiAgLy8gQWxzbywgYGh0bWwuY2xpZW50SGVpZ2h0YCBhZGRzIHRoZSBib3R0b20gYmFyIGhlaWdodCBpbiBTYWZhcmkgaU9TLCBldmVuXG4gIC8vIGlmIGl0IGlzbid0IG9wZW4sIHNvIGlmIHRoaXMgaXNuJ3QgYXZhaWxhYmxlLCB0aGUgcG9wcGVyIHdpbGwgYmUgZGV0ZWN0ZWRcbiAgLy8gdG8gb3ZlcmZsb3cgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIHRvbyBlYXJseS5cblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDsgLy8gVXNlcyBMYXlvdXQgVmlld3BvcnQgKGxpa2UgQ2hyb21lOyBTYWZhcmkgZG9lcyBub3QgY3VycmVudGx5KVxuICAgIC8vIEluIENocm9tZSwgaXQgcmV0dXJucyBhIHZhbHVlIHZlcnkgY2xvc2UgdG8gMCAoKy8tKSBidXQgY29udGFpbnMgcm91bmRpbmdcbiAgICAvLyBlcnJvcnMgZHVlIHRvIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIHNvIHdlIG5lZWQgdG8gY2hlY2sgcHJlY2lzaW9uLlxuICAgIC8vIFNhZmFyaSByZXR1cm5zIGEgbnVtYmVyIDw9IDAsIHVzdWFsbHkgPCAtMSB3aGVuIHBpbmNoLXpvb21lZFxuICAgIC8vIEZlYXR1cmUgZGV0ZWN0aW9uIGZhaWxzIGluIG1vYmlsZSBlbXVsYXRpb24gbW9kZSBpbiBDaHJvbWUuXG4gICAgLy8gTWF0aC5hYnMod2luLmlubmVyV2lkdGggLyB2aXN1YWxWaWV3cG9ydC5zY2FsZSAtIHZpc3VhbFZpZXdwb3J0LndpZHRoKSA8XG4gICAgLy8gMC4wMDFcbiAgICAvLyBGYWxsYmFjayBoZXJlOiBcIk5vdCBTYWZhcmlcIiB1c2VyQWdlbnRcblxuICAgIGlmICghL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn0iLCJpbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XG4gIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KG5vZGUpICYmIGlzU2Nyb2xsUGFyZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xufSIsImltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSBcIi4vZ2V0U2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG4vKlxuZ2l2ZW4gYSBET00gZWxlbWVudCwgcmV0dXJuIHRoZSBsaXN0IG9mIGFsbCBzY3JvbGwgcGFyZW50cywgdXAgdGhlIGxpc3Qgb2YgYW5jZXNvcnNcbnVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXG50bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG5yZWZlcmVuY2UgZWxlbWVudCdzIHBvc2l0aW9uLlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cblxuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IGlzQm9keSB0ZWxscyB1cyB0YXJnZXQgd2lsbCBiZSBhbiBIVE1MRWxlbWVudCBoZXJlXG4gIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn0iLCJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgbWF4LCBtaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpO1xuICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIHJlY3QubGVmdCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC53aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3QuaGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgcmVjdC55ID0gcmVjdC50b3A7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkpIDogaXNIVE1MRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcblxuXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XG4gIH0pO1xufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHJlZmVyZW5jZUVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZUVsZW1lbnQpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcblxuICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gIH07XG4gIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xuICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xufSIsImltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyB2YXJpYXRpb25QbGFjZW1lbnRzLCBiYXNlUGxhY2VtZW50cywgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gYWxsUGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBUaGUgYGFsbG93ZWRBdXRvUGxhY2VtZW50c2Agb3B0aW9uIGRpZCBub3QgYWxsb3cgYW55JywgJ3BsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvbicsICdvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLicsICdGb3IgZXhhbXBsZSwgXCJhdXRvXCIgY2Fubm90IGJlIHVzZWQgdG8gYWxsb3cgXCJib3R0b20tc3RhcnRcIi4nLCAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufSIsImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyBib3R0b20sIHRvcCwgc3RhcnQsIHJpZ2h0LCBsZWZ0LCBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgaWYgKGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHJldHVybiBbZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSwgb3Bwb3NpdGVQbGFjZW1lbnQsIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KG9wcG9zaXRlUGxhY2VtZW50KV07XG59XG5cbmZ1bmN0aW9uIGZsaXAoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9IG9wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xuICB2YXIgcHJlZmVycmVkUGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xuICB2YXIgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBWYXJpYXRpb25zID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocHJlZmVycmVkUGxhY2VtZW50KSk7XG4gIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXG4gICAgfSkgOiBwbGFjZW1lbnQpO1xuICB9LCBbXSk7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XG4gIHZhciBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzW2ldO1xuXG4gICAgdmFyIF9iYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XG4gICAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSk7XG4gICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xuXG4gICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xuICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgfVxuXG4gICAgdmFyIGFsdFZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W19iYXNlUGxhY2VtZW50XSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgIHJldHVybiBjaGVjaztcbiAgICB9KSkge1xuICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgbWFrZUZhbGxiYWNrQ2hlY2tzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjaGVja3NNYXAuc2V0KHBsYWNlbWVudCwgY2hlY2tzKTtcbiAgfVxuXG4gIGlmIChtYWtlRmFsbGJhY2tDaGVja3MpIHtcbiAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyDigJMgcmVzZWFyY2ggbGF0ZXJcbiAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgIHZhciBmaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50cy5maW5kKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICBpZiAoY2hlY2tzKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrcy5zbGljZSgwLCBfaSkuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZml0dGluZ1BsYWNlbWVudCkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICBpZiAoX3JldCA9PT0gXCJicmVha1wiKSBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICBzdGF0ZS5wbGFjZW1lbnQgPSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgc3RhdGUucmVzZXQgPSB0cnVlO1xuICB9XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdmbGlwJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IGZsaXAsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXG4gIGRhdGE6IHtcbiAgICBfc2tpcDogZmFsc2VcbiAgfVxufTsiLCJpbXBvcnQgeyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gIH0pO1xuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gIH0pO1xuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgfTtcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59OyIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBwbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHdpdGhpbiBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi4vdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMgfHwgY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIHRldGhlck9mZnNldFZhbHVlIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSB0ZXRoZXJPZmZzZXRWYWx1ZTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWUgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIHRldGhlck9mZnNldFZhbHVlO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XVttYWluQXhpc10gOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IG1hdGhNYXgobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcbiAgICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKF9taW4sIHRldGhlck1pbikgOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KF9tYXgsIHRldGhlck1heCkgOiBfbWF4KTtcblxuICAgICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59OyIsImV4cG9ydCB7IGRlZmF1bHQgYXMgYXBwbHlTdHlsZXMgfSBmcm9tIFwiLi9hcHBseVN0eWxlcy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhcnJvdyB9IGZyb20gXCIuL2Fycm93LmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGNvbXB1dGVTdHlsZXMgfSBmcm9tIFwiLi9jb21wdXRlU3R5bGVzLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGV2ZW50TGlzdGVuZXJzIH0gZnJvbSBcIi4vZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmxpcCB9IGZyb20gXCIuL2ZsaXAuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaGlkZSB9IGZyb20gXCIuL2hpZGUuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgb2Zmc2V0IH0gZnJvbSBcIi4vb2Zmc2V0LmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBvcHBlck9mZnNldHMgfSBmcm9tIFwiLi9wb3BwZXJPZmZzZXRzLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByZXZlbnRPdmVyZmxvdyB9IGZyb20gXCIuL3ByZXZlbnRPdmVyZmxvdy5qc1wiOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50KTtcbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCB2YWxpZGF0ZU1vZGlmaWVycyBmcm9tIFwiLi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IHVuaXF1ZUJ5IGZyb20gXCIuL3V0aWxzL3VuaXF1ZUJ5LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi9lbnVtcy5qc1wiO1xudmFyIElOVkFMSURfRUxFTUVOVF9FUlJPUiA9ICdQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC4nO1xudmFyIElORklOSVRFX0xPT1BfRVJST1IgPSAnUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC4nO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTsgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcbiAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtb2RpZmllcnMgaXMgaW52YWxpZCBmb3IgYW55IHJlYXNvblxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgbW9kaWZpZXJzID0gdW5pcXVlQnkoW10uY29uY2F0KG9yZGVyZWRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKTtcblxuICAgICAgICAgIGlmIChnZXRCYXNlUGxhY2VtZW50KHN0YXRlLm9wdGlvbnMucGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgICAgICAgICAgdmFyIGZsaXBNb2RpZmllciA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZmluZChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2ZsaXAnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZmxpcE1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXV0b1wiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXCJmbGlwXCIgbW9kaWZpZXIgYmUnLCAncHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShwb3BwZXIpLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luUmlnaHQsXG4gICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkJvdHRvbSxcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkxlZnQ7IC8vIFdlIG5vIGxvbmdlciB0YWtlIGludG8gYWNjb3VudCBgbWFyZ2luc2Agb24gdGhlIHBvcHBlciwgYW5kIGl0IGNhblxuICAgICAgICAgIC8vIGNhdXNlIGJ1Z3Mgd2l0aCBwb3NpdGlvbmluZywgc28gd2UnbGwgd2FybiB0aGUgY29uc3VtZXJcblxuXG4gICAgICAgICAgaWYgKFttYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnRdLnNvbWUoZnVuY3Rpb24gKG1hcmdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWFyZ2luKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBDU1MgXCJtYXJnaW5cIiBzdHlsZXMgY2Fubm90IGJlIHVzZWQgdG8gYXBwbHkgcGFkZGluZycsICdiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS4nLCAnVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhcycsICd0aGUgYHBhZGRpbmdgIG9wdGlvbiBpbiB0aGUgYHByZXZlbnRPdmVyZmxvd2AgYW5kIGBmbGlwYCcsICdtb2RpZmllcnMuJ10uam9pbignICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfX2RlYnVnX2xvb3BzX18gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIF9fZGVidWdfbG9vcHNfXyArPSAxO1xuXG4gICAgICAgICAgICBpZiAoX19kZWJ1Z19sb29wc19fID4gMTAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5GSU5JVEVfTE9PUF9FUlJPUik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZjMkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZjMuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwiaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG5pbXBvcnQgb2Zmc2V0IGZyb20gXCIuL21vZGlmaWVycy9vZmZzZXQuanNcIjtcbmltcG9ydCBmbGlwIGZyb20gXCIuL21vZGlmaWVycy9mbGlwLmpzXCI7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gXCIuL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBhcnJvdyBmcm9tIFwiLi9tb2RpZmllcnMvYXJyb3cuanNcIjtcbmltcG9ydCBoaWRlIGZyb20gXCIuL21vZGlmaWVycy9oaWRlLmpzXCI7XG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cywgY29tcHV0ZVN0eWxlcywgYXBwbHlTdHlsZXMsIG9mZnNldCwgZmxpcCwgcHJldmVudE92ZXJmbG93LCBhcnJvdywgaGlkZV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSBcIi4vcG9wcGVyLWxpdGUuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgKiBmcm9tIFwiLi9tb2RpZmllcnMvaW5kZXguanNcIjsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlc107XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyIsImV4cG9ydCAqIGZyb20gXCIuL2VudW1zLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9tb2RpZmllcnMvaW5kZXguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93LCBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyQmFzZSB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciB9IGZyb20gXCIuL3BvcHBlci5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSBcIi4vcG9wcGVyLWxpdGUuanNcIjsiLCIvKiFcbiAgKiBCb290c3RyYXAgdjUuMC4wLWJldGEzIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxuICAqIENvcHlyaWdodCAyMDExLTIwMjEgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcbiAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgKi9cbmltcG9ydCAqIGFzIFBvcHBlciBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4wLWJldGEzKTogdXRpbC9pbmRleC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5jb25zdCBNQVhfVUlEID0gMTAwMDAwMDtcbmNvbnN0IE1JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMDtcbmNvbnN0IFRSQU5TSVRJT05fRU5EID0gJ3RyYW5zaXRpb25lbmQnOyAvLyBTaG91dG91dCBBbmd1c0Nyb2xsIChodHRwczovL2dvby5nbC9weHdRR3ApXG5cbmNvbnN0IHRvVHlwZSA9IG9iaiA9PiB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYCR7b2JqfWA7XG4gIH1cblxuICByZXR1cm4ge30udG9TdHJpbmcuY2FsbChvYmopLm1hdGNoKC9cXHMoW2Etel0rKS9pKVsxXS50b0xvd2VyQ2FzZSgpO1xufTtcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFB1YmxpYyBVdGlsIEFwaVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmNvbnN0IGdldFVJRCA9IHByZWZpeCA9PiB7XG4gIGRvIHtcbiAgICBwcmVmaXggKz0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYX1VJRCk7XG4gIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpO1xuXG4gIHJldHVybiBwcmVmaXg7XG59O1xuXG5jb25zdCBnZXRTZWxlY3RvciA9IGVsZW1lbnQgPT4ge1xuICBsZXQgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy10YXJnZXQnKTtcblxuICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSAnIycpIHtcbiAgICBsZXQgaHJlZkF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpOyAvLyBUaGUgb25seSB2YWxpZCBjb250ZW50IHRoYXQgY291bGQgZG91YmxlIGFzIGEgc2VsZWN0b3IgYXJlIElEcyBvciBjbGFzc2VzLFxuICAgIC8vIHNvIGV2ZXJ5dGhpbmcgc3RhcnRpbmcgd2l0aCBgI2Agb3IgYC5gLiBJZiBhIFwicmVhbFwiIFVSTCBpcyB1c2VkIGFzIHRoZSBzZWxlY3RvcixcbiAgICAvLyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcmAgd2lsbCByaWdodGZ1bGx5IGNvbXBsYWluIGl0IGlzIGludmFsaWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMzIyNzNcblxuICAgIGlmICghaHJlZkF0dHIgfHwgIWhyZWZBdHRyLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBKdXN0IGluIGNhc2Ugc29tZSBDTVMgcHV0cyBvdXQgYSBmdWxsIFVSTCB3aXRoIHRoZSBhbmNob3IgYXBwZW5kZWRcblxuXG4gICAgaWYgKGhyZWZBdHRyLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgaHJlZkF0dHIgPSAnIycgKyBocmVmQXR0ci5zcGxpdCgnIycpWzFdO1xuICAgIH1cblxuICAgIHNlbGVjdG9yID0gaHJlZkF0dHIgJiYgaHJlZkF0dHIgIT09ICcjJyA/IGhyZWZBdHRyLnRyaW0oKSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0b3I7XG59O1xuXG5jb25zdCBnZXRTZWxlY3RvckZyb21FbGVtZW50ID0gZWxlbWVudCA9PiB7XG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XG5cbiAgaWYgKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBnZXRFbGVtZW50RnJvbVNlbGVjdG9yID0gZWxlbWVudCA9PiB7XG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XG4gIHJldHVybiBzZWxlY3RvciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIDogbnVsbDtcbn07XG5cbmNvbnN0IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50ID0gZWxlbWVudCA9PiB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIEdldCB0cmFuc2l0aW9uLWR1cmF0aW9uIG9mIHRoZSBlbGVtZW50XG5cblxuICBsZXQge1xuICAgIHRyYW5zaXRpb25EdXJhdGlvbixcbiAgICB0cmFuc2l0aW9uRGVsYXlcbiAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICBjb25zdCBmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbik7XG4gIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KTsgLy8gUmV0dXJuIDAgaWYgZWxlbWVudCBvciB0cmFuc2l0aW9uIGR1cmF0aW9uIGlzIG5vdCBmb3VuZFxuXG4gIGlmICghZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gJiYgIWZsb2F0VHJhbnNpdGlvbkRlbGF5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gSWYgbXVsdGlwbGUgZHVyYXRpb25zIGFyZSBkZWZpbmVkLCB0YWtlIHRoZSBmaXJzdFxuXG5cbiAgdHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uLnNwbGl0KCcsJylbMF07XG4gIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xuICByZXR1cm4gKE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbikgKyBOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRGVsYXkpKSAqIE1JTExJU0VDT05EU19NVUxUSVBMSUVSO1xufTtcblxuY29uc3QgdHJpZ2dlclRyYW5zaXRpb25FbmQgPSBlbGVtZW50ID0+IHtcbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChUUkFOU0lUSU9OX0VORCkpO1xufTtcblxuY29uc3QgaXNFbGVtZW50ID0gb2JqID0+IChvYmpbMF0gfHwgb2JqKS5ub2RlVHlwZTtcblxuY29uc3QgZW11bGF0ZVRyYW5zaXRpb25FbmQgPSAoZWxlbWVudCwgZHVyYXRpb24pID0+IHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICBjb25zdCBkdXJhdGlvblBhZGRpbmcgPSA1O1xuICBjb25zdCBlbXVsYXRlZER1cmF0aW9uID0gZHVyYXRpb24gKyBkdXJhdGlvblBhZGRpbmc7XG5cbiAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTl9FTkQsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgbGlzdGVuZXIpO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQoZWxlbWVudCk7XG4gICAgfVxuICB9LCBlbXVsYXRlZER1cmF0aW9uKTtcbn07XG5cbmNvbnN0IHR5cGVDaGVja0NvbmZpZyA9IChjb21wb25lbnROYW1lLCBjb25maWcsIGNvbmZpZ1R5cGVzKSA9PiB7XG4gIE9iamVjdC5rZXlzKGNvbmZpZ1R5cGVzKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gY29uZmlnVHlwZXNbcHJvcGVydHldO1xuICAgIGNvbnN0IHZhbHVlID0gY29uZmlnW3Byb3BlcnR5XTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB2YWx1ZSAmJiBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcblxuICAgIGlmICghbmV3IFJlZ0V4cChleHBlY3RlZFR5cGVzKS50ZXN0KHZhbHVlVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29tcG9uZW50TmFtZS50b1VwcGVyQ2FzZSgpfTogYCArIGBPcHRpb24gXCIke3Byb3BlcnR5fVwiIHByb3ZpZGVkIHR5cGUgXCIke3ZhbHVlVHlwZX1cIiBgICsgYGJ1dCBleHBlY3RlZCB0eXBlIFwiJHtleHBlY3RlZFR5cGVzfVwiLmApO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCBpc1Zpc2libGUgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQuc3R5bGUgJiYgZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5zdHlsZSkge1xuICAgIGNvbnN0IGVsZW1lbnRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgY29uc3QgcGFyZW50Tm9kZVN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LnBhcmVudE5vZGUpO1xuICAgIHJldHVybiBlbGVtZW50U3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnICYmIHBhcmVudE5vZGVTdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScgJiYgZWxlbWVudFN0eWxlLnZpc2liaWxpdHkgIT09ICdoaWRkZW4nO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgaXNEaXNhYmxlZCA9IGVsZW1lbnQgPT4ge1xuICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlbGVtZW50LmRpc2FibGVkO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpICE9PSAnZmFsc2UnO1xufTtcblxuY29uc3QgZmluZFNoYWRvd1Jvb3QgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQ2FuIGZpbmQgdGhlIHNoYWRvdyByb290IG90aGVyd2lzZSBpdCdsbCByZXR1cm4gdGhlIGRvY3VtZW50XG5cblxuICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Um9vdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCByb290ID0gZWxlbWVudC5nZXRSb290Tm9kZSgpO1xuICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gd2hlbiB3ZSBkb24ndCBmaW5kIGEgc2hhZG93IHJvb3RcblxuXG4gIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZmluZFNoYWRvd1Jvb3QoZWxlbWVudC5wYXJlbnROb2RlKTtcbn07XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiBmdW5jdGlvbiAoKSB7fTtcblxuY29uc3QgcmVmbG93ID0gZWxlbWVudCA9PiBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuY29uc3QgZ2V0alF1ZXJ5ID0gKCkgPT4ge1xuICBjb25zdCB7XG4gICAgalF1ZXJ5XG4gIH0gPSB3aW5kb3c7XG5cbiAgaWYgKGpRdWVyeSAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RhdGEtYnMtbm8tanF1ZXJ5JykpIHtcbiAgICByZXR1cm4galF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBvbkRPTUNvbnRlbnRMb2FkZWQgPSBjYWxsYmFjayA9PiB7XG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbmNvbnN0IGlzUlRMID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gJ3J0bCc7XG5cbmNvbnN0IGRlZmluZUpRdWVyeVBsdWdpbiA9IChuYW1lLCBwbHVnaW4pID0+IHtcbiAgb25ET01Db250ZW50TG9hZGVkKCgpID0+IHtcbiAgICBjb25zdCAkID0gZ2V0alF1ZXJ5KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgICBpZiAoJCkge1xuICAgICAgY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltuYW1lXTtcbiAgICAgICQuZm5bbmFtZV0gPSBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xuICAgICAgJC5mbltuYW1lXS5Db25zdHJ1Y3RvciA9IHBsdWdpbjtcblxuICAgICAgJC5mbltuYW1lXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAgICAgICAkLmZuW25hbWVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgICAgICByZXR1cm4gcGx1Z2luLmpRdWVyeUludGVyZmFjZTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4wLWJldGEzKTogZG9tL2RhdGEuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuY29uc3QgZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbnZhciBEYXRhID0ge1xuICBzZXQoZWxlbWVudCwga2V5LCBpbnN0YW5jZSkge1xuICAgIGlmICghZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnRNYXAuc2V0KGVsZW1lbnQsIG5ldyBNYXAoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTsgLy8gbWFrZSBpdCBjbGVhciB3ZSBvbmx5IHdhbnQgb25lIGluc3RhbmNlIHBlciBlbGVtZW50XG4gICAgLy8gY2FuIGJlIHJlbW92ZWQgbGF0ZXIgd2hlbiBtdWx0aXBsZSBrZXkvaW5zdGFuY2VzIGFyZSBmaW5lIHRvIGJlIHVzZWRcblxuICAgIGlmICghaW5zdGFuY2VNYXAuaGFzKGtleSkgJiYgaW5zdGFuY2VNYXAuc2l6ZSAhPT0gMCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEJvb3RzdHJhcCBkb2Vzbid0IGFsbG93IG1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnQuIEJvdW5kIGluc3RhbmNlOiAke0FycmF5LmZyb20oaW5zdGFuY2VNYXAua2V5cygpKVswXX0uYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2VNYXAuc2V0KGtleSwgaW5zdGFuY2UpO1xuICB9LFxuXG4gIGdldChlbGVtZW50LCBrZXkpIHtcbiAgICBpZiAoZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBlbGVtZW50TWFwLmdldChlbGVtZW50KS5nZXQoa2V5KSB8fCBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIHJlbW92ZShlbGVtZW50LCBrZXkpIHtcbiAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTtcbiAgICBpbnN0YW5jZU1hcC5kZWxldGUoa2V5KTsgLy8gZnJlZSB1cCBlbGVtZW50IHJlZmVyZW5jZXMgaWYgdGhlcmUgYXJlIG5vIGluc3RhbmNlcyBsZWZ0IGZvciBhbiBlbGVtZW50XG5cbiAgICBpZiAoaW5zdGFuY2VNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgZWxlbWVudE1hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4wLWJldGEzKTogZG9tL2V2ZW50LWhhbmRsZXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgbmFtZXNwYWNlUmVnZXggPSAvW14uXSooPz1cXC4uKilcXC58LiovO1xuY29uc3Qgc3RyaXBOYW1lUmVnZXggPSAvXFwuLiovO1xuY29uc3Qgc3RyaXBVaWRSZWdleCA9IC86OlxcZCskLztcbmNvbnN0IGV2ZW50UmVnaXN0cnkgPSB7fTsgLy8gRXZlbnRzIHN0b3JhZ2VcblxubGV0IHVpZEV2ZW50ID0gMTtcbmNvbnN0IGN1c3RvbUV2ZW50cyA9IHtcbiAgbW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXG4gIG1vdXNlbGVhdmU6ICdtb3VzZW91dCdcbn07XG5jb25zdCBuYXRpdmVFdmVudHMgPSBuZXcgU2V0KFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnY29udGV4dG1lbnUnLCAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ3NlbGVjdHN0YXJ0JywgJ3NlbGVjdGVuZCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ29yaWVudGF0aW9uY2hhbmdlJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJywgJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCcsICdwb2ludGVybGVhdmUnLCAncG9pbnRlcmNhbmNlbCcsICdnZXN0dXJlc3RhcnQnLCAnZ2VzdHVyZWNoYW5nZScsICdnZXN0dXJlZW5kJywgJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJywgJ3Jlc2V0JywgJ3NlbGVjdCcsICdzdWJtaXQnLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdsb2FkJywgJ3VubG9hZCcsICdiZWZvcmV1bmxvYWQnLCAncmVzaXplJywgJ21vdmUnLCAnRE9NQ29udGVudExvYWRlZCcsICdyZWFkeXN0YXRlY2hhbmdlJywgJ2Vycm9yJywgJ2Fib3J0JywgJ3Njcm9sbCddKTtcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBQcml2YXRlIG1ldGhvZHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmZ1bmN0aW9uIGdldFVpZEV2ZW50KGVsZW1lbnQsIHVpZCkge1xuICByZXR1cm4gdWlkICYmIGAke3VpZH06OiR7dWlkRXZlbnQrK31gIHx8IGVsZW1lbnQudWlkRXZlbnQgfHwgdWlkRXZlbnQrKztcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnQoZWxlbWVudCkge1xuICBjb25zdCB1aWQgPSBnZXRVaWRFdmVudChlbGVtZW50KTtcbiAgZWxlbWVudC51aWRFdmVudCA9IHVpZDtcbiAgZXZlbnRSZWdpc3RyeVt1aWRdID0gZXZlbnRSZWdpc3RyeVt1aWRdIHx8IHt9O1xuICByZXR1cm4gZXZlbnRSZWdpc3RyeVt1aWRdO1xufVxuXG5mdW5jdGlvbiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSBlbGVtZW50O1xuXG4gICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4uYXBwbHkoZWxlbWVudCwgW2V2ZW50XSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJvb3RzdHJhcERlbGVnYXRpb25IYW5kbGVyKGVsZW1lbnQsIHNlbGVjdG9yLCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgIGNvbnN0IGRvbUVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgIGZvciAobGV0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDsgdGFyZ2V0ICYmIHRhcmdldCAhPT0gdGhpczsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIGZvciAobGV0IGkgPSBkb21FbGVtZW50cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnRzW2ldID09PSB0YXJnZXQpIHtcbiAgICAgICAgICBldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRhcmdldDtcblxuICAgICAgICAgIGlmIChoYW5kbGVyLm9uZU9mZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vY29uc2lzdGVudC1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIGZuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGFyZ2V0LCBbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gVG8gcGxlYXNlIEVTTGludFxuXG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZEhhbmRsZXIoZXZlbnRzLCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IgPSBudWxsKSB7XG4gIGNvbnN0IHVpZEV2ZW50TGlzdCA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHVpZEV2ZW50TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzW3VpZEV2ZW50TGlzdFtpXV07XG5cbiAgICBpZiAoZXZlbnQub3JpZ2luYWxIYW5kbGVyID09PSBoYW5kbGVyICYmIGV2ZW50LmRlbGVnYXRpb25TZWxlY3RvciA9PT0gZGVsZWdhdGlvblNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtcyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSB7XG4gIGNvbnN0IGRlbGVnYXRpb24gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZyc7XG4gIGNvbnN0IG9yaWdpbmFsSGFuZGxlciA9IGRlbGVnYXRpb24gPyBkZWxlZ2F0aW9uRm4gOiBoYW5kbGVyOyAvLyBhbGxvdyB0byBnZXQgdGhlIG5hdGl2ZSBldmVudHMgZnJvbSBuYW1lc3BhY2VkIGV2ZW50cyAoJ2NsaWNrLmJzLmJ1dHRvbicgLS0+ICdjbGljaycpXG5cbiAgbGV0IHR5cGVFdmVudCA9IG9yaWdpbmFsVHlwZUV2ZW50LnJlcGxhY2Uoc3RyaXBOYW1lUmVnZXgsICcnKTtcbiAgY29uc3QgY3VzdG9tID0gY3VzdG9tRXZlbnRzW3R5cGVFdmVudF07XG5cbiAgaWYgKGN1c3RvbSkge1xuICAgIHR5cGVFdmVudCA9IGN1c3RvbTtcbiAgfVxuXG4gIGNvbnN0IGlzTmF0aXZlID0gbmF0aXZlRXZlbnRzLmhhcyh0eXBlRXZlbnQpO1xuXG4gIGlmICghaXNOYXRpdmUpIHtcbiAgICB0eXBlRXZlbnQgPSBvcmlnaW5hbFR5cGVFdmVudDtcbiAgfVxuXG4gIHJldHVybiBbZGVsZWdhdGlvbiwgb3JpZ2luYWxIYW5kbGVyLCB0eXBlRXZlbnRdO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4sIG9uZU9mZikge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghaGFuZGxlcikge1xuICAgIGhhbmRsZXIgPSBkZWxlZ2F0aW9uRm47XG4gICAgZGVsZWdhdGlvbkZuID0gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IFtkZWxlZ2F0aW9uLCBvcmlnaW5hbEhhbmRsZXIsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbXMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbik7XG4gIGNvbnN0IGV2ZW50cyA9IGdldEV2ZW50KGVsZW1lbnQpO1xuICBjb25zdCBoYW5kbGVycyA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IChldmVudHNbdHlwZUV2ZW50XSA9IHt9KTtcbiAgY29uc3QgcHJldmlvdXNGbiA9IGZpbmRIYW5kbGVyKGhhbmRsZXJzLCBvcmlnaW5hbEhhbmRsZXIsIGRlbGVnYXRpb24gPyBoYW5kbGVyIDogbnVsbCk7XG5cbiAgaWYgKHByZXZpb3VzRm4pIHtcbiAgICBwcmV2aW91c0ZuLm9uZU9mZiA9IHByZXZpb3VzRm4ub25lT2ZmICYmIG9uZU9mZjtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB1aWQgPSBnZXRVaWRFdmVudChvcmlnaW5hbEhhbmRsZXIsIG9yaWdpbmFsVHlwZUV2ZW50LnJlcGxhY2UobmFtZXNwYWNlUmVnZXgsICcnKSk7XG4gIGNvbnN0IGZuID0gZGVsZWdhdGlvbiA/IGJvb3RzdHJhcERlbGVnYXRpb25IYW5kbGVyKGVsZW1lbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GbikgOiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGhhbmRsZXIpO1xuICBmbi5kZWxlZ2F0aW9uU2VsZWN0b3IgPSBkZWxlZ2F0aW9uID8gaGFuZGxlciA6IG51bGw7XG4gIGZuLm9yaWdpbmFsSGFuZGxlciA9IG9yaWdpbmFsSGFuZGxlcjtcbiAgZm4ub25lT2ZmID0gb25lT2ZmO1xuICBmbi51aWRFdmVudCA9IHVpZDtcbiAgaGFuZGxlcnNbdWlkXSA9IGZuO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgZGVsZWdhdGlvbik7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcikge1xuICBjb25zdCBmbiA9IGZpbmRIYW5kbGVyKGV2ZW50c1t0eXBlRXZlbnRdLCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xuXG4gIGlmICghZm4pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgQm9vbGVhbihkZWxlZ2F0aW9uU2VsZWN0b3IpKTtcbiAgZGVsZXRlIGV2ZW50c1t0eXBlRXZlbnRdW2ZuLnVpZEV2ZW50XTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBuYW1lc3BhY2UpIHtcbiAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fTtcbiAgT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpLmZvckVhY2goaGFuZGxlcktleSA9PiB7XG4gICAgaWYgKGhhbmRsZXJLZXkuaW5jbHVkZXMobmFtZXNwYWNlKSkge1xuICAgICAgY29uc3QgZXZlbnQgPSBzdG9yZUVsZW1lbnRFdmVudFtoYW5kbGVyS2V5XTtcbiAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50Lm9yaWdpbmFsSGFuZGxlciwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBFdmVudEhhbmRsZXIgPSB7XG4gIG9uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4pIHtcbiAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4sIGZhbHNlKTtcbiAgfSxcblxuICBvbmUoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbikge1xuICAgIGFkZEhhbmRsZXIoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GbiwgdHJ1ZSk7XG4gIH0sXG5cbiAgb2ZmKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4pIHtcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IFtkZWxlZ2F0aW9uLCBvcmlnaW5hbEhhbmRsZXIsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbXMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25Gbik7XG4gICAgY29uc3QgaW5OYW1lc3BhY2UgPSB0eXBlRXZlbnQgIT09IG9yaWdpbmFsVHlwZUV2ZW50O1xuICAgIGNvbnN0IGV2ZW50cyA9IGdldEV2ZW50KGVsZW1lbnQpO1xuICAgIGNvbnN0IGlzTmFtZXNwYWNlID0gb3JpZ2luYWxUeXBlRXZlbnQuc3RhcnRzV2l0aCgnLicpO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbEhhbmRsZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBTaW1wbGVzdCBjYXNlOiBoYW5kbGVyIGlzIHBhc3NlZCwgcmVtb3ZlIHRoYXQgbGlzdGVuZXIgT05MWS5cbiAgICAgIGlmICghZXZlbnRzIHx8ICFldmVudHNbdHlwZUV2ZW50XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIG9yaWdpbmFsSGFuZGxlciwgZGVsZWdhdGlvbiA/IGhhbmRsZXIgOiBudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNOYW1lc3BhY2UpIHtcbiAgICAgIE9iamVjdC5rZXlzKGV2ZW50cykuZm9yRWFjaChlbGVtZW50RXZlbnQgPT4ge1xuICAgICAgICByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCBlbGVtZW50RXZlbnQsIG9yaWdpbmFsVHlwZUV2ZW50LnNsaWNlKDEpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlRWxlbWVudEV2ZW50ID0gZXZlbnRzW3R5cGVFdmVudF0gfHwge307XG4gICAgT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpLmZvckVhY2goa2V5SGFuZGxlcnMgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlcktleSA9IGtleUhhbmRsZXJzLnJlcGxhY2Uoc3RyaXBVaWRSZWdleCwgJycpO1xuXG4gICAgICBpZiAoIWluTmFtZXNwYWNlIHx8IG9yaWdpbmFsVHlwZUV2ZW50LmluY2x1ZGVzKGhhbmRsZXJLZXkpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gc3RvcmVFbGVtZW50RXZlbnRba2V5SGFuZGxlcnNdO1xuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5vcmlnaW5hbEhhbmRsZXIsIGV2ZW50LmRlbGVnYXRpb25TZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgdHJpZ2dlcihlbGVtZW50LCBldmVudCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCAkID0gZ2V0alF1ZXJ5KCk7XG4gICAgY29uc3QgdHlwZUV2ZW50ID0gZXZlbnQucmVwbGFjZShzdHJpcE5hbWVSZWdleCwgJycpO1xuICAgIGNvbnN0IGluTmFtZXNwYWNlID0gZXZlbnQgIT09IHR5cGVFdmVudDtcbiAgICBjb25zdCBpc05hdGl2ZSA9IG5hdGl2ZUV2ZW50cy5oYXModHlwZUV2ZW50KTtcbiAgICBsZXQgalF1ZXJ5RXZlbnQ7XG4gICAgbGV0IGJ1YmJsZXMgPSB0cnVlO1xuICAgIGxldCBuYXRpdmVEaXNwYXRjaCA9IHRydWU7XG4gICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICBsZXQgZXZ0ID0gbnVsbDtcblxuICAgIGlmIChpbk5hbWVzcGFjZSAmJiAkKSB7XG4gICAgICBqUXVlcnlFdmVudCA9ICQuRXZlbnQoZXZlbnQsIGFyZ3MpO1xuICAgICAgJChlbGVtZW50KS50cmlnZ2VyKGpRdWVyeUV2ZW50KTtcbiAgICAgIGJ1YmJsZXMgPSAhalF1ZXJ5RXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbiAgICAgIG5hdGl2ZURpc3BhdGNoID0gIWpRdWVyeUV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCk7XG4gICAgICBkZWZhdWx0UHJldmVudGVkID0galF1ZXJ5RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTmF0aXZlKSB7XG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICAgICAgZXZ0LmluaXRFdmVudCh0eXBlRXZlbnQsIGJ1YmJsZXMsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSAvLyBtZXJnZSBjdXN0b20gaW5mb3JtYXRpb24gaW4gb3VyIGV2ZW50XG5cblxuICAgIGlmICh0eXBlb2YgYXJncyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKGFyZ3MpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2dCwga2V5LCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3Nba2V5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKG5hdGl2ZURpc3BhdGNoKSB7XG4gICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9XG5cbiAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgJiYgdHlwZW9mIGpRdWVyeUV2ZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgalF1ZXJ5RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZ0O1xuICB9XG5cbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4wLWJldGEzKTogYmFzZS1jb21wb25lbnQuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgVkVSU0lPTiA9ICc1LjAuMC1iZXRhMyc7XG5cbmNsYXNzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgRGF0YS5zZXQodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIERhdGEucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8qKiBTdGF0aWMgKi9cblxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIERhdGEuZ2V0KGVsZW1lbnQsIHRoaXMuREFUQV9LRVkpO1xuICB9XG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OO1xuICB9XG5cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjAtYmV0YTMpOiBhbGVydC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FJGIgPSAnYWxlcnQnO1xuY29uc3QgREFUQV9LRVkkYiA9ICdicy5hbGVydCc7XG5jb25zdCBFVkVOVF9LRVkkYiA9IGAuJHtEQVRBX0tFWSRifWA7XG5jb25zdCBEQVRBX0FQSV9LRVkkOCA9ICcuZGF0YS1hcGknO1xuY29uc3QgU0VMRUNUT1JfRElTTUlTUyA9ICdbZGF0YS1icy1kaXNtaXNzPVwiYWxlcnRcIl0nO1xuY29uc3QgRVZFTlRfQ0xPU0UgPSBgY2xvc2Uke0VWRU5UX0tFWSRifWA7XG5jb25zdCBFVkVOVF9DTE9TRUQgPSBgY2xvc2VkJHtFVkVOVF9LRVkkYn1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNyA9IGBjbGljayR7RVZFTlRfS0VZJGJ9JHtEQVRBX0FQSV9LRVkkOH1gO1xuY29uc3QgQ0xBU1NfTkFNRV9BTEVSVCA9ICdhbGVydCc7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUkNSA9ICdmYWRlJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQ4ID0gJ3Nob3cnO1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIEFsZXJ0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gREFUQV9LRVkkYjtcbiAgfSAvLyBQdWJsaWNcblxuXG4gIGNsb3NlKGVsZW1lbnQpIHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IGVsZW1lbnQgPyB0aGlzLl9nZXRSb290RWxlbWVudChlbGVtZW50KSA6IHRoaXMuX2VsZW1lbnQ7XG5cbiAgICBjb25zdCBjdXN0b21FdmVudCA9IHRoaXMuX3RyaWdnZXJDbG9zZUV2ZW50KHJvb3RFbGVtZW50KTtcblxuICAgIGlmIChjdXN0b21FdmVudCA9PT0gbnVsbCB8fCBjdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVtb3ZlRWxlbWVudChyb290RWxlbWVudCk7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSB8fCBlbGVtZW50LmNsb3Nlc3QoYC4ke0NMQVNTX05BTUVfQUxFUlR9YCk7XG4gIH1cblxuICBfdHJpZ2dlckNsb3NlRXZlbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9DTE9TRSk7XG4gIH1cblxuICBfcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ4KTtcblxuICAgIGlmICghZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDUpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgIEV2ZW50SGFuZGxlci5vbmUoZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCAoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50KSk7XG4gICAgZW11bGF0ZVRyYW5zaXRpb25FbmQoZWxlbWVudCwgdHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgfVxuXG4gIF9kZXN0cm95RWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX0NMT1NFRCk7XG4gIH0gLy8gU3RhdGljXG5cblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSBEYXRhLmdldCh0aGlzLCBEQVRBX0tFWSRiKTtcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQWxlcnQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcgPT09ICdjbG9zZScpIHtcbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGhhbmRsZURpc21pc3MoYWxlcnRJbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBhbGVydEluc3RhbmNlLmNsb3NlKHRoaXMpO1xuICAgIH07XG4gIH1cblxufVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNywgU0VMRUNUT1JfRElTTUlTUywgQWxlcnQuaGFuZGxlRGlzbWlzcyhuZXcgQWxlcnQoKSkpO1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBhZGQgLkFsZXJ0IHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKE5BTUUkYiwgQWxlcnQpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjAuMC1iZXRhMyk6IGJ1dHRvbi5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FJGEgPSAnYnV0dG9uJztcbmNvbnN0IERBVEFfS0VZJGEgPSAnYnMuYnV0dG9uJztcbmNvbnN0IEVWRU5UX0tFWSRhID0gYC4ke0RBVEFfS0VZJGF9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQ3ID0gJy5kYXRhLWFwaSc7XG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQzID0gJ2FjdGl2ZSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImJ1dHRvblwiXSc7XG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ2ID0gYGNsaWNrJHtFVkVOVF9LRVkkYX0ke0RBVEFfQVBJX0tFWSQ3fWA7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gREFUQV9LRVkkYTtcbiAgfSAvLyBQdWJsaWNcblxuXG4gIHRvZ2dsZSgpIHtcbiAgICAvLyBUb2dnbGUgY2xhc3MgYW5kIHN5bmMgdGhlIGBhcmlhLXByZXNzZWRgIGF0dHJpYnV0ZSB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGAudG9nZ2xlKClgIG1ldGhvZFxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9BQ1RJVkUkMykpO1xuICB9IC8vIFN0YXRpY1xuXG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBkYXRhID0gRGF0YS5nZXQodGhpcywgREFUQV9LRVkkYSk7XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IEJ1dHRvbih0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZyA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiwgU0VMRUNUT1JfREFUQV9UT0dHTEUkNSwgZXZlbnQgPT4ge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBjb25zdCBidXR0b24gPSBldmVudC50YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1KTtcbiAgbGV0IGRhdGEgPSBEYXRhLmdldChidXR0b24sIERBVEFfS0VZJGEpO1xuXG4gIGlmICghZGF0YSkge1xuICAgIGRhdGEgPSBuZXcgQnV0dG9uKGJ1dHRvbik7XG4gIH1cblxuICBkYXRhLnRvZ2dsZSgpO1xufSk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuQnV0dG9uIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKE5BTUUkYSwgQnV0dG9uKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjAtYmV0YTMpOiBkb20vbWFuaXB1bGF0b3IuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGF0YSh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gJ3RydWUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodmFsID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHZhbCA9PT0gTnVtYmVyKHZhbCkudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsKTtcbiAgfVxuXG4gIGlmICh2YWwgPT09ICcnIHx8IHZhbCA9PT0gJ251bGwnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVEYXRhS2V5KGtleSkge1xuICByZXR1cm4ga2V5LnJlcGxhY2UoL1tBLVpdL2csIGNociA9PiBgLSR7Y2hyLnRvTG93ZXJDYXNlKCl9YCk7XG59XG5cbmNvbnN0IE1hbmlwdWxhdG9yID0ge1xuICBzZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gLCB2YWx1ZSk7XG4gIH0sXG5cbiAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKTtcbiAgfSxcblxuICBnZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGVsZW1lbnQuZGF0YXNldCkuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnYnMnKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgbGV0IHB1cmVLZXkgPSBrZXkucmVwbGFjZSgvXmJzLywgJycpO1xuICAgICAgcHVyZUtleSA9IHB1cmVLZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBwdXJlS2V5LnNsaWNlKDEsIHB1cmVLZXkubGVuZ3RoKTtcbiAgICAgIGF0dHJpYnV0ZXNbcHVyZUtleV0gPSBub3JtYWxpemVEYXRhKGVsZW1lbnQuZGF0YXNldFtrZXldKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfSxcblxuICBnZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSkge1xuICAgIHJldHVybiBub3JtYWxpemVEYXRhKGVsZW1lbnQuZ2V0QXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWApKTtcbiAgfSxcblxuICBvZmZzZXQoZWxlbWVudCkge1xuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHJlY3QudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICBsZWZ0OiByZWN0LmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnRcbiAgICB9O1xuICB9LFxuXG4gIHBvc2l0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICAgIGxlZnQ6IGVsZW1lbnQub2Zmc2V0TGVmdFxuICAgIH07XG4gIH1cblxufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjAtYmV0YTMpOiBkb20vc2VsZWN0b3ItZW5naW5lLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmNvbnN0IE5PREVfVEVYVCA9IDM7XG5jb25zdCBTZWxlY3RvckVuZ2luZSA9IHtcbiAgZmluZChzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoLi4uRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbC5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKSk7XG4gIH0sXG5cbiAgZmluZE9uZShzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xuICB9LFxuXG4gIGNoaWxkcmVuKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5lbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpO1xuICB9LFxuXG4gIHBhcmVudHMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgbGV0IGFuY2VzdG9yID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgd2hpbGUgKGFuY2VzdG9yICYmIGFuY2VzdG9yLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBhbmNlc3Rvci5ub2RlVHlwZSAhPT0gTk9ERV9URVhUKSB7XG4gICAgICBpZiAoYW5jZXN0b3IubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgcGFyZW50cy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgIH1cblxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnRzO1xuICB9LFxuXG4gIHByZXYoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgcHJldmlvdXMgPSBlbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG5cbiAgICB3aGlsZSAocHJldmlvdXMpIHtcbiAgICAgIGlmIChwcmV2aW91cy5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gW3ByZXZpb3VzXTtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXMgPSBwcmV2aW91cy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfSxcblxuICBuZXh0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgbGV0IG5leHQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcblxuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gW25leHRdO1xuICAgICAgfVxuXG4gICAgICBuZXh0ID0gbmV4dC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4wLWJldGEzKTogY2Fyb3VzZWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSQ5ID0gJ2Nhcm91c2VsJztcbmNvbnN0IERBVEFfS0VZJDkgPSAnYnMuY2Fyb3VzZWwnO1xuY29uc3QgRVZFTlRfS0VZJDkgPSBgLiR7REFUQV9LRVkkOX1gO1xuY29uc3QgREFUQV9BUElfS0VZJDYgPSAnLmRhdGEtYXBpJztcbmNvbnN0IEFSUk9XX0xFRlRfS0VZID0gJ0Fycm93TGVmdCc7XG5jb25zdCBBUlJPV19SSUdIVF9LRVkgPSAnQXJyb3dSaWdodCc7XG5jb25zdCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBUaW1lIGZvciBtb3VzZSBjb21wYXQgZXZlbnRzIHRvIGZpcmUgYWZ0ZXIgdG91Y2hcblxuY29uc3QgU1dJUEVfVEhSRVNIT0xEID0gNDA7XG5jb25zdCBEZWZhdWx0JDggPSB7XG4gIGludGVydmFsOiA1MDAwLFxuICBrZXlib2FyZDogdHJ1ZSxcbiAgc2xpZGU6IGZhbHNlLFxuICBwYXVzZTogJ2hvdmVyJyxcbiAgd3JhcDogdHJ1ZSxcbiAgdG91Y2g6IHRydWVcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ4ID0ge1xuICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICBzbGlkZTogJyhib29sZWFufHN0cmluZyknLFxuICBwYXVzZTogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICB3cmFwOiAnYm9vbGVhbicsXG4gIHRvdWNoOiAnYm9vbGVhbidcbn07XG5jb25zdCBPUkRFUl9ORVhUID0gJ25leHQnO1xuY29uc3QgT1JERVJfUFJFViA9ICdwcmV2JztcbmNvbnN0IERJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xuY29uc3QgRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcbmNvbnN0IEVWRU5UX1NMSURFID0gYHNsaWRlJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfU0xJRCA9IGBzbGlkJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfS0VZRE9XTiA9IGBrZXlkb3duJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfTU9VU0VFTlRFUiA9IGBtb3VzZWVudGVyJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfTU9VU0VMRUFWRSA9IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfVE9VQ0hTVEFSVCA9IGB0b3VjaHN0YXJ0JHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfVE9VQ0hNT1ZFID0gYHRvdWNobW92ZSR7RVZFTlRfS0VZJDl9YDtcbmNvbnN0IEVWRU5UX1RPVUNIRU5EID0gYHRvdWNoZW5kJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfUE9JTlRFUkRPV04gPSBgcG9pbnRlcmRvd24ke0VWRU5UX0tFWSQ5fWA7XG5jb25zdCBFVkVOVF9QT0lOVEVSVVAgPSBgcG9pbnRlcnVwJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfRFJBR19TVEFSVCA9IGBkcmFnc3RhcnQke0VWRU5UX0tFWSQ5fWA7XG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIgPSBgbG9hZCR7RVZFTlRfS0VZJDl9JHtEQVRBX0FQSV9LRVkkNn1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSA9IGBjbGljayR7RVZFTlRfS0VZJDl9JHtEQVRBX0FQSV9LRVkkNn1gO1xuY29uc3QgQ0xBU1NfTkFNRV9DQVJPVVNFTCA9ICdjYXJvdXNlbCc7XG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQyID0gJ2FjdGl2ZSc7XG5jb25zdCBDTEFTU19OQU1FX1NMSURFID0gJ3NsaWRlJztcbmNvbnN0IENMQVNTX05BTUVfRU5EID0gJ2Nhcm91c2VsLWl0ZW0tZW5kJztcbmNvbnN0IENMQVNTX05BTUVfU1RBUlQgPSAnY2Fyb3VzZWwtaXRlbS1zdGFydCc7XG5jb25zdCBDTEFTU19OQU1FX05FWFQgPSAnY2Fyb3VzZWwtaXRlbS1uZXh0JztcbmNvbnN0IENMQVNTX05BTUVfUFJFViA9ICdjYXJvdXNlbC1pdGVtLXByZXYnO1xuY29uc3QgQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UID0gJ3BvaW50ZXItZXZlbnQnO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFJDEgPSAnLmFjdGl2ZSc7XG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkVfSVRFTSA9ICcuYWN0aXZlLmNhcm91c2VsLWl0ZW0nO1xuY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSc7XG5jb25zdCBTRUxFQ1RPUl9JVEVNX0lNRyA9ICcuY2Fyb3VzZWwtaXRlbSBpbWcnO1xuY29uc3QgU0VMRUNUT1JfTkVYVF9QUkVWID0gJy5jYXJvdXNlbC1pdGVtLW5leHQsIC5jYXJvdXNlbC1pdGVtLXByZXYnO1xuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycyc7XG5jb25zdCBTRUxFQ1RPUl9JTkRJQ0FUT1IgPSAnW2RhdGEtYnMtdGFyZ2V0XSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1NMSURFID0gJ1tkYXRhLWJzLXNsaWRlXSwgW2RhdGEtYnMtc2xpZGUtdG9dJztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfUklERSA9ICdbZGF0YS1icy1yaWRlPVwiY2Fyb3VzZWxcIl0nO1xuY29uc3QgUE9JTlRFUl9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbmNvbnN0IFBPSU5URVJfVFlQRV9QRU4gPSAncGVuJztcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBDYXJvdXNlbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50KTtcbiAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMudG91Y2hTdGFydFggPSAwO1xuICAgIHRoaXMudG91Y2hEZWx0YVggPSAwO1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9JTkRJQ0FUT1JTLCB0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl90b3VjaFN1cHBvcnRlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xuICAgIHRoaXMuX3BvaW50ZXJFdmVudCA9IEJvb2xlYW4od2luZG93LlBvaW50ZXJFdmVudCk7XG5cbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICB9IC8vIEdldHRlcnNcblxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQ4O1xuICB9XG5cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gREFUQV9LRVkkOTtcbiAgfSAvLyBQdWJsaWNcblxuXG4gIG5leHQoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpO1xuICAgIH1cbiAgfVxuXG4gIG5leHRXaGVuVmlzaWJsZSgpIHtcbiAgICAvLyBEb24ndCBjYWxsIG5leHQgd2hlbiB0aGUgcGFnZSBpc24ndCB2aXNpYmxlXG4gICAgLy8gb3IgdGhlIGNhcm91c2VsIG9yIGl0cyBwYXJlbnQgaXNuJ3QgdmlzaWJsZVxuICAgIGlmICghZG9jdW1lbnQuaGlkZGVuICYmIGlzVmlzaWJsZSh0aGlzLl9lbGVtZW50KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgcHJldigpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2xpZGluZykge1xuICAgICAgdGhpcy5fc2xpZGUoT1JERVJfUFJFVik7XG4gICAgfVxuICB9XG5cbiAgcGF1c2UoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTkVYVF9QUkVWLCB0aGlzLl9lbGVtZW50KSkge1xuICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLmN5Y2xlKHRydWUpO1xuICAgIH1cblxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgfVxuXG4gIGN5Y2xlKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlSW50ZXJ2YWwoKTtcblxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID8gdGhpcy5uZXh0V2hlblZpc2libGUgOiB0aGlzLm5leHQpLmJpbmQodGhpcyksIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgdG8oaW5kZXgpIHtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkVfSVRFTSwgdGhpcy5fZWxlbWVudCk7XG5cbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtcblxuICAgIGlmIChpbmRleCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLnRvKGluZGV4KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xuXG4gICAgdGhpcy5fc2xpZGUob3JkZXIsIHRoaXMuX2l0ZW1zW2luZGV4XSk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZJDkpO1xuICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLl9pc1BhdXNlZCA9IG51bGw7XG4gICAgdGhpcy5faXNTbGlkaW5nID0gbnVsbDtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IG51bGw7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9IC8vIFByaXZhdGVcblxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0geyAuLi5EZWZhdWx0JDgsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJDksIGNvbmZpZywgRGVmYXVsdFR5cGUkOCk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIF9oYW5kbGVTd2lwZSgpIHtcbiAgICBjb25zdCBhYnNEZWx0YXggPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGFYKTtcblxuICAgIGlmIChhYnNEZWx0YXggPD0gU1dJUEVfVEhSRVNIT0xEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gYWJzRGVsdGF4IC8gdGhpcy50b3VjaERlbHRhWDtcbiAgICB0aGlzLnRvdWNoRGVsdGFYID0gMDtcblxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc2xpZGUoZGlyZWN0aW9uID4gMCA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUKTtcbiAgfVxuXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTiwgZXZlbnQgPT4gdGhpcy5fa2V5ZG93bihldmVudCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRUVOVEVSLCBldmVudCA9PiB0aGlzLnBhdXNlKGV2ZW50KSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VMRUFWRSwgZXZlbnQgPT4gdGhpcy5jeWNsZShldmVudCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcudG91Y2ggJiYgdGhpcy5fdG91Y2hTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH1cblxuICBfYWRkVG91Y2hFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCBzdGFydCA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLl9wb2ludGVyRXZlbnQgJiYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBQT0lOVEVSX1RZUEVfUEVOIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSBQT0lOVEVSX1RZUEVfVE9VQ0gpKSB7XG4gICAgICAgIHRoaXMudG91Y2hTdGFydFggPSBldmVudC5jbGllbnRYO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fcG9pbnRlckV2ZW50KSB7XG4gICAgICAgIHRoaXMudG91Y2hTdGFydFggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG1vdmUgPSBldmVudCA9PiB7XG4gICAgICAvLyBlbnN1cmUgc3dpcGluZyB3aXRoIG9uZSB0b3VjaCBhbmQgbm90IHBpbmNoaW5nXG4gICAgICB0aGlzLnRvdWNoRGVsdGFYID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WDtcbiAgICB9O1xuXG4gICAgY29uc3QgZW5kID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCkpIHtcbiAgICAgICAgdGhpcy50b3VjaERlbHRhWCA9IGV2ZW50LmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9oYW5kbGVTd2lwZSgpO1xuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlID09PSAnaG92ZXInKSB7XG4gICAgICAgIC8vIElmIGl0J3MgYSB0b3VjaC1lbmFibGVkIGRldmljZSwgbW91c2VlbnRlci9sZWF2ZSBhcmUgZmlyZWQgYXNcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgbW91c2UgY29tcGF0aWJpbGl0eSBldmVudHMgb24gZmlyc3QgdGFwIC0gdGhlIGNhcm91c2VsXG4gICAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XG4gICAgICAgIC8vIGhlcmUsIHdlIGxpc3RlbiBmb3IgdG91Y2hlbmQsIGV4cGxpY2l0bHkgcGF1c2UgdGhlIGNhcm91c2VsXG4gICAgICAgIC8vIChhcyBpZiBpdCdzIHRoZSBzZWNvbmQgdGltZSB3ZSB0YXAgb24gaXQsIG1vdXNlZW50ZXIgY29tcGF0IGV2ZW50XG4gICAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcbiAgICAgICAgLy8gZXZlbnRzIHRvIGZpcmUpIHdlIGV4cGxpY2l0bHkgcmVzdGFydCBjeWNsaW5nXG4gICAgICAgIHRoaXMucGF1c2UoKTtcblxuICAgICAgICBpZiAodGhpcy50b3VjaFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGV2ZW50ID0+IHRoaXMuY3ljbGUoZXZlbnQpLCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUICsgdGhpcy5fY29uZmlnLmludGVydmFsKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChpdGVtSW1nID0+IHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbihpdGVtSW1nLCBFVkVOVF9EUkFHX1NUQVJULCBlID0+IGUucHJldmVudERlZmF1bHQoKSk7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5fcG9pbnRlckV2ZW50KSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUkRPV04sIGV2ZW50ID0+IHN0YXJ0KGV2ZW50KSk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUlVQLCBldmVudCA9PiBlbmQoZXZlbnQpKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSFNUQVJULCBldmVudCA9PiBzdGFydChldmVudCkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNITU9WRSwgZXZlbnQgPT4gbW92ZShldmVudCkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIRU5ELCBldmVudCA9PiBlbmQoZXZlbnQpKTtcbiAgICB9XG4gIH1cblxuICBfa2V5ZG93bihldmVudCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX0xFRlRfS0VZKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9zbGlkZShESVJFQ1RJT05fTEVGVCk7XG4gICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IEFSUk9XX1JJR0hUX0tFWSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5fc2xpZGUoRElSRUNUSU9OX1JJR0hUKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0SXRlbUluZGV4KGVsZW1lbnQpIHtcbiAgICB0aGlzLl9pdGVtcyA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlID8gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNLCBlbGVtZW50LnBhcmVudE5vZGUpIDogW107XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YoZWxlbWVudCk7XG4gIH1cblxuICBfZ2V0SXRlbUJ5T3JkZXIob3JkZXIsIGFjdGl2ZUVsZW1lbnQpIHtcbiAgICBjb25zdCBpc05leHQgPSBvcmRlciA9PT0gT1JERVJfTkVYVDtcbiAgICBjb25zdCBpc1ByZXYgPSBvcmRlciA9PT0gT1JERVJfUFJFVjtcblxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KGFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgY29uc3QgbGFzdEl0ZW1JbmRleCA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgaXNHb2luZ1RvV3JhcCA9IGlzUHJldiAmJiBhY3RpdmVJbmRleCA9PT0gMCB8fCBpc05leHQgJiYgYWN0aXZlSW5kZXggPT09IGxhc3RJdGVtSW5kZXg7XG5cbiAgICBpZiAoaXNHb2luZ1RvV3JhcCAmJiAhdGhpcy5fY29uZmlnLndyYXApIHtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0gaXNQcmV2ID8gLTEgOiAxO1xuICAgIGNvbnN0IGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgICByZXR1cm4gaXRlbUluZGV4ID09PSAtMSA/IHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdIDogdGhpcy5faXRlbXNbaXRlbUluZGV4XTtcbiAgfVxuXG4gIF90cmlnZ2VyU2xpZGVFdmVudChyZWxhdGVkVGFyZ2V0LCBldmVudERpcmVjdGlvbk5hbWUpIHtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChyZWxhdGVkVGFyZ2V0KTtcblxuICAgIGNvbnN0IGZyb21JbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KSk7XG5cbiAgICByZXR1cm4gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJREUsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQsXG4gICAgICBkaXJlY3Rpb246IGV2ZW50RGlyZWN0aW9uTmFtZSxcbiAgICAgIGZyb206IGZyb21JbmRleCxcbiAgICAgIHRvOiB0YXJnZXRJbmRleFxuICAgIH0pO1xuICB9XG5cbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgY29uc3QgYWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkUkMSwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpO1xuICAgICAgYWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICBhY3RpdmVJbmRpY2F0b3IucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnKTtcbiAgICAgIGNvbnN0IGluZGljYXRvcnMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lORElDQVRPUiwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljYXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChpbmRpY2F0b3JzW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1icy1zbGlkZS10bycpLCAxMCkgPT09IHRoaXMuX2dldEl0ZW1JbmRleChlbGVtZW50KSkge1xuICAgICAgICAgIGluZGljYXRvcnNbaV0uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQyKTtcbiAgICAgICAgICBpbmRpY2F0b3JzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ3RydWUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVJbnRlcnZhbCgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KTtcblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRJbnRlcnZhbCA9IE51bWJlci5wYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1pbnRlcnZhbCcpLCAxMCk7XG5cbiAgICBpZiAoZWxlbWVudEludGVydmFsKSB7XG4gICAgICB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWw7XG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlbGVtZW50SW50ZXJ2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsO1xuICAgIH1cbiAgfVxuXG4gIF9zbGlkZShkaXJlY3Rpb25Pck9yZGVyLCBlbGVtZW50KSB7XG4gICAgY29uc3Qgb3JkZXIgPSB0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbk9yT3JkZXIpO1xuXG4gICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgY29uc3QgYWN0aXZlRWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KGFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgY29uc3QgbmV4dEVsZW1lbnQgPSBlbGVtZW50IHx8IHRoaXMuX2dldEl0ZW1CeU9yZGVyKG9yZGVyLCBhY3RpdmVFbGVtZW50KTtcblxuICAgIGNvbnN0IG5leHRFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgobmV4dEVsZW1lbnQpO1xuXG4gICAgY29uc3QgaXNDeWNsaW5nID0gQm9vbGVhbih0aGlzLl9pbnRlcnZhbCk7XG4gICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XG4gICAgY29uc3QgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX1NUQVJUIDogQ0xBU1NfTkFNRV9FTkQ7XG4gICAgY29uc3Qgb3JkZXJDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX05FWFQgOiBDTEFTU19OQU1FX1BSRVY7XG5cbiAgICBjb25zdCBldmVudERpcmVjdGlvbk5hbWUgPSB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKTtcblxuICAgIGlmIChuZXh0RWxlbWVudCAmJiBuZXh0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUkMikpIHtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNsaWRlRXZlbnQgPSB0aGlzLl90cmlnZ2VyU2xpZGVFdmVudChuZXh0RWxlbWVudCwgZXZlbnREaXJlY3Rpb25OYW1lKTtcblxuICAgIGlmIChzbGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgIW5leHRFbGVtZW50KSB7XG4gICAgICAvLyBTb21lIHdlaXJkbmVzcyBpcyBoYXBwZW5pbmcsIHNvIHdlIGJhaWxcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlO1xuXG4gICAgaWYgKGlzQ3ljbGluZykge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQobmV4dEVsZW1lbnQpO1xuXG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG5leHRFbGVtZW50O1xuXG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0xJREUpKSB7XG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcbiAgICAgIHJlZmxvdyhuZXh0RWxlbWVudCk7XG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChhY3RpdmVFbGVtZW50KTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUoYWN0aXZlRWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCAoKSA9PiB7XG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZGlyZWN0aW9uYWxDbGFzc05hbWUsIG9yZGVyQ2xhc3NOYW1lKTtcbiAgICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQyKTtcbiAgICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIsIG9yZGVyQ2xhc3NOYW1lLCBkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCB7XG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxuICAgICAgICAgICAgZnJvbTogYWN0aXZlRWxlbWVudEluZGV4LFxuICAgICAgICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9KTtcbiAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGFjdGl2ZUVsZW1lbnQsIHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQyKTtcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogbmV4dEVsZW1lbnQsXG4gICAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxuICAgICAgICBmcm9tOiBhY3RpdmVFbGVtZW50SW5kZXgsXG4gICAgICAgIHRvOiBuZXh0RWxlbWVudEluZGV4XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNDeWNsaW5nKSB7XG4gICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgfVxuICB9XG5cbiAgX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKCFbRElSRUNUSU9OX1JJR0hULCBESVJFQ1RJT05fTEVGVF0uaW5jbHVkZXMoZGlyZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoaXNSVEwoKSkge1xuICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1JJR0hUID8gT1JERVJfUFJFViA6IE9SREVSX05FWFQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1JJR0hUID8gT1JERVJfTkVYVCA6IE9SREVSX1BSRVY7XG4gIH1cblxuICBfb3JkZXJUb0RpcmVjdGlvbihvcmRlcikge1xuICAgIGlmICghW09SREVSX05FWFQsIE9SREVSX1BSRVZdLmluY2x1ZGVzKG9yZGVyKSkge1xuICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH1cblxuICAgIGlmIChpc1JUTCgpKSB7XG4gICAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX05FWFQgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX05FWFQgPyBESVJFQ1RJT05fUklHSFQgOiBESVJFQ1RJT05fTEVGVDtcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBjYXJvdXNlbEludGVyZmFjZShlbGVtZW50LCBjb25maWcpIHtcbiAgICBsZXQgZGF0YSA9IERhdGEuZ2V0KGVsZW1lbnQsIERBVEFfS0VZJDkpO1xuICAgIGxldCBfY29uZmlnID0geyAuLi5EZWZhdWx0JDgsXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIF9jb25maWcgPSB7IC4uLl9jb25maWcsXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpb24gPSB0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyA/IGNvbmZpZyA6IF9jb25maWcuc2xpZGU7XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIGRhdGEgPSBuZXcgQ2Fyb3VzZWwoZWxlbWVudCwgX2NvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICBkYXRhLnRvKGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhW2FjdGlvbl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7YWN0aW9ufVwiYCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFbYWN0aW9uXSgpO1xuICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5pbnRlcnZhbCAmJiBfY29uZmlnLnJpZGUpIHtcbiAgICAgIGRhdGEucGF1c2UoKTtcbiAgICAgIGRhdGEuY3ljbGUoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgQ2Fyb3VzZWwuY2Fyb3VzZWxJbnRlcmZhY2UodGhpcywgY29uZmlnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkYXRhQXBpQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcblxuICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ0FST1VTRUwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29uZmlnID0geyAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0YXJnZXQpLFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcylcbiAgICB9O1xuICAgIGNvbnN0IHNsaWRlSW5kZXggPSB0aGlzLmdldEF0dHJpYnV0ZSgnZGF0YS1icy1zbGlkZS10bycpO1xuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgIGNvbmZpZy5pbnRlcnZhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIENhcm91c2VsLmNhcm91c2VsSW50ZXJmYWNlKHRhcmdldCwgY29uZmlnKTtcblxuICAgIGlmIChzbGlkZUluZGV4KSB7XG4gICAgICBEYXRhLmdldCh0YXJnZXQsIERBVEFfS0VZJDkpLnRvKHNsaWRlSW5kZXgpO1xuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxufVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSwgU0VMRUNUT1JfREFUQV9TTElERSwgQ2Fyb3VzZWwuZGF0YUFwaUNsaWNrSGFuZGxlcik7XG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIsICgpID0+IHtcbiAgY29uc3QgY2Fyb3VzZWxzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1JJREUpO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYXJvdXNlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBDYXJvdXNlbC5jYXJvdXNlbEludGVyZmFjZShjYXJvdXNlbHNbaV0sIERhdGEuZ2V0KGNhcm91c2Vsc1tpXSwgREFUQV9LRVkkOSkpO1xuICB9XG59KTtcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogYWRkIC5DYXJvdXNlbCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihOQU1FJDksIENhcm91c2VsKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjAtYmV0YTMpOiBjb2xsYXBzZS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FJDggPSAnY29sbGFwc2UnO1xuY29uc3QgREFUQV9LRVkkOCA9ICdicy5jb2xsYXBzZSc7XG5jb25zdCBFVkVOVF9LRVkkOCA9IGAuJHtEQVRBX0tFWSQ4fWA7XG5jb25zdCBEQVRBX0FQSV9LRVkkNSA9ICcuZGF0YS1hcGknO1xuY29uc3QgRGVmYXVsdCQ3ID0ge1xuICB0b2dnbGU6IHRydWUsXG4gIHBhcmVudDogJydcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ3ID0ge1xuICB0b2dnbGU6ICdib29sZWFuJyxcbiAgcGFyZW50OiAnKHN0cmluZ3xlbGVtZW50KSdcbn07XG5jb25zdCBFVkVOVF9TSE9XJDUgPSBgc2hvdyR7RVZFTlRfS0VZJDh9YDtcbmNvbnN0IEVWRU5UX1NIT1dOJDUgPSBgc2hvd24ke0VWRU5UX0tFWSQ4fWA7XG5jb25zdCBFVkVOVF9ISURFJDUgPSBgaGlkZSR7RVZFTlRfS0VZJDh9YDtcbmNvbnN0IEVWRU5UX0hJRERFTiQ1ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDh9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQgPSBgY2xpY2ske0VWRU5UX0tFWSQ4fSR7REFUQV9BUElfS0VZJDV9YDtcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQ3ID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSc7XG5jb25zdCBDTEFTU19OQU1FX0NPTExBUFNJTkcgPSAnY29sbGFwc2luZyc7XG5jb25zdCBDTEFTU19OQU1FX0NPTExBUFNFRCA9ICdjb2xsYXBzZWQnO1xuY29uc3QgV0lEVEggPSAnd2lkdGgnO1xuY29uc3QgSEVJR0hUID0gJ2hlaWdodCc7XG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkVTID0gJy5zaG93LCAuY29sbGFwc2luZyc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCJdJztcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBDb2xsYXBzZSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50KTtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBTZWxlY3RvckVuZ2luZS5maW5kKGAke1NFTEVDVE9SX0RBVEFfVE9HR0xFJDR9W2hyZWY9XCIjJHt0aGlzLl9lbGVtZW50LmlkfVwiXSxgICsgYCR7U0VMRUNUT1JfREFUQV9UT0dHTEUkNH1bZGF0YS1icy10YXJnZXQ9XCIjJHt0aGlzLl9lbGVtZW50LmlkfVwiXWApO1xuICAgIGNvbnN0IHRvZ2dsZUxpc3QgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRvZ2dsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSB0b2dnbGVMaXN0W2ldO1xuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW0pO1xuICAgICAgY29uc3QgZmlsdGVyRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZpbHRlcihmb3VuZEVsZW0gPT4gZm91bmRFbGVtID09PSB0aGlzLl9lbGVtZW50KTtcblxuICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmIGZpbHRlckVsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XG5cbiAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goZWxlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fY29uZmlnLnBhcmVudCA/IHRoaXMuX2dldFBhcmVudCgpIDogbnVsbDtcblxuICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3RyaWdnZXJBcnJheSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcbiAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgfVxuICB9IC8vIEdldHRlcnNcblxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQ3O1xuICB9XG5cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gREFUQV9LRVkkODtcbiAgfSAvLyBQdWJsaWNcblxuXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpKSB7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBhY3RpdmVzO1xuICAgIGxldCBhY3RpdmVzRGF0YTtcblxuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIGFjdGl2ZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0FDVElWRVMsIHRoaXMuX3BhcmVudCkuZmlsdGVyKGVsZW0gPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5wYXJlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXBhcmVudCcpID09PSB0aGlzLl9jb25maWcucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhY3RpdmVzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKHRoaXMuX3NlbGVjdG9yKTtcblxuICAgIGlmIChhY3RpdmVzKSB7XG4gICAgICBjb25zdCB0ZW1wQWN0aXZlRGF0YSA9IGFjdGl2ZXMuZmluZChlbGVtID0+IGNvbnRhaW5lciAhPT0gZWxlbSk7XG4gICAgICBhY3RpdmVzRGF0YSA9IHRlbXBBY3RpdmVEYXRhID8gRGF0YS5nZXQodGVtcEFjdGl2ZURhdGEsIERBVEFfS0VZJDgpIDogbnVsbDtcblxuICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDUpO1xuXG4gICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmVzKSB7XG4gICAgICBhY3RpdmVzLmZvckVhY2goZWxlbUFjdGl2ZSA9PiB7XG4gICAgICAgIGlmIChjb250YWluZXIgIT09IGVsZW1BY3RpdmUpIHtcbiAgICAgICAgICBDb2xsYXBzZS5jb2xsYXBzZUludGVyZmFjZShlbGVtQWN0aXZlLCAnaGlkZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhY3RpdmVzRGF0YSkge1xuICAgICAgICAgIERhdGEuc2V0KGVsZW1BY3RpdmUsIERBVEFfS0VZJDgsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNFKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gMDtcblxuICAgIGlmICh0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0VEKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKTtcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFLCBDTEFTU19OQU1FX1NIT1ckNyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDUpO1xuICAgIH07XG5cbiAgICBjb25zdCBjYXBpdGFsaXplZERpbWVuc2lvbiA9IGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpO1xuICAgIGNvbnN0IHNjcm9sbFNpemUgPSBgc2Nyb2xsJHtjYXBpdGFsaXplZERpbWVuc2lvbn1gO1xuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBjb21wbGV0ZSk7XG4gICAgZW11bGF0ZVRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCwgdHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50W3Njcm9sbFNpemVdfXB4YDtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNSk7XG5cbiAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl19cHhgO1xuICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVyQ3KTtcblxuICAgIGNvbnN0IHRyaWdnZXJBcnJheUxlbmd0aCA9IHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGg7XG5cbiAgICBpZiAodHJpZ2dlckFycmF5TGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmlnZ2VyQXJyYXlMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0cmlnZ2VyID0gdGhpcy5fdHJpZ2dlckFycmF5W2ldO1xuICAgICAgICBjb25zdCBlbGVtID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0cmlnZ2VyKTtcblxuICAgICAgICBpZiAoZWxlbSAmJiAhZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpKSB7XG4gICAgICAgICAgdHJpZ2dlci5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0VEKTtcbiAgICAgICAgICB0cmlnZ2VyLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKTtcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFKTtcblxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDUpO1xuICAgIH07XG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsICd0cmFuc2l0aW9uZW5kJywgY29tcGxldGUpO1xuICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQsIHRyYW5zaXRpb25EdXJhdGlvbik7XG4gIH1cblxuICBzZXRUcmFuc2l0aW9uaW5nKGlzVHJhbnNpdGlvbmluZykge1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGlzVHJhbnNpdGlvbmluZztcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2NvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBudWxsO1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IG51bGw7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkNyxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSk7IC8vIENvZXJjZSBzdHJpbmcgdmFsdWVzXG5cbiAgICB0eXBlQ2hlY2tDb25maWcoTkFNRSQ4LCBjb25maWcsIERlZmF1bHRUeXBlJDcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBfZ2V0RGltZW5zaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhXSURUSCkgPyBXSURUSCA6IEhFSUdIVDtcbiAgfVxuXG4gIF9nZXRQYXJlbnQoKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzLl9jb25maWc7XG5cbiAgICBpZiAoaXNFbGVtZW50KHBhcmVudCkpIHtcbiAgICAgIC8vIGl0J3MgYSBqUXVlcnkgb2JqZWN0XG4gICAgICBpZiAodHlwZW9mIHBhcmVudC5qcXVlcnkgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwYXJlbnRbMF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShwYXJlbnQpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdG9yID0gYCR7U0VMRUNUT1JfREFUQV9UT0dHTEUkNH1bZGF0YS1icy1wYXJlbnQ9XCIke3BhcmVudH1cIl1gO1xuICAgIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHBhcmVudCkuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0gZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KTtcblxuICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHNlbGVjdGVkLCBbZWxlbWVudF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJlbnQ7XG4gIH1cblxuICBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGVsZW1lbnQsIHRyaWdnZXJBcnJheSkge1xuICAgIGlmICghZWxlbWVudCB8fCAhdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlzT3BlbiA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KTtcbiAgICB0cmlnZ2VyQXJyYXkuZm9yRWFjaChlbGVtID0+IHtcbiAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0VEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFRCk7XG4gICAgICB9XG5cbiAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcbiAgICB9KTtcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBjb2xsYXBzZUludGVyZmFjZShlbGVtZW50LCBjb25maWcpIHtcbiAgICBsZXQgZGF0YSA9IERhdGEuZ2V0KGVsZW1lbnQsIERBVEFfS0VZJDgpO1xuICAgIGNvbnN0IF9jb25maWcgPSB7IC4uLkRlZmF1bHQkNyxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgIH07XG5cbiAgICBpZiAoIWRhdGEgJiYgX2NvbmZpZy50b2dnbGUgJiYgdHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycgJiYgL3Nob3d8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghZGF0YSkge1xuICAgICAgZGF0YSA9IG5ldyBDb2xsYXBzZShlbGVtZW50LCBfY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuXG4gICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgQ29sbGFwc2UuY29sbGFwc2VJbnRlcmZhY2UodGhpcywgY29uZmlnKTtcbiAgICB9KTtcbiAgfVxuXG59XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gcHJldmVudERlZmF1bHQgb25seSBmb3IgPGE+IGVsZW1lbnRzICh3aGljaCBjaGFuZ2UgdGhlIFVSTCkgbm90IGluc2lkZSB0aGUgY29sbGFwc2libGUgZWxlbWVudFxuICBpZiAoZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdBJyB8fCBldmVudC5kZWxlZ2F0ZVRhcmdldCAmJiBldmVudC5kZWxlZ2F0ZVRhcmdldC50YWdOYW1lID09PSAnQScpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgY29uc3QgdHJpZ2dlckRhdGEgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzKTtcbiAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpO1xuICBjb25zdCBzZWxlY3RvckVsZW1lbnRzID0gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3Rvcik7XG4gIHNlbGVjdG9yRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBjb25zdCBkYXRhID0gRGF0YS5nZXQoZWxlbWVudCwgREFUQV9LRVkkOCk7XG4gICAgbGV0IGNvbmZpZztcblxuICAgIGlmIChkYXRhKSB7XG4gICAgICAvLyB1cGRhdGUgcGFyZW50IGF0dHJpYnV0ZVxuICAgICAgaWYgKGRhdGEuX3BhcmVudCA9PT0gbnVsbCAmJiB0eXBlb2YgdHJpZ2dlckRhdGEucGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhLl9jb25maWcucGFyZW50ID0gdHJpZ2dlckRhdGEucGFyZW50O1xuICAgICAgICBkYXRhLl9wYXJlbnQgPSBkYXRhLl9nZXRQYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgY29uZmlnID0gJ3RvZ2dsZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZyA9IHRyaWdnZXJEYXRhO1xuICAgIH1cblxuICAgIENvbGxhcHNlLmNvbGxhcHNlSW50ZXJmYWNlKGVsZW1lbnQsIGNvbmZpZyk7XG4gIH0pO1xufSk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuQ29sbGFwc2UgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oTkFNRSQ4LCBDb2xsYXBzZSk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4wLWJldGEzKTogZHJvcGRvd24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSQ3ID0gJ2Ryb3Bkb3duJztcbmNvbnN0IERBVEFfS0VZJDcgPSAnYnMuZHJvcGRvd24nO1xuY29uc3QgRVZFTlRfS0VZJDcgPSBgLiR7REFUQV9LRVkkN31gO1xuY29uc3QgREFUQV9BUElfS0VZJDQgPSAnLmRhdGEtYXBpJztcbmNvbnN0IEVTQ0FQRV9LRVkkMiA9ICdFc2NhcGUnO1xuY29uc3QgU1BBQ0VfS0VZID0gJ1NwYWNlJztcbmNvbnN0IFRBQl9LRVkgPSAnVGFiJztcbmNvbnN0IEFSUk9XX1VQX0tFWSA9ICdBcnJvd1VwJztcbmNvbnN0IEFSUk9XX0RPV05fS0VZID0gJ0Fycm93RG93bic7XG5jb25zdCBSSUdIVF9NT1VTRV9CVVRUT04gPSAyOyAvLyBNb3VzZUV2ZW50LmJ1dHRvbiB2YWx1ZSBmb3IgdGhlIHNlY29uZGFyeSBidXR0b24sIHVzdWFsbHkgdGhlIHJpZ2h0IGJ1dHRvblxuXG5jb25zdCBSRUdFWFBfS0VZRE9XTiA9IG5ldyBSZWdFeHAoYCR7QVJST1dfVVBfS0VZfXwke0FSUk9XX0RPV05fS0VZfXwke0VTQ0FQRV9LRVkkMn1gKTtcbmNvbnN0IEVWRU5UX0hJREUkNCA9IGBoaWRlJHtFVkVOVF9LRVkkN31gO1xuY29uc3QgRVZFTlRfSElEREVOJDQgPSBgaGlkZGVuJHtFVkVOVF9LRVkkN31gO1xuY29uc3QgRVZFTlRfU0hPVyQ0ID0gYHNob3cke0VWRU5UX0tFWSQ3fWA7XG5jb25zdCBFVkVOVF9TSE9XTiQ0ID0gYHNob3duJHtFVkVOVF9LRVkkN31gO1xuY29uc3QgRVZFTlRfQ0xJQ0sgPSBgY2xpY2ske0VWRU5UX0tFWSQ3fWA7XG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQzID0gYGNsaWNrJHtFVkVOVF9LRVkkN30ke0RBVEFfQVBJX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJID0gYGtleWRvd24ke0VWRU5UX0tFWSQ3fSR7REFUQV9BUElfS0VZJDR9YDtcbmNvbnN0IEVWRU5UX0tFWVVQX0RBVEFfQVBJID0gYGtleXVwJHtFVkVOVF9LRVkkN30ke0RBVEFfQVBJX0tFWSQ0fWA7XG5jb25zdCBDTEFTU19OQU1FX0RJU0FCTEVEID0gJ2Rpc2FibGVkJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQ2ID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVAgPSAnZHJvcHVwJztcbmNvbnN0IENMQVNTX05BTUVfRFJPUEVORCA9ICdkcm9wZW5kJztcbmNvbnN0IENMQVNTX05BTUVfRFJPUFNUQVJUID0gJ2Ryb3BzdGFydCc7XG5jb25zdCBDTEFTU19OQU1FX05BVkJBUiA9ICduYXZiYXInO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMyA9ICdbZGF0YS1icy10b2dnbGU9XCJkcm9wZG93blwiXSc7XG5jb25zdCBTRUxFQ1RPUl9NRU5VID0gJy5kcm9wZG93bi1tZW51JztcbmNvbnN0IFNFTEVDVE9SX05BVkJBUl9OQVYgPSAnLm5hdmJhci1uYXYnO1xuY29uc3QgU0VMRUNUT1JfVklTSUJMRV9JVEVNUyA9ICcuZHJvcGRvd24tbWVudSAuZHJvcGRvd24taXRlbTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XG5jb25zdCBQTEFDRU1FTlRfVE9QID0gaXNSVEwoKSA/ICd0b3AtZW5kJyA6ICd0b3Atc3RhcnQnO1xuY29uc3QgUExBQ0VNRU5UX1RPUEVORCA9IGlzUlRMKCkgPyAndG9wLXN0YXJ0JyA6ICd0b3AtZW5kJztcbmNvbnN0IFBMQUNFTUVOVF9CT1RUT00gPSBpc1JUTCgpID8gJ2JvdHRvbS1lbmQnIDogJ2JvdHRvbS1zdGFydCc7XG5jb25zdCBQTEFDRU1FTlRfQk9UVE9NRU5EID0gaXNSVEwoKSA/ICdib3R0b20tc3RhcnQnIDogJ2JvdHRvbS1lbmQnO1xuY29uc3QgUExBQ0VNRU5UX1JJR0hUID0gaXNSVEwoKSA/ICdsZWZ0LXN0YXJ0JyA6ICdyaWdodC1zdGFydCc7XG5jb25zdCBQTEFDRU1FTlRfTEVGVCA9IGlzUlRMKCkgPyAncmlnaHQtc3RhcnQnIDogJ2xlZnQtc3RhcnQnO1xuY29uc3QgRGVmYXVsdCQ2ID0ge1xuICBvZmZzZXQ6IFswLCAyXSxcbiAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxuICByZWZlcmVuY2U6ICd0b2dnbGUnLFxuICBkaXNwbGF5OiAnZHluYW1pYycsXG4gIHBvcHBlckNvbmZpZzogbnVsbFxufTtcbmNvbnN0IERlZmF1bHRUeXBlJDYgPSB7XG4gIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgcmVmZXJlbmNlOiAnKHN0cmluZ3xlbGVtZW50fG9iamVjdCknLFxuICBkaXNwbGF5OiAnc3RyaW5nJyxcbiAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKSdcbn07XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCk7XG4gICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9tZW51ID0gdGhpcy5fZ2V0TWVudUVsZW1lbnQoKTtcbiAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSAvLyBHZXR0ZXJzXG5cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkNjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDY7XG4gIH1cblxuICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgIHJldHVybiBEQVRBX0tFWSQ3O1xuICB9IC8vIFB1YmxpY1xuXG5cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LmRpc2FibGVkIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRElTQUJMRUQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaXNBY3RpdmUgPSB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNik7XG5cbiAgICBEcm9wZG93bi5jbGVhck1lbnVzKCk7XG5cbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNob3coKTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9ESVNBQkxFRCkgfHwgdGhpcy5fbWVudS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDYpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gRHJvcGRvd24uZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNCwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRvdGFsbHkgZGlzYWJsZSBQb3BwZXIgZm9yIERyb3Bkb3ducyBpbiBOYXZiYXJcblxuXG4gICAgaWYgKHRoaXMuX2luTmF2YmFyKSB7XG4gICAgICBNYW5pcHVsYXRvci5zZXREYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInLCAnbm9uZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHBhcmVudDtcbiAgICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlOyAvLyBDaGVjayBpZiBpdCdzIGpRdWVyeSBlbGVtZW50XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlLmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZVswXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvcHBlckNvbmZpZyA9IHRoaXMuX2dldFBvcHBlckNvbmZpZygpO1xuXG4gICAgICBjb25zdCBpc0Rpc3BsYXlTdGF0aWMgPSBwb3BwZXJDb25maWcubW9kaWZpZXJzLmZpbmQobW9kaWZpZXIgPT4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGVzJyAmJiBtb2RpZmllci5lbmFibGVkID09PSBmYWxzZSk7XG4gICAgICB0aGlzLl9wb3BwZXIgPSBQb3BwZXIuY3JlYXRlUG9wcGVyKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHBvcHBlckNvbmZpZyk7XG5cbiAgICAgIGlmIChpc0Rpc3BsYXlTdGF0aWMpIHtcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ3N0YXRpYycpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcblxuXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhcGFyZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSX05BVikpIHtcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKGVsZW0gPT4gRXZlbnRIYW5kbGVyLm9uKGVsZW0sICdtb3VzZW92ZXInLCBudWxsLCBub29wKCkpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XG5cbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgdGhpcy5fbWVudS5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfU0hPVyQ2KTtcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX1NIT1ckNik7XG5cbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ0LCByZWxhdGVkVGFyZ2V0KTtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9ESVNBQkxFRCkgfHwgIXRoaXMuX21lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ2KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfTtcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDQsIHJlbGF0ZWRUYXJnZXQpO1xuXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfU0hPVyQ2KTtcblxuICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgJ3BvcHBlcicpO1xuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ0LCByZWxhdGVkVGFyZ2V0KTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVkkNyk7XG4gICAgdGhpcy5fbWVudSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuXG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xuXG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSAvLyBQcml2YXRlXG5cblxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLLCBldmVudCA9PiB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0geyAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkNywgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcblxuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudChjb25maWcucmVmZXJlbmNlKSAmJiB0eXBlb2YgY29uZmlnLnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFBvcHBlciB2aXJ0dWFsIGVsZW1lbnRzIHJlcXVpcmUgYSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgbWV0aG9kXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke05BTUUkNy50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgX2dldE1lbnVFbGVtZW50KCkge1xuICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdO1xuICB9XG5cbiAgX2dldFBsYWNlbWVudCgpIHtcbiAgICBjb25zdCBwYXJlbnREcm9wZG93biA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xuICAgICAgcmV0dXJuIFBMQUNFTUVOVF9SSUdIVDtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFNUQVJUKSkge1xuICAgICAgcmV0dXJuIFBMQUNFTUVOVF9MRUZUO1xuICAgIH0gLy8gV2UgbmVlZCB0byB0cmltIHRoZSB2YWx1ZSBiZWNhdXNlIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBhbHNvIGluY2x1ZGUgc3BhY2VzXG5cblxuICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJztcblxuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QVVApKSB7XG4gICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfVE9QRU5EIDogUExBQ0VNRU5UX1RPUDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfQk9UVE9NRU5EIDogUExBQ0VNRU5UX0JPVFRPTTtcbiAgfVxuXG4gIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChgLiR7Q0xBU1NfTkFNRV9OQVZCQVJ9YCkgIT09IG51bGw7XG4gIH1cblxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFxuICAgIH0gPSB0aGlzLl9jb25maWc7XG5cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsID0+IE51bWJlci5wYXJzZUludCh2YWwsIDEwKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICBjb25zdCBkZWZhdWx0QnNQb3BwZXJDb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgbW9kaWZpZXJzOiBbe1xuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9OyAvLyBEaXNhYmxlIFBvcHBlciBpZiB3ZSBoYXZlIGEgc3RhdGljIGRpc3BsYXlcblxuICAgIGlmICh0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIGRlZmF1bHRCc1BvcHBlckNvbmZpZy5tb2RpZmllcnMgPSBbe1xuICAgICAgICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgLi4uZGVmYXVsdEJzUG9wcGVyQ29uZmlnLFxuICAgICAgLi4uKHR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09PSAnZnVuY3Rpb24nID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyhkZWZhdWx0QnNQb3BwZXJDb25maWcpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZylcbiAgICB9O1xuICB9IC8vIFN0YXRpY1xuXG5cbiAgc3RhdGljIGRyb3Bkb3duSW50ZXJmYWNlKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIGxldCBkYXRhID0gRGF0YS5nZXQoZWxlbWVudCwgREFUQV9LRVkkNyk7XG5cbiAgICBjb25zdCBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsO1xuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBkYXRhID0gbmV3IERyb3Bkb3duKGVsZW1lbnQsIF9jb25maWcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBEcm9wZG93bi5kcm9wZG93bkludGVyZmFjZSh0aGlzLCBjb25maWcpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGNsZWFyTWVudXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5idXR0b24gPT09IFJJR0hUX01PVVNFX0JVVFRPTiB8fCBldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LmtleSAhPT0gVEFCX0tFWSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGZvcm0vaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdG9nZ2xlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEUkMyk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdG9nZ2xlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgY29udGV4dCA9IERhdGEuZ2V0KHRvZ2dsZXNbaV0sIERBVEFfS0VZJDcpO1xuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdG9nZ2xlc1tpXVxuICAgICAgfTtcblxuICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldC5jbGlja0V2ZW50ID0gZXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZHJvcGRvd25NZW51ID0gY29udGV4dC5fbWVudTtcblxuICAgICAgaWYgKCF0b2dnbGVzW2ldLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICAvLyBEb24ndCBjbG9zZSB0aGUgbWVudSBpZiB0aGUgY2xpY2tlZCBlbGVtZW50IG9yIG9uZSBvZiBpdHMgcGFyZW50cyBpcyB0aGUgZHJvcGRvd24gYnV0dG9uXG4gICAgICAgIGlmIChbY29udGV4dC5fZWxlbWVudF0uc29tZShlbGVtZW50ID0+IGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKGVsZW1lbnQpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIFRhYiBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIGRyb3Bkb3duIG1lbnUgc2hvdWxkbid0IGNsb3NlIHRoZSBtZW51XG5cblxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgPT09IFRBQl9LRVkgJiYgZHJvcGRvd25NZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0b2dnbGVzW2ldLCBFVkVOVF9ISURFJDQsIHJlbGF0ZWRUYXJnZXQpO1xuXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuXG5cbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2goZWxlbSA9PiBFdmVudEhhbmRsZXIub2ZmKGVsZW0sICdtb3VzZW92ZXInLCBudWxsLCBub29wKCkpKTtcbiAgICAgIH1cblxuICAgICAgdG9nZ2xlc1tpXS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuICAgICAgaWYgKGNvbnRleHQuX3BvcHBlcikge1xuICAgICAgICBjb250ZXh0Ll9wb3BwZXIuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICBkcm9wZG93bk1lbnUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNik7XG4gICAgICB0b2dnbGVzW2ldLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZShkcm9wZG93bk1lbnUsICdwb3BwZXInKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRvZ2dsZXNbaV0sIEVWRU5UX0hJRERFTiQ0LCByZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpIHx8IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcbiAgICAvLyBJZiBub3QgaW5wdXQvdGV4dGFyZWE6XG4gICAgLy8gIC0gQW5kIG5vdCBhIGtleSBpbiBSRUdFWFBfS0VZRE9XTiA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gSWYgaW5wdXQvdGV4dGFyZWE6XG4gICAgLy8gIC0gSWYgc3BhY2Uga2V5ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAvLyAgLSBJZiBrZXkgaXMgb3RoZXIgdGhhbiBlc2NhcGVcbiAgICAvLyAgICAtIElmIGtleSBpcyBub3QgdXAgb3IgZG93biA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gICAgLSBJZiB0cmlnZ2VyIGluc2lkZSB0aGUgbWVudSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpID8gZXZlbnQua2V5ID09PSBTUEFDRV9LRVkgfHwgZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZJDIgJiYgKGV2ZW50LmtleSAhPT0gQVJST1dfRE9XTl9LRVkgJiYgZXZlbnQua2V5ICE9PSBBUlJPV19VUF9LRVkgfHwgZXZlbnQudGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfTUVOVSkpIDogIVJFR0VYUF9LRVlET1dOLnRlc3QoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudCA9IERyb3Bkb3duLmdldFBhcmVudEZyb21FbGVtZW50KHRoaXMpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSQyKSB7XG4gICAgICBjb25zdCBidXR0b24gPSB0aGlzLm1hdGNoZXMoU0VMRUNUT1JfREFUQV9UT0dHTEUkMykgPyB0aGlzIDogU2VsZWN0b3JFbmdpbmUucHJldih0aGlzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKVswXTtcbiAgICAgIGJ1dHRvbi5mb2N1cygpO1xuICAgICAgRHJvcGRvd24uY2xlYXJNZW51cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXNBY3RpdmUgJiYgKGV2ZW50LmtleSA9PT0gQVJST1dfVVBfS0VZIHx8IGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTl9LRVkpKSB7XG4gICAgICBjb25zdCBidXR0b24gPSB0aGlzLm1hdGNoZXMoU0VMRUNUT1JfREFUQV9UT0dHTEUkMykgPyB0aGlzIDogU2VsZWN0b3JFbmdpbmUucHJldih0aGlzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKVswXTtcbiAgICAgIGJ1dHRvbi5jbGljaygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXNBY3RpdmUgfHwgZXZlbnQua2V5ID09PSBTUEFDRV9LRVkpIHtcbiAgICAgIERyb3Bkb3duLmNsZWFyTWVudXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVklTSUJMRV9JVEVNUywgcGFyZW50KS5maWx0ZXIoaXNWaXNpYmxlKTtcblxuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gaXRlbXMuaW5kZXhPZihldmVudC50YXJnZXQpOyAvLyBVcFxuXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfVVBfS0VZICYmIGluZGV4ID4gMCkge1xuICAgICAgaW5kZXgtLTtcbiAgICB9IC8vIERvd25cblxuXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTl9LRVkgJiYgaW5kZXggPCBpdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICBpbmRleCsrO1xuICAgIH0gLy8gaW5kZXggaXMgLTEgaWYgdGhlIGZpcnN0IGtleWRvd24gaXMgYW4gQXJyb3dVcFxuXG5cbiAgICBpbmRleCA9IGluZGV4ID09PSAtMSA/IDAgOiBpbmRleDtcbiAgICBpdGVtc1tpbmRleF0uZm9jdXMoKTtcbiAgfVxuXG59XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBEcm9wZG93bi5kYXRhQXBpS2V5ZG93bkhhbmRsZXIpO1xuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9NRU5VLCBEcm9wZG93bi5kYXRhQXBpS2V5ZG93bkhhbmRsZXIpO1xuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZVVBfREFUQV9BUEksIERyb3Bkb3duLmNsZWFyTWVudXMpO1xuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgRHJvcGRvd24uZHJvcGRvd25JbnRlcmZhY2UodGhpcyk7XG59KTtcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogYWRkIC5Ecm9wZG93biB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihOQU1FJDcsIERyb3Bkb3duKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjAtYmV0YTMpOiBtb2RhbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FJDYgPSAnbW9kYWwnO1xuY29uc3QgREFUQV9LRVkkNiA9ICdicy5tb2RhbCc7XG5jb25zdCBFVkVOVF9LRVkkNiA9IGAuJHtEQVRBX0tFWSQ2fWA7XG5jb25zdCBEQVRBX0FQSV9LRVkkMyA9ICcuZGF0YS1hcGknO1xuY29uc3QgRVNDQVBFX0tFWSQxID0gJ0VzY2FwZSc7XG5jb25zdCBEZWZhdWx0JDUgPSB7XG4gIGJhY2tkcm9wOiB0cnVlLFxuICBrZXlib2FyZDogdHJ1ZSxcbiAgZm9jdXM6IHRydWVcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ1ID0ge1xuICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICBmb2N1czogJ2Jvb2xlYW4nXG59O1xuY29uc3QgRVZFTlRfSElERSQzID0gYGhpZGUke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfSElEREVOJDMgPSBgaGlkZGVuJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfU0hPVyQzID0gYHNob3cke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9TSE9XTiQzID0gYHNob3duJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfRk9DVVNJTiQxID0gYGZvY3VzaW4ke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9SRVNJWkUgPSBgcmVzaXplJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyQyID0gYGNsaWNrLmRpc21pc3Mke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfTU9VU0VVUF9ESVNNSVNTID0gYG1vdXNldXAuZGlzbWlzcyR7RVZFTlRfS0VZJDZ9YDtcbmNvbnN0IEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTID0gYG1vdXNlZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiA9IGBjbGljayR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xuY29uc3QgQ0xBU1NfTkFNRV9TQ1JPTExCQVJfTUVBU1VSRVIgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnO1xuY29uc3QgQ0xBU1NfTkFNRV9CQUNLRFJPUCA9ICdtb2RhbC1iYWNrZHJvcCc7XG5jb25zdCBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3Blbic7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUkNCA9ICdmYWRlJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQ1ID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9TVEFUSUMgPSAnbW9kYWwtc3RhdGljJztcbmNvbnN0IFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJztcbmNvbnN0IFNFTEVDVE9SX01PREFMX0JPRFkgPSAnLm1vZGFsLWJvZHknO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiA9ICdbZGF0YS1icy10b2dnbGU9XCJtb2RhbFwiXSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX0RJU01JU1MkMiA9ICdbZGF0YS1icy1kaXNtaXNzPVwibW9kYWxcIl0nO1xuY29uc3QgU0VMRUNUT1JfRklYRURfQ09OVEVOVCQxID0gJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnO1xuY29uc3QgU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQkMSA9ICcuc3RpY2t5LXRvcCc7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgTW9kYWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCk7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fZGlhbG9nID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9ESUFMT0csIHRoaXMuX2VsZW1lbnQpO1xuICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggPSAwO1xuICB9IC8vIEdldHRlcnNcblxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQ1O1xuICB9XG5cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gREFUQV9LRVkkNjtcbiAgfSAvLyBQdWJsaWNcblxuXG4gIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgfVxuXG4gIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKCkpIHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQzLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5faXNTaG93biB8fCBzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuXG4gICAgdGhpcy5fY2hlY2tTY3JvbGxiYXIoKTtcblxuICAgIHRoaXMuX3NldFNjcm9sbGJhcigpO1xuXG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG5cbiAgICB0aGlzLl9zZXRFc2NhcGVFdmVudCgpO1xuXG4gICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKTtcblxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTJDIsIFNFTEVDVE9SX0RBVEFfRElTTUlTUyQyLCBldmVudCA9PiB0aGlzLmhpZGUoZXZlbnQpKTtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZGlhbG9nLCBFVkVOVF9NT1VTRURPV05fRElTTUlTUywgKCkgPT4ge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRVVQX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3Nob3dCYWNrZHJvcCgoKSA9PiB0aGlzLl9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSk7XG4gIH1cblxuICBoaWRlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDMpO1xuXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMuX2lzQW5pbWF0ZWQoKTtcblxuICAgIGlmIChpc0FuaW1hdGVkKSB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KCk7XG5cbiAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpO1xuXG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQxKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNSk7XG5cbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MkMik7XG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9kaWFsb2csIEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTKTtcblxuICAgIGlmIChpc0FuaW1hdGVkKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCBldmVudCA9PiB0aGlzLl9oaWRlTW9kYWwoZXZlbnQpKTtcbiAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQsIHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hpZGVNb2RhbCgpO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgW3dpbmRvdywgdGhpcy5fZWxlbWVudCwgdGhpcy5fZGlhbG9nXS5mb3JFYWNoKGh0bWxFbGVtZW50ID0+IEV2ZW50SGFuZGxlci5vZmYoaHRtbEVsZW1lbnQsIEVWRU5UX0tFWSQ2KSk7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIC8qKlxuICAgICAqIGBkb2N1bWVudGAgaGFzIDIgZXZlbnRzIGBFVkVOVF9GT0NVU0lOYCBhbmQgYEVWRU5UX0NMSUNLX0RBVEFfQVBJYFxuICAgICAqIERvIG5vdCBtb3ZlIGBkb2N1bWVudGAgaW4gYGh0bWxFbGVtZW50c2AgYXJyYXlcbiAgICAgKiBJdCB3aWxsIHJlbW92ZSBgRVZFTlRfQ0xJQ0tfREFUQV9BUElgIGV2ZW50IHRoYXQgc2hvdWxkIHJlbWFpblxuICAgICAqL1xuXG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQxKTtcbiAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgIHRoaXMuX2RpYWxvZyA9IG51bGw7XG4gICAgdGhpcy5fYmFja2Ryb3AgPSBudWxsO1xuICAgIHRoaXMuX2lzU2hvd24gPSBudWxsO1xuICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gbnVsbDtcbiAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gbnVsbDtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBudWxsO1xuICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gbnVsbDtcbiAgfVxuXG4gIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgfSAvLyBQcml2YXRlXG5cblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHsgLi4uRGVmYXVsdCQ1LFxuICAgICAgLi4uY29uZmlnXG4gICAgfTtcbiAgICB0eXBlQ2hlY2tDb25maWcoTkFNRSQ2LCBjb25maWcsIERlZmF1bHRUeXBlJDUpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLl9pc0FuaW1hdGVkKCk7XG5cbiAgICBjb25zdCBtb2RhbEJvZHkgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX01PREFMX0JPRFksIHRoaXMuX2RpYWxvZyk7XG5cbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSB8fCB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAvLyBEb24ndCBtb3ZlIG1vZGFsJ3MgRE9NIHBvc2l0aW9uXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XG5cbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcblxuICAgIGlmIChtb2RhbEJvZHkpIHtcbiAgICAgIG1vZGFsQm9keS5zY3JvbGxUb3AgPSAwO1xuICAgIH1cblxuICAgIGlmIChpc0FuaW1hdGVkKSB7XG4gICAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ1KTtcblxuICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDMsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChpc0FuaW1hdGVkKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9kaWFsb2cpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9kaWFsb2csICd0cmFuc2l0aW9uZW5kJywgdHJhbnNpdGlvbkNvbXBsZXRlKTtcbiAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRoaXMuX2RpYWxvZywgdHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdGlvbkNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2VuZm9yY2VGb2N1cygpIHtcbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDEpOyAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcblxuICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQxLCBldmVudCA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJiB0aGlzLl9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgJiYgIXRoaXMuX2VsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfc2V0RXNjYXBlRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMSkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTKTtcbiAgICB9XG4gIH1cblxuICBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSwgKCkgPT4gdGhpcy5fYWRqdXN0RGlhbG9nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHdpbmRvdywgRVZFTlRfUkVTSVpFKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZU1vZGFsKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcblxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG5cbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX3Nob3dCYWNrZHJvcCgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9PUEVOKTtcblxuICAgICAgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpO1xuXG4gICAgICB0aGlzLl9yZXNldFNjcm9sbGJhcigpO1xuXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kMyk7XG4gICAgfSk7XG4gIH1cblxuICBfcmVtb3ZlQmFja2Ryb3AoKSB7XG4gICAgdGhpcy5fYmFja2Ryb3AucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9iYWNrZHJvcCk7XG5cbiAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGw7XG4gIH1cblxuICBfc2hvd0JhY2tkcm9wKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMuX2lzQW5pbWF0ZWQoKTtcblxuICAgIGlmICh0aGlzLl9pc1Nob3duICYmIHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgdGhpcy5fYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTmFtZSA9IENMQVNTX05BTUVfQkFDS0RST1A7XG5cbiAgICAgIGlmIChpc0FuaW1hdGVkKSB7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDQpO1xuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2JhY2tkcm9wKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTJDIsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzQW5pbWF0ZWQpIHtcbiAgICAgICAgcmVmbG93KHRoaXMuX2JhY2tkcm9wKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNSk7XG5cbiAgICAgIGlmICghaXNBbmltYXRlZCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fYmFja2Ryb3ApO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9iYWNrZHJvcCwgJ3RyYW5zaXRpb25lbmQnLCBjYWxsYmFjayk7XG4gICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0aGlzLl9iYWNrZHJvcCwgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24gJiYgdGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDUpO1xuXG4gICAgICBjb25zdCBjYWxsYmFja1JlbW92ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQmFja2Ryb3AoKTtcblxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfTtcblxuICAgICAgaWYgKGlzQW5pbWF0ZWQpIHtcbiAgICAgICAgY29uc3QgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9iYWNrZHJvcCk7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fYmFja2Ryb3AsICd0cmFuc2l0aW9uZW5kJywgY2FsbGJhY2tSZW1vdmUpO1xuICAgICAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0aGlzLl9iYWNrZHJvcCwgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBfaXNBbmltYXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDQpO1xuICB9XG5cbiAgX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSB7XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQpO1xuXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgaWYgKCFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU1RBVElDKTtcblxuICAgIGNvbnN0IG1vZGFsVHJhbnNpdGlvbkR1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZGlhbG9nKTtcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsICd0cmFuc2l0aW9uZW5kJyk7XG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NUQVRJQyk7XG5cbiAgICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgJ3RyYW5zaXRpb25lbmQnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnJztcbiAgICAgICAgfSk7XG4gICAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQsIG1vZGFsVHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbXVsYXRlVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50LCBtb2RhbFRyYW5zaXRpb25EdXJhdGlvbik7XG5cbiAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XG4gIH0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICBfYWRqdXN0RGlhbG9nKCkge1xuICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcblxuICAgIGlmICghdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nICYmICFpc1JUTCgpIHx8IHRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcgJiYgaXNSVEwoKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IGAke3RoaXMuX3Njcm9sbGJhcldpZHRofXB4YDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgIWlzTW9kYWxPdmVyZmxvd2luZyAmJiAhaXNSVEwoKSB8fCAhdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nICYmIGlzUlRMKCkpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7dGhpcy5fc2Nyb2xsYmFyV2lkdGh9cHhgO1xuICAgIH1cbiAgfVxuXG4gIF9yZXNldEFkanVzdG1lbnRzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSAnJztcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICB9XG5cbiAgX2NoZWNrU2Nyb2xsYmFyKCkge1xuICAgIGNvbnN0IHJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gTWF0aC5yb3VuZChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSA8IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gdGhpcy5fZ2V0U2Nyb2xsYmFyV2lkdGgoKTtcbiAgfVxuXG4gIF9zZXRTY3JvbGxiYXIoKSB7XG4gICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nKSB7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5UJDEsICdwYWRkaW5nUmlnaHQnLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgdGhpcy5fc2Nyb2xsYmFyV2lkdGgpO1xuXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCQxLCAnbWFyZ2luUmlnaHQnLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlIC0gdGhpcy5fc2Nyb2xsYmFyV2lkdGgpO1xuXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcygnYm9keScsICdwYWRkaW5nUmlnaHQnLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgdGhpcy5fc2Nyb2xsYmFyV2lkdGgpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX09QRU4pO1xuICB9XG5cbiAgX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3AsIGNhbGxiYWNrKSB7XG4gICAgU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvcikuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGlmIChlbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmIHdpbmRvdy5pbm5lcldpZHRoID4gZWxlbWVudC5jbGllbnRXaWR0aCArIHRoaXMuX3Njcm9sbGJhcldpZHRoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSBlbGVtZW50LnN0eWxlW3N0eWxlUHJvcF07XG4gICAgICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtzdHlsZVByb3BdO1xuICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3AsIGFjdHVhbFZhbHVlKTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVQcm9wXSA9IGNhbGxiYWNrKE51bWJlci5wYXJzZUZsb2F0KGNhbGN1bGF0ZWRWYWx1ZSkpICsgJ3B4JztcbiAgICB9KTtcbiAgfVxuXG4gIF9yZXNldFNjcm9sbGJhcigpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQkMSwgJ3BhZGRpbmdSaWdodCcpO1xuXG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCQxLCAnbWFyZ2luUmlnaHQnKTtcblxuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoJ2JvZHknLCAncGFkZGluZ1JpZ2h0Jyk7XG4gIH1cblxuICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyhzZWxlY3Rvciwgc3R5bGVQcm9wKSB7XG4gICAgU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvcikuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3ApO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiBlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVQcm9wXSA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3ApO1xuICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlUHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRTY3JvbGxiYXJXaWR0aCgpIHtcbiAgICAvLyB0aHggZC53YWxzaFxuICAgIGNvbnN0IHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSBDTEFTU19OQU1FX1NDUk9MTEJBUl9NRUFTVVJFUjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdik7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aDtcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9IERhdGEuZ2V0KHRoaXMsIERBVEFfS0VZJDYpO1xuICAgICAgY29uc3QgX2NvbmZpZyA9IHsgLi4uRGVmYXVsdCQ1LFxuICAgICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzKSxcbiAgICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgICAgfTtcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgTW9kYWwodGhpcywgX2NvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIsIGZ1bmN0aW9uIChldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xuXG4gIGlmICh0aGlzLnRhZ05hbWUgPT09ICdBJyB8fCB0aGlzLnRhZ05hbWUgPT09ICdBUkVBJykge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfU0hPVyQzLCBzaG93RXZlbnQgPT4ge1xuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kMywgKCkgPT4ge1xuICAgICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBsZXQgZGF0YSA9IERhdGEuZ2V0KHRhcmdldCwgREFUQV9LRVkkNik7XG5cbiAgaWYgKCFkYXRhKSB7XG4gICAgY29uc3QgY29uZmlnID0geyAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0YXJnZXQpLFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcylcbiAgICB9O1xuICAgIGRhdGEgPSBuZXcgTW9kYWwodGFyZ2V0LCBjb25maWcpO1xuICB9XG5cbiAgZGF0YS50b2dnbGUodGhpcyk7XG59KTtcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogYWRkIC5Nb2RhbCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihOQU1FJDYsIE1vZGFsKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjAtYmV0YTMpOiB1dGlsL3Njcm9sbEJhci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5jb25zdCBTRUxFQ1RPUl9GSVhFRF9DT05URU5UID0gJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCc7XG5jb25zdCBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCA9ICcuc3RpY2t5LXRvcCc7XG5cbmNvbnN0IGdldFdpZHRoID0gKCkgPT4ge1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2lubmVyV2lkdGgjdXNhZ2Vfbm90ZXNcbiAgY29uc3QgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnRXaWR0aCk7XG59O1xuXG5jb25zdCBoaWRlID0gKHdpZHRoID0gZ2V0V2lkdGgoKSkgPT4ge1xuICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsICdwYWRkaW5nUmlnaHQnLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpO1xuXG4gIF9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgJ21hcmdpblJpZ2h0JywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSAtIHdpZHRoKTtcblxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoJ2JvZHknLCAncGFkZGluZ1JpZ2h0JywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTtcbn07XG5cbmNvbnN0IF9zZXRFbGVtZW50QXR0cmlidXRlcyA9IChzZWxlY3Rvciwgc3R5bGVQcm9wLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IGdldFdpZHRoKCk7XG4gIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgaWYgKGVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgd2luZG93LmlubmVyV2lkdGggPiBlbGVtZW50LmNsaWVudFdpZHRoICsgc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3R1YWxWYWx1ZSA9IGVsZW1lbnQuc3R5bGVbc3R5bGVQcm9wXTtcbiAgICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtzdHlsZVByb3BdO1xuICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wLCBhY3R1YWxWYWx1ZSk7XG4gICAgZWxlbWVudC5zdHlsZVtzdHlsZVByb3BdID0gY2FsbGJhY2soTnVtYmVyLnBhcnNlRmxvYXQoY2FsY3VsYXRlZFZhbHVlKSkgKyAncHgnO1xuICB9KTtcbn07XG5cbmNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuXG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsICdwYWRkaW5nUmlnaHQnKTtcblxuICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgJ21hcmdpblJpZ2h0Jyk7XG5cbiAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoJ2JvZHknLCAncGFkZGluZ1JpZ2h0Jyk7XG59O1xuXG5jb25zdCBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyA9IChzZWxlY3Rvciwgc3R5bGVQcm9wKSA9PiB7XG4gIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcCk7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiBlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHN0eWxlUHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wKTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbc3R5bGVQcm9wXSA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjAuMC1iZXRhMyk6IG9mZmNhbnZhcy5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUkNSA9ICdvZmZjYW52YXMnO1xuY29uc3QgREFUQV9LRVkkNSA9ICdicy5vZmZjYW52YXMnO1xuY29uc3QgRVZFTlRfS0VZJDUgPSBgLiR7REFUQV9LRVkkNX1gO1xuY29uc3QgREFUQV9BUElfS0VZJDIgPSAnLmRhdGEtYXBpJztcbmNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMSA9IGBsb2FkJHtFVkVOVF9LRVkkNX0ke0RBVEFfQVBJX0tFWSQyfWA7XG5jb25zdCBFU0NBUEVfS0VZID0gJ0VzY2FwZSc7XG5jb25zdCBEZWZhdWx0JDQgPSB7XG4gIGJhY2tkcm9wOiB0cnVlLFxuICBrZXlib2FyZDogdHJ1ZSxcbiAgc2Nyb2xsOiBmYWxzZVxufTtcbmNvbnN0IERlZmF1bHRUeXBlJDQgPSB7XG4gIGJhY2tkcm9wOiAnYm9vbGVhbicsXG4gIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gIHNjcm9sbDogJ2Jvb2xlYW4nXG59O1xuY29uc3QgQ0xBU1NfTkFNRV9CQUNLRFJPUF9CT0RZID0gJ29mZmNhbnZhcy1iYWNrZHJvcCc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1ckNCA9ICdzaG93JztcbmNvbnN0IENMQVNTX05BTUVfVE9HR0xJTkcgPSAnb2ZmY2FudmFzLXRvZ2dsaW5nJztcbmNvbnN0IE9QRU5fU0VMRUNUT1IgPSAnLm9mZmNhbnZhcy5zaG93JztcbmNvbnN0IEFDVElWRV9TRUxFQ1RPUiA9IGAke09QRU5fU0VMRUNUT1J9LCAuJHtDTEFTU19OQU1FX1RPR0dMSU5HfWA7XG5jb25zdCBFVkVOVF9TSE9XJDIgPSBgc2hvdyR7RVZFTlRfS0VZJDV9YDtcbmNvbnN0IEVWRU5UX1NIT1dOJDIgPSBgc2hvd24ke0VWRU5UX0tFWSQ1fWA7XG5jb25zdCBFVkVOVF9ISURFJDIgPSBgaGlkZSR7RVZFTlRfS0VZJDV9YDtcbmNvbnN0IEVWRU5UX0hJRERFTiQyID0gYGhpZGRlbiR7RVZFTlRfS0VZJDV9YDtcbmNvbnN0IEVWRU5UX0ZPQ1VTSU4gPSBgZm9jdXNpbiR7RVZFTlRfS0VZJDV9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEgPSBgY2xpY2ske0VWRU5UX0tFWSQ1fSR7REFUQV9BUElfS0VZJDJ9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RJU01JU1MkMSA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVkkNX1gO1xuY29uc3QgU0VMRUNUT1JfREFUQV9ESVNNSVNTJDEgPSAnW2RhdGEtYnMtZGlzbWlzcz1cIm9mZmNhbnZhc1wiXSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxID0gJ1tkYXRhLWJzLXRvZ2dsZT1cIm9mZmNhbnZhc1wiXSc7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgT2ZmY2FudmFzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQpO1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcblxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH0gLy8gR2V0dGVyc1xuXG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgIHJldHVybiBEQVRBX0tFWSQ1O1xuICB9IC8vIFB1YmxpY1xuXG5cbiAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpO1xuICB9XG5cbiAgc2hvdyhyZWxhdGVkVGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDIsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICB9KTtcblxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcblxuICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0JBQ0tEUk9QX0JPRFkpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xuICAgICAgaGlkZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1RPR0dMSU5HKTtcblxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ0KTtcblxuICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9UT0dHTElORyk7XG5cbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDIsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2VuZm9yY2VGb2N1c09uRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICB9O1xuXG4gICAgc2V0VGltZW91dChjb21wbGV0ZUNhbGxCYWNrLCBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KSk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkMik7XG5cbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9UT0dHTElORyk7XG5cbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuYmx1cigpO1xuXG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ0KTtcblxuICAgIGNvbnN0IGNvbXBsZXRlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQkFDS0RST1BfQk9EWSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xuICAgICAgICByZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kMik7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1RPR0dMSU5HKTtcbiAgICB9O1xuXG4gICAgc2V0VGltZW91dChjb21wbGV0ZUNhbGxiYWNrLCBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KSk7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkNCxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXG4gICAgfTtcbiAgICB0eXBlQ2hlY2tDb25maWcoTkFNRSQ1LCBjb25maWcsIERlZmF1bHRUeXBlJDQpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBfZW5mb3JjZUZvY3VzT25FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOKTsgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG5cbiAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4sIGV2ZW50ID0+IHtcbiAgICAgIGlmIChkb2N1bWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmIGVsZW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJiAhZWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbGVtZW50LmZvY3VzKCk7XG4gIH1cblxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MkMSwgU0VMRUNUT1JfREFUQV9ESVNNSVNTJDEsICgpID0+IHRoaXMuaGlkZSgpKTtcbiAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsICdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQxLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZXZlbnQudGFyZ2V0KSk7XG5cbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpICYmIHRhcmdldCAhPT0gdGhpcy5fZWxlbWVudCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gRGF0YS5nZXQodGhpcywgREFUQV9LRVkkNSkgfHwgbmV3IE9mZmNhbnZhcyh0aGlzLCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KTtcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcbiAgICB9KTtcbiAgfVxuXG59XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQxLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcblxuICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQyLCAoKSA9PiB7XG4gICAgLy8gZm9jdXMgb24gdHJpZ2dlciB3aGVuIGl0IGlzIGNsb3NlZFxuICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcbiAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICB9XG4gIH0pOyAvLyBhdm9pZCBjb25mbGljdCB3aGVuIGNsaWNraW5nIGEgdG9nZ2xlciBvZiBhbiBvZmZjYW52YXMsIHdoaWxlIGFub3RoZXIgaXMgb3BlblxuXG4gIGNvbnN0IGFsbFJlYWR5T3BlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoQUNUSVZFX1NFTEVDVE9SKTtcblxuICBpZiAoYWxsUmVhZHlPcGVuICYmIGFsbFJlYWR5T3BlbiAhPT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IERhdGEuZ2V0KHRhcmdldCwgREFUQV9LRVkkNSkgfHwgbmV3IE9mZmNhbnZhcyh0YXJnZXQpO1xuICBkYXRhLnRvZ2dsZSh0aGlzKTtcbn0pO1xuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQxLCAoKSA9PiB7XG4gIFNlbGVjdG9yRW5naW5lLmZpbmQoT1BFTl9TRUxFQ1RPUikuZm9yRWFjaChlbCA9PiAoRGF0YS5nZXQoZWwsIERBVEFfS0VZJDUpIHx8IG5ldyBPZmZjYW52YXMoZWwpKS5zaG93KCkpO1xufSk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oTkFNRSQ1LCBPZmZjYW52YXMpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjAuMC1iZXRhMyk6IHV0aWwvc2FuaXRpemVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmNvbnN0IHVyaUF0dHJzID0gbmV3IFNldChbJ2JhY2tncm91bmQnLCAnY2l0ZScsICdocmVmJywgJ2l0ZW10eXBlJywgJ2xvbmdkZXNjJywgJ3Bvc3RlcicsICdzcmMnLCAneGxpbms6aHJlZiddKTtcbmNvbnN0IEFSSUFfQVRUUklCVVRFX1BBVFRFUk4gPSAvXmFyaWEtW1xcdy1dKiQvaTtcbi8qKlxuICogQSBwYXR0ZXJuIHRoYXQgcmVjb2duaXplcyBhIGNvbW1vbmx5IHVzZWZ1bCBzdWJzZXQgb2YgVVJMcyB0aGF0IGFyZSBzYWZlLlxuICpcbiAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcbiAqL1xuXG5jb25zdCBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteIyYvOj9dKig/OlsjLz9dfCQpKS9pO1xuLyoqXG4gKiBBIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHNhZmUgZGF0YSBVUkxzLiBPbmx5IG1hdGNoZXMgaW1hZ2UsIHZpZGVvIGFuZCBhdWRpbyB0eXBlcy5cbiAqXG4gKiBTaG91dG91dCB0byBBbmd1bGFyIDcgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzcuMi40L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXG4gKi9cblxuY29uc3QgREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTooPzppbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFtcXGQrL2Etel0rPSokL2k7XG5cbmNvbnN0IGFsbG93ZWRBdHRyaWJ1dGUgPSAoYXR0ciwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpID0+IHtcbiAgY29uc3QgYXR0ck5hbWUgPSBhdHRyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluY2x1ZGVzKGF0dHJOYW1lKSkge1xuICAgIGlmICh1cmlBdHRycy5oYXMoYXR0ck5hbWUpKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihTQUZFX1VSTF9QQVRURVJOLnRlc3QoYXR0ci5ub2RlVmFsdWUpIHx8IERBVEFfVVJMX1BBVFRFUk4udGVzdChhdHRyLm5vZGVWYWx1ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgcmVnRXhwID0gYWxsb3dlZEF0dHJpYnV0ZUxpc3QuZmlsdGVyKGF0dHJSZWdleCA9PiBhdHRyUmVnZXggaW5zdGFuY2VvZiBSZWdFeHApOyAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmVnRXhwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHJlZ0V4cFtpXS50ZXN0KGF0dHJOYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgRGVmYXVsdEFsbG93bGlzdCA9IHtcbiAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cbiAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcbiAgYTogWyd0YXJnZXQnLCAnaHJlZicsICd0aXRsZScsICdyZWwnXSxcbiAgYXJlYTogW10sXG4gIGI6IFtdLFxuICBicjogW10sXG4gIGNvbDogW10sXG4gIGNvZGU6IFtdLFxuICBkaXY6IFtdLFxuICBlbTogW10sXG4gIGhyOiBbXSxcbiAgaDE6IFtdLFxuICBoMjogW10sXG4gIGgzOiBbXSxcbiAgaDQ6IFtdLFxuICBoNTogW10sXG4gIGg2OiBbXSxcbiAgaTogW10sXG4gIGltZzogWydzcmMnLCAnc3Jjc2V0JywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcbiAgbGk6IFtdLFxuICBvbDogW10sXG4gIHA6IFtdLFxuICBwcmU6IFtdLFxuICBzOiBbXSxcbiAgc21hbGw6IFtdLFxuICBzcGFuOiBbXSxcbiAgc3ViOiBbXSxcbiAgc3VwOiBbXSxcbiAgc3Ryb25nOiBbXSxcbiAgdTogW10sXG4gIHVsOiBbXVxufTtcbmZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sLCBhbGxvd0xpc3QsIHNhbml0aXplRm4pIHtcbiAgaWYgKCF1bnNhZmVIdG1sLmxlbmd0aCkge1xuICAgIHJldHVybiB1bnNhZmVIdG1sO1xuICB9XG5cbiAgaWYgKHNhbml0aXplRm4gJiYgdHlwZW9mIHNhbml0aXplRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2FuaXRpemVGbih1bnNhZmVIdG1sKTtcbiAgfVxuXG4gIGNvbnN0IGRvbVBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XG4gIGNvbnN0IGNyZWF0ZWREb2N1bWVudCA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcodW5zYWZlSHRtbCwgJ3RleHQvaHRtbCcpO1xuICBjb25zdCBhbGxvd2xpc3RLZXlzID0gT2JqZWN0LmtleXMoYWxsb3dMaXN0KTtcbiAgY29uc3QgZWxlbWVudHMgPSBbXS5jb25jYXQoLi4uY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBlbCA9IGVsZW1lbnRzW2ldO1xuICAgIGNvbnN0IGVsTmFtZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIWFsbG93bGlzdEtleXMuaW5jbHVkZXMoZWxOYW1lKSkge1xuICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uY29uY2F0KC4uLmVsLmF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGFsbG93ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KGFsbG93TGlzdFsnKiddIHx8IFtdLCBhbGxvd0xpc3RbZWxOYW1lXSB8fCBbXSk7XG4gICAgYXR0cmlidXRlTGlzdC5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHIsIGFsbG93ZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlZERvY3VtZW50LmJvZHkuaW5uZXJIVE1MO1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjAuMC1iZXRhMyk6IHRvb2x0aXAuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSQ0ID0gJ3Rvb2x0aXAnO1xuY29uc3QgREFUQV9LRVkkNCA9ICdicy50b29sdGlwJztcbmNvbnN0IEVWRU5UX0tFWSQ0ID0gYC4ke0RBVEFfS0VZJDR9YDtcbmNvbnN0IENMQVNTX1BSRUZJWCQxID0gJ2JzLXRvb2x0aXAnO1xuY29uc3QgQlNDTFNfUFJFRklYX1JFR0VYJDEgPSBuZXcgUmVnRXhwKGAoXnxcXFxccykke0NMQVNTX1BSRUZJWCQxfVxcXFxTK2AsICdnJyk7XG5jb25zdCBESVNBTExPV0VEX0FUVFJJQlVURVMgPSBuZXcgU2V0KFsnc2FuaXRpemUnLCAnYWxsb3dMaXN0JywgJ3Nhbml0aXplRm4nXSk7XG5jb25zdCBEZWZhdWx0VHlwZSQzID0ge1xuICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgdGVtcGxhdGU6ICdzdHJpbmcnLFxuICB0aXRsZTogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknLFxuICB0cmlnZ2VyOiAnc3RyaW5nJyxcbiAgZGVsYXk6ICcobnVtYmVyfG9iamVjdCknLFxuICBodG1sOiAnYm9vbGVhbicsXG4gIHNlbGVjdG9yOiAnKHN0cmluZ3xib29sZWFuKScsXG4gIHBsYWNlbWVudDogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgb2Zmc2V0OiAnKGFycmF5fHN0cmluZ3xmdW5jdGlvbiknLFxuICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxuICBmYWxsYmFja1BsYWNlbWVudHM6ICdhcnJheScsXG4gIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXG4gIGN1c3RvbUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBzYW5pdGl6ZTogJ2Jvb2xlYW4nLFxuICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcbiAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcbiAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKSdcbn07XG5jb25zdCBBdHRhY2htZW50TWFwID0ge1xuICBBVVRPOiAnYXV0bycsXG4gIFRPUDogJ3RvcCcsXG4gIFJJR0hUOiBpc1JUTCgpID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgQk9UVE9NOiAnYm90dG9tJyxcbiAgTEVGVDogaXNSVEwoKSA/ICdyaWdodCcgOiAnbGVmdCdcbn07XG5jb25zdCBEZWZhdWx0JDMgPSB7XG4gIGFuaW1hdGlvbjogdHJ1ZSxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj4nICsgJzwvZGl2PicsXG4gIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gIHRpdGxlOiAnJyxcbiAgZGVsYXk6IDAsXG4gIGh0bWw6IGZhbHNlLFxuICBzZWxlY3RvcjogZmFsc2UsXG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIG9mZnNldDogWzAsIDBdLFxuICBjb250YWluZXI6IGZhbHNlLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10sXG4gIGJvdW5kYXJ5OiAnY2xpcHBpbmdQYXJlbnRzJyxcbiAgY3VzdG9tQ2xhc3M6ICcnLFxuICBzYW5pdGl6ZTogdHJ1ZSxcbiAgc2FuaXRpemVGbjogbnVsbCxcbiAgYWxsb3dMaXN0OiBEZWZhdWx0QWxsb3dsaXN0LFxuICBwb3BwZXJDb25maWc6IG51bGxcbn07XG5jb25zdCBFdmVudCQyID0ge1xuICBISURFOiBgaGlkZSR7RVZFTlRfS0VZJDR9YCxcbiAgSElEREVOOiBgaGlkZGVuJHtFVkVOVF9LRVkkNH1gLFxuICBTSE9XOiBgc2hvdyR7RVZFTlRfS0VZJDR9YCxcbiAgU0hPV046IGBzaG93biR7RVZFTlRfS0VZJDR9YCxcbiAgSU5TRVJURUQ6IGBpbnNlcnRlZCR7RVZFTlRfS0VZJDR9YCxcbiAgQ0xJQ0s6IGBjbGljayR7RVZFTlRfS0VZJDR9YCxcbiAgRk9DVVNJTjogYGZvY3VzaW4ke0VWRU5UX0tFWSQ0fWAsXG4gIEZPQ1VTT1VUOiBgZm9jdXNvdXQke0VWRU5UX0tFWSQ0fWAsXG4gIE1PVVNFRU5URVI6IGBtb3VzZWVudGVyJHtFVkVOVF9LRVkkNH1gLFxuICBNT1VTRUxFQVZFOiBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZJDR9YFxufTtcbmNvbnN0IENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9NT0RBTCA9ICdtb2RhbCc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1ckMyA9ICdzaG93JztcbmNvbnN0IEhPVkVSX1NUQVRFX1NIT1cgPSAnc2hvdyc7XG5jb25zdCBIT1ZFUl9TVEFURV9PVVQgPSAnb3V0JztcbmNvbnN0IFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIgPSAnLnRvb2x0aXAtaW5uZXInO1xuY29uc3QgVFJJR0dFUl9IT1ZFUiA9ICdob3Zlcic7XG5jb25zdCBUUklHR0VSX0ZPQ1VTID0gJ2ZvY3VzJztcbmNvbnN0IFRSSUdHRVJfQ0xJQ0sgPSAnY2xpY2snO1xuY29uc3QgVFJJR0dFUl9NQU5VQUwgPSAnbWFudWFsJztcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBUb29sdGlwIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xuICAgIH1cblxuICAgIHN1cGVyKGVsZW1lbnQpOyAvLyBwcml2YXRlXG5cbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xuICAgIHRoaXMuX2hvdmVyU3RhdGUgPSAnJztcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge307XG4gICAgdGhpcy5fcG9wcGVyID0gbnVsbDsgLy8gUHJvdGVjdGVkXG5cbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMudGlwID0gbnVsbDtcblxuICAgIHRoaXMuX3NldExpc3RlbmVycygpO1xuICB9IC8vIEdldHRlcnNcblxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQzO1xuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDQ7XG4gIH1cblxuICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgIHJldHVybiBEQVRBX0tFWSQ0O1xuICB9XG5cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gRXZlbnQkMjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xuICAgIHJldHVybiBFVkVOVF9LRVkkNDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDM7XG4gIH0gLy8gUHVibGljXG5cblxuICBlbmFibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICB0b2dnbGVFbmFibGVkKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWQ7XG4gIH1cblxuICB0b2dnbGUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XG5cbiAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXIuY2xpY2sgPSAhY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljaztcblxuICAgICAgaWYgKGNvbnRleHQuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgICBjb250ZXh0Ll9lbnRlcihudWxsLCBjb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuX2xlYXZlKG51bGwsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQzKSkge1xuICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VudGVyKG51bGwsIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpO1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudC5jbG9zZXN0KGAuJHtDTEFTU19OQU1FX01PREFMfWApLCAnaGlkZS5icy5tb2RhbCcsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xuXG4gICAgaWYgKHRoaXMudGlwICYmIHRoaXMudGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMudGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy50aXApO1xuICAgIH1cblxuICAgIHRoaXMuX2lzRW5hYmxlZCA9IG51bGw7XG4gICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgdGhpcy5faG92ZXJTdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgIHRoaXMudGlwID0gbnVsbDtcbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50cycpO1xuICAgIH1cblxuICAgIGlmICghKHRoaXMuaXNXaXRoQ29udGVudCgpICYmIHRoaXMuX2lzRW5hYmxlZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpO1xuICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBmaW5kU2hhZG93Um9vdCh0aGlzLl9lbGVtZW50KTtcbiAgICBjb25zdCBpc0luVGhlRG9tID0gc2hhZG93Um9vdCA9PT0gbnVsbCA/IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy5fZWxlbWVudCkgOiBzaGFkb3dSb290LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFpc0luVGhlRG9tKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KCk7XG4gICAgY29uc3QgdGlwSWQgPSBnZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtcbiAgICB0aXAuc2V0QXR0cmlidXRlKCdpZCcsIHRpcElkKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpO1xuXG4gICAgdGhpcy5zZXRDb250ZW50KCk7XG5cbiAgICBpZiAodGhpcy5jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkMyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMuY29uZmlnLnBsYWNlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIHRpcCwgdGhpcy5fZWxlbWVudCkgOiB0aGlzLmNvbmZpZy5wbGFjZW1lbnQ7XG5cbiAgICBjb25zdCBhdHRhY2htZW50ID0gdGhpcy5fZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpO1xuXG4gICAgdGhpcy5fYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpO1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG5cbiAgICBEYXRhLnNldCh0aXAsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpO1xuXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSkge1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRpcCk7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BvcHBlciA9IFBvcHBlci5jcmVhdGVQb3BwZXIodGhpcy5fZWxlbWVudCwgdGlwLCB0aGlzLl9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkpO1xuICAgIH1cblxuICAgIHRpcC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQzKTtcbiAgICBjb25zdCBjdXN0b21DbGFzcyA9IHR5cGVvZiB0aGlzLmNvbmZpZy5jdXN0b21DbGFzcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLmN1c3RvbUNsYXNzKCkgOiB0aGlzLmNvbmZpZy5jdXN0b21DbGFzcztcblxuICAgIGlmIChjdXN0b21DbGFzcykge1xuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoLi4uY3VzdG9tQ2xhc3Muc3BsaXQoJyAnKSk7XG4gICAgfSAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuXG5cbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwcmV2SG92ZXJTdGF0ZSA9IHRoaXMuX2hvdmVyU3RhdGU7XG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gbnVsbDtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPV04pO1xuXG4gICAgICBpZiAocHJldkhvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX09VVCkge1xuICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMykpIHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMudGlwKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy50aXAsICd0cmFuc2l0aW9uZW5kJywgY29tcGxldGUpO1xuICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQodGhpcy50aXAsIHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX3BvcHBlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2hvdmVyU3RhdGUgIT09IEhPVkVSX1NUQVRFX1NIT1cgJiYgdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGlwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2xlYW5UaXBDbGFzcygpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpO1xuXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTik7XG5cbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREUpO1xuXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDMpOyAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG5cbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaChlbGVtZW50ID0+IEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfQ0xJQ0tdID0gZmFsc2U7XG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0ZPQ1VTXSA9IGZhbHNlO1xuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9IT1ZFUl0gPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDMpKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aXApO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aXAsICd0cmFuc2l0aW9uZW5kJywgY29tcGxldGUpO1xuICAgICAgZW11bGF0ZVRyYW5zaXRpb25FbmQodGlwLCB0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2hvdmVyU3RhdGUgPSAnJztcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gICAgfVxuICB9IC8vIFByb3RlY3RlZFxuXG5cbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldFRpdGxlKCkpO1xuICB9XG5cbiAgZ2V0VGlwRWxlbWVudCgpIHtcbiAgICBpZiAodGhpcy50aXApIHtcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLmNvbmZpZy50ZW1wbGF0ZTtcbiAgICB0aGlzLnRpcCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIHRoaXMudGlwO1xuICB9XG5cbiAgc2V0Q29udGVudCgpIHtcbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiwgdGlwKSwgdGhpcy5nZXRUaXRsZSgpKTtcbiAgICB0aXAuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0ZBREUkMywgQ0xBU1NfTkFNRV9TSE9XJDMpO1xuICB9XG5cbiAgc2V0RWxlbWVudENvbnRlbnQoZWxlbWVudCwgY29udGVudCkge1xuICAgIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnb2JqZWN0JyAmJiBpc0VsZW1lbnQoY29udGVudCkpIHtcbiAgICAgIGlmIChjb250ZW50LmpxdWVyeSkge1xuICAgICAgICBjb250ZW50ID0gY29udGVudFswXTtcbiAgICAgIH0gLy8gY29udGVudCBpcyBhIERPTSBub2RlIG9yIGEgalF1ZXJ5XG5cblxuICAgICAgaWYgKHRoaXMuY29uZmlnLmh0bWwpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQucGFyZW50Tm9kZSAhPT0gZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnQudGV4dENvbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnNhbml0aXplKSB7XG4gICAgICAgIGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoY29udGVudCwgdGhpcy5jb25maWcuYWxsb3dMaXN0LCB0aGlzLmNvbmZpZy5zYW5pdGl6ZUZuKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gIH1cblxuICBnZXRUaXRsZSgpIHtcbiAgICBsZXQgdGl0bGUgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpO1xuXG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgdGl0bGUgPSB0eXBlb2YgdGhpcy5jb25maWcudGl0bGUgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNvbmZpZy50aXRsZS5jYWxsKHRoaXMuX2VsZW1lbnQpIDogdGhpcy5jb25maWcudGl0bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpdGxlO1xuICB9XG5cbiAgdXBkYXRlQXR0YWNobWVudChhdHRhY2htZW50KSB7XG4gICAgaWYgKGF0dGFjaG1lbnQgPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiAnZW5kJztcbiAgICB9XG5cbiAgICBpZiAoYXR0YWNobWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgICByZXR1cm4gJ3N0YXJ0JztcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0YWNobWVudDtcbiAgfSAvLyBQcml2YXRlXG5cblxuICBfaW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50LCBjb250ZXh0KSB7XG4gICAgY29uc3QgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7XG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgRGF0YS5nZXQoZXZlbnQuZGVsZWdhdGVUYXJnZXQsIGRhdGFLZXkpO1xuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuZGVsZWdhdGVUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpO1xuICAgICAgRGF0YS5zZXQoZXZlbnQuZGVsZWdhdGVUYXJnZXQsIGRhdGFLZXksIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRcbiAgICB9ID0gdGhpcy5jb25maWc7XG5cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsID0+IE51bWJlci5wYXJzZUludCh2YWwsIDEwKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSB7XG4gICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgbW9kaWZpZXJzOiBbe1xuICAgICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBhbHRCb3VuZGFyeTogdHJ1ZSxcbiAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuY29uZmlnLmZhbGxiYWNrUGxhY2VtZW50c1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgYm91bmRhcnk6IHRoaXMuY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ2Fycm93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdvbkNoYW5nZScsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIHBoYXNlOiAnYWZ0ZXJXcml0ZScsXG4gICAgICAgIGZuOiBkYXRhID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKVxuICAgICAgfV0sXG4gICAgICBvbkZpcnN0VXBkYXRlOiBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEub3B0aW9ucy5wbGFjZW1lbnQgIT09IGRhdGEucGxhY2VtZW50KSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyAuLi5kZWZhdWx0QnNQb3BwZXJDb25maWcsXG4gICAgICAuLi4odHlwZW9mIHRoaXMuY29uZmlnLnBvcHBlckNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLnBvcHBlckNvbmZpZyhkZWZhdWx0QnNQb3BwZXJDb25maWcpIDogdGhpcy5jb25maWcucG9wcGVyQ29uZmlnKVxuICAgIH07XG4gIH1cblxuICBfYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpIHtcbiAgICB0aGlzLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKGAke0NMQVNTX1BSRUZJWCQxfS0ke3RoaXMudXBkYXRlQXR0YWNobWVudChhdHRhY2htZW50KX1gKTtcbiAgfVxuXG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmNvbnRhaW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgIH1cblxuICAgIGlmIChpc0VsZW1lbnQodGhpcy5jb25maWcuY29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZE9uZSh0aGlzLmNvbmZpZy5jb250YWluZXIpO1xuICB9XG5cbiAgX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIEF0dGFjaG1lbnRNYXBbcGxhY2VtZW50LnRvVXBwZXJDYXNlKCldO1xuICB9XG5cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuY29uZmlnLnRyaWdnZXIuc3BsaXQoJyAnKTtcbiAgICB0cmlnZ2Vycy5mb3JFYWNoKHRyaWdnZXIgPT4ge1xuICAgICAgaWYgKHRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuQ0xJQ0ssIHRoaXMuY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB0aGlzLnRvZ2dsZShldmVudCkpO1xuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xuICAgICAgICBjb25zdCBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTjtcbiAgICAgICAgY29uc3QgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVDtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50SW4sIHRoaXMuY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB0aGlzLl9lbnRlcihldmVudCkpO1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgZXZlbnRPdXQsIHRoaXMuY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB0aGlzLl9sZWF2ZShldmVudCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudC5jbG9zZXN0KGAuJHtDTEFTU19OQU1FX01PREFMfWApLCAnaGlkZS5icy5tb2RhbCcsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLnNlbGVjdG9yKSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsXG4gICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICBzZWxlY3RvcjogJydcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZpeFRpdGxlKCk7XG4gICAgfVxuICB9XG5cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG5cbiAgICBjb25zdCBvcmlnaW5hbFRpdGxlVHlwZSA9IHR5cGVvZiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpO1xuXG4gICAgaWYgKHRpdGxlIHx8IG9yaWdpbmFsVGl0bGVUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSB8fCAnJyk7XG5cbiAgICAgIGlmICh0aXRsZSAmJiAhdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSAmJiAhdGhpcy5fZWxlbWVudC50ZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJycpO1xuICAgIH1cbiAgfVxuXG4gIF9lbnRlcihldmVudCwgY29udGV4dCkge1xuICAgIGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQsIGNvbnRleHQpO1xuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c2luJyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckMykgfHwgY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfU0hPVykge1xuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1c7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xuICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIT1ZFUl9TVEFURV9TSE9XO1xuXG4gICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgY29udGV4dC5zaG93KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX1NIT1cpIHtcbiAgICAgICAgY29udGV4dC5zaG93KCk7XG4gICAgICB9XG4gICAgfSwgY29udGV4dC5jb25maWcuZGVsYXkuc2hvdyk7XG4gIH1cblxuICBfbGVhdmUoZXZlbnQsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50LCBjb250ZXh0KTtcblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gY29udGV4dC5fZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xuICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIT1ZFUl9TVEFURV9PVVQ7XG5cbiAgICBpZiAoIWNvbnRleHQuY29uZmlnLmRlbGF5IHx8ICFjb250ZXh0LmNvbmZpZy5kZWxheS5oaWRlKSB7XG4gICAgICBjb250ZXh0LmhpZGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfT1VUKSB7XG4gICAgICAgIGNvbnRleHQuaGlkZSgpO1xuICAgICAgfVxuICAgIH0sIGNvbnRleHQuY29uZmlnLmRlbGF5LmhpZGUpO1xuICB9XG5cbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgZm9yIChjb25zdCB0cmlnZ2VyIGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RyaWdnZXJdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uc3QgZGF0YUF0dHJpYnV0ZXMgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcykuZm9yRWFjaChkYXRhQXR0ciA9PiB7XG4gICAgICBpZiAoRElTQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhkYXRhQXR0cikpIHtcbiAgICAgICAgZGVsZXRlIGRhdGFBdHRyaWJ1dGVzW2RhdGFBdHRyXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjb25maWcgJiYgdHlwZW9mIGNvbmZpZy5jb250YWluZXIgPT09ICdvYmplY3QnICYmIGNvbmZpZy5jb250YWluZXIuanF1ZXJ5KSB7XG4gICAgICBjb25maWcuY29udGFpbmVyID0gY29uZmlnLmNvbnRhaW5lclswXTtcbiAgICB9XG5cbiAgICBjb25maWcgPSB7IC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLmRhdGFBdHRyaWJ1dGVzLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy5kZWxheSA9IHtcbiAgICAgICAgc2hvdzogY29uZmlnLmRlbGF5LFxuICAgICAgICBoaWRlOiBjb25maWcuZGVsYXlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcudGl0bGUgPSBjb25maWcudGl0bGUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uZmlnLmNvbnRlbnQgPSBjb25maWcuY29udGVudC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJDQsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XG5cbiAgICBpZiAoY29uZmlnLnNhbml0aXplKSB7XG4gICAgICBjb25maWcudGVtcGxhdGUgPSBzYW5pdGl6ZUh0bWwoY29uZmlnLnRlbXBsYXRlLCBjb25maWcuYWxsb3dMaXN0LCBjb25maWcuc2FuaXRpemVGbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICBjb25zdCBjb25maWcgPSB7fTtcblxuICAgIGlmICh0aGlzLmNvbmZpZykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jb25maWcpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB0aGlzLmNvbmZpZ1trZXldKSB7XG4gICAgICAgICAgY29uZmlnW2tleV0gPSB0aGlzLmNvbmZpZ1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIF9jbGVhblRpcENsYXNzKCkge1xuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgIGNvbnN0IHRhYkNsYXNzID0gdGlwLmdldEF0dHJpYnV0ZSgnY2xhc3MnKS5tYXRjaChCU0NMU19QUkVGSVhfUkVHRVgkMSk7XG5cbiAgICBpZiAodGFiQ2xhc3MgIT09IG51bGwgJiYgdGFiQ2xhc3MubGVuZ3RoID4gMCkge1xuICAgICAgdGFiQ2xhc3MubWFwKHRva2VuID0+IHRva2VuLnRyaW0oKSkuZm9yRWFjaCh0Q2xhc3MgPT4gdGlwLmNsYXNzTGlzdC5yZW1vdmUodENsYXNzKSk7XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShwb3BwZXJEYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhdGVcbiAgICB9ID0gcG9wcGVyRGF0YTtcblxuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRpcCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlcjtcblxuICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKTtcblxuICAgIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KHN0YXRlLnBsYWNlbWVudCkpO1xuICB9IC8vIFN0YXRpY1xuXG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBkYXRhID0gRGF0YS5nZXQodGhpcywgREFUQV9LRVkkNCk7XG5cbiAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWc7XG5cbiAgICAgIGlmICghZGF0YSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUb29sdGlwKHRoaXMsIF9jb25maWcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogYWRkIC5Ub29sdGlwIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuXG5kZWZpbmVKUXVlcnlQbHVnaW4oTkFNRSQ0LCBUb29sdGlwKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjAtYmV0YTMpOiBwb3BvdmVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUkMyA9ICdwb3BvdmVyJztcbmNvbnN0IERBVEFfS0VZJDMgPSAnYnMucG9wb3Zlcic7XG5jb25zdCBFVkVOVF9LRVkkMyA9IGAuJHtEQVRBX0tFWSQzfWA7XG5jb25zdCBDTEFTU19QUkVGSVggPSAnYnMtcG9wb3Zlcic7XG5jb25zdCBCU0NMU19QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKGAoXnxcXFxccykke0NMQVNTX1BSRUZJWH1cXFxcUytgLCAnZycpO1xuY29uc3QgRGVmYXVsdCQyID0geyAuLi5Ub29sdGlwLkRlZmF1bHQsXG4gIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgb2Zmc2V0OiBbMCwgOF0sXG4gIHRyaWdnZXI6ICdjbGljaycsXG4gIGNvbnRlbnQ6ICcnLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJwb3BvdmVyXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWFycm93XCI+PC9kaXY+JyArICc8aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlclwiPjwvaDM+JyArICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+JyArICc8L2Rpdj4nXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkMiA9IHsgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcbiAgY29udGVudDogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXG59O1xuY29uc3QgRXZlbnQkMSA9IHtcbiAgSElERTogYGhpZGUke0VWRU5UX0tFWSQzfWAsXG4gIEhJRERFTjogYGhpZGRlbiR7RVZFTlRfS0VZJDN9YCxcbiAgU0hPVzogYHNob3cke0VWRU5UX0tFWSQzfWAsXG4gIFNIT1dOOiBgc2hvd24ke0VWRU5UX0tFWSQzfWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke0VWRU5UX0tFWSQzfWAsXG4gIENMSUNLOiBgY2xpY2ske0VWRU5UX0tFWSQzfWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtFVkVOVF9LRVkkM31gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHtFVkVOVF9LRVkkM31gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7RVZFTlRfS0VZJDN9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke0VWRU5UX0tFWSQzfWBcbn07XG5jb25zdCBDTEFTU19OQU1FX0ZBREUkMiA9ICdmYWRlJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQyID0gJ3Nob3cnO1xuY29uc3QgU0VMRUNUT1JfVElUTEUgPSAnLnBvcG92ZXItaGVhZGVyJztcbmNvbnN0IFNFTEVDVE9SX0NPTlRFTlQgPSAnLnBvcG92ZXItYm9keSc7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgUG9wb3ZlciBleHRlbmRzIFRvb2x0aXAge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQyO1xuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgIHJldHVybiBEQVRBX0tFWSQzO1xuICB9XG5cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gRXZlbnQkMTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xuICAgIHJldHVybiBFVkVOVF9LRVkkMztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDI7XG4gIH0gLy8gT3ZlcnJpZGVzXG5cblxuICBpc1dpdGhDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5fZ2V0Q29udGVudCgpO1xuICB9XG5cbiAgc2V0Q29udGVudCgpIHtcbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTsgLy8gd2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuXG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudChTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX1RJVExFLCB0aXApLCB0aGlzLmdldFRpdGxlKCkpO1xuXG4gICAgbGV0IGNvbnRlbnQgPSB0aGlzLl9nZXRDb250ZW50KCk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRlbnQgPSBjb250ZW50LmNhbGwodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudChTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0NPTlRFTlQsIHRpcCksIGNvbnRlbnQpO1xuICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfRkFERSQyLCBDTEFTU19OQU1FX1NIT1ckMik7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KSB7XG4gICAgdGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChgJHtDTEFTU19QUkVGSVh9LSR7dGhpcy51cGRhdGVBdHRhY2htZW50KGF0dGFjaG1lbnQpfWApO1xuICB9XG5cbiAgX2dldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLWNvbnRlbnQnKSB8fCB0aGlzLmNvbmZpZy5jb250ZW50O1xuICB9XG5cbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgY29uc3QgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KCk7XG4gICAgY29uc3QgdGFiQ2xhc3MgPSB0aXAuZ2V0QXR0cmlidXRlKCdjbGFzcycpLm1hdGNoKEJTQ0xTX1BSRUZJWF9SRUdFWCk7XG5cbiAgICBpZiAodGFiQ2xhc3MgIT09IG51bGwgJiYgdGFiQ2xhc3MubGVuZ3RoID4gMCkge1xuICAgICAgdGFiQ2xhc3MubWFwKHRva2VuID0+IHRva2VuLnRyaW0oKSkuZm9yRWFjaCh0Q2xhc3MgPT4gdGlwLmNsYXNzTGlzdC5yZW1vdmUodENsYXNzKSk7XG4gICAgfVxuICB9IC8vIFN0YXRpY1xuXG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBkYXRhID0gRGF0YS5nZXQodGhpcywgREFUQV9LRVkkMyk7XG5cbiAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGw7XG5cbiAgICAgIGlmICghZGF0YSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIF9jb25maWcpO1xuICAgICAgICBEYXRhLnNldCh0aGlzLCBEQVRBX0tFWSQzLCBkYXRhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuUG9wb3ZlciB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKE5BTUUkMywgUG9wb3Zlcik7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4wLWJldGEzKTogc2Nyb2xsc3B5LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUkMiA9ICdzY3JvbGxzcHknO1xuY29uc3QgREFUQV9LRVkkMiA9ICdicy5zY3JvbGxzcHknO1xuY29uc3QgRVZFTlRfS0VZJDIgPSBgLiR7REFUQV9LRVkkMn1gO1xuY29uc3QgREFUQV9BUElfS0VZJDEgPSAnLmRhdGEtYXBpJztcbmNvbnN0IERlZmF1bHQkMSA9IHtcbiAgb2Zmc2V0OiAxMCxcbiAgbWV0aG9kOiAnYXV0bycsXG4gIHRhcmdldDogJydcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQxID0ge1xuICBvZmZzZXQ6ICdudW1iZXInLFxuICBtZXRob2Q6ICdzdHJpbmcnLFxuICB0YXJnZXQ6ICcoc3RyaW5nfGVsZW1lbnQpJ1xufTtcbmNvbnN0IEVWRU5UX0FDVElWQVRFID0gYGFjdGl2YXRlJHtFVkVOVF9LRVkkMn1gO1xuY29uc3QgRVZFTlRfU0NST0xMID0gYHNjcm9sbCR7RVZFTlRfS0VZJDJ9YDtcbmNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkgPSBgbG9hZCR7RVZFTlRfS0VZJDJ9JHtEQVRBX0FQSV9LRVkkMX1gO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNID0gJ2Ryb3Bkb3duLWl0ZW0nO1xuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMSA9ICdhY3RpdmUnO1xuY29uc3QgU0VMRUNUT1JfREFUQV9TUFkgPSAnW2RhdGEtYnMtc3B5PVwic2Nyb2xsXCJdJztcbmNvbnN0IFNFTEVDVE9SX05BVl9MSVNUX0dST1VQJDEgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnO1xuY29uc3QgU0VMRUNUT1JfTkFWX0xJTktTID0gJy5uYXYtbGluayc7XG5jb25zdCBTRUxFQ1RPUl9OQVZfSVRFTVMgPSAnLm5hdi1pdGVtJztcbmNvbnN0IFNFTEVDVE9SX0xJU1RfSVRFTVMgPSAnLmxpc3QtZ3JvdXAtaXRlbSc7XG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiQxID0gJy5kcm9wZG93bic7XG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUkMSA9ICcuZHJvcGRvd24tdG9nZ2xlJztcbmNvbnN0IE1FVEhPRF9PRkZTRVQgPSAnb2Zmc2V0JztcbmNvbnN0IE1FVEhPRF9QT1NJVElPTiA9ICdwb3NpdGlvbic7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgU2Nyb2xsU3B5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQpO1xuICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LnRhZ05hbWUgPT09ICdCT0RZJyA/IHdpbmRvdyA6IHRoaXMuX2VsZW1lbnQ7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2VsZWN0b3IgPSBgJHt0aGlzLl9jb25maWcudGFyZ2V0fSAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7dGhpcy5fY29uZmlnLnRhcmdldH0gJHtTRUxFQ1RPUl9MSVNUX0lURU1TfSwgJHt0aGlzLl9jb25maWcudGFyZ2V0fSAuJHtDTEFTU19OQU1FX0RST1BET1dOX0lURU19YDtcbiAgICB0aGlzLl9vZmZzZXRzID0gW107XG4gICAgdGhpcy5fdGFyZ2V0cyA9IFtdO1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gMDtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fc2Nyb2xsRWxlbWVudCwgRVZFTlRfU0NST0xMLCAoKSA9PiB0aGlzLl9wcm9jZXNzKCkpO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgdGhpcy5fcHJvY2VzcygpO1xuICB9IC8vIEdldHRlcnNcblxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQxO1xuICB9XG5cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gREFUQV9LRVkkMjtcbiAgfSAvLyBQdWJsaWNcblxuXG4gIHJlZnJlc2goKSB7XG4gICAgY29uc3QgYXV0b01ldGhvZCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHRoaXMuX3Njcm9sbEVsZW1lbnQud2luZG93ID8gTUVUSE9EX09GRlNFVCA6IE1FVEhPRF9QT1NJVElPTjtcbiAgICBjb25zdCBvZmZzZXRNZXRob2QgPSB0aGlzLl9jb25maWcubWV0aG9kID09PSAnYXV0bycgPyBhdXRvTWV0aG9kIDogdGhpcy5fY29uZmlnLm1ldGhvZDtcbiAgICBjb25zdCBvZmZzZXRCYXNlID0gb2Zmc2V0TWV0aG9kID09PSBNRVRIT0RfUE9TSVRJT04gPyB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6IDA7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IFtdO1xuICAgIHRoaXMuX3RhcmdldHMgPSBbXTtcbiAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKTtcbiAgICBjb25zdCB0YXJnZXRzID0gU2VsZWN0b3JFbmdpbmUuZmluZCh0aGlzLl9zZWxlY3Rvcik7XG4gICAgdGFyZ2V0cy5tYXAoZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUodGFyZ2V0U2VsZWN0b3IpIDogbnVsbDtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXRCQ1IgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKHRhcmdldEJDUi53aWR0aCB8fCB0YXJnZXRCQ1IuaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIFtNYW5pcHVsYXRvcltvZmZzZXRNZXRob2RdKHRhcmdldCkudG9wICsgb2Zmc2V0QmFzZSwgdGFyZ2V0U2VsZWN0b3JdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcihpdGVtID0+IGl0ZW0pLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgdGhpcy5fb2Zmc2V0cy5wdXNoKGl0ZW1bMF0pO1xuXG4gICAgICB0aGlzLl90YXJnZXRzLnB1c2goaXRlbVsxXSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX3Njcm9sbEVsZW1lbnQsIEVWRU5UX0tFWSQyKTtcbiAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgIHRoaXMuX3NlbGVjdG9yID0gbnVsbDtcbiAgICB0aGlzLl9vZmZzZXRzID0gbnVsbDtcbiAgICB0aGlzLl90YXJnZXRzID0gbnVsbDtcbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IG51bGw7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkMSxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiBpc0VsZW1lbnQoY29uZmlnLnRhcmdldCkpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGlkXG4gICAgICB9ID0gY29uZmlnLnRhcmdldDtcblxuICAgICAgaWYgKCFpZCkge1xuICAgICAgICBpZCA9IGdldFVJRChOQU1FJDIpO1xuICAgICAgICBjb25maWcudGFyZ2V0LmlkID0gaWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbmZpZy50YXJnZXQgPSBgIyR7aWR9YDtcbiAgICB9XG5cbiAgICB0eXBlQ2hlY2tDb25maWcoTkFNRSQyLCBjb25maWcsIERlZmF1bHRUeXBlJDEpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBfZ2V0U2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB0aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICBfZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCk7XG4gIH1cblxuICBfZ2V0T2Zmc2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgfVxuXG4gIF9wcm9jZXNzKCkge1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpICsgdGhpcy5fY29uZmlnLm9mZnNldDtcblxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpO1xuXG4gICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5fY29uZmlnLm9mZnNldCArIHNjcm9sbEhlaWdodCAtIHRoaXMuX2dldE9mZnNldEhlaWdodCgpO1xuXG4gICAgaWYgKHRoaXMuX3Njcm9sbEhlaWdodCAhPT0gc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICBpZiAoc2Nyb2xsVG9wID49IG1heFNjcm9sbCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1t0aGlzLl90YXJnZXRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgc2Nyb2xsVG9wIDwgdGhpcy5fb2Zmc2V0c1swXSAmJiB0aGlzLl9vZmZzZXRzWzBdID4gMCkge1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcblxuICAgICAgdGhpcy5fY2xlYXIoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgaXNBY3RpdmVUYXJnZXQgPSB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbaV0gJiYgc2Nyb2xsVG9wID49IHRoaXMuX29mZnNldHNbaV0gJiYgKHR5cGVvZiB0aGlzLl9vZmZzZXRzW2kgKyAxXSA9PT0gJ3VuZGVmaW5lZCcgfHwgc2Nyb2xsVG9wIDwgdGhpcy5fb2Zmc2V0c1tpICsgMV0pO1xuXG4gICAgICBpZiAoaXNBY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2FjdGl2YXRlKHRhcmdldCkge1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcblxuICAgIHRoaXMuX2NsZWFyKCk7XG5cbiAgICBjb25zdCBxdWVyaWVzID0gdGhpcy5fc2VsZWN0b3Iuc3BsaXQoJywnKS5tYXAoc2VsZWN0b3IgPT4gYCR7c2VsZWN0b3J9W2RhdGEtYnMtdGFyZ2V0PVwiJHt0YXJnZXR9XCJdLCR7c2VsZWN0b3J9W2hyZWY9XCIke3RhcmdldH1cIl1gKTtcblxuICAgIGNvbnN0IGxpbmsgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKHF1ZXJpZXMuam9pbignLCcpKTtcblxuICAgIGlmIChsaW5rLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0lURU0pKSB7XG4gICAgICBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxLCBsaW5rLmNsb3Nlc3QoU0VMRUNUT1JfRFJPUERPV04kMSkpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICBsaW5rLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGluayBhcyBhY3RpdmVcbiAgICAgIGxpbmsuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICAgIFNlbGVjdG9yRW5naW5lLnBhcmVudHMobGluaywgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAkMSkuZm9yRWFjaChsaXN0R3JvdXAgPT4ge1xuICAgICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmtzIHBhcmVudHMgYXMgYWN0aXZlXG4gICAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxuICAgICAgICBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgYCR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9MSVNUX0lURU1TfWApLmZvckVhY2goaXRlbSA9PiBpdGVtLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSkpOyAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIHdoZW4gLm5hdi1saW5rIGlzIGluc2lkZSAubmF2LWl0ZW1cblxuICAgICAgICBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgU0VMRUNUT1JfTkFWX0lURU1TKS5mb3JFYWNoKG5hdkl0ZW0gPT4ge1xuICAgICAgICAgIFNlbGVjdG9yRW5naW5lLmNoaWxkcmVuKG5hdkl0ZW0sIFNFTEVDVE9SX05BVl9MSU5LUykuZm9yRWFjaChpdGVtID0+IGl0ZW0uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fc2Nyb2xsRWxlbWVudCwgRVZFTlRfQUNUSVZBVEUsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRhcmdldFxuICAgIH0pO1xuICB9XG5cbiAgX2NsZWFyKCkge1xuICAgIFNlbGVjdG9yRW5naW5lLmZpbmQodGhpcy5fc2VsZWN0b3IpLmZpbHRlcihub2RlID0+IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFJDEpKS5mb3JFYWNoKG5vZGUgPT4gbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpKTtcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9IERhdGEuZ2V0KHRoaXMsIERBVEFfS0VZJDIpO1xuXG4gICAgICBjb25zdCBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnO1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBTY3JvbGxTcHkodGhpcywgX2NvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbkV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcbiAgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1NQWSkuZm9yRWFjaChzcHkgPT4gbmV3IFNjcm9sbFNweShzcHksIE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHNweSkpKTtcbn0pO1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBhZGQgLlNjcm9sbFNweSB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihOQU1FJDIsIFNjcm9sbFNweSk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4wLWJldGEzKTogdGFiLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUkMSA9ICd0YWInO1xuY29uc3QgREFUQV9LRVkkMSA9ICdicy50YWInO1xuY29uc3QgRVZFTlRfS0VZJDEgPSBgLiR7REFUQV9LRVkkMX1gO1xuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFVkVOVF9ISURFJDEgPSBgaGlkZSR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX0hJRERFTiQxID0gYGhpZGRlbiR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX1NIT1ckMSA9IGBzaG93JHtFVkVOVF9LRVkkMX1gO1xuY29uc3QgRVZFTlRfU0hPV04kMSA9IGBzaG93biR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVkkMX0ke0RBVEFfQVBJX0tFWX1gO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9NRU5VID0gJ2Ryb3Bkb3duLW1lbnUnO1xuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJztcbmNvbnN0IENMQVNTX05BTUVfRkFERSQxID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDEgPSAnc2hvdyc7XG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nO1xuY29uc3QgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFID0gJy5hY3RpdmUnO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFX1VMID0gJzpzY29wZSA+IGxpID4gLmFjdGl2ZSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS1icy10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cImxpc3RcIl0nO1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJy5kcm9wZG93bi10b2dnbGUnO1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fQUNUSVZFX0NISUxEID0gJzpzY29wZSA+IC5kcm9wZG93bi1tZW51IC5hY3RpdmUnO1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIFRhYiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgcmV0dXJuIERBVEFfS0VZJDE7XG4gIH0gLy8gUHVibGljXG5cblxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgJiYgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSkgfHwgaXNEaXNhYmxlZCh0aGlzLl9lbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBwcmV2aW91cztcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgY29uc3QgbGlzdEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVApO1xuXG4gICAgaWYgKGxpc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCBpdGVtU2VsZWN0b3IgPSBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ09MJyA/IFNFTEVDVE9SX0FDVElWRV9VTCA6IFNFTEVDVE9SX0FDVElWRTtcbiAgICAgIHByZXZpb3VzID0gU2VsZWN0b3JFbmdpbmUuZmluZChpdGVtU2VsZWN0b3IsIGxpc3RFbGVtZW50KTtcbiAgICAgIHByZXZpb3VzID0gcHJldmlvdXNbcHJldmlvdXMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gcHJldmlvdXMgPyBFdmVudEhhbmRsZXIudHJpZ2dlcihwcmV2aW91cywgRVZFTlRfSElERSQxLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfSkgOiBudWxsO1xuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckMSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcbiAgICB9KTtcblxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCBoaWRlRXZlbnQgIT09IG51bGwgJiYgaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmF0ZSh0aGlzLl9lbGVtZW50LCBsaXN0RWxlbWVudCk7XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHByZXZpb3VzLCBFVkVOVF9ISURERU4kMSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDEsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLl9hY3RpdmF0ZSh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlLCBjb21wbGV0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuICB9IC8vIFByaXZhdGVcblxuXG4gIF9hY3RpdmF0ZShlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYWN0aXZlRWxlbWVudHMgPSBjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBjb250YWluZXIubm9kZU5hbWUgPT09ICdPTCcpID8gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9BQ1RJVkVfVUwsIGNvbnRhaW5lcikgOiBTZWxlY3RvckVuZ2luZS5jaGlsZHJlbihjb250YWluZXIsIFNFTEVDVE9SX0FDVElWRSk7XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHNbMF07XG4gICAgY29uc3QgaXNUcmFuc2l0aW9uaW5nID0gY2FsbGJhY2sgJiYgYWN0aXZlICYmIGFjdGl2ZS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDEpO1xuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB0aGlzLl90cmFuc2l0aW9uQ29tcGxldGUoZWxlbWVudCwgYWN0aXZlLCBjYWxsYmFjayk7XG5cbiAgICBpZiAoYWN0aXZlICYmIGlzVHJhbnNpdGlvbmluZykge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQoYWN0aXZlKTtcbiAgICAgIGFjdGl2ZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQxKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUoYWN0aXZlLCAndHJhbnNpdGlvbmVuZCcsIGNvbXBsZXRlKTtcbiAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKGFjdGl2ZSwgdHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKTtcbiAgICB9XG4gIH1cblxuICBfdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBhY3RpdmUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICBjb25zdCBkcm9wZG93bkNoaWxkID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQsIGFjdGl2ZS5wYXJlbnROb2RlKTtcblxuICAgICAgaWYgKGRyb3Bkb3duQ2hpbGQpIHtcbiAgICAgICAgZHJvcGRvd25DaGlsZC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcbiAgICAgICAgYWN0aXZlLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuXG4gICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpO1xuICAgIH1cblxuICAgIHJlZmxvdyhlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMSkpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUERPV05fTUVOVSkpIHtcbiAgICAgIGNvbnN0IGRyb3Bkb3duRWxlbWVudCA9IGVsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTik7XG5cbiAgICAgIGlmIChkcm9wZG93bkVsZW1lbnQpIHtcbiAgICAgICAgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUpLmZvckVhY2goZHJvcGRvd24gPT4gZHJvcGRvd24uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSkpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0gLy8gU3RhdGljXG5cblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IERhdGEuZ2V0KHRoaXMsIERBVEFfS0VZJDEpIHx8IG5ldyBUYWIodGhpcyk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgZGF0YSA9IERhdGEuZ2V0KHRoaXMsIERBVEFfS0VZJDEpIHx8IG5ldyBUYWIodGhpcyk7XG4gIGRhdGEuc2hvdygpO1xufSk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuVGFiIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKE5BTUUkMSwgVGFiKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjAtYmV0YTMpOiB0b2FzdC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FID0gJ3RvYXN0JztcbmNvbnN0IERBVEFfS0VZID0gJ2JzLnRvYXN0JztcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9TSE9XTiA9IGBzaG93biR7RVZFTlRfS0VZfWA7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XG5jb25zdCBDTEFTU19OQU1FX0hJREUgPSAnaGlkZSc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdyc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1dJTkcgPSAnc2hvd2luZyc7XG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gIGF1dG9oaWRlOiAnYm9vbGVhbicsXG4gIGRlbGF5OiAnbnVtYmVyJ1xufTtcbmNvbnN0IERlZmF1bHQgPSB7XG4gIGFuaW1hdGlvbjogdHJ1ZSxcbiAgYXV0b2hpZGU6IHRydWUsXG4gIGRlbGF5OiA1MDAwXG59O1xuY29uc3QgU0VMRUNUT1JfREFUQV9ESVNNSVNTID0gJ1tkYXRhLWJzLWRpc21pc3M9XCJ0b2FzdFwiXSc7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgVG9hc3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCk7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG5cbiAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgfSAvLyBHZXR0ZXJzXG5cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgcmV0dXJuIERBVEFfS0VZO1xuICB9IC8vIFB1YmxpY1xuXG5cbiAgc2hvdygpIHtcbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XKTtcblxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1cpO1xuXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTik7XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2hpZGUpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9ISURFKTtcblxuICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkcpO1xuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGNvbXBsZXRlKTtcbiAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQsIHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFKTtcblxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfSElERSk7XG5cbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTik7XG4gICAgfTtcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpO1xuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCAndHJhbnNpdGlvbmVuZCcsIGNvbXBsZXRlKTtcbiAgICAgIGVtdWxhdGVUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQsIHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgIGlmICh0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICB9XG5cbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MpO1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICB9IC8vIFByaXZhdGVcblxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0geyAuLi5EZWZhdWx0LFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXG4gICAgfTtcbiAgICB0eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xJQ0tfRElTTUlTUywgU0VMRUNUT1JfREFUQV9ESVNNSVNTLCAoKSA9PiB0aGlzLmhpZGUoKSk7XG4gIH1cblxuICBfY2xlYXJUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9IERhdGEuZ2V0KHRoaXMsIERBVEFfS0VZKTtcblxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZztcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVG9hc3QodGhpcywgX2NvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogYWRkIC5Ub2FzdCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKE5BTUUsIFRvYXN0KTtcblxuZXhwb3J0IHsgQWxlcnQsIEJ1dHRvbiwgQ2Fyb3VzZWwsIENvbGxhcHNlLCBEcm9wZG93biwgTW9kYWwsIE9mZmNhbnZhcywgUG9wb3ZlciwgU2Nyb2xsU3B5LCBUYWIsIFRvYXN0LCBUb29sdGlwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib290c3RyYXAuZXNtLmpzLm1hcFxuIiwiLy8gV2UgbmVlZCB0byBpbXBvcnQgdGhlIENTUyBzbyB0aGF0IHdlYnBhY2sgd2lsbCBsb2FkIGl0LlxuLy8gVGhlIE1pbmlDc3NFeHRyYWN0UGx1Z2luIGlzIHVzZWQgdG8gc2VwYXJhdGUgaXQgb3V0IGludG9cbi8vIGl0cyBvd24gQ1NTIGZpbGUuXG5pbXBvcnQgXCIuLi9jc3MvYXBwLnNjc3NcIlxuaW1wb3J0IFwiYm9vdHN0cmFwXCJcblxuLy8gd2VicGFjayBhdXRvbWF0aWNhbGx5IGJ1bmRsZXMgYWxsIG1vZHVsZXMgaW4geW91clxuLy8gZW50cnkgcG9pbnRzLiBUaG9zZSBlbnRyeSBwb2ludHMgY2FuIGJlIGNvbmZpZ3VyZWRcbi8vIGluIFwid2VicGFjay5jb25maWcuanNcIi5cbi8vXG4vLyBJbXBvcnQgZGVwcyB3aXRoIHRoZSBkZXAgbmFtZSBvciBsb2NhbCBmaWxlcyB3aXRoIGEgcmVsYXRpdmUgcGF0aCwgZm9yIGV4YW1wbGU6XG4vL1xuLy8gICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXG4vLyAgICAgaW1wb3J0IHNvY2tldCBmcm9tIFwiLi9zb2NrZXRcIlxuLy9cbmltcG9ydCBcInBob2VuaXhfaHRtbFwiXG5pbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuaW1wb3J0IE5Qcm9ncmVzcyBmcm9tIFwibnByb2dyZXNzXCJcbmltcG9ydCB7TGl2ZVNvY2tldH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcblxubGV0IGNzcmZUb2tlbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW25hbWU9J2NzcmYtdG9rZW4nXVwiKS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpXG5sZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7cGFyYW1zOiB7X2NzcmZfdG9rZW46IGNzcmZUb2tlbn19KVxuXG4vLyBTaG93IHByb2dyZXNzIGJhciBvbiBsaXZlIG5hdmlnYXRpb24gYW5kIGZvcm0gc3VibWl0c1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIGluZm8gPT4gTlByb2dyZXNzLnN0YXJ0KCkpXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLCBpbmZvID0+IE5Qcm9ncmVzcy5kb25lKCkpXG5cbi8vIGNvbm5lY3QgaWYgdGhlcmUgYXJlIGFueSBMaXZlVmlld3Mgb24gdGhlIHBhZ2VcbmxpdmVTb2NrZXQuY29ubmVjdCgpXG5cbi8vIGV4cG9zZSBsaXZlU29ja2V0IG9uIHdpbmRvdyBmb3Igd2ViIGNvbnNvbGUgZGVidWcgbG9ncyBhbmQgbGF0ZW5jeSBzaW11bGF0aW9uOlxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVEZWJ1ZygpXG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZUxhdGVuY3lTaW0oMTAwMCkgIC8vIGVuYWJsZWQgZm9yIGR1cmF0aW9uIG9mIGJyb3dzZXIgc2Vzc2lvblxuLy8gPj4gbGl2ZVNvY2tldC5kaXNhYmxlTGF0ZW5jeVNpbSgpXG53aW5kb3cubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcblxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBSUE7QUFDQTtBQUNBO0FBQ0EsaUJBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvMEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///6\\n\")}]);","extractedComments":[]}