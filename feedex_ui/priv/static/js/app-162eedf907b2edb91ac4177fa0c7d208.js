/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../deps/phoenix/priv/static/phoenix.js":
/*!******************************************************************!*\
  !*** /home/aleak/src/feedex/deps/phoenix/priv/static/phoenix.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function (e, t) {\n   true ? module.exports = t() : undefined;\n}(this, function () {\n  return function (e) {\n    var t = {};\n\n    function n(i) {\n      if (t[i]) return t[i].exports;\n      var o = t[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return e[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, i) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: i\n      });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n      var i = Object.create(null);\n      if (n.r(i), Object.defineProperty(i, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var o in e) n.d(i, o, function (t) {\n        return e[t];\n      }.bind(null, o));\n      return i;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 0);\n  }([function (e, t, n) {\n    (function (t) {\n      e.exports = t.Phoenix = n(2);\n    }).call(this, n(1));\n  }, function (e, t) {\n    var n;\n\n    n = function () {\n      return this;\n    }();\n\n    try {\n      n = n || new Function(\"return this\")();\n    } catch (e) {\n      \"object\" == typeof window && (n = window);\n    }\n\n    e.exports = n;\n  }, function (e, t, n) {\n    \"use strict\";\n\n    function i(e) {\n      return function (e) {\n        if (Array.isArray(e)) return a(e);\n      }(e) || function (e) {\n        if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);\n      }(e) || s(e) || function () {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function o(e) {\n      return (o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }\n\n    function r(e, t) {\n      return function (e) {\n        if (Array.isArray(e)) return e;\n      }(e) || function (e, t) {\n        if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(e))) return;\n        var n = [],\n            i = !0,\n            o = !1,\n            r = void 0;\n\n        try {\n          for (var s, a = e[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); i = !0);\n        } catch (e) {\n          o = !0, r = e;\n        } finally {\n          try {\n            i || null == a.return || a.return();\n          } finally {\n            if (o) throw r;\n          }\n        }\n\n        return n;\n      }(e, t) || s(e, t) || function () {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function s(e, t) {\n      if (e) {\n        if (\"string\" == typeof e) return a(e, t);\n        var n = Object.prototype.toString.call(e).slice(8, -1);\n        return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(n) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? a(e, t) : void 0;\n      }\n    }\n\n    function a(e, t) {\n      (null == t || t > e.length) && (t = e.length);\n\n      for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n\n      return i;\n    }\n\n    function c(e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function u(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var i = t[n];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n      }\n    }\n\n    function h(e, t, n) {\n      return t && u(e.prototype, t), n && u(e, n), e;\n    }\n\n    n.r(t), n.d(t, \"Channel\", function () {\n      return _;\n    }), n.d(t, \"Serializer\", function () {\n      return H;\n    }), n.d(t, \"Socket\", function () {\n      return U;\n    }), n.d(t, \"LongPoll\", function () {\n      return D;\n    }), n.d(t, \"Ajax\", function () {\n      return M;\n    }), n.d(t, \"Presence\", function () {\n      return N;\n    });\n\n    var l = \"undefined\" != typeof self ? self : null,\n        f = \"undefined\" != typeof window ? window : null,\n        d = l || f || void 0,\n        p = 0,\n        v = 1,\n        y = 2,\n        m = 3,\n        g = \"closed\",\n        k = \"errored\",\n        b = \"joined\",\n        j = \"joining\",\n        C = \"leaving\",\n        E = \"phx_close\",\n        R = \"phx_error\",\n        T = \"phx_join\",\n        S = \"phx_reply\",\n        w = \"phx_leave\",\n        A = [E, R, T, S, w],\n        L = \"longpoll\",\n        x = \"websocket\",\n        O = function (e) {\n      if (\"function\" == typeof e) return e;\n      return function () {\n        return e;\n      };\n    },\n        P = function () {\n      function e(t, n, i, o) {\n        c(this, e), this.channel = t, this.event = n, this.payload = i || function () {\n          return {};\n        }, this.receivedResp = null, this.timeout = o, this.timeoutTimer = null, this.recHooks = [], this.sent = !1;\n      }\n\n      return h(e, [{\n        key: \"resend\",\n        value: function (e) {\n          this.timeout = e, this.reset(), this.send();\n        }\n      }, {\n        key: \"send\",\n        value: function () {\n          this.hasReceived(\"timeout\") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload(),\n            ref: this.ref,\n            join_ref: this.channel.joinRef()\n          }));\n        }\n      }, {\n        key: \"receive\",\n        value: function (e, t) {\n          return this.hasReceived(e) && t(this.receivedResp.response), this.recHooks.push({\n            status: e,\n            callback: t\n          }), this;\n        }\n      }, {\n        key: \"reset\",\n        value: function () {\n          this.cancelRefEvent(), this.ref = null, this.refEvent = null, this.receivedResp = null, this.sent = !1;\n        }\n      }, {\n        key: \"matchReceive\",\n        value: function (e) {\n          var t = e.status,\n              n = e.response;\n          e.ref;\n          this.recHooks.filter(function (e) {\n            return e.status === t;\n          }).forEach(function (e) {\n            return e.callback(n);\n          });\n        }\n      }, {\n        key: \"cancelRefEvent\",\n        value: function () {\n          this.refEvent && this.channel.off(this.refEvent);\n        }\n      }, {\n        key: \"cancelTimeout\",\n        value: function () {\n          clearTimeout(this.timeoutTimer), this.timeoutTimer = null;\n        }\n      }, {\n        key: \"startTimeout\",\n        value: function () {\n          var e = this;\n          this.timeoutTimer && this.cancelTimeout(), this.ref = this.channel.socket.makeRef(), this.refEvent = this.channel.replyEventName(this.ref), this.channel.on(this.refEvent, function (t) {\n            e.cancelRefEvent(), e.cancelTimeout(), e.receivedResp = t, e.matchReceive(t);\n          }), this.timeoutTimer = setTimeout(function () {\n            e.trigger(\"timeout\", {});\n          }, this.timeout);\n        }\n      }, {\n        key: \"hasReceived\",\n        value: function (e) {\n          return this.receivedResp && this.receivedResp.status === e;\n        }\n      }, {\n        key: \"trigger\",\n        value: function (e, t) {\n          this.channel.trigger(this.refEvent, {\n            status: e,\n            response: t\n          });\n        }\n      }]), e;\n    }(),\n        _ = function () {\n      function e(t, n, i) {\n        var o = this;\n        c(this, e), this.state = g, this.topic = t, this.params = O(n || {}), this.socket = i, this.bindings = [], this.bindingRef = 0, this.timeout = this.socket.timeout, this.joinedOnce = !1, this.joinPush = new P(this, T, this.params, this.timeout), this.pushBuffer = [], this.stateChangeRefs = [], this.rejoinTimer = new J(function () {\n          o.socket.isConnected() && o.rejoin();\n        }, this.socket.rejoinAfterMs), this.stateChangeRefs.push(this.socket.onError(function () {\n          return o.rejoinTimer.reset();\n        })), this.stateChangeRefs.push(this.socket.onOpen(function () {\n          o.rejoinTimer.reset(), o.isErrored() && o.rejoin();\n        })), this.joinPush.receive(\"ok\", function () {\n          o.state = b, o.rejoinTimer.reset(), o.pushBuffer.forEach(function (e) {\n            return e.send();\n          }), o.pushBuffer = [];\n        }), this.joinPush.receive(\"error\", function () {\n          o.state = k, o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.onClose(function () {\n          o.rejoinTimer.reset(), o.socket.hasLogger() && o.socket.log(\"channel\", \"close \".concat(o.topic, \" \").concat(o.joinRef())), o.state = g, o.socket.remove(o);\n        }), this.onError(function (e) {\n          o.socket.hasLogger() && o.socket.log(\"channel\", \"error \".concat(o.topic), e), o.isJoining() && o.joinPush.reset(), o.state = k, o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.joinPush.receive(\"timeout\", function () {\n          o.socket.hasLogger() && o.socket.log(\"channel\", \"timeout \".concat(o.topic, \" (\").concat(o.joinRef(), \")\"), o.joinPush.timeout), new P(o, w, O({}), o.timeout).send(), o.state = k, o.joinPush.reset(), o.socket.isConnected() && o.rejoinTimer.scheduleTimeout();\n        }), this.on(S, function (e, t) {\n          o.trigger(o.replyEventName(t), e);\n        });\n      }\n\n      return h(e, [{\n        key: \"join\",\n        value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          if (this.joinedOnce) throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n          return this.timeout = e, this.joinedOnce = !0, this.rejoin(), this.joinPush;\n        }\n      }, {\n        key: \"onClose\",\n        value: function (e) {\n          this.on(E, e);\n        }\n      }, {\n        key: \"onError\",\n        value: function (e) {\n          return this.on(R, function (t) {\n            return e(t);\n          });\n        }\n      }, {\n        key: \"on\",\n        value: function (e, t) {\n          var n = this.bindingRef++;\n          return this.bindings.push({\n            event: e,\n            ref: n,\n            callback: t\n          }), n;\n        }\n      }, {\n        key: \"off\",\n        value: function (e, t) {\n          this.bindings = this.bindings.filter(function (n) {\n            return !(n.event === e && (void 0 === t || t === n.ref));\n          });\n        }\n      }, {\n        key: \"canPush\",\n        value: function () {\n          return this.socket.isConnected() && this.isJoined();\n        }\n      }, {\n        key: \"push\",\n        value: function (e, t) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.timeout;\n          if (t = t || {}, !this.joinedOnce) throw new Error(\"tried to push '\".concat(e, \"' to '\").concat(this.topic, \"' before joining. Use channel.join() before pushing events\"));\n          var i = new P(this, e, function () {\n            return t;\n          }, n);\n          return this.canPush() ? i.send() : (i.startTimeout(), this.pushBuffer.push(i)), i;\n        }\n      }, {\n        key: \"leave\",\n        value: function () {\n          var e = this,\n              t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          this.rejoinTimer.reset(), this.joinPush.cancelTimeout(), this.state = C;\n\n          var n = function () {\n            e.socket.hasLogger() && e.socket.log(\"channel\", \"leave \".concat(e.topic)), e.trigger(E, \"leave\");\n          },\n              i = new P(this, w, O({}), t);\n\n          return i.receive(\"ok\", function () {\n            return n();\n          }).receive(\"timeout\", function () {\n            return n();\n          }), i.send(), this.canPush() || i.trigger(\"ok\", {}), i;\n        }\n      }, {\n        key: \"onMessage\",\n        value: function (e, t, n) {\n          return t;\n        }\n      }, {\n        key: \"isLifecycleEvent\",\n        value: function (e) {\n          return A.indexOf(e) >= 0;\n        }\n      }, {\n        key: \"isMember\",\n        value: function (e, t, n, i) {\n          return this.topic === e && (!i || i === this.joinRef() || !this.isLifecycleEvent(t) || (this.socket.hasLogger() && this.socket.log(\"channel\", \"dropping outdated message\", {\n            topic: e,\n            event: t,\n            payload: n,\n            joinRef: i\n          }), !1));\n        }\n      }, {\n        key: \"joinRef\",\n        value: function () {\n          return this.joinPush.ref;\n        }\n      }, {\n        key: \"rejoin\",\n        value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.timeout;\n          this.isLeaving() || (this.socket.leaveOpenTopic(this.topic), this.state = j, this.joinPush.resend(e));\n        }\n      }, {\n        key: \"trigger\",\n        value: function (e, t, n, i) {\n          var o = this.onMessage(e, t, n, i);\n          if (t && !o) throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n\n          for (var r = this.bindings.filter(function (t) {\n            return t.event === e;\n          }), s = 0; s < r.length; s++) {\n            r[s].callback(o, n, i || this.joinRef());\n          }\n        }\n      }, {\n        key: \"replyEventName\",\n        value: function (e) {\n          return \"chan_reply_\".concat(e);\n        }\n      }, {\n        key: \"isClosed\",\n        value: function () {\n          return this.state === g;\n        }\n      }, {\n        key: \"isErrored\",\n        value: function () {\n          return this.state === k;\n        }\n      }, {\n        key: \"isJoined\",\n        value: function () {\n          return this.state === b;\n        }\n      }, {\n        key: \"isJoining\",\n        value: function () {\n          return this.state === j;\n        }\n      }, {\n        key: \"isLeaving\",\n        value: function () {\n          return this.state === C;\n        }\n      }]), e;\n    }(),\n        H = {\n      HEADER_LENGTH: 1,\n      META_LENGTH: 4,\n      KINDS: {\n        push: 0,\n        reply: 1,\n        broadcast: 2\n      },\n      encode: function (e, t) {\n        if (e.payload.constructor === ArrayBuffer) return t(this.binaryEncode(e));\n        var n = [e.join_ref, e.ref, e.topic, e.event, e.payload];\n        return t(JSON.stringify(n));\n      },\n      decode: function (e, t) {\n        if (e.constructor === ArrayBuffer) return t(this.binaryDecode(e));\n        var n = r(JSON.parse(e), 5);\n        return t({\n          join_ref: n[0],\n          ref: n[1],\n          topic: n[2],\n          event: n[3],\n          payload: n[4]\n        });\n      },\n      binaryEncode: function (e) {\n        var t = e.join_ref,\n            n = e.ref,\n            i = e.event,\n            o = e.topic,\n            r = e.payload,\n            s = this.META_LENGTH + t.length + n.length + o.length + i.length,\n            a = new ArrayBuffer(this.HEADER_LENGTH + s),\n            c = new DataView(a),\n            u = 0;\n        c.setUint8(u++, this.KINDS.push), c.setUint8(u++, t.length), c.setUint8(u++, n.length), c.setUint8(u++, o.length), c.setUint8(u++, i.length), Array.from(t, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        }), Array.from(n, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        }), Array.from(o, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        }), Array.from(i, function (e) {\n          return c.setUint8(u++, e.charCodeAt(0));\n        });\n        var h = new Uint8Array(a.byteLength + r.byteLength);\n        return h.set(new Uint8Array(a), 0), h.set(new Uint8Array(r), a.byteLength), h.buffer;\n      },\n      binaryDecode: function (e) {\n        var t = new DataView(e),\n            n = t.getUint8(0),\n            i = new TextDecoder();\n\n        switch (n) {\n          case this.KINDS.push:\n            return this.decodePush(e, t, i);\n\n          case this.KINDS.reply:\n            return this.decodeReply(e, t, i);\n\n          case this.KINDS.broadcast:\n            return this.decodeBroadcast(e, t, i);\n        }\n      },\n      decodePush: function (e, t, n) {\n        var i = t.getUint8(1),\n            o = t.getUint8(2),\n            r = t.getUint8(3),\n            s = this.HEADER_LENGTH + this.META_LENGTH - 1,\n            a = n.decode(e.slice(s, s + i));\n        s += i;\n        var c = n.decode(e.slice(s, s + o));\n        s += o;\n        var u = n.decode(e.slice(s, s + r));\n        return s += r, {\n          join_ref: a,\n          ref: null,\n          topic: c,\n          event: u,\n          payload: e.slice(s, e.byteLength)\n        };\n      },\n      decodeReply: function (e, t, n) {\n        var i = t.getUint8(1),\n            o = t.getUint8(2),\n            r = t.getUint8(3),\n            s = t.getUint8(4),\n            a = this.HEADER_LENGTH + this.META_LENGTH,\n            c = n.decode(e.slice(a, a + i));\n        a += i;\n        var u = n.decode(e.slice(a, a + o));\n        a += o;\n        var h = n.decode(e.slice(a, a + r));\n        a += r;\n        var l = n.decode(e.slice(a, a + s));\n        a += s;\n        var f = e.slice(a, e.byteLength);\n        return {\n          join_ref: c,\n          ref: u,\n          topic: h,\n          event: S,\n          payload: {\n            status: l,\n            response: f\n          }\n        };\n      },\n      decodeBroadcast: function (e, t, n) {\n        var i = t.getUint8(1),\n            o = t.getUint8(2),\n            r = this.HEADER_LENGTH + 2,\n            s = n.decode(e.slice(r, r + i));\n        r += i;\n        var a = n.decode(e.slice(r, r + o));\n        return r += o, {\n          join_ref: null,\n          ref: null,\n          topic: s,\n          event: a,\n          payload: e.slice(r, e.byteLength)\n        };\n      }\n    },\n        U = function () {\n      function e(t) {\n        var n = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        c(this, e), this.stateChangeCallbacks = {\n          open: [],\n          close: [],\n          error: [],\n          message: []\n        }, this.channels = [], this.sendBuffer = [], this.ref = 0, this.timeout = i.timeout || 1e4, this.transport = i.transport || d.WebSocket || D, this.defaultEncoder = H.encode.bind(H), this.defaultDecoder = H.decode.bind(H), this.closeWasClean = !1, this.unloaded = !1, this.binaryType = i.binaryType || \"arraybuffer\", this.transport !== D ? (this.encode = i.encode || this.defaultEncoder, this.decode = i.decode || this.defaultDecoder) : (this.encode = this.defaultEncoder, this.decode = this.defaultDecoder), f && f.addEventListener && f.addEventListener(\"unload\", function (e) {\n          n.conn && (n.unloaded = !0, n.abnormalClose(\"unloaded\"));\n        }), this.heartbeatIntervalMs = i.heartbeatIntervalMs || 3e4, this.rejoinAfterMs = function (e) {\n          return i.rejoinAfterMs ? i.rejoinAfterMs(e) : [1e3, 2e3, 5e3][e - 1] || 1e4;\n        }, this.reconnectAfterMs = function (e) {\n          return n.unloaded ? 100 : i.reconnectAfterMs ? i.reconnectAfterMs(e) : [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][e - 1] || 5e3;\n        }, this.logger = i.logger || null, this.longpollerTimeout = i.longpollerTimeout || 2e4, this.params = O(i.params || {}), this.endPoint = \"\".concat(t, \"/\").concat(x), this.vsn = i.vsn || \"2.0.0\", this.heartbeatTimer = null, this.pendingHeartbeatRef = null, this.reconnectTimer = new J(function () {\n          n.teardown(function () {\n            return n.connect();\n          });\n        }, this.reconnectAfterMs);\n      }\n\n      return h(e, [{\n        key: \"protocol\",\n        value: function () {\n          return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n        }\n      }, {\n        key: \"endPointURL\",\n        value: function () {\n          var e = M.appendParams(M.appendParams(this.endPoint, this.params()), {\n            vsn: this.vsn\n          });\n          return \"/\" !== e.charAt(0) ? e : \"/\" === e.charAt(1) ? \"\".concat(this.protocol(), \":\").concat(e) : \"\".concat(this.protocol(), \"://\").concat(location.host).concat(e);\n        }\n      }, {\n        key: \"disconnect\",\n        value: function (e, t, n) {\n          this.closeWasClean = !0, this.reconnectTimer.reset(), this.teardown(e, t, n);\n        }\n      }, {\n        key: \"connect\",\n        value: function (e) {\n          var t = this;\n          e && (console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\"), this.params = O(e)), this.conn || (this.closeWasClean = !1, this.conn = new this.transport(this.endPointURL()), this.conn.binaryType = this.binaryType, this.conn.timeout = this.longpollerTimeout, this.conn.onopen = function () {\n            return t.onConnOpen();\n          }, this.conn.onerror = function (e) {\n            return t.onConnError(e);\n          }, this.conn.onmessage = function (e) {\n            return t.onConnMessage(e);\n          }, this.conn.onclose = function (e) {\n            return t.onConnClose(e);\n          });\n        }\n      }, {\n        key: \"log\",\n        value: function (e, t, n) {\n          this.logger(e, t, n);\n        }\n      }, {\n        key: \"hasLogger\",\n        value: function () {\n          return null !== this.logger;\n        }\n      }, {\n        key: \"onOpen\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.open.push([t, e]), t;\n        }\n      }, {\n        key: \"onClose\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.close.push([t, e]), t;\n        }\n      }, {\n        key: \"onError\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.error.push([t, e]), t;\n        }\n      }, {\n        key: \"onMessage\",\n        value: function (e) {\n          var t = this.makeRef();\n          return this.stateChangeCallbacks.message.push([t, e]), t;\n        }\n      }, {\n        key: \"onConnOpen\",\n        value: function () {\n          this.hasLogger() && this.log(\"transport\", \"connected to \".concat(this.endPointURL())), this.unloaded = !1, this.closeWasClean = !1, this.flushSendBuffer(), this.reconnectTimer.reset(), this.resetHeartbeat(), this.stateChangeCallbacks.open.forEach(function (e) {\n            return (0, r(e, 2)[1])();\n          });\n        }\n      }, {\n        key: \"resetHeartbeat\",\n        value: function () {\n          var e = this;\n          this.conn && this.conn.skipHeartbeat || (this.pendingHeartbeatRef = null, clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(function () {\n            return e.sendHeartbeat();\n          }, this.heartbeatIntervalMs));\n        }\n      }, {\n        key: \"teardown\",\n        value: function (e, t, n) {\n          var i = this;\n          if (!this.conn) return e && e();\n          this.waitForBufferDone(function () {\n            i.conn && (t ? i.conn.close(t, n || \"\") : i.conn.close()), i.waitForSocketClosed(function () {\n              i.conn && (i.conn.onclose = function () {}, i.conn = null), e && e();\n            });\n          });\n        }\n      }, {\n        key: \"waitForBufferDone\",\n        value: function (e) {\n          var t = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n          5 !== n && this.conn && this.conn.bufferedAmount ? setTimeout(function () {\n            t.waitForBufferDone(e, n + 1);\n          }, 150 * n) : e();\n        }\n      }, {\n        key: \"waitForSocketClosed\",\n        value: function (e) {\n          var t = this,\n              n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n          5 !== n && this.conn && this.conn.readyState !== m ? setTimeout(function () {\n            t.waitForSocketClosed(e, n + 1);\n          }, 150 * n) : e();\n        }\n      }, {\n        key: \"onConnClose\",\n        value: function (e) {\n          this.hasLogger() && this.log(\"transport\", \"close\", e), this.triggerChanError(), clearInterval(this.heartbeatTimer), this.closeWasClean || this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(function (t) {\n            return (0, r(t, 2)[1])(e);\n          });\n        }\n      }, {\n        key: \"onConnError\",\n        value: function (e) {\n          this.hasLogger() && this.log(\"transport\", e), this.triggerChanError(), this.stateChangeCallbacks.error.forEach(function (t) {\n            return (0, r(t, 2)[1])(e);\n          });\n        }\n      }, {\n        key: \"triggerChanError\",\n        value: function () {\n          this.channels.forEach(function (e) {\n            e.isErrored() || e.isLeaving() || e.isClosed() || e.trigger(R);\n          });\n        }\n      }, {\n        key: \"connectionState\",\n        value: function () {\n          switch (this.conn && this.conn.readyState) {\n            case p:\n              return \"connecting\";\n\n            case v:\n              return \"open\";\n\n            case y:\n              return \"closing\";\n\n            default:\n              return \"closed\";\n          }\n        }\n      }, {\n        key: \"isConnected\",\n        value: function () {\n          return \"open\" === this.connectionState();\n        }\n      }, {\n        key: \"remove\",\n        value: function (e) {\n          this.off(e.stateChangeRefs), this.channels = this.channels.filter(function (t) {\n            return t.joinRef() !== e.joinRef();\n          });\n        }\n      }, {\n        key: \"off\",\n        value: function (e) {\n          for (var t in this.stateChangeCallbacks) this.stateChangeCallbacks[t] = this.stateChangeCallbacks[t].filter(function (t) {\n            var n = r(t, 1)[0];\n            return -1 === e.indexOf(n);\n          });\n        }\n      }, {\n        key: \"channel\",\n        value: function (e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n              n = new _(e, t, this);\n          return this.channels.push(n), n;\n        }\n      }, {\n        key: \"push\",\n        value: function (e) {\n          var t = this;\n\n          if (this.hasLogger()) {\n            var n = e.topic,\n                i = e.event,\n                o = e.payload,\n                r = e.ref,\n                s = e.join_ref;\n            this.log(\"push\", \"\".concat(n, \" \").concat(i, \" (\").concat(s, \", \").concat(r, \")\"), o);\n          }\n\n          this.isConnected() ? this.encode(e, function (e) {\n            return t.conn.send(e);\n          }) : this.sendBuffer.push(function () {\n            return t.encode(e, function (e) {\n              return t.conn.send(e);\n            });\n          });\n        }\n      }, {\n        key: \"makeRef\",\n        value: function () {\n          var e = this.ref + 1;\n          return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString();\n        }\n      }, {\n        key: \"sendHeartbeat\",\n        value: function () {\n          if (this.isConnected()) {\n            if (this.pendingHeartbeatRef) return this.pendingHeartbeatRef = null, this.hasLogger() && this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\"), void this.abnormalClose(\"heartbeat timeout\");\n            this.pendingHeartbeatRef = this.makeRef(), this.push({\n              topic: \"phoenix\",\n              event: \"heartbeat\",\n              payload: {},\n              ref: this.pendingHeartbeatRef\n            });\n          }\n        }\n      }, {\n        key: \"abnormalClose\",\n        value: function (e) {\n          this.closeWasClean = !1, this.conn.readyState === v && this.conn.close(1e3, e);\n        }\n      }, {\n        key: \"flushSendBuffer\",\n        value: function () {\n          this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(function (e) {\n            return e();\n          }), this.sendBuffer = []);\n        }\n      }, {\n        key: \"onConnMessage\",\n        value: function (e) {\n          var t = this;\n          this.decode(e.data, function (e) {\n            var n = e.topic,\n                i = e.event,\n                o = e.payload,\n                s = e.ref,\n                a = e.join_ref;\n            s && s === t.pendingHeartbeatRef && (t.pendingHeartbeatRef = null), t.hasLogger() && t.log(\"receive\", \"\".concat(o.status || \"\", \" \").concat(n, \" \").concat(i, \" \").concat(s && \"(\" + s + \")\" || \"\"), o);\n\n            for (var c = 0; c < t.channels.length; c++) {\n              var u = t.channels[c];\n              u.isMember(n, i, o, a) && u.trigger(i, o, s, a);\n            }\n\n            for (var h = 0; h < t.stateChangeCallbacks.message.length; h++) {\n              (0, r(t.stateChangeCallbacks.message[h], 2)[1])(e);\n            }\n          });\n        }\n      }, {\n        key: \"leaveOpenTopic\",\n        value: function (e) {\n          var t = this.channels.find(function (t) {\n            return t.topic === e && (t.isJoined() || t.isJoining());\n          });\n          t && (this.hasLogger() && this.log(\"transport\", 'leaving duplicate topic \"'.concat(e, '\"')), t.leave());\n        }\n      }]), e;\n    }(),\n        D = function () {\n      function e(t) {\n        c(this, e), this.endPoint = null, this.token = null, this.skipHeartbeat = !0, this.onopen = function () {}, this.onerror = function () {}, this.onmessage = function () {}, this.onclose = function () {}, this.pollEndpoint = this.normalizeEndpoint(t), this.readyState = p, this.poll();\n      }\n\n      return h(e, [{\n        key: \"normalizeEndpoint\",\n        value: function (e) {\n          return e.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + x), \"$1/\" + L);\n        }\n      }, {\n        key: \"endpointURL\",\n        value: function () {\n          return M.appendParams(this.pollEndpoint, {\n            token: this.token\n          });\n        }\n      }, {\n        key: \"closeAndRetry\",\n        value: function () {\n          this.close(), this.readyState = p;\n        }\n      }, {\n        key: \"ontimeout\",\n        value: function () {\n          this.onerror(\"timeout\"), this.closeAndRetry();\n        }\n      }, {\n        key: \"poll\",\n        value: function () {\n          var e = this;\n          this.readyState !== v && this.readyState !== p || M.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (t) {\n            if (t) {\n              var n = t.status,\n                  i = t.token,\n                  o = t.messages;\n              e.token = i;\n            } else n = 0;\n\n            switch (n) {\n              case 200:\n                o.forEach(function (t) {\n                  return e.onmessage({\n                    data: t\n                  });\n                }), e.poll();\n                break;\n\n              case 204:\n                e.poll();\n                break;\n\n              case 410:\n                e.readyState = v, e.onopen(), e.poll();\n                break;\n\n              case 403:\n                e.onerror(), e.close();\n                break;\n\n              case 0:\n              case 500:\n                e.onerror(), e.closeAndRetry();\n                break;\n\n              default:\n                throw new Error(\"unhandled poll status \".concat(n));\n            }\n          });\n        }\n      }, {\n        key: \"send\",\n        value: function (e) {\n          var t = this;\n          M.request(\"POST\", this.endpointURL(), \"application/json\", e, this.timeout, this.onerror.bind(this, \"timeout\"), function (e) {\n            e && 200 === e.status || (t.onerror(e && e.status), t.closeAndRetry());\n          });\n        }\n      }, {\n        key: \"close\",\n        value: function (e, t) {\n          this.readyState = m, this.onclose();\n        }\n      }]), e;\n    }(),\n        M = function () {\n      function e() {\n        c(this, e);\n      }\n\n      return h(e, null, [{\n        key: \"request\",\n        value: function (e, t, n, i, o, r, s) {\n          if (d.XDomainRequest) {\n            var a = new XDomainRequest();\n            this.xdomainRequest(a, e, t, i, o, r, s);\n          } else {\n            var c = new d.XMLHttpRequest();\n            this.xhrRequest(c, e, t, n, i, o, r, s);\n          }\n        }\n      }, {\n        key: \"xdomainRequest\",\n        value: function (e, t, n, i, o, r, s) {\n          var a = this;\n          e.timeout = o, e.open(t, n), e.onload = function () {\n            var t = a.parseJSON(e.responseText);\n            s && s(t);\n          }, r && (e.ontimeout = r), e.onprogress = function () {}, e.send(i);\n        }\n      }, {\n        key: \"xhrRequest\",\n        value: function (e, t, n, i, o, r, s, a) {\n          var c = this;\n          e.open(t, n, !0), e.timeout = r, e.setRequestHeader(\"Content-Type\", i), e.onerror = function () {\n            a && a(null);\n          }, e.onreadystatechange = function () {\n            if (e.readyState === c.states.complete && a) {\n              var t = c.parseJSON(e.responseText);\n              a(t);\n            }\n          }, s && (e.ontimeout = s), e.send(o);\n        }\n      }, {\n        key: \"parseJSON\",\n        value: function (e) {\n          if (!e || \"\" === e) return null;\n\n          try {\n            return JSON.parse(e);\n          } catch (t) {\n            return console && console.log(\"failed to parse JSON response\", e), null;\n          }\n        }\n      }, {\n        key: \"serialize\",\n        value: function (e, t) {\n          var n = [];\n\n          for (var i in e) if (e.hasOwnProperty(i)) {\n            var r = t ? \"\".concat(t, \"[\").concat(i, \"]\") : i,\n                s = e[i];\n            \"object\" === o(s) ? n.push(this.serialize(s, r)) : n.push(encodeURIComponent(r) + \"=\" + encodeURIComponent(s));\n          }\n\n          return n.join(\"&\");\n        }\n      }, {\n        key: \"appendParams\",\n        value: function (e, t) {\n          if (0 === Object.keys(t).length) return e;\n          var n = e.match(/\\?/) ? \"&\" : \"?\";\n          return \"\".concat(e).concat(n).concat(this.serialize(t));\n        }\n      }]), e;\n    }();\n\n    M.states = {\n      complete: 4\n    };\n\n    var N = function () {\n      function e(t) {\n        var n = this,\n            i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        c(this, e);\n        var o = i.events || {\n          state: \"presence_state\",\n          diff: \"presence_diff\"\n        };\n        this.state = {}, this.pendingDiffs = [], this.channel = t, this.joinRef = null, this.caller = {\n          onJoin: function () {},\n          onLeave: function () {},\n          onSync: function () {}\n        }, this.channel.on(o.state, function (t) {\n          var i = n.caller,\n              o = i.onJoin,\n              r = i.onLeave,\n              s = i.onSync;\n          n.joinRef = n.channel.joinRef(), n.state = e.syncState(n.state, t, o, r), n.pendingDiffs.forEach(function (t) {\n            n.state = e.syncDiff(n.state, t, o, r);\n          }), n.pendingDiffs = [], s();\n        }), this.channel.on(o.diff, function (t) {\n          var i = n.caller,\n              o = i.onJoin,\n              r = i.onLeave,\n              s = i.onSync;\n          n.inPendingSyncState() ? n.pendingDiffs.push(t) : (n.state = e.syncDiff(n.state, t, o, r), s());\n        });\n      }\n\n      return h(e, [{\n        key: \"onJoin\",\n        value: function (e) {\n          this.caller.onJoin = e;\n        }\n      }, {\n        key: \"onLeave\",\n        value: function (e) {\n          this.caller.onLeave = e;\n        }\n      }, {\n        key: \"onSync\",\n        value: function (e) {\n          this.caller.onSync = e;\n        }\n      }, {\n        key: \"list\",\n        value: function (t) {\n          return e.list(this.state, t);\n        }\n      }, {\n        key: \"inPendingSyncState\",\n        value: function () {\n          return !this.joinRef || this.joinRef !== this.channel.joinRef();\n        }\n      }], [{\n        key: \"syncState\",\n        value: function (e, t, n, i) {\n          var o = this,\n              r = this.clone(e),\n              s = {},\n              a = {};\n          return this.map(r, function (e, n) {\n            t[e] || (a[e] = n);\n          }), this.map(t, function (e, t) {\n            var n = r[e];\n\n            if (n) {\n              var i = t.metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  c = n.metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  u = t.metas.filter(function (e) {\n                return c.indexOf(e.phx_ref) < 0;\n              }),\n                  h = n.metas.filter(function (e) {\n                return i.indexOf(e.phx_ref) < 0;\n              });\n              u.length > 0 && (s[e] = t, s[e].metas = u), h.length > 0 && (a[e] = o.clone(n), a[e].metas = h);\n            } else s[e] = t;\n          }), this.syncDiff(r, {\n            joins: s,\n            leaves: a\n          }, n, i);\n        }\n      }, {\n        key: \"syncDiff\",\n        value: function (e, t, n, o) {\n          var r = t.joins,\n              s = t.leaves,\n              a = this.clone(e);\n          return n || (n = function () {}), o || (o = function () {}), this.map(r, function (e, t) {\n            var o = a[e];\n\n            if (a[e] = t, o) {\n              var r,\n                  s = a[e].metas.map(function (e) {\n                return e.phx_ref;\n              }),\n                  c = o.metas.filter(function (e) {\n                return s.indexOf(e.phx_ref) < 0;\n              });\n              (r = a[e].metas).unshift.apply(r, i(c));\n            }\n\n            n(e, o, t);\n          }), this.map(s, function (e, t) {\n            var n = a[e];\n\n            if (n) {\n              var i = t.metas.map(function (e) {\n                return e.phx_ref;\n              });\n              n.metas = n.metas.filter(function (e) {\n                return i.indexOf(e.phx_ref) < 0;\n              }), o(e, n, t), 0 === n.metas.length && delete a[e];\n            }\n          }), a;\n        }\n      }, {\n        key: \"list\",\n        value: function (e, t) {\n          return t || (t = function (e, t) {\n            return t;\n          }), this.map(e, function (e, n) {\n            return t(e, n);\n          });\n        }\n      }, {\n        key: \"map\",\n        value: function (e, t) {\n          return Object.getOwnPropertyNames(e).map(function (n) {\n            return t(n, e[n]);\n          });\n        }\n      }, {\n        key: \"clone\",\n        value: function (e) {\n          return JSON.parse(JSON.stringify(e));\n        }\n      }]), e;\n    }(),\n        J = function () {\n      function e(t, n) {\n        c(this, e), this.callback = t, this.timerCalc = n, this.timer = null, this.tries = 0;\n      }\n\n      return h(e, [{\n        key: \"reset\",\n        value: function () {\n          this.tries = 0, clearTimeout(this.timer);\n        }\n      }, {\n        key: \"scheduleTimeout\",\n        value: function () {\n          var e = this;\n          clearTimeout(this.timer), this.timer = setTimeout(function () {\n            e.tries = e.tries + 1, e.callback();\n          }, this.timerCalc(this.tries + 1));\n        }\n      }]), e;\n    }();\n  }]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL2hvbWUvYWxlYWsvc3JjL2ZlZWRleC9kZXBzL3Bob2VuaXgvcHJpdi9zdGF0aWMvcGhvZW5peC5qcz81Y2NjIl0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuUGhvZW5peD10KCk6ZS5QaG9lbml4PXQoKX0odGhpcywoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gbihpKXtpZih0W2ldKXJldHVybiB0W2ldLmV4cG9ydHM7dmFyIG89dFtpXT17aTppLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbaV0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsbiksby5sPSEwLG8uZXhwb3J0c31yZXR1cm4gbi5tPWUsbi5jPXQsbi5kPWZ1bmN0aW9uKGUsdCxpKXtuLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6aX0pfSxuLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sbi50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1uKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBpPU9iamVjdC5jcmVhdGUobnVsbCk7aWYobi5yKGkpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgbyBpbiBlKW4uZChpLG8sZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxvKSk7cmV0dXJuIGl9LG4ubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbi5kKHQsXCJhXCIsdCksdH0sbi5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxuLnA9XCJcIixuKG4ucz0wKX0oW2Z1bmN0aW9uKGUsdCxuKXsoZnVuY3Rpb24odCl7ZS5leHBvcnRzPXQuUGhvZW5peD1uKDIpfSkuY2FsbCh0aGlzLG4oMSkpfSxmdW5jdGlvbihlLHQpe3ZhciBuO249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKTt0cnl7bj1ufHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKGUpe1wib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJihuPXdpbmRvdyl9ZS5leHBvcnRzPW59LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBhKGUpfShlKXx8ZnVuY3Rpb24oZSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSlyZXR1cm4gQXJyYXkuZnJvbShlKX0oZSl8fHMoZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24gbyhlKXtyZXR1cm4obz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gcihlLHQpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlfShlKXx8ZnVuY3Rpb24oZSx0KXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgU3ltYm9sfHwhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpKXJldHVybjt2YXIgbj1bXSxpPSEwLG89ITEscj12b2lkIDA7dHJ5e2Zvcih2YXIgcyxhPWVbU3ltYm9sLml0ZXJhdG9yXSgpOyEoaT0ocz1hLm5leHQoKSkuZG9uZSkmJihuLnB1c2gocy52YWx1ZSksIXR8fG4ubGVuZ3RoIT09dCk7aT0hMCk7fWNhdGNoKGUpe289ITAscj1lfWZpbmFsbHl7dHJ5e2l8fG51bGw9PWEucmV0dXJufHxhLnJldHVybigpfWZpbmFsbHl7aWYobyl0aHJvdyByfX1yZXR1cm4gbn0oZSx0KXx8cyhlLHQpfHxmdW5jdGlvbigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9KCl9ZnVuY3Rpb24gcyhlLHQpe2lmKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBhKGUsdCk7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1uJiZlLmNvbnN0cnVjdG9yJiYobj1lLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1ufHxcIlNldFwiPT09bj9BcnJheS5mcm9tKG4pOlwiQXJndW1lbnRzXCI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKT9hKGUsdCk6dm9pZCAwfX1mdW5jdGlvbiBhKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciBuPTAsaT1uZXcgQXJyYXkodCk7bjx0O24rKylpW25dPWVbbl07cmV0dXJuIGl9ZnVuY3Rpb24gYyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gdShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxpLmtleSxpKX19ZnVuY3Rpb24gaChlLHQsbil7cmV0dXJuIHQmJnUoZS5wcm90b3R5cGUsdCksbiYmdShlLG4pLGV9bi5yKHQpLG4uZCh0LFwiQ2hhbm5lbFwiLChmdW5jdGlvbigpe3JldHVybiBffSkpLG4uZCh0LFwiU2VyaWFsaXplclwiLChmdW5jdGlvbigpe3JldHVybiBIfSkpLG4uZCh0LFwiU29ja2V0XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFV9KSksbi5kKHQsXCJMb25nUG9sbFwiLChmdW5jdGlvbigpe3JldHVybiBEfSkpLG4uZCh0LFwiQWpheFwiLChmdW5jdGlvbigpe3JldHVybiBNfSkpLG4uZCh0LFwiUHJlc2VuY2VcIiwoZnVuY3Rpb24oKXtyZXR1cm4gTn0pKTt2YXIgbD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOm51bGwsZj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpudWxsLGQ9bHx8Znx8dm9pZCAwLHA9MCx2PTEseT0yLG09MyxnPVwiY2xvc2VkXCIsaz1cImVycm9yZWRcIixiPVwiam9pbmVkXCIsaj1cImpvaW5pbmdcIixDPVwibGVhdmluZ1wiLEU9XCJwaHhfY2xvc2VcIixSPVwicGh4X2Vycm9yXCIsVD1cInBoeF9qb2luXCIsUz1cInBoeF9yZXBseVwiLHc9XCJwaHhfbGVhdmVcIixBPVtFLFIsVCxTLHddLEw9XCJsb25ncG9sbFwiLHg9XCJ3ZWJzb2NrZXRcIixPPWZ1bmN0aW9uKGUpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGUpcmV0dXJuIGU7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGV9fSxQPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4saSxvKXtjKHRoaXMsZSksdGhpcy5jaGFubmVsPXQsdGhpcy5ldmVudD1uLHRoaXMucGF5bG9hZD1pfHxmdW5jdGlvbigpe3JldHVybnt9fSx0aGlzLnJlY2VpdmVkUmVzcD1udWxsLHRoaXMudGltZW91dD1vLHRoaXMudGltZW91dFRpbWVyPW51bGwsdGhpcy5yZWNIb29rcz1bXSx0aGlzLnNlbnQ9ITF9cmV0dXJuIGgoZSxbe2tleTpcInJlc2VuZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMudGltZW91dD1lLHRoaXMucmVzZXQoKSx0aGlzLnNlbmQoKX19LHtrZXk6XCJzZW5kXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmhhc1JlY2VpdmVkKFwidGltZW91dFwiKXx8KHRoaXMuc3RhcnRUaW1lb3V0KCksdGhpcy5zZW50PSEwLHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7dG9waWM6dGhpcy5jaGFubmVsLnRvcGljLGV2ZW50OnRoaXMuZXZlbnQscGF5bG9hZDp0aGlzLnBheWxvYWQoKSxyZWY6dGhpcy5yZWYsam9pbl9yZWY6dGhpcy5jaGFubmVsLmpvaW5SZWYoKX0pKX19LHtrZXk6XCJyZWNlaXZlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5oYXNSZWNlaXZlZChlKSYmdCh0aGlzLnJlY2VpdmVkUmVzcC5yZXNwb25zZSksdGhpcy5yZWNIb29rcy5wdXNoKHtzdGF0dXM6ZSxjYWxsYmFjazp0fSksdGhpc319LHtrZXk6XCJyZXNldFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jYW5jZWxSZWZFdmVudCgpLHRoaXMucmVmPW51bGwsdGhpcy5yZWZFdmVudD1udWxsLHRoaXMucmVjZWl2ZWRSZXNwPW51bGwsdGhpcy5zZW50PSExfX0se2tleTpcIm1hdGNoUmVjZWl2ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RhdHVzLG49ZS5yZXNwb25zZTtlLnJlZjt0aGlzLnJlY0hvb2tzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3RhdHVzPT09dH0pKS5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4gZS5jYWxsYmFjayhuKX0pKX19LHtrZXk6XCJjYW5jZWxSZWZFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5yZWZFdmVudCYmdGhpcy5jaGFubmVsLm9mZih0aGlzLnJlZkV2ZW50KX19LHtrZXk6XCJjYW5jZWxUaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpLHRoaXMudGltZW91dFRpbWVyPW51bGx9fSx7a2V5Olwic3RhcnRUaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMudGltZW91dFRpbWVyJiZ0aGlzLmNhbmNlbFRpbWVvdXQoKSx0aGlzLnJlZj10aGlzLmNoYW5uZWwuc29ja2V0Lm1ha2VSZWYoKSx0aGlzLnJlZkV2ZW50PXRoaXMuY2hhbm5lbC5yZXBseUV2ZW50TmFtZSh0aGlzLnJlZiksdGhpcy5jaGFubmVsLm9uKHRoaXMucmVmRXZlbnQsKGZ1bmN0aW9uKHQpe2UuY2FuY2VsUmVmRXZlbnQoKSxlLmNhbmNlbFRpbWVvdXQoKSxlLnJlY2VpdmVkUmVzcD10LGUubWF0Y2hSZWNlaXZlKHQpfSkpLHRoaXMudGltZW91dFRpbWVyPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS50cmlnZ2VyKFwidGltZW91dFwiLHt9KX0pLHRoaXMudGltZW91dCl9fSx7a2V5OlwiaGFzUmVjZWl2ZWRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AmJnRoaXMucmVjZWl2ZWRSZXNwLnN0YXR1cz09PWV9fSx7a2V5OlwidHJpZ2dlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5jaGFubmVsLnRyaWdnZXIodGhpcy5yZWZFdmVudCx7c3RhdHVzOmUscmVzcG9uc2U6dH0pfX1dKSxlfSgpLF89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixpKXt2YXIgbz10aGlzO2ModGhpcyxlKSx0aGlzLnN0YXRlPWcsdGhpcy50b3BpYz10LHRoaXMucGFyYW1zPU8obnx8e30pLHRoaXMuc29ja2V0PWksdGhpcy5iaW5kaW5ncz1bXSx0aGlzLmJpbmRpbmdSZWY9MCx0aGlzLnRpbWVvdXQ9dGhpcy5zb2NrZXQudGltZW91dCx0aGlzLmpvaW5lZE9uY2U9ITEsdGhpcy5qb2luUHVzaD1uZXcgUCh0aGlzLFQsdGhpcy5wYXJhbXMsdGhpcy50aW1lb3V0KSx0aGlzLnB1c2hCdWZmZXI9W10sdGhpcy5zdGF0ZUNoYW5nZVJlZnM9W10sdGhpcy5yZWpvaW5UaW1lcj1uZXcgSigoZnVuY3Rpb24oKXtvLnNvY2tldC5pc0Nvbm5lY3RlZCgpJiZvLnJlam9pbigpfSksdGhpcy5zb2NrZXQucmVqb2luQWZ0ZXJNcyksdGhpcy5zdGF0ZUNoYW5nZVJlZnMucHVzaCh0aGlzLnNvY2tldC5vbkVycm9yKChmdW5jdGlvbigpe3JldHVybiBvLnJlam9pblRpbWVyLnJlc2V0KCl9KSkpLHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25PcGVuKChmdW5jdGlvbigpe28ucmVqb2luVGltZXIucmVzZXQoKSxvLmlzRXJyb3JlZCgpJiZvLnJlam9pbigpfSkpKSx0aGlzLmpvaW5QdXNoLnJlY2VpdmUoXCJva1wiLChmdW5jdGlvbigpe28uc3RhdGU9YixvLnJlam9pblRpbWVyLnJlc2V0KCksby5wdXNoQnVmZmVyLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNlbmQoKX0pKSxvLnB1c2hCdWZmZXI9W119KSksdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwiZXJyb3JcIiwoZnVuY3Rpb24oKXtvLnN0YXRlPWssby5zb2NrZXQuaXNDb25uZWN0ZWQoKSYmby5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKX0pKSx0aGlzLm9uQ2xvc2UoKGZ1bmN0aW9uKCl7by5yZWpvaW5UaW1lci5yZXNldCgpLG8uc29ja2V0Lmhhc0xvZ2dlcigpJiZvLnNvY2tldC5sb2coXCJjaGFubmVsXCIsXCJjbG9zZSBcIi5jb25jYXQoby50b3BpYyxcIiBcIikuY29uY2F0KG8uam9pblJlZigpKSksby5zdGF0ZT1nLG8uc29ja2V0LnJlbW92ZShvKX0pKSx0aGlzLm9uRXJyb3IoKGZ1bmN0aW9uKGUpe28uc29ja2V0Lmhhc0xvZ2dlcigpJiZvLnNvY2tldC5sb2coXCJjaGFubmVsXCIsXCJlcnJvciBcIi5jb25jYXQoby50b3BpYyksZSksby5pc0pvaW5pbmcoKSYmby5qb2luUHVzaC5yZXNldCgpLG8uc3RhdGU9ayxvLnNvY2tldC5pc0Nvbm5lY3RlZCgpJiZvLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpfSkpLHRoaXMuam9pblB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwoZnVuY3Rpb24oKXtvLnNvY2tldC5oYXNMb2dnZXIoKSYmby5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLFwidGltZW91dCBcIi5jb25jYXQoby50b3BpYyxcIiAoXCIpLmNvbmNhdChvLmpvaW5SZWYoKSxcIilcIiksby5qb2luUHVzaC50aW1lb3V0KSxuZXcgUChvLHcsTyh7fSksby50aW1lb3V0KS5zZW5kKCksby5zdGF0ZT1rLG8uam9pblB1c2gucmVzZXQoKSxvLnNvY2tldC5pc0Nvbm5lY3RlZCgpJiZvLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpfSkpLHRoaXMub24oUywoZnVuY3Rpb24oZSx0KXtvLnRyaWdnZXIoby5yZXBseUV2ZW50TmFtZSh0KSxlKX0pKX1yZXR1cm4gaChlLFt7a2V5Olwiam9pblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnRoaXMudGltZW91dDtpZih0aGlzLmpvaW5lZE9uY2UpdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpO3JldHVybiB0aGlzLnRpbWVvdXQ9ZSx0aGlzLmpvaW5lZE9uY2U9ITAsdGhpcy5yZWpvaW4oKSx0aGlzLmpvaW5QdXNofX0se2tleTpcIm9uQ2xvc2VcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLm9uKEUsZSl9fSx7a2V5Olwib25FcnJvclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9uKFIsKGZ1bmN0aW9uKHQpe3JldHVybiBlKHQpfSkpfX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLmJpbmRpbmdSZWYrKztyZXR1cm4gdGhpcy5iaW5kaW5ncy5wdXNoKHtldmVudDplLHJlZjpuLGNhbGxiYWNrOnR9KSxufX0se2tleTpcIm9mZlwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5iaW5kaW5ncz10aGlzLmJpbmRpbmdzLmZpbHRlcigoZnVuY3Rpb24obil7cmV0dXJuIShuLmV2ZW50PT09ZSYmKHZvaWQgMD09PXR8fHQ9PT1uLnJlZikpfSkpfX0se2tleTpcImNhblB1c2hcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpJiZ0aGlzLmlzSm9pbmVkKCl9fSx7a2V5OlwicHVzaFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnRoaXMudGltZW91dDtpZih0PXR8fHt9LCF0aGlzLmpvaW5lZE9uY2UpdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gcHVzaCAnXCIuY29uY2F0KGUsXCInIHRvICdcIikuY29uY2F0KHRoaXMudG9waWMsXCInIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5qb2luKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzXCIpKTt2YXIgaT1uZXcgUCh0aGlzLGUsKGZ1bmN0aW9uKCl7cmV0dXJuIHR9KSxuKTtyZXR1cm4gdGhpcy5jYW5QdXNoKCk/aS5zZW5kKCk6KGkuc3RhcnRUaW1lb3V0KCksdGhpcy5wdXNoQnVmZmVyLnB1c2goaSkpLGl9fSx7a2V5OlwibGVhdmVcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06dGhpcy50aW1lb3V0O3RoaXMucmVqb2luVGltZXIucmVzZXQoKSx0aGlzLmpvaW5QdXNoLmNhbmNlbFRpbWVvdXQoKSx0aGlzLnN0YXRlPUM7dmFyIG49ZnVuY3Rpb24oKXtlLnNvY2tldC5oYXNMb2dnZXIoKSYmZS5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLFwibGVhdmUgXCIuY29uY2F0KGUudG9waWMpKSxlLnRyaWdnZXIoRSxcImxlYXZlXCIpfSxpPW5ldyBQKHRoaXMsdyxPKHt9KSx0KTtyZXR1cm4gaS5yZWNlaXZlKFwib2tcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbigpfSkpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG4oKX0pKSxpLnNlbmQoKSx0aGlzLmNhblB1c2goKXx8aS50cmlnZ2VyKFwib2tcIix7fSksaX19LHtrZXk6XCJvbk1lc3NhZ2VcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHR9fSx7a2V5OlwiaXNMaWZlY3ljbGVFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBBLmluZGV4T2YoZSk+PTB9fSx7a2V5OlwiaXNNZW1iZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpKXtyZXR1cm4gdGhpcy50b3BpYz09PWUmJighaXx8aT09PXRoaXMuam9pblJlZigpfHwhdGhpcy5pc0xpZmVjeWNsZUV2ZW50KHQpfHwodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkmJnRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIixcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIix7dG9waWM6ZSxldmVudDp0LHBheWxvYWQ6bixqb2luUmVmOml9KSwhMSkpfX0se2tleTpcImpvaW5SZWZcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmpvaW5QdXNoLnJlZn19LHtrZXk6XCJyZWpvaW5cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp0aGlzLnRpbWVvdXQ7dGhpcy5pc0xlYXZpbmcoKXx8KHRoaXMuc29ja2V0LmxlYXZlT3BlblRvcGljKHRoaXMudG9waWMpLHRoaXMuc3RhdGU9aix0aGlzLmpvaW5QdXNoLnJlc2VuZChlKSl9fSx7a2V5OlwidHJpZ2dlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGkpe3ZhciBvPXRoaXMub25NZXNzYWdlKGUsdCxuLGkpO2lmKHQmJiFvKXRocm93IG5ldyBFcnJvcihcImNoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFwiKTtmb3IodmFyIHI9dGhpcy5iaW5kaW5ncy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmV2ZW50PT09ZX0pKSxzPTA7czxyLmxlbmd0aDtzKyspe3Jbc10uY2FsbGJhY2sobyxuLGl8fHRoaXMuam9pblJlZigpKX19fSx7a2V5OlwicmVwbHlFdmVudE5hbWVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm5cImNoYW5fcmVwbHlfXCIuY29uY2F0KGUpfX0se2tleTpcImlzQ2xvc2VkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZT09PWd9fSx7a2V5OlwiaXNFcnJvcmVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0ZT09PWt9fSx7a2V5OlwiaXNKb2luZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlPT09Yn19LHtrZXk6XCJpc0pvaW5pbmdcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlPT09an19LHtrZXk6XCJpc0xlYXZpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlPT09Q319XSksZX0oKSxIPXtIRUFERVJfTEVOR1RIOjEsTUVUQV9MRU5HVEg6NCxLSU5EUzp7cHVzaDowLHJlcGx5OjEsYnJvYWRjYXN0OjJ9LGVuY29kZTpmdW5jdGlvbihlLHQpe2lmKGUucGF5bG9hZC5jb25zdHJ1Y3Rvcj09PUFycmF5QnVmZmVyKXJldHVybiB0KHRoaXMuYmluYXJ5RW5jb2RlKGUpKTt2YXIgbj1bZS5qb2luX3JlZixlLnJlZixlLnRvcGljLGUuZXZlbnQsZS5wYXlsb2FkXTtyZXR1cm4gdChKU09OLnN0cmluZ2lmeShuKSl9LGRlY29kZTpmdW5jdGlvbihlLHQpe2lmKGUuY29uc3RydWN0b3I9PT1BcnJheUJ1ZmZlcilyZXR1cm4gdCh0aGlzLmJpbmFyeURlY29kZShlKSk7dmFyIG49cihKU09OLnBhcnNlKGUpLDUpO3JldHVybiB0KHtqb2luX3JlZjpuWzBdLHJlZjpuWzFdLHRvcGljOm5bMl0sZXZlbnQ6blszXSxwYXlsb2FkOm5bNF19KX0sYmluYXJ5RW5jb2RlOmZ1bmN0aW9uKGUpe3ZhciB0PWUuam9pbl9yZWYsbj1lLnJlZixpPWUuZXZlbnQsbz1lLnRvcGljLHI9ZS5wYXlsb2FkLHM9dGhpcy5NRVRBX0xFTkdUSCt0Lmxlbmd0aCtuLmxlbmd0aCtvLmxlbmd0aCtpLmxlbmd0aCxhPW5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEgrcyksYz1uZXcgRGF0YVZpZXcoYSksdT0wO2Muc2V0VWludDgodSsrLHRoaXMuS0lORFMucHVzaCksYy5zZXRVaW50OCh1KyssdC5sZW5ndGgpLGMuc2V0VWludDgodSsrLG4ubGVuZ3RoKSxjLnNldFVpbnQ4KHUrKyxvLmxlbmd0aCksYy5zZXRVaW50OCh1KyssaS5sZW5ndGgpLEFycmF5LmZyb20odCwoZnVuY3Rpb24oZSl7cmV0dXJuIGMuc2V0VWludDgodSsrLGUuY2hhckNvZGVBdCgwKSl9KSksQXJyYXkuZnJvbShuLChmdW5jdGlvbihlKXtyZXR1cm4gYy5zZXRVaW50OCh1KyssZS5jaGFyQ29kZUF0KDApKX0pKSxBcnJheS5mcm9tKG8sKGZ1bmN0aW9uKGUpe3JldHVybiBjLnNldFVpbnQ4KHUrKyxlLmNoYXJDb2RlQXQoMCkpfSkpLEFycmF5LmZyb20oaSwoZnVuY3Rpb24oZSl7cmV0dXJuIGMuc2V0VWludDgodSsrLGUuY2hhckNvZGVBdCgwKSl9KSk7dmFyIGg9bmV3IFVpbnQ4QXJyYXkoYS5ieXRlTGVuZ3RoK3IuYnl0ZUxlbmd0aCk7cmV0dXJuIGguc2V0KG5ldyBVaW50OEFycmF5KGEpLDApLGguc2V0KG5ldyBVaW50OEFycmF5KHIpLGEuYnl0ZUxlbmd0aCksaC5idWZmZXJ9LGJpbmFyeURlY29kZTpmdW5jdGlvbihlKXt2YXIgdD1uZXcgRGF0YVZpZXcoZSksbj10LmdldFVpbnQ4KDApLGk9bmV3IFRleHREZWNvZGVyO3N3aXRjaChuKXtjYXNlIHRoaXMuS0lORFMucHVzaDpyZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGUsdCxpKTtjYXNlIHRoaXMuS0lORFMucmVwbHk6cmV0dXJuIHRoaXMuZGVjb2RlUmVwbHkoZSx0LGkpO2Nhc2UgdGhpcy5LSU5EUy5icm9hZGNhc3Q6cmV0dXJuIHRoaXMuZGVjb2RlQnJvYWRjYXN0KGUsdCxpKX19LGRlY29kZVB1c2g6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXQuZ2V0VWludDgoMSksbz10LmdldFVpbnQ4KDIpLHI9dC5nZXRVaW50OCgzKSxzPXRoaXMuSEVBREVSX0xFTkdUSCt0aGlzLk1FVEFfTEVOR1RILTEsYT1uLmRlY29kZShlLnNsaWNlKHMscytpKSk7cys9aTt2YXIgYz1uLmRlY29kZShlLnNsaWNlKHMscytvKSk7cys9bzt2YXIgdT1uLmRlY29kZShlLnNsaWNlKHMscytyKSk7cmV0dXJuIHMrPXIse2pvaW5fcmVmOmEscmVmOm51bGwsdG9waWM6YyxldmVudDp1LHBheWxvYWQ6ZS5zbGljZShzLGUuYnl0ZUxlbmd0aCl9fSxkZWNvZGVSZXBseTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dC5nZXRVaW50OCgxKSxvPXQuZ2V0VWludDgoMikscj10LmdldFVpbnQ4KDMpLHM9dC5nZXRVaW50OCg0KSxhPXRoaXMuSEVBREVSX0xFTkdUSCt0aGlzLk1FVEFfTEVOR1RILGM9bi5kZWNvZGUoZS5zbGljZShhLGEraSkpO2ErPWk7dmFyIHU9bi5kZWNvZGUoZS5zbGljZShhLGErbykpO2ErPW87dmFyIGg9bi5kZWNvZGUoZS5zbGljZShhLGErcikpO2ErPXI7dmFyIGw9bi5kZWNvZGUoZS5zbGljZShhLGErcykpO2ErPXM7dmFyIGY9ZS5zbGljZShhLGUuYnl0ZUxlbmd0aCk7cmV0dXJue2pvaW5fcmVmOmMscmVmOnUsdG9waWM6aCxldmVudDpTLHBheWxvYWQ6e3N0YXR1czpsLHJlc3BvbnNlOmZ9fX0sZGVjb2RlQnJvYWRjYXN0OmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10LmdldFVpbnQ4KDEpLG89dC5nZXRVaW50OCgyKSxyPXRoaXMuSEVBREVSX0xFTkdUSCsyLHM9bi5kZWNvZGUoZS5zbGljZShyLHIraSkpO3IrPWk7dmFyIGE9bi5kZWNvZGUoZS5zbGljZShyLHIrbykpO3JldHVybiByKz1vLHtqb2luX3JlZjpudWxsLHJlZjpudWxsLHRvcGljOnMsZXZlbnQ6YSxwYXlsb2FkOmUuc2xpY2UocixlLmJ5dGVMZW5ndGgpfX19LFU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3ZhciBuPXRoaXMsaT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307Yyh0aGlzLGUpLHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3M9e29wZW46W10sY2xvc2U6W10sZXJyb3I6W10sbWVzc2FnZTpbXX0sdGhpcy5jaGFubmVscz1bXSx0aGlzLnNlbmRCdWZmZXI9W10sdGhpcy5yZWY9MCx0aGlzLnRpbWVvdXQ9aS50aW1lb3V0fHwxZTQsdGhpcy50cmFuc3BvcnQ9aS50cmFuc3BvcnR8fGQuV2ViU29ja2V0fHxELHRoaXMuZGVmYXVsdEVuY29kZXI9SC5lbmNvZGUuYmluZChIKSx0aGlzLmRlZmF1bHREZWNvZGVyPUguZGVjb2RlLmJpbmQoSCksdGhpcy5jbG9zZVdhc0NsZWFuPSExLHRoaXMudW5sb2FkZWQ9ITEsdGhpcy5iaW5hcnlUeXBlPWkuYmluYXJ5VHlwZXx8XCJhcnJheWJ1ZmZlclwiLHRoaXMudHJhbnNwb3J0IT09RD8odGhpcy5lbmNvZGU9aS5lbmNvZGV8fHRoaXMuZGVmYXVsdEVuY29kZXIsdGhpcy5kZWNvZGU9aS5kZWNvZGV8fHRoaXMuZGVmYXVsdERlY29kZXIpOih0aGlzLmVuY29kZT10aGlzLmRlZmF1bHRFbmNvZGVyLHRoaXMuZGVjb2RlPXRoaXMuZGVmYXVsdERlY29kZXIpLGYmJmYuYWRkRXZlbnRMaXN0ZW5lciYmZi5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsKGZ1bmN0aW9uKGUpe24uY29ubiYmKG4udW5sb2FkZWQ9ITAsbi5hYm5vcm1hbENsb3NlKFwidW5sb2FkZWRcIikpfSkpLHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcz1pLmhlYXJ0YmVhdEludGVydmFsTXN8fDNlNCx0aGlzLnJlam9pbkFmdGVyTXM9ZnVuY3Rpb24oZSl7cmV0dXJuIGkucmVqb2luQWZ0ZXJNcz9pLnJlam9pbkFmdGVyTXMoZSk6WzFlMywyZTMsNWUzXVtlLTFdfHwxZTR9LHRoaXMucmVjb25uZWN0QWZ0ZXJNcz1mdW5jdGlvbihlKXtyZXR1cm4gbi51bmxvYWRlZD8xMDA6aS5yZWNvbm5lY3RBZnRlck1zP2kucmVjb25uZWN0QWZ0ZXJNcyhlKTpbMTAsNTAsMTAwLDE1MCwyMDAsMjUwLDUwMCwxZTMsMmUzXVtlLTFdfHw1ZTN9LHRoaXMubG9nZ2VyPWkubG9nZ2VyfHxudWxsLHRoaXMubG9uZ3BvbGxlclRpbWVvdXQ9aS5sb25ncG9sbGVyVGltZW91dHx8MmU0LHRoaXMucGFyYW1zPU8oaS5wYXJhbXN8fHt9KSx0aGlzLmVuZFBvaW50PVwiXCIuY29uY2F0KHQsXCIvXCIpLmNvbmNhdCh4KSx0aGlzLnZzbj1pLnZzbnx8XCIyLjAuMFwiLHRoaXMuaGVhcnRiZWF0VGltZXI9bnVsbCx0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWY9bnVsbCx0aGlzLnJlY29ubmVjdFRpbWVyPW5ldyBKKChmdW5jdGlvbigpe24udGVhcmRvd24oKGZ1bmN0aW9uKCl7cmV0dXJuIG4uY29ubmVjdCgpfSkpfSksdGhpcy5yZWNvbm5lY3RBZnRlck1zKX1yZXR1cm4gaChlLFt7a2V5OlwicHJvdG9jb2xcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBsb2NhdGlvbi5wcm90b2NvbC5tYXRjaCgvXmh0dHBzLyk/XCJ3c3NcIjpcIndzXCJ9fSx7a2V5OlwiZW5kUG9pbnRVUkxcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPU0uYXBwZW5kUGFyYW1zKE0uYXBwZW5kUGFyYW1zKHRoaXMuZW5kUG9pbnQsdGhpcy5wYXJhbXMoKSkse3Zzbjp0aGlzLnZzbn0pO3JldHVyblwiL1wiIT09ZS5jaGFyQXQoMCk/ZTpcIi9cIj09PWUuY2hhckF0KDEpP1wiXCIuY29uY2F0KHRoaXMucHJvdG9jb2woKSxcIjpcIikuY29uY2F0KGUpOlwiXCIuY29uY2F0KHRoaXMucHJvdG9jb2woKSxcIjovL1wiKS5jb25jYXQobG9jYXRpb24uaG9zdCkuY29uY2F0KGUpfX0se2tleTpcImRpc2Nvbm5lY3RcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dGhpcy5jbG9zZVdhc0NsZWFuPSEwLHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKSx0aGlzLnRlYXJkb3duKGUsdCxuKX19LHtrZXk6XCJjb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztlJiYoY29uc29sZSYmY29uc29sZS5sb2coXCJwYXNzaW5nIHBhcmFtcyB0byBjb25uZWN0IGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgcGFzcyA6cGFyYW1zIHRvIHRoZSBTb2NrZXQgY29uc3RydWN0b3JcIiksdGhpcy5wYXJhbXM9TyhlKSksdGhpcy5jb25ufHwodGhpcy5jbG9zZVdhc0NsZWFuPSExLHRoaXMuY29ubj1uZXcgdGhpcy50cmFuc3BvcnQodGhpcy5lbmRQb2ludFVSTCgpKSx0aGlzLmNvbm4uYmluYXJ5VHlwZT10aGlzLmJpbmFyeVR5cGUsdGhpcy5jb25uLnRpbWVvdXQ9dGhpcy5sb25ncG9sbGVyVGltZW91dCx0aGlzLmNvbm4ub25vcGVuPWZ1bmN0aW9uKCl7cmV0dXJuIHQub25Db25uT3BlbigpfSx0aGlzLmNvbm4ub25lcnJvcj1mdW5jdGlvbihlKXtyZXR1cm4gdC5vbkNvbm5FcnJvcihlKX0sdGhpcy5jb25uLm9ubWVzc2FnZT1mdW5jdGlvbihlKXtyZXR1cm4gdC5vbkNvbm5NZXNzYWdlKGUpfSx0aGlzLmNvbm4ub25jbG9zZT1mdW5jdGlvbihlKXtyZXR1cm4gdC5vbkNvbm5DbG9zZShlKX0pfX0se2tleTpcImxvZ1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt0aGlzLmxvZ2dlcihlLHQsbil9fSx7a2V5OlwiaGFzTG9nZ2VyXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMubG9nZ2VyfX0se2tleTpcIm9uT3BlblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMubWFrZVJlZigpO3JldHVybiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4ucHVzaChbdCxlXSksdH19LHtrZXk6XCJvbkNsb3NlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5tYWtlUmVmKCk7cmV0dXJuIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbdCxlXSksdH19LHtrZXk6XCJvbkVycm9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5tYWtlUmVmKCk7cmV0dXJuIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuZXJyb3IucHVzaChbdCxlXSksdH19LHtrZXk6XCJvbk1lc3NhZ2VcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLm1ha2VSZWYoKTtyZXR1cm4gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLnB1c2goW3QsZV0pLHR9fSx7a2V5Olwib25Db25uT3BlblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5oYXNMb2dnZXIoKSYmdGhpcy5sb2coXCJ0cmFuc3BvcnRcIixcImNvbm5lY3RlZCB0byBcIi5jb25jYXQodGhpcy5lbmRQb2ludFVSTCgpKSksdGhpcy51bmxvYWRlZD0hMSx0aGlzLmNsb3NlV2FzQ2xlYW49ITEsdGhpcy5mbHVzaFNlbmRCdWZmZXIoKSx0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KCksdGhpcy5yZXNldEhlYXJ0YmVhdCgpLHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5mb3JFYWNoKChmdW5jdGlvbihlKXtyZXR1cm4oMCxyKGUsMilbMV0pKCl9KSl9fSx7a2V5OlwicmVzZXRIZWFydGJlYXRcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5jb25uJiZ0aGlzLmNvbm4uc2tpcEhlYXJ0YmVhdHx8KHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZj1udWxsLGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRUaW1lciksdGhpcy5oZWFydGJlYXRUaW1lcj1zZXRJbnRlcnZhbCgoZnVuY3Rpb24oKXtyZXR1cm4gZS5zZW5kSGVhcnRiZWF0KCl9KSx0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpKX19LHtrZXk6XCJ0ZWFyZG93blwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzO2lmKCF0aGlzLmNvbm4pcmV0dXJuIGUmJmUoKTt0aGlzLndhaXRGb3JCdWZmZXJEb25lKChmdW5jdGlvbigpe2kuY29ubiYmKHQ/aS5jb25uLmNsb3NlKHQsbnx8XCJcIik6aS5jb25uLmNsb3NlKCkpLGkud2FpdEZvclNvY2tldENsb3NlZCgoZnVuY3Rpb24oKXtpLmNvbm4mJihpLmNvbm4ub25jbG9zZT1mdW5jdGlvbigpe30saS5jb25uPW51bGwpLGUmJmUoKX0pKX0pKX19LHtrZXk6XCJ3YWl0Rm9yQnVmZmVyRG9uZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MTs1IT09biYmdGhpcy5jb25uJiZ0aGlzLmNvbm4uYnVmZmVyZWRBbW91bnQ/c2V0VGltZW91dCgoZnVuY3Rpb24oKXt0LndhaXRGb3JCdWZmZXJEb25lKGUsbisxKX0pLDE1MCpuKTplKCl9fSx7a2V5Olwid2FpdEZvclNvY2tldENsb3NlZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MTs1IT09biYmdGhpcy5jb25uJiZ0aGlzLmNvbm4ucmVhZHlTdGF0ZSE9PW0/c2V0VGltZW91dCgoZnVuY3Rpb24oKXt0LndhaXRGb3JTb2NrZXRDbG9zZWQoZSxuKzEpfSksMTUwKm4pOmUoKX19LHtrZXk6XCJvbkNvbm5DbG9zZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuaGFzTG9nZ2VyKCkmJnRoaXMubG9nKFwidHJhbnNwb3J0XCIsXCJjbG9zZVwiLGUpLHRoaXMudHJpZ2dlckNoYW5FcnJvcigpLGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRUaW1lciksdGhpcy5jbG9zZVdhc0NsZWFufHx0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpLHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoZnVuY3Rpb24odCl7cmV0dXJuKDAscih0LDIpWzFdKShlKX0pKX19LHtrZXk6XCJvbkNvbm5FcnJvclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuaGFzTG9nZ2VyKCkmJnRoaXMubG9nKFwidHJhbnNwb3J0XCIsZSksdGhpcy50cmlnZ2VyQ2hhbkVycm9yKCksdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4oMCxyKHQsMilbMV0pKGUpfSkpfX0se2tleTpcInRyaWdnZXJDaGFuRXJyb3JcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuY2hhbm5lbHMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7ZS5pc0Vycm9yZWQoKXx8ZS5pc0xlYXZpbmcoKXx8ZS5pc0Nsb3NlZCgpfHxlLnRyaWdnZXIoUil9KSl9fSx7a2V5OlwiY29ubmVjdGlvblN0YXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5jb25uJiZ0aGlzLmNvbm4ucmVhZHlTdGF0ZSl7Y2FzZSBwOnJldHVyblwiY29ubmVjdGluZ1wiO2Nhc2UgdjpyZXR1cm5cIm9wZW5cIjtjYXNlIHk6cmV0dXJuXCJjbG9zaW5nXCI7ZGVmYXVsdDpyZXR1cm5cImNsb3NlZFwifX19LHtrZXk6XCJpc0Nvbm5lY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJvcGVuXCI9PT10aGlzLmNvbm5lY3Rpb25TdGF0ZSgpfX0se2tleTpcInJlbW92ZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMub2ZmKGUuc3RhdGVDaGFuZ2VSZWZzKSx0aGlzLmNoYW5uZWxzPXRoaXMuY2hhbm5lbHMuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5qb2luUmVmKCkhPT1lLmpvaW5SZWYoKX0pKX19LHtrZXk6XCJvZmZcIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQgaW4gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcyl0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW3RdPXRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3NbdF0uZmlsdGVyKChmdW5jdGlvbih0KXt2YXIgbj1yKHQsMSlbMF07cmV0dXJuLTE9PT1lLmluZGV4T2Yobil9KSl9fSx7a2V5OlwiY2hhbm5lbFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fSxuPW5ldyBfKGUsdCx0aGlzKTtyZXR1cm4gdGhpcy5jaGFubmVscy5wdXNoKG4pLG59fSx7a2V5OlwicHVzaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYodGhpcy5oYXNMb2dnZXIoKSl7dmFyIG49ZS50b3BpYyxpPWUuZXZlbnQsbz1lLnBheWxvYWQscj1lLnJlZixzPWUuam9pbl9yZWY7dGhpcy5sb2coXCJwdXNoXCIsXCJcIi5jb25jYXQobixcIiBcIikuY29uY2F0KGksXCIgKFwiKS5jb25jYXQocyxcIiwgXCIpLmNvbmNhdChyLFwiKVwiKSxvKX10aGlzLmlzQ29ubmVjdGVkKCk/dGhpcy5lbmNvZGUoZSwoZnVuY3Rpb24oZSl7cmV0dXJuIHQuY29ubi5zZW5kKGUpfSkpOnRoaXMuc2VuZEJ1ZmZlci5wdXNoKChmdW5jdGlvbigpe3JldHVybiB0LmVuY29kZShlLChmdW5jdGlvbihlKXtyZXR1cm4gdC5jb25uLnNlbmQoZSl9KSl9KSl9fSx7a2V5OlwibWFrZVJlZlwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5yZWYrMTtyZXR1cm4gZT09PXRoaXMucmVmP3RoaXMucmVmPTA6dGhpcy5yZWY9ZSx0aGlzLnJlZi50b1N0cmluZygpfX0se2tleTpcInNlbmRIZWFydGJlYXRcIix2YWx1ZTpmdW5jdGlvbigpe2lmKHRoaXMuaXNDb25uZWN0ZWQoKSl7aWYodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKXJldHVybiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWY9bnVsbCx0aGlzLmhhc0xvZ2dlcigpJiZ0aGlzLmxvZyhcInRyYW5zcG9ydFwiLFwiaGVhcnRiZWF0IHRpbWVvdXQuIEF0dGVtcHRpbmcgdG8gcmUtZXN0YWJsaXNoIGNvbm5lY3Rpb25cIiksdm9pZCB0aGlzLmFibm9ybWFsQ2xvc2UoXCJoZWFydGJlYXQgdGltZW91dFwiKTt0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWY9dGhpcy5tYWtlUmVmKCksdGhpcy5wdXNoKHt0b3BpYzpcInBob2VuaXhcIixldmVudDpcImhlYXJ0YmVhdFwiLHBheWxvYWQ6e30scmVmOnRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZn0pfX19LHtrZXk6XCJhYm5vcm1hbENsb3NlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5jbG9zZVdhc0NsZWFuPSExLHRoaXMuY29ubi5yZWFkeVN0YXRlPT09diYmdGhpcy5jb25uLmNsb3NlKDFlMyxlKX19LHtrZXk6XCJmbHVzaFNlbmRCdWZmZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaXNDb25uZWN0ZWQoKSYmdGhpcy5zZW5kQnVmZmVyLmxlbmd0aD4wJiYodGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKGZ1bmN0aW9uKGUpe3JldHVybiBlKCl9KSksdGhpcy5zZW5kQnVmZmVyPVtdKX19LHtrZXk6XCJvbkNvbm5NZXNzYWdlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aGlzLmRlY29kZShlLmRhdGEsKGZ1bmN0aW9uKGUpe3ZhciBuPWUudG9waWMsaT1lLmV2ZW50LG89ZS5wYXlsb2FkLHM9ZS5yZWYsYT1lLmpvaW5fcmVmO3MmJnM9PT10LnBlbmRpbmdIZWFydGJlYXRSZWYmJih0LnBlbmRpbmdIZWFydGJlYXRSZWY9bnVsbCksdC5oYXNMb2dnZXIoKSYmdC5sb2coXCJyZWNlaXZlXCIsXCJcIi5jb25jYXQoby5zdGF0dXN8fFwiXCIsXCIgXCIpLmNvbmNhdChuLFwiIFwiKS5jb25jYXQoaSxcIiBcIikuY29uY2F0KHMmJlwiKFwiK3MrXCIpXCJ8fFwiXCIpLG8pO2Zvcih2YXIgYz0wO2M8dC5jaGFubmVscy5sZW5ndGg7YysrKXt2YXIgdT10LmNoYW5uZWxzW2NdO3UuaXNNZW1iZXIobixpLG8sYSkmJnUudHJpZ2dlcihpLG8scyxhKX1mb3IodmFyIGg9MDtoPHQuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5sZW5ndGg7aCsrKXsoMCxyKHQuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZVtoXSwyKVsxXSkoZSl9fSkpfX0se2tleTpcImxlYXZlT3BlblRvcGljXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5jaGFubmVscy5maW5kKChmdW5jdGlvbih0KXtyZXR1cm4gdC50b3BpYz09PWUmJih0LmlzSm9pbmVkKCl8fHQuaXNKb2luaW5nKCkpfSkpO3QmJih0aGlzLmhhc0xvZ2dlcigpJiZ0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCdsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIicuY29uY2F0KGUsJ1wiJykpLHQubGVhdmUoKSl9fV0pLGV9KCksRD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7Yyh0aGlzLGUpLHRoaXMuZW5kUG9pbnQ9bnVsbCx0aGlzLnRva2VuPW51bGwsdGhpcy5za2lwSGVhcnRiZWF0PSEwLHRoaXMub25vcGVuPWZ1bmN0aW9uKCl7fSx0aGlzLm9uZXJyb3I9ZnVuY3Rpb24oKXt9LHRoaXMub25tZXNzYWdlPWZ1bmN0aW9uKCl7fSx0aGlzLm9uY2xvc2U9ZnVuY3Rpb24oKXt9LHRoaXMucG9sbEVuZHBvaW50PXRoaXMubm9ybWFsaXplRW5kcG9pbnQodCksdGhpcy5yZWFkeVN0YXRlPXAsdGhpcy5wb2xsKCl9cmV0dXJuIGgoZSxbe2tleTpcIm5vcm1hbGl6ZUVuZHBvaW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVwbGFjZShcIndzOi8vXCIsXCJodHRwOi8vXCIpLnJlcGxhY2UoXCJ3c3M6Ly9cIixcImh0dHBzOi8vXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChcIiguKikvXCIreCksXCIkMS9cIitMKX19LHtrZXk6XCJlbmRwb2ludFVSTFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIE0uYXBwZW5kUGFyYW1zKHRoaXMucG9sbEVuZHBvaW50LHt0b2tlbjp0aGlzLnRva2VufSl9fSx7a2V5OlwiY2xvc2VBbmRSZXRyeVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5jbG9zZSgpLHRoaXMucmVhZHlTdGF0ZT1wfX0se2tleTpcIm9udGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5vbmVycm9yKFwidGltZW91dFwiKSx0aGlzLmNsb3NlQW5kUmV0cnkoKX19LHtrZXk6XCJwb2xsXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucmVhZHlTdGF0ZSE9PXYmJnRoaXMucmVhZHlTdGF0ZSE9PXB8fE0ucmVxdWVzdChcIkdFVFwiLHRoaXMuZW5kcG9pbnRVUkwoKSxcImFwcGxpY2F0aW9uL2pzb25cIixudWxsLHRoaXMudGltZW91dCx0aGlzLm9udGltZW91dC5iaW5kKHRoaXMpLChmdW5jdGlvbih0KXtpZih0KXt2YXIgbj10LnN0YXR1cyxpPXQudG9rZW4sbz10Lm1lc3NhZ2VzO2UudG9rZW49aX1lbHNlIG49MDtzd2l0Y2gobil7Y2FzZSAyMDA6by5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gZS5vbm1lc3NhZ2Uoe2RhdGE6dH0pfSkpLGUucG9sbCgpO2JyZWFrO2Nhc2UgMjA0OmUucG9sbCgpO2JyZWFrO2Nhc2UgNDEwOmUucmVhZHlTdGF0ZT12LGUub25vcGVuKCksZS5wb2xsKCk7YnJlYWs7Y2FzZSA0MDM6ZS5vbmVycm9yKCksZS5jbG9zZSgpO2JyZWFrO2Nhc2UgMDpjYXNlIDUwMDplLm9uZXJyb3IoKSxlLmNsb3NlQW5kUmV0cnkoKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVuaGFuZGxlZCBwb2xsIHN0YXR1cyBcIi5jb25jYXQobikpfX0pKX19LHtrZXk6XCJzZW5kXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztNLnJlcXVlc3QoXCJQT1NUXCIsdGhpcy5lbmRwb2ludFVSTCgpLFwiYXBwbGljYXRpb24vanNvblwiLGUsdGhpcy50aW1lb3V0LHRoaXMub25lcnJvci5iaW5kKHRoaXMsXCJ0aW1lb3V0XCIpLChmdW5jdGlvbihlKXtlJiYyMDA9PT1lLnN0YXR1c3x8KHQub25lcnJvcihlJiZlLnN0YXR1cyksdC5jbG9zZUFuZFJldHJ5KCkpfSkpfX0se2tleTpcImNsb3NlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLnJlYWR5U3RhdGU9bSx0aGlzLm9uY2xvc2UoKX19XSksZX0oKSxNPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe2ModGhpcyxlKX1yZXR1cm4gaChlLG51bGwsW3trZXk6XCJyZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxvLHIscyl7aWYoZC5YRG9tYWluUmVxdWVzdCl7dmFyIGE9bmV3IFhEb21haW5SZXF1ZXN0O3RoaXMueGRvbWFpblJlcXVlc3QoYSxlLHQsaSxvLHIscyl9ZWxzZXt2YXIgYz1uZXcgZC5YTUxIdHRwUmVxdWVzdDt0aGlzLnhoclJlcXVlc3QoYyxlLHQsbixpLG8scixzKX19fSx7a2V5OlwieGRvbWFpblJlcXVlc3RcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpLG8scixzKXt2YXIgYT10aGlzO2UudGltZW91dD1vLGUub3Blbih0LG4pLGUub25sb2FkPWZ1bmN0aW9uKCl7dmFyIHQ9YS5wYXJzZUpTT04oZS5yZXNwb25zZVRleHQpO3MmJnModCl9LHImJihlLm9udGltZW91dD1yKSxlLm9ucHJvZ3Jlc3M9ZnVuY3Rpb24oKXt9LGUuc2VuZChpKX19LHtrZXk6XCJ4aHJSZXF1ZXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxvLHIscyxhKXt2YXIgYz10aGlzO2Uub3Blbih0LG4sITApLGUudGltZW91dD1yLGUuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLGkpLGUub25lcnJvcj1mdW5jdGlvbigpe2EmJmEobnVsbCl9LGUub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoZS5yZWFkeVN0YXRlPT09Yy5zdGF0ZXMuY29tcGxldGUmJmEpe3ZhciB0PWMucGFyc2VKU09OKGUucmVzcG9uc2VUZXh0KTthKHQpfX0scyYmKGUub250aW1lb3V0PXMpLGUuc2VuZChvKX19LHtrZXk6XCJwYXJzZUpTT05cIix2YWx1ZTpmdW5jdGlvbihlKXtpZighZXx8XCJcIj09PWUpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBKU09OLnBhcnNlKGUpfWNhdGNoKHQpe3JldHVybiBjb25zb2xlJiZjb25zb2xlLmxvZyhcImZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlXCIsZSksbnVsbH19fSx7a2V5Olwic2VyaWFsaXplXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1bXTtmb3IodmFyIGkgaW4gZSlpZihlLmhhc093blByb3BlcnR5KGkpKXt2YXIgcj10P1wiXCIuY29uY2F0KHQsXCJbXCIpLmNvbmNhdChpLFwiXVwiKTppLHM9ZVtpXTtcIm9iamVjdFwiPT09byhzKT9uLnB1c2godGhpcy5zZXJpYWxpemUocyxyKSk6bi5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChyKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQocykpfXJldHVybiBuLmpvaW4oXCImXCIpfX0se2tleTpcImFwcGVuZFBhcmFtc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoMD09PU9iamVjdC5rZXlzKHQpLmxlbmd0aClyZXR1cm4gZTt2YXIgbj1lLm1hdGNoKC9cXD8vKT9cIiZcIjpcIj9cIjtyZXR1cm5cIlwiLmNvbmNhdChlKS5jb25jYXQobikuY29uY2F0KHRoaXMuc2VyaWFsaXplKHQpKX19XSksZX0oKTtNLnN0YXRlcz17Y29tcGxldGU6NH07dmFyIE49ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3ZhciBuPXRoaXMsaT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307Yyh0aGlzLGUpO3ZhciBvPWkuZXZlbnRzfHx7c3RhdGU6XCJwcmVzZW5jZV9zdGF0ZVwiLGRpZmY6XCJwcmVzZW5jZV9kaWZmXCJ9O3RoaXMuc3RhdGU9e30sdGhpcy5wZW5kaW5nRGlmZnM9W10sdGhpcy5jaGFubmVsPXQsdGhpcy5qb2luUmVmPW51bGwsdGhpcy5jYWxsZXI9e29uSm9pbjpmdW5jdGlvbigpe30sb25MZWF2ZTpmdW5jdGlvbigpe30sb25TeW5jOmZ1bmN0aW9uKCl7fX0sdGhpcy5jaGFubmVsLm9uKG8uc3RhdGUsKGZ1bmN0aW9uKHQpe3ZhciBpPW4uY2FsbGVyLG89aS5vbkpvaW4scj1pLm9uTGVhdmUscz1pLm9uU3luYztuLmpvaW5SZWY9bi5jaGFubmVsLmpvaW5SZWYoKSxuLnN0YXRlPWUuc3luY1N0YXRlKG4uc3RhdGUsdCxvLHIpLG4ucGVuZGluZ0RpZmZzLmZvckVhY2goKGZ1bmN0aW9uKHQpe24uc3RhdGU9ZS5zeW5jRGlmZihuLnN0YXRlLHQsbyxyKX0pKSxuLnBlbmRpbmdEaWZmcz1bXSxzKCl9KSksdGhpcy5jaGFubmVsLm9uKG8uZGlmZiwoZnVuY3Rpb24odCl7dmFyIGk9bi5jYWxsZXIsbz1pLm9uSm9pbixyPWkub25MZWF2ZSxzPWkub25TeW5jO24uaW5QZW5kaW5nU3luY1N0YXRlKCk/bi5wZW5kaW5nRGlmZnMucHVzaCh0KToobi5zdGF0ZT1lLnN5bmNEaWZmKG4uc3RhdGUsdCxvLHIpLHMoKSl9KSl9cmV0dXJuIGgoZSxbe2tleTpcIm9uSm9pblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuY2FsbGVyLm9uSm9pbj1lfX0se2tleTpcIm9uTGVhdmVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmNhbGxlci5vbkxlYXZlPWV9fSx7a2V5Olwib25TeW5jXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5jYWxsZXIub25TeW5jPWV9fSx7a2V5OlwibGlzdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiBlLmxpc3QodGhpcy5zdGF0ZSx0KX19LHtrZXk6XCJpblBlbmRpbmdTeW5jU3RhdGVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiF0aGlzLmpvaW5SZWZ8fHRoaXMuam9pblJlZiE9PXRoaXMuY2hhbm5lbC5qb2luUmVmKCl9fV0sW3trZXk6XCJzeW5jU3RhdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpKXt2YXIgbz10aGlzLHI9dGhpcy5jbG9uZShlKSxzPXt9LGE9e307cmV0dXJuIHRoaXMubWFwKHIsKGZ1bmN0aW9uKGUsbil7dFtlXXx8KGFbZV09bil9KSksdGhpcy5tYXAodCwoZnVuY3Rpb24oZSx0KXt2YXIgbj1yW2VdO2lmKG4pe3ZhciBpPXQubWV0YXMubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5waHhfcmVmfSkpLGM9bi5tZXRhcy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnBoeF9yZWZ9KSksdT10Lm1ldGFzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGMuaW5kZXhPZihlLnBoeF9yZWYpPDB9KSksaD1uLm1ldGFzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGkuaW5kZXhPZihlLnBoeF9yZWYpPDB9KSk7dS5sZW5ndGg+MCYmKHNbZV09dCxzW2VdLm1ldGFzPXUpLGgubGVuZ3RoPjAmJihhW2VdPW8uY2xvbmUobiksYVtlXS5tZXRhcz1oKX1lbHNlIHNbZV09dH0pKSx0aGlzLnN5bmNEaWZmKHIse2pvaW5zOnMsbGVhdmVzOmF9LG4saSl9fSx7a2V5Olwic3luY0RpZmZcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixvKXt2YXIgcj10LmpvaW5zLHM9dC5sZWF2ZXMsYT10aGlzLmNsb25lKGUpO3JldHVybiBufHwobj1mdW5jdGlvbigpe30pLG98fChvPWZ1bmN0aW9uKCl7fSksdGhpcy5tYXAociwoZnVuY3Rpb24oZSx0KXt2YXIgbz1hW2VdO2lmKGFbZV09dCxvKXt2YXIgcixzPWFbZV0ubWV0YXMubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gZS5waHhfcmVmfSkpLGM9by5tZXRhcy5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBzLmluZGV4T2YoZS5waHhfcmVmKTwwfSkpOyhyPWFbZV0ubWV0YXMpLnVuc2hpZnQuYXBwbHkocixpKGMpKX1uKGUsbyx0KX0pKSx0aGlzLm1hcChzLChmdW5jdGlvbihlLHQpe3ZhciBuPWFbZV07aWYobil7dmFyIGk9dC5tZXRhcy5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnBoeF9yZWZ9KSk7bi5tZXRhcz1uLm1ldGFzLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGkuaW5kZXhPZihlLnBoeF9yZWYpPDB9KSksbyhlLG4sdCksMD09PW4ubWV0YXMubGVuZ3RoJiZkZWxldGUgYVtlXX19KSksYX19LHtrZXk6XCJsaXN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8KHQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH0pLHRoaXMubWFwKGUsKGZ1bmN0aW9uKGUsbil7cmV0dXJuIHQoZSxuKX0pKX19LHtrZXk6XCJtYXBcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlKS5tYXAoKGZ1bmN0aW9uKG4pe3JldHVybiB0KG4sZVtuXSl9KSl9fSx7a2V5OlwiY2xvbmVcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlKSl9fV0pLGV9KCksSj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuKXtjKHRoaXMsZSksdGhpcy5jYWxsYmFjaz10LHRoaXMudGltZXJDYWxjPW4sdGhpcy50aW1lcj1udWxsLHRoaXMudHJpZXM9MH1yZXR1cm4gaChlLFt7a2V5OlwicmVzZXRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMudHJpZXM9MCxjbGVhclRpbWVvdXQodGhpcy50aW1lcil9fSx7a2V5Olwic2NoZWR1bGVUaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2NsZWFyVGltZW91dCh0aGlzLnRpbWVyKSx0aGlzLnRpbWVyPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZS50cmllcz1lLnRyaWVzKzEsZS5jYWxsYmFjaygpfSksdGhpcy50aW1lckNhbGModGhpcy50cmllcysxKSl9fV0pLGV9KCl9XSl9KSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../../deps/phoenix/priv/static/phoenix.js\n");

/***/ }),

/***/ "../../../deps/phoenix_html/priv/static/phoenix_html.js":
/*!****************************************************************************!*\
  !*** /home/aleak/src/feedex/deps/phoenix_html/priv/static/phoenix_html.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent; // IE<=9 Support\n\n    function CustomEvent(event, params) {\n      params = params || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        target = element.getAttribute(\"target\");\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n    if (target) form.target = target;\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function (e) {\n    var element = e.target;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true,\n        \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n\n    if (message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy9ob21lL2FsZWFrL3NyYy9mZWVkZXgvZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzP2UwNDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFBvbHlmaWxsRXZlbnQgPSBldmVudENvbnN0cnVjdG9yKCk7XG5cbiAgZnVuY3Rpb24gZXZlbnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gd2luZG93LkN1c3RvbUV2ZW50O1xuICAgIC8vIElFPD05IFN1cHBvcnRcbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge2J1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWR9O1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfVxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRIaWRkZW5JbnB1dChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGVsZW1lbnQpIHtcbiAgICB2YXIgdG8gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdG9cIiksXG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfbWV0aG9kXCIsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikpLFxuICAgICAgICBjc3JmID0gYnVpbGRIaWRkZW5JbnB1dChcIl9jc3JmX3Rva2VuXCIsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jc3JmXCIpKSxcbiAgICAgICAgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpLFxuICAgICAgICB0YXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblxuICAgIGZvcm0ubWV0aG9kID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikgPT09IFwiZ2V0XCIpID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGZvcm0uYWN0aW9uID0gdG87XG4gICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJoaWRkZW5cIjtcblxuICAgIGlmICh0YXJnZXQpIGZvcm0udGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgZm9ybS5hcHBlbmRDaGlsZChjc3JmKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKG1ldGhvZCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbiAgICBmb3JtLnN1Ym1pdCgpO1xuICB9XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBlLnRhcmdldDtcblxuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XG4gICAgICB2YXIgcGhvZW5peExpbmtFdmVudCA9IG5ldyBQb2x5ZmlsbEV2ZW50KCdwaG9lbml4LmxpbmsuY2xpY2snLCB7XG4gICAgICAgIFwiYnViYmxlc1wiOiB0cnVlLCBcImNhbmNlbGFibGVcIjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KHBob2VuaXhMaW5rRXZlbnQpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSkge1xuICAgICAgICBoYW5kbGVDbGljayhlbGVtZW50KTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwaG9lbml4LmxpbmsuY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtZXNzYWdlID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb25maXJtXCIpO1xuICAgIGlmKG1lc3NhZ2UgJiYgIXdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../../deps/phoenix_html/priv/static/phoenix_html.js\n");

/***/ }),

/***/ "../../../deps/phoenix_live_view/priv/static/phoenix_live_view.js":
/*!**************************************************************************************!*\
  !*** /home/aleak/src/feedex/deps/phoenix_live_view/priv/static/phoenix_live_view.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function (e, t) {\n   true ? module.exports = t() : undefined;\n}(this, function () {\n  return function (e) {\n    var t = {};\n\n    function n(i) {\n      if (t[i]) return t[i].exports;\n      var r = t[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return e[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, i) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        configurable: !1,\n        enumerable: !0,\n        get: i\n      });\n    }, n.r = function (e) {\n      Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 2);\n  }([function (e, t, n) {\n    \"use strict\";\n\n    n.r(t);\n    var i,\n        r = 11;\n    var o = \"http://www.w3.org/1999/xhtml\",\n        a = \"undefined\" == typeof document ? void 0 : document,\n        u = !!a && \"content\" in a.createElement(\"template\"),\n        s = !!a && a.createRange && \"createContextualFragment\" in a.createRange();\n\n    function c(e) {\n      return e = e.trim(), u ? function (e) {\n        var t = a.createElement(\"template\");\n        return t.innerHTML = e, t.content.childNodes[0];\n      }(e) : s ? function (e) {\n        return i || (i = a.createRange()).selectNode(a.body), i.createContextualFragment(e).childNodes[0];\n      }(e) : function (e) {\n        var t = a.createElement(\"body\");\n        return t.innerHTML = e, t.childNodes[0];\n      }(e);\n    }\n\n    function l(e, t) {\n      var n,\n          i,\n          r = e.nodeName,\n          o = t.nodeName;\n      return r === o || (n = r.charCodeAt(0), i = o.charCodeAt(0), n <= 90 && i >= 97 ? r === o.toUpperCase() : i <= 90 && n >= 97 && o === r.toUpperCase());\n    }\n\n    function d(e, t, n) {\n      e[n] !== t[n] && (e[n] = t[n], e[n] ? e.setAttribute(n, \"\") : e.removeAttribute(n));\n    }\n\n    var h = {\n      OPTION: function (e, t) {\n        var n = e.parentNode;\n\n        if (n) {\n          var i = n.nodeName.toUpperCase();\n          \"OPTGROUP\" === i && (i = (n = n.parentNode) && n.nodeName.toUpperCase()), \"SELECT\" !== i || n.hasAttribute(\"multiple\") || (e.hasAttribute(\"selected\") && !t.selected && (e.setAttribute(\"selected\", \"selected\"), e.removeAttribute(\"selected\")), n.selectedIndex = -1);\n        }\n\n        d(e, t, \"selected\");\n      },\n      INPUT: function (e, t) {\n        d(e, t, \"checked\"), d(e, t, \"disabled\"), e.value !== t.value && (e.value = t.value), t.hasAttribute(\"value\") || e.removeAttribute(\"value\");\n      },\n      TEXTAREA: function (e, t) {\n        var n = t.value;\n        e.value !== n && (e.value = n);\n        var i = e.firstChild;\n\n        if (i) {\n          var r = i.nodeValue;\n          if (r == n || !n && r == e.placeholder) return;\n          i.nodeValue = n;\n        }\n      },\n      SELECT: function (e, t) {\n        if (!t.hasAttribute(\"multiple\")) {\n          for (var n, i, r = -1, o = 0, a = e.firstChild; a;) if (\"OPTGROUP\" === (i = a.nodeName && a.nodeName.toUpperCase())) a = (n = a).firstChild;else {\n            if (\"OPTION\" === i) {\n              if (a.hasAttribute(\"selected\")) {\n                r = o;\n                break;\n              }\n\n              o++;\n            }\n\n            !(a = a.nextSibling) && n && (a = n.nextSibling, n = null);\n          }\n\n          e.selectedIndex = r;\n        }\n      }\n    },\n        f = 1,\n        v = 11,\n        p = 3,\n        g = 8;\n\n    function m() {}\n\n    function y(e) {\n      if (e) return e.getAttribute && e.getAttribute(\"id\") || e.id;\n    }\n\n    var b = function (e) {\n      return function (t, n, i) {\n        if (i || (i = {}), \"string\" == typeof n) if (\"#document\" === t.nodeName || \"HTML\" === t.nodeName || \"BODY\" === t.nodeName) {\n          var r = n;\n          (n = a.createElement(\"html\")).innerHTML = r;\n        } else n = c(n);\n        var u = i.getNodeKey || y,\n            s = i.onBeforeNodeAdded || m,\n            d = i.onNodeAdded || m,\n            b = i.onBeforeElUpdated || m,\n            k = i.onElUpdated || m,\n            w = i.onBeforeNodeDiscarded || m,\n            E = i.onNodeDiscarded || m,\n            A = i.onBeforeElChildrenUpdated || m,\n            S = !0 === i.childrenOnly,\n            x = Object.create(null),\n            C = [];\n\n        function P(e) {\n          C.push(e);\n        }\n\n        function L(e, t, n) {\n          !1 !== w(e) && (t && t.removeChild(e), E(e), function e(t, n) {\n            if (t.nodeType === f) for (var i = t.firstChild; i;) {\n              var r = void 0;\n              n && (r = u(i)) ? P(r) : (E(i), i.firstChild && e(i, n)), i = i.nextSibling;\n            }\n          }(e, n));\n        }\n\n        function I(e) {\n          d(e);\n\n          for (var t = e.firstChild; t;) {\n            var n = t.nextSibling,\n                i = u(t);\n\n            if (i) {\n              var r = x[i];\n              r && l(t, r) ? (t.parentNode.replaceChild(r, t), T(r, t)) : I(t);\n            } else I(t);\n\n            t = n;\n          }\n        }\n\n        function T(t, n, i) {\n          var r = u(n);\n\n          if (r && delete x[r], !i) {\n            if (!1 === b(t, n)) return;\n            if (e(t, n), k(t), !1 === A(t, n)) return;\n          }\n\n          \"TEXTAREA\" !== t.nodeName ? function (e, t) {\n            var n,\n                i,\n                r,\n                o,\n                c,\n                d = t.firstChild,\n                v = e.firstChild;\n\n            e: for (; d;) {\n              for (o = d.nextSibling, n = u(d); v;) {\n                if (r = v.nextSibling, d.isSameNode && d.isSameNode(v)) {\n                  d = o, v = r;\n                  continue e;\n                }\n\n                i = u(v);\n                var m = v.nodeType,\n                    y = void 0;\n\n                if (m === d.nodeType && (m === f ? (n ? n !== i && ((c = x[n]) ? r === c ? y = !1 : (e.insertBefore(c, v), i ? P(i) : L(v, e, !0), v = c) : y = !1) : i && (y = !1), (y = !1 !== y && l(v, d)) && T(v, d)) : m !== p && m != g || (y = !0, v.nodeValue !== d.nodeValue && (v.nodeValue = d.nodeValue))), y) {\n                  d = o, v = r;\n                  continue e;\n                }\n\n                i ? P(i) : L(v, e, !0), v = r;\n              }\n\n              if (n && (c = x[n]) && l(c, d)) e.appendChild(c), T(c, d);else {\n                var b = s(d);\n                !1 !== b && (b && (d = b), d.actualize && (d = d.actualize(e.ownerDocument || a)), e.appendChild(d), I(d));\n              }\n              d = o, v = r;\n            }\n\n            !function (e, t, n) {\n              for (; t;) {\n                var i = t.nextSibling;\n                (n = u(t)) ? P(n) : L(t, e, !0), t = i;\n              }\n            }(e, v, i);\n            var k = h[e.nodeName];\n            k && k(e, t);\n          }(t, n) : h.TEXTAREA(t, n);\n        }\n\n        !function e(t) {\n          if (t.nodeType === f || t.nodeType === v) for (var n = t.firstChild; n;) {\n            var i = u(n);\n            i && (x[i] = n), e(n), n = n.nextSibling;\n          }\n        }(t);\n        var D = t,\n            _ = D.nodeType,\n            N = n.nodeType;\n        if (!S) if (_ === f) N === f ? l(t, n) || (E(t), D = function (e, t) {\n          for (var n = e.firstChild; n;) {\n            var i = n.nextSibling;\n            t.appendChild(n), n = i;\n          }\n\n          return t;\n        }(t, function (e, t) {\n          return t && t !== o ? a.createElementNS(t, e) : a.createElement(e);\n        }(n.nodeName, n.namespaceURI))) : D = n;else if (_ === p || _ === g) {\n          if (N === _) return D.nodeValue !== n.nodeValue && (D.nodeValue = n.nodeValue), D;\n          D = n;\n        }\n        if (D === n) E(t);else {\n          if (n.isSameNode && n.isSameNode(D)) return;\n          if (T(D, n, S), C) for (var R = 0, O = C.length; R < O; R++) {\n            var j = x[C[R]];\n            j && L(j, j.parentNode, !1);\n          }\n        }\n        return !S && D !== t && t.parentNode && (D.actualize && (D = D.actualize(t.ownerDocument || a)), t.parentNode.replaceChild(D, t)), D;\n      };\n    }(function (e, t) {\n      var n,\n          i,\n          o,\n          a,\n          u = t.attributes;\n\n      if (t.nodeType !== r && e.nodeType !== r) {\n        for (var s = u.length - 1; s >= 0; s--) i = (n = u[s]).name, o = n.namespaceURI, a = n.value, o ? (i = n.localName || i, e.getAttributeNS(o, i) !== a && (\"xmlns\" === n.prefix && (i = n.name), e.setAttributeNS(o, i, a))) : e.getAttribute(i) !== a && e.setAttribute(i, a);\n\n        for (var c = e.attributes, l = c.length - 1; l >= 0; l--) i = (n = c[l]).name, (o = n.namespaceURI) ? (i = n.localName || i, t.hasAttributeNS(o, i) || e.removeAttributeNS(o, i)) : t.hasAttribute(i) || e.removeAttribute(i);\n      }\n    });\n\n    function k(e) {\n      return P(e) || S(e) || L(e) || C();\n    }\n\n    function w(e, t) {\n      var n = Object.keys(e);\n\n      if (Object.getOwnPropertySymbols) {\n        var i = Object.getOwnPropertySymbols(e);\n        t && (i = i.filter(function (t) {\n          return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), n.push.apply(n, i);\n      }\n\n      return n;\n    }\n\n    function E(e, t, n) {\n      return t in e ? Object.defineProperty(e, t, {\n        value: n,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n      }) : e[t] = n, e;\n    }\n\n    function A(e) {\n      return function (e) {\n        if (Array.isArray(e)) return I(e);\n      }(e) || S(e) || L(e) || function () {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n\n    function S(e) {\n      if (\"undefined\" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e);\n    }\n\n    function x(e, t) {\n      return P(e) || function (e, t) {\n        if (\"undefined\" == typeof Symbol || !(Symbol.iterator in Object(e))) return;\n        var n = [],\n            i = !0,\n            r = !1,\n            o = void 0;\n\n        try {\n          for (var a, u = e[Symbol.iterator](); !(i = (a = u.next()).done) && (n.push(a.value), !t || n.length !== t); i = !0);\n        } catch (e) {\n          r = !0, o = e;\n        } finally {\n          try {\n            i || null == u.return || u.return();\n          } finally {\n            if (r) throw o;\n          }\n        }\n\n        return n;\n      }(e, t) || L(e, t) || C();\n    }\n\n    function C() {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    function P(e) {\n      if (Array.isArray(e)) return e;\n    }\n\n    function L(e, t) {\n      if (e) {\n        if (\"string\" == typeof e) return I(e, t);\n        var n = Object.prototype.toString.call(e).slice(8, -1);\n        return \"Object\" === n && e.constructor && (n = e.constructor.name), \"Map\" === n || \"Set\" === n ? Array.from(e) : \"Arguments\" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? I(e, t) : void 0;\n      }\n    }\n\n    function I(e, t) {\n      (null == t || t > e.length) && (t = e.length);\n\n      for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];\n\n      return i;\n    }\n\n    function T(e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n\n    function D(e, t) {\n      for (var n = 0; n < t.length; n++) {\n        var i = t[n];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n      }\n    }\n\n    function _(e, t, n) {\n      return t && D(e.prototype, t), n && D(e, n), e;\n    }\n\n    function N(e) {\n      \"@babel/helpers - typeof\";\n\n      return (N = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n        return typeof e;\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n      })(e);\n    }\n\n    n.d(t, \"debug\", function () {\n      return K;\n    }), n.d(t, \"Rendered\", function () {\n      return ue;\n    }), n.d(t, \"LiveSocket\", function () {\n      return se;\n    }), n.d(t, \"Browser\", function () {\n      return ce;\n    }), n.d(t, \"DOM\", function () {\n      return le;\n    }), n.d(t, \"View\", function () {\n      return fe;\n    });\n\n    var R = [1e3, 3e3],\n        O = \"data-phx-view\",\n        j = [\"phx-click-loading\", \"phx-change-loading\", \"phx-submit-loading\", \"phx-keydown-loading\", \"phx-keyup-loading\", \"phx-blur-loading\", \"phx-focus-loading\"],\n        H = \"data-phx-component\",\n        F = \"data-phx-ref\",\n        M = \"data-phx-upload-ref\",\n        U = \"[\".concat(O, \"]\"),\n        B = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\", \"date\", \"time\"],\n        J = [\"checkbox\", \"radio\"],\n        V = 1,\n        W = \"phx-\",\n        q = {\n      debounce: 300,\n      throttle: 300\n    },\n        z = function (e, t) {\n      return console.error && console.error(e, t);\n    };\n\n    var K = function (e, t, n, i) {\n      e.liveSocket.isDebugEnabled() && console.log(\"\".concat(e.id, \" \").concat(t, \": \").concat(n, \" - \"), i);\n    },\n        X = function (e) {\n      return \"function\" == typeof e ? e : function () {\n        return e;\n      };\n    },\n        $ = function (e) {\n      return JSON.parse(JSON.stringify(e));\n    },\n        G = function (e, t, n) {\n      do {\n        if (e.matches(\"[\".concat(t, \"]\"))) return e;\n        e = e.parentElement || e.parentNode;\n      } while (null !== e && 1 === e.nodeType && !(n && n.isSameNode(e) || e.matches(U)));\n\n      return null;\n    },\n        Y = function (e) {\n      return null !== e && \"object\" === N(e) && !(e instanceof Array);\n    },\n        Q = function (e) {\n      for (var t in e) return !1;\n\n      return !0;\n    },\n        Z = function (e, t) {\n      return e && t(e);\n    },\n        ee = function () {\n      function e(t, n, i) {\n        T(this, e), this.ref = ie.genFileRef(n), this.fileEl = t, this.file = n, this.view = i, this.meta = null, this._isCancelled = !1, this._isDone = !1, this._progress = 0, this._onDone = function () {};\n      }\n\n      return _(e, null, [{\n        key: \"isActive\",\n        value: function (e, t) {\n          var n = void 0 === t._phxRef,\n              i = e.getAttribute(\"data-phx-active-refs\").split(\",\").indexOf(ie.genFileRef(t)) >= 0;\n          return t.size > 0 && (n || i);\n        }\n      }, {\n        key: \"isPreflighted\",\n        value: function (e, t) {\n          var n = e.getAttribute(\"data-phx-preflighted-refs\").split(\",\").indexOf(ie.genFileRef(t)) >= 0;\n          return n && this.isActive(e, t);\n        }\n      }]), _(e, [{\n        key: \"metadata\",\n        value: function () {\n          return this.meta;\n        }\n      }, {\n        key: \"progress\",\n        value: function (e) {\n          var t = this;\n          this._progress = Math.floor(e), this._progress >= 100 ? (this._progress = 100, this._isDone = !0, this.view.pushFileProgress(this.fileEl, this.ref, 100, function () {\n            ie.untrackFile(t.fileEl, t.file), t._onDone();\n          })) : this.view.pushFileProgress(this.fileEl, this.ref, this._progress);\n        }\n      }, {\n        key: \"cancel\",\n        value: function () {\n          this._isCancelled = !0, this._isDone = !0, this._onDone();\n        }\n      }, {\n        key: \"isDone\",\n        value: function () {\n          return this._isDone;\n        }\n      }, {\n        key: \"error\",\n        value: function () {\n          var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"failed\";\n          this.view.pushFileProgress(this.fileEl, this.ref, {\n            error: e\n          });\n        }\n      }, {\n        key: \"onDone\",\n        value: function (e) {\n          this._onDone = e;\n        }\n      }, {\n        key: \"toPreflightPayload\",\n        value: function () {\n          return {\n            last_modified: this.file.lastModified,\n            name: this.file.name,\n            size: this.file.size,\n            type: this.file.type,\n            ref: this.ref\n          };\n        }\n      }, {\n        key: \"uploader\",\n        value: function (e) {\n          if (this.meta.uploader) {\n            var t = e[this.meta.uploader] || z(\"no uploader configured for \".concat(this.meta.uploader));\n            return {\n              name: this.meta.uploader,\n              callback: t\n            };\n          }\n\n          return {\n            name: \"channel\",\n            callback: re\n          };\n        }\n      }, {\n        key: \"zipPostFlight\",\n        value: function (e) {\n          this.meta = e.entries[this.ref], this.meta || z(\"no preflight upload response returned with ref \".concat(this.ref), {\n            input: this.fileEl,\n            response: e\n          });\n        }\n      }]), e;\n    }(),\n        te = {\n      LiveFileUpload: {\n        preflightedRefs: function () {\n          return this.el.getAttribute(\"data-phx-preflighted-refs\");\n        },\n        mounted: function () {\n          this.preflightedWas = this.preflightedRefs();\n        },\n        updated: function () {\n          var e = this.preflightedRefs();\n          this.preflightedWas !== e && (this.preflightedWas = e, \"\" === e && this.__view.cancelSubmit(this.el.form));\n        }\n      }\n    };\n\n    te.LiveImgPreview = {\n      mounted: function () {\n        var e = this;\n        this.ref = this.el.getAttribute(\"data-phx-entry-ref\"), this.inputEl = document.getElementById(this.el.getAttribute(M)), ie.getEntryDataURL(this.inputEl, this.ref, function (t) {\n          return e.el.src = t;\n        });\n      }\n    };\n\n    var ne = 0,\n        ie = function () {\n      function e(t, n, i) {\n        T(this, e), this.view = n, this.onComplete = i, this._entries = Array.from(e.filesAwaitingPreflight(t) || []).map(function (e) {\n          return new ee(t, e, n);\n        }), this.numEntriesInProgress = this._entries.length;\n      }\n\n      return _(e, null, [{\n        key: \"genFileRef\",\n        value: function (e) {\n          var t = e._phxRef;\n          return void 0 !== t ? t : (e._phxRef = (ne++).toString(), e._phxRef);\n        }\n      }, {\n        key: \"getEntryDataURL\",\n        value: function (e, t, n) {\n          var i = this,\n              r = this.activeFiles(e).find(function (e) {\n            return i.genFileRef(e) === t;\n          }),\n              o = new FileReader();\n          o.onload = function (e) {\n            return n(e.target.result);\n          }, o.readAsDataURL(r);\n        }\n      }, {\n        key: \"hasUploadsInProgress\",\n        value: function (e) {\n          var t = 0;\n          return le.findUploadInputs(e).forEach(function (e) {\n            e.getAttribute(\"data-phx-preflighted-refs\") !== e.getAttribute(\"data-phx-done-refs\") && t++;\n          }), t > 0;\n        }\n      }, {\n        key: \"serializeUploads\",\n        value: function (e) {\n          var t = this,\n              n = {};\n          return this.activeFiles(e, \"serialize\").forEach(function (i) {\n            var r = {\n              path: e.name\n            },\n                o = e.getAttribute(M);\n            n[o] = n[o] || [], r.ref = t.genFileRef(i), r.name = i.name, r.type = i.type, r.size = i.size, n[o].push(r);\n          }), n;\n        }\n      }, {\n        key: \"clearFiles\",\n        value: function (e) {\n          e.value = null, le.putPrivate(e, \"files\", []);\n        }\n      }, {\n        key: \"untrackFile\",\n        value: function (e, t) {\n          le.putPrivate(e, \"files\", le.private(e, \"files\").filter(function (e) {\n            return !Object.is(e, t);\n          }));\n        }\n      }, {\n        key: \"trackFiles\",\n        value: function (e, t) {\n          var n = this;\n\n          if (null !== e.getAttribute(\"multiple\")) {\n            var i = t.filter(function (t) {\n              return !n.activeFiles(e).find(function (e) {\n                return Object.is(e, t);\n              });\n            });\n            le.putPrivate(e, \"files\", this.activeFiles(e).concat(i)), e.value = null;\n          } else le.putPrivate(e, \"files\", t);\n        }\n      }, {\n        key: \"activeFileInputs\",\n        value: function (e) {\n          var t = this,\n              n = le.findUploadInputs(e);\n          return Array.from(n).filter(function (e) {\n            return e.files && t.activeFiles(e).length > 0;\n          });\n        }\n      }, {\n        key: \"activeFiles\",\n        value: function (e) {\n          return (le.private(e, \"files\") || []).filter(function (t) {\n            return ee.isActive(e, t);\n          });\n        }\n      }, {\n        key: \"inputsAwaitingPreflight\",\n        value: function (e) {\n          var t = this,\n              n = le.findUploadInputs(e);\n          return Array.from(n).filter(function (e) {\n            return t.filesAwaitingPreflight(e).length > 0;\n          });\n        }\n      }, {\n        key: \"filesAwaitingPreflight\",\n        value: function (e) {\n          return this.activeFiles(e).filter(function (t) {\n            return !ee.isPreflighted(e, t);\n          });\n        }\n      }]), _(e, [{\n        key: \"entries\",\n        value: function () {\n          return this._entries;\n        }\n      }, {\n        key: \"initAdapterUpload\",\n        value: function (e, t, n) {\n          var i = this;\n          this._entries = this._entries.map(function (t) {\n            return t.zipPostFlight(e), t.onDone(function () {\n              i.numEntriesInProgress--, 0 === i.numEntriesInProgress && i.onComplete();\n            }), t;\n          });\n\n          var r = this._entries.reduce(function (e, t) {\n            var i = t.uploader(n.uploaders),\n                r = i.name,\n                o = i.callback;\n            return e[r] = e[r] || {\n              callback: o,\n              entries: []\n            }, e[r].entries.push(t), e;\n          }, {});\n\n          for (var o in r) {\n            var a = r[o];\n            (0, a.callback)(a.entries, t, e, n);\n          }\n        }\n      }]), e;\n    }(),\n        re = function (e, t, n, i) {\n      e.forEach(function (e) {\n        new oe(e, n.config.chunk_size, i).upload();\n      });\n    },\n        oe = function () {\n      function e(t, n, i) {\n        T(this, e), this.liveSocket = i, this.entry = t, this.offset = 0, this.chunkSize = n, this.uploadChannel = i.channel(\"lvu:\".concat(t.ref), {\n          token: t.metadata()\n        });\n      }\n\n      return _(e, [{\n        key: \"upload\",\n        value: function () {\n          var e = this;\n          this.uploadChannel.join().receive(\"ok\", function (t) {\n            return e.readNextChunk();\n          }).receive(\"error\", function (t) {\n            e.uploadChannel.leave(), e.entry.error();\n          });\n        }\n      }, {\n        key: \"isDone\",\n        value: function () {\n          return this.offset >= this.entry.file.size;\n        }\n      }, {\n        key: \"readNextChunk\",\n        value: function () {\n          var e = this,\n              t = new window.FileReader(),\n              n = this.entry.file.slice(this.offset, this.chunkSize + this.offset);\n          t.onload = function (t) {\n            if (null !== t.target.error) return z(\"Read error: \" + t.target.error);\n            e.offset += t.target.result.byteLength, e.pushChunk(t.target.result);\n          }, t.readAsArrayBuffer(n);\n        }\n      }, {\n        key: \"pushChunk\",\n        value: function (e) {\n          var t = this;\n          this.uploadChannel.isJoined() && this.uploadChannel.push(\"chunk\", e).receive(\"ok\", function () {\n            t.entry.progress(t.offset / t.entry.file.size * 100), t.isDone() || setTimeout(function () {\n              return t.readNextChunk();\n            }, t.liveSocket.getLatencySim() || 0);\n          });\n        }\n      }]), e;\n    }(),\n        ae = function (e) {\n      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n          n = new FormData(e),\n          i = [];\n      n.forEach(function (e, t, n) {\n        e instanceof File && i.push(t);\n      }), i.forEach(function (e) {\n        return n.delete(e);\n      });\n\n      var r,\n          o = new URLSearchParams(),\n          a = function (e) {\n        if (\"undefined\" == typeof Symbol || null == e[Symbol.iterator]) {\n          if (Array.isArray(e) || (e = L(e))) {\n            var t = 0,\n                n = function () {};\n\n            return {\n              s: n,\n              n: function () {\n                return t >= e.length ? {\n                  done: !0\n                } : {\n                  done: !1,\n                  value: e[t++]\n                };\n              },\n              e: function (e) {\n                throw e;\n              },\n              f: n\n            };\n          }\n\n          throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n        }\n\n        var i,\n            r,\n            o = !0,\n            a = !1;\n        return {\n          s: function () {\n            i = e[Symbol.iterator]();\n          },\n          n: function () {\n            var e = i.next();\n            return o = e.done, e;\n          },\n          e: function (e) {\n            a = !0, r = e;\n          },\n          f: function () {\n            try {\n              o || null == i.return || i.return();\n            } finally {\n              if (a) throw r;\n            }\n          }\n        };\n      }(n.entries());\n\n      try {\n        for (a.s(); !(r = a.n()).done;) {\n          var u = x(r.value, 2),\n              s = u[0],\n              c = u[1];\n          o.append(s, c);\n        }\n      } catch (e) {\n        a.e(e);\n      } finally {\n        a.f();\n      }\n\n      for (var l in t) o.append(l, t[l]);\n\n      return o.toString();\n    },\n        ue = function () {\n      function e(t, n) {\n        T(this, e), this.viewId = t, this.rendered = {}, this.mergeDiff(n);\n      }\n\n      return _(e, null, [{\n        key: \"extract\",\n        value: function (e) {\n          var t = e.r,\n              n = e.e,\n              i = e.t;\n          return delete e.r, delete e.e, delete e.t, {\n            diff: e,\n            title: i,\n            reply: t || null,\n            events: n || []\n          };\n        }\n      }]), _(e, [{\n        key: \"parentViewId\",\n        value: function () {\n          return this.viewId;\n        }\n      }, {\n        key: \"toString\",\n        value: function (e) {\n          return this.recursiveToString(this.rendered, this.rendered.c, e);\n        }\n      }, {\n        key: \"recursiveToString\",\n        value: function (e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.c,\n              n = arguments.length > 2 ? arguments[2] : void 0,\n              i = {\n            buffer: \"\",\n            components: t,\n            onlyCids: n = n ? new Set(n) : null\n          };\n          return this.toOutputBuffer(e, i), i.buffer;\n        }\n      }, {\n        key: \"componentCIDs\",\n        value: function (e) {\n          return Object.keys(e.c || {}).map(function (e) {\n            return parseInt(e);\n          });\n        }\n      }, {\n        key: \"isComponentOnlyDiff\",\n        value: function (e) {\n          return !!e.c && 1 === Object.keys(e).length;\n        }\n      }, {\n        key: \"getComponent\",\n        value: function (e, t) {\n          return e.c[t];\n        }\n      }, {\n        key: \"mergeDiff\",\n        value: function (e) {\n          var t = e.c;\n\n          if (delete e.c, this.rendered = this.recursiveMerge(this.rendered, e), this.rendered.c = this.rendered.c || {}, t) {\n            var n = this.rendered.c;\n\n            for (var i in t) {\n              var r = t[i],\n                  o = r,\n                  a = o.s;\n\n              if (\"number\" == typeof a) {\n                for (; \"number\" == typeof a;) a = (o = a > 0 ? t[a] : n[-a]).s;\n\n                o = $(o), this.doRecursiveMerge(o, r), o.s = a;\n              } else o = n[i] || {}, o = this.recursiveMerge(o, r);\n\n              t[i] = o;\n            }\n\n            for (var u in t) n[u] = t[u];\n\n            e.c = t;\n          }\n        }\n      }, {\n        key: \"recursiveMerge\",\n        value: function (e, t) {\n          return void 0 !== t.s ? t : (this.doRecursiveMerge(e, t), e);\n        }\n      }, {\n        key: \"doRecursiveMerge\",\n        value: function (e, t) {\n          for (var n in t) {\n            var i = t[n],\n                r = e[n];\n            Y(i) && void 0 === i.s && Y(r) ? this.doRecursiveMerge(r, i) : e[n] = i;\n          }\n        }\n      }, {\n        key: \"componentToString\",\n        value: function (e) {\n          return this.recursiveCIDToString(this.rendered.c, e);\n        }\n      }, {\n        key: \"pruneCIDs\",\n        value: function (e) {\n          var t = this;\n          e.forEach(function (e) {\n            return delete t.rendered.c[e];\n          });\n        }\n      }, {\n        key: \"get\",\n        value: function () {\n          return this.rendered;\n        }\n      }, {\n        key: \"isNewFingerprint\",\n        value: function () {\n          return !!(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).s;\n        }\n      }, {\n        key: \"toOutputBuffer\",\n        value: function (e, t) {\n          if (e.d) return this.comprehensionToBuffer(e, t);\n          var n = e.s;\n          t.buffer += n[0];\n\n          for (var i = 1; i < n.length; i++) this.dynamicToBuffer(e[i - 1], t), t.buffer += n[i];\n        }\n      }, {\n        key: \"comprehensionToBuffer\",\n        value: function (e, t) {\n          for (var n = e.d, i = e.s, r = 0; r < n.length; r++) {\n            var o = n[r];\n            t.buffer += i[0];\n\n            for (var a = 1; a < i.length; a++) this.dynamicToBuffer(o[a - 1], t), t.buffer += i[a];\n          }\n        }\n      }, {\n        key: \"dynamicToBuffer\",\n        value: function (e, t) {\n          \"number\" == typeof e ? t.buffer += this.recursiveCIDToString(t.components, e, t.onlyCids) : Y(e) ? this.toOutputBuffer(e, t) : t.buffer += e;\n        }\n      }, {\n        key: \"recursiveCIDToString\",\n        value: function (e, t, n) {\n          var i = this,\n              r = e[t] || z(\"no component for CID \".concat(t), e),\n              o = document.createElement(\"template\");\n          o.innerHTML = this.recursiveToString(r, e, n);\n          var a = o.content,\n              u = n && !n.has(t),\n              s = x(Array.from(a.childNodes).reduce(function (e, n, r) {\n            var a = x(e, 2),\n                s = a[0],\n                c = a[1];\n            return n.nodeType === Node.ELEMENT_NODE ? n.getAttribute(H) ? [s, !0] : (n.setAttribute(H, t), n.id || (n.id = \"\".concat(i.parentViewId(), \"-\").concat(t, \"-\").concat(r)), u && (n.setAttribute(\"data-phx-skip\", \"\"), n.innerHTML = \"\"), [!0, c]) : \"\" !== n.nodeValue.trim() ? (z(\"only HTML element tags are allowed at the root of components.\\n\\n\" + 'got: \"'.concat(n.nodeValue.trim(), '\"\\n\\n') + \"within:\\n\", o.innerHTML.trim()), n.replaceWith(i.createSpan(n.nodeValue, t)), [!0, c]) : (n.remove(), [s, c]);\n          }, [!1, !1]), 2),\n              c = s[0],\n              l = s[1];\n          return c || l ? !c && l ? (z(\"expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.\", o.innerHTML.trim()), o.innerHTML) : o.innerHTML : (z(\"expected at least one HTML element tag inside a component, but the component is empty:\\n\", o.innerHTML.trim()), this.createSpan(\"\", t).outerHTML);\n        }\n      }, {\n        key: \"createSpan\",\n        value: function (e, t) {\n          var n = document.createElement(\"span\");\n          return n.innerText = e, n.setAttribute(H, t), n;\n        }\n      }]), e;\n    }(),\n        se = function () {\n      function e(t, n) {\n        var i = this,\n            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n        if (T(this, e), this.unloaded = !1, !n || \"Object\" === n.constructor.name) throw new Error('\\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\\n\\n          import {Socket} from \"phoenix\"\\n          import {LiveSocket} from \"phoenix_live_view\"\\n          let liveSocket = new LiveSocket(\"/live\", Socket, {...})\\n      ');\n        this.socket = new n(t, r), this.bindingPrefix = r.bindingPrefix || W, this.opts = r, this.params = X(r.params || {}), this.viewLogger = r.viewLogger, this.metadataCallbacks = r.metadata || {}, this.defaults = Object.assign($(q), r.defaults || {}), this.activeElement = null, this.prevActive = null, this.silenced = !1, this.main = null, this.linkRef = 0, this.roots = {}, this.href = window.location.href, this.pendingLink = null, this.currentLocation = $(window.location), this.hooks = r.hooks || {}, this.uploaders = r.uploaders || {}, this.loaderTimeout = r.loaderTimeout || V, this.boundTopLevelEvents = !1, this.domCallbacks = Object.assign({\n          onNodeAdded: X(),\n          onBeforeElUpdated: X()\n        }, r.dom || {}), window.addEventListener(\"unload\", function (e) {\n          i.unloaded = !0;\n        }), this.socket.onOpen(function () {\n          i.isUnloaded() && window.location.reload();\n        });\n      }\n\n      return _(e, [{\n        key: \"isProfileEnabled\",\n        value: function () {\n          return \"true\" === sessionStorage.getItem(\"phx:live-socket:profiling\");\n        }\n      }, {\n        key: \"isDebugEnabled\",\n        value: function () {\n          return \"true\" === sessionStorage.getItem(\"phx:live-socket:debug\");\n        }\n      }, {\n        key: \"enableDebug\",\n        value: function () {\n          sessionStorage.setItem(\"phx:live-socket:debug\", \"true\");\n        }\n      }, {\n        key: \"enableProfiling\",\n        value: function () {\n          sessionStorage.setItem(\"phx:live-socket:profiling\", \"true\");\n        }\n      }, {\n        key: \"disableDebug\",\n        value: function () {\n          sessionStorage.removeItem(\"phx:live-socket:debug\");\n        }\n      }, {\n        key: \"disableProfiling\",\n        value: function () {\n          sessionStorage.removeItem(\"phx:live-socket:profiling\");\n        }\n      }, {\n        key: \"enableLatencySim\",\n        value: function (e) {\n          this.enableDebug(), console.log(\"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\"), sessionStorage.setItem(\"phx:live-socket:latency-sim\", e);\n        }\n      }, {\n        key: \"disableLatencySim\",\n        value: function () {\n          sessionStorage.removeItem(\"phx:live-socket:latency-sim\");\n        }\n      }, {\n        key: \"getLatencySim\",\n        value: function () {\n          var e = sessionStorage.getItem(\"phx:live-socket:latency-sim\");\n          return e ? parseInt(e) : null;\n        }\n      }, {\n        key: \"getSocket\",\n        value: function () {\n          return this.socket;\n        }\n      }, {\n        key: \"connect\",\n        value: function () {\n          var e = this,\n              t = function () {\n            e.joinRootViews() && (e.bindTopLevelEvents(), e.socket.connect());\n          };\n\n          [\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0 ? t() : document.addEventListener(\"DOMContentLoaded\", function () {\n            return t();\n          });\n        }\n      }, {\n        key: \"disconnect\",\n        value: function (e) {\n          this.socket.disconnect(e);\n        }\n      }, {\n        key: \"triggerDOM\",\n        value: function (e, t) {\n          var n;\n          (n = this.domCallbacks)[e].apply(n, A(t));\n        }\n      }, {\n        key: \"time\",\n        value: function (e, t) {\n          if (!this.isProfileEnabled() || !console.time) return t();\n          console.time(e);\n          var n = t();\n          return console.timeEnd(e), n;\n        }\n      }, {\n        key: \"log\",\n        value: function (e, t, n) {\n          if (this.viewLogger) {\n            var i = x(n(), 2),\n                r = i[0],\n                o = i[1];\n            this.viewLogger(e, t, r, o);\n          } else if (this.isDebugEnabled()) {\n            var a = x(n(), 2),\n                u = a[0],\n                s = a[1];\n            K(e, t, u, s);\n          }\n        }\n      }, {\n        key: \"onChannel\",\n        value: function (e, t, n) {\n          var i = this;\n          e.on(t, function (e) {\n            var t = i.getLatencySim();\n            t ? (console.log(\"simulating \".concat(t, \"ms of latency from server to client\")), setTimeout(function () {\n              return n(e);\n            }, t)) : n(e);\n          });\n        }\n      }, {\n        key: \"wrapPush\",\n        value: function (e, t, n) {\n          var i = this,\n              r = this.getLatencySim(),\n              o = e.joinCount;\n          if (!r) return t.timeout ? n().receive(\"timeout\", function () {\n            e.joinCount === o && i.reloadWithJitter(e, function () {\n              i.log(e, \"timeout\", function () {\n                return [\"received timeout while communicating with server. Falling back to hard refresh for recovery\"];\n              });\n            });\n          }) : n();\n          console.log(\"simulating \".concat(r, \"ms of latency from client to server\"));\n          var a = {\n            receives: [],\n            receive: function (e, t) {\n              this.receives.push([e, t]);\n            }\n          };\n          return setTimeout(function () {\n            a.receives.reduce(function (e, t) {\n              var n = x(t, 2),\n                  i = n[0],\n                  r = n[1];\n              return e.receive(i, r);\n            }, n());\n          }, r), a;\n        }\n      }, {\n        key: \"reloadWithJitter\",\n        value: function (e, t) {\n          var n = this;\n          e.destroy(), this.disconnect();\n          var i = R[0],\n              r = R[1],\n              o = Math.floor(Math.random() * (r - i + 1)) + i,\n              a = ce.updateLocal(e.name(), \"consecutive-reloads\", 0, function (e) {\n            return e + 1;\n          });\n          t ? t() : this.log(e, \"join\", function () {\n            return [\"encountered \".concat(a, \" consecutive reloads\")];\n          }), a > 10 && (this.log(e, \"join\", function () {\n            return [\"exceeded \".concat(10, \" consecutive reloads. Entering failsafe mode\")];\n          }), o = 3e4), setTimeout(function () {\n            n.hasPendingLink() ? window.location = n.pendingLink : window.location.reload();\n          }, o);\n        }\n      }, {\n        key: \"getHookCallbacks\",\n        value: function (e) {\n          return e && e.startsWith(\"Phoenix.\") ? te[e.split(\".\")[1]] : this.hooks[e];\n        }\n      }, {\n        key: \"isUnloaded\",\n        value: function () {\n          return this.unloaded;\n        }\n      }, {\n        key: \"isConnected\",\n        value: function () {\n          return this.socket.isConnected();\n        }\n      }, {\n        key: \"getBindingPrefix\",\n        value: function () {\n          return this.bindingPrefix;\n        }\n      }, {\n        key: \"binding\",\n        value: function (e) {\n          return \"\".concat(this.getBindingPrefix()).concat(e);\n        }\n      }, {\n        key: \"channel\",\n        value: function (e, t) {\n          return this.socket.channel(e, t);\n        }\n      }, {\n        key: \"joinRootViews\",\n        value: function () {\n          var e = this,\n              t = !1;\n          return le.all(document, \"\".concat(U, \":not([\").concat(\"data-phx-parent-id\", \"])\"), function (n) {\n            if (!e.getRootById(n.id)) {\n              var i = e.joinRootView(n, e.getHref());\n              e.root = e.root || i, n.getAttribute(\"data-phx-main\") && (e.main = i);\n            }\n\n            t = !0;\n          }), t;\n        }\n      }, {\n        key: \"redirect\",\n        value: function (e, t) {\n          this.disconnect(), ce.redirect(e, t);\n        }\n      }, {\n        key: \"replaceMain\",\n        value: function (e, t) {\n          var n = this,\n              i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,\n              r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.setPendingLink(e),\n              o = this.main.el;\n          this.main.showLoader(this.loaderTimeout), this.main.destroy(), ce.fetchPage(e, function (a, u) {\n            if (200 !== a) return n.redirect(e);\n            var s = document.createElement(\"template\");\n            s.innerHTML = u;\n            var c = s.content.childNodes[0];\n            if (!c || !n.isPhxView(c)) return n.redirect(e);\n            n.joinRootView(c, e, t, function (e, t) {\n              1 === t && (n.commitPendingLink(r) ? (o.replaceWith(e.el), n.main = e, i && i()) : e.destroy());\n            });\n          });\n        }\n      }, {\n        key: \"isPhxView\",\n        value: function (e) {\n          return e.getAttribute && null !== e.getAttribute(O);\n        }\n      }, {\n        key: \"joinRootView\",\n        value: function (e, t, n, i) {\n          var r = new fe(e, this, null, t, n);\n          return this.roots[r.id] = r, r.join(i), r;\n        }\n      }, {\n        key: \"owner\",\n        value: function (e, t) {\n          var n = this,\n              i = Z(e.closest(U), function (e) {\n            return n.getViewByEl(e);\n          });\n          i && t(i);\n        }\n      }, {\n        key: \"withinOwners\",\n        value: function (e, t) {\n          var n = this;\n          this.owner(e, function (i) {\n            var r = e.getAttribute(n.binding(\"target\"));\n            null === r ? t(i, e) : i.withinTargets(r, t);\n          });\n        }\n      }, {\n        key: \"getViewByEl\",\n        value: function (e) {\n          var t = e.getAttribute(\"data-phx-root-id\");\n          return Z(this.getRootById(t), function (t) {\n            return t.getDescendentByEl(e);\n          });\n        }\n      }, {\n        key: \"getRootById\",\n        value: function (e) {\n          return this.roots[e];\n        }\n      }, {\n        key: \"destroyAllViews\",\n        value: function () {\n          for (var e in this.roots) this.roots[e].destroy(), delete this.roots[e];\n        }\n      }, {\n        key: \"destroyViewByEl\",\n        value: function (e) {\n          var t = this.getRootById(e.getAttribute(\"data-phx-root-id\"));\n          t && t.destroyDescendent(e.id);\n        }\n      }, {\n        key: \"setActiveElement\",\n        value: function (e) {\n          var t = this;\n\n          if (this.activeElement !== e) {\n            this.activeElement = e;\n\n            var n = function () {\n              e === t.activeElement && (t.activeElement = null), e.removeEventListener(\"mouseup\", t), e.removeEventListener(\"touchend\", t);\n            };\n\n            e.addEventListener(\"mouseup\", n), e.addEventListener(\"touchend\", n);\n          }\n        }\n      }, {\n        key: \"getActiveElement\",\n        value: function () {\n          return document.activeElement === document.body ? this.activeElement || document.activeElement : document.activeElement || document.body;\n        }\n      }, {\n        key: \"dropActiveElement\",\n        value: function (e) {\n          this.prevActive && e.ownsElement(this.prevActive) && (this.prevActive = null);\n        }\n      }, {\n        key: \"restorePreviouslyActiveFocus\",\n        value: function () {\n          this.prevActive && this.prevActive !== document.body && this.prevActive.focus();\n        }\n      }, {\n        key: \"blurActiveElement\",\n        value: function () {\n          this.prevActive = this.getActiveElement(), this.prevActive !== document.body && this.prevActive.blur();\n        }\n      }, {\n        key: \"bindTopLevelEvents\",\n        value: function () {\n          var e = this;\n          this.boundTopLevelEvents || (this.boundTopLevelEvents = !0, document.body.addEventListener(\"click\", function () {}), window.addEventListener(\"pageshow\", function (t) {\n            t.persisted && (e.withPageLoading({\n              to: window.location.href,\n              kind: \"redirect\"\n            }), window.location.reload());\n          }), this.bindClicks(), this.bindNav(), this.bindForms(), this.bind({\n            keyup: \"keyup\",\n            keydown: \"keydown\"\n          }, function (t, n, i, r, o, a, u) {\n            var s = r.getAttribute(e.binding(\"key\")),\n                c = t.key && t.key.toLowerCase();\n            s && s.toLowerCase() !== c || i.pushKey(r, o, n, a, function (e) {\n              for (var t = 1; t < arguments.length; t++) {\n                var n = null != arguments[t] ? arguments[t] : {};\n                t % 2 ? w(Object(n), !0).forEach(function (t) {\n                  E(e, t, n[t]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w(Object(n)).forEach(function (t) {\n                  Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n                });\n              }\n\n              return e;\n            }({\n              key: t.key\n            }, e.eventMeta(n, t, r)));\n          }), this.bind({\n            blur: \"focusout\",\n            focus: \"focusin\"\n          }, function (t, n, i, r, o, a, u) {\n            u || i.pushEvent(n, r, o, a, e.eventMeta(n, t, r));\n          }), this.bind({\n            blur: \"blur\",\n            focus: \"focus\"\n          }, function (t, n, i, r, o, a, u) {\n            u && \"window\" !== !u && i.pushEvent(n, r, o, a, e.eventMeta(n, t, r));\n          }), window.addEventListener(\"dragover\", function (e) {\n            return e.preventDefault();\n          }), window.addEventListener(\"drop\", function (t) {\n            t.preventDefault();\n            var n = Z(G(t.target, e.binding(\"drop-target\")), function (t) {\n              return t.getAttribute(e.binding(\"drop-target\"));\n            }),\n                i = n && document.getElementById(n),\n                r = Array.from(t.dataTransfer.files || []);\n            i && !i.disabled && 0 !== r.length && i.files instanceof FileList && (ie.trackFiles(i, r), i.dispatchEvent(new Event(\"input\", {\n              bubbles: !0\n            })));\n          }));\n        }\n      }, {\n        key: \"eventMeta\",\n        value: function (e, t, n) {\n          var i = this.metadataCallbacks[e];\n          return i ? i(t, n) : {};\n        }\n      }, {\n        key: \"setPendingLink\",\n        value: function (e) {\n          return this.linkRef++, this.pendingLink = e, this.linkRef;\n        }\n      }, {\n        key: \"commitPendingLink\",\n        value: function (e) {\n          return this.linkRef === e && (this.href = this.pendingLink, this.pendingLink = null, !0);\n        }\n      }, {\n        key: \"getHref\",\n        value: function () {\n          return this.href;\n        }\n      }, {\n        key: \"hasPendingLink\",\n        value: function () {\n          return !!this.pendingLink;\n        }\n      }, {\n        key: \"bind\",\n        value: function (e, t) {\n          var n = this,\n              i = function (i) {\n            var r = e[i];\n            n.on(r, function (e) {\n              var r = n.binding(i),\n                  o = n.binding(\"window-\".concat(i)),\n                  a = e.target.getAttribute && e.target.getAttribute(r);\n              a ? n.debounce(e.target, e, function () {\n                n.withinOwners(e.target, function (n, r) {\n                  t(e, i, n, e.target, r, a, null);\n                });\n              }) : le.all(document, \"[\".concat(o, \"]\"), function (r) {\n                var a = r.getAttribute(o);\n                n.debounce(r, e, function () {\n                  n.withinOwners(r, function (n, o) {\n                    t(e, i, n, r, o, a, \"window\");\n                  });\n                });\n              });\n            });\n          };\n\n          for (var r in e) i(r);\n        }\n      }, {\n        key: \"bindClicks\",\n        value: function () {\n          this.bindClick(\"click\", \"click\", !1), this.bindClick(\"mousedown\", \"capture-click\", !0);\n        }\n      }, {\n        key: \"bindClick\",\n        value: function (e, t, n) {\n          var i = this,\n              r = this.binding(t);\n          window.addEventListener(e, function (e) {\n            if (i.isConnected()) {\n              var t = null,\n                  o = (t = n ? e.target.matches(\"[\".concat(r, \"]\")) ? e.target : e.target.querySelector(\"[\".concat(r, \"]\")) : G(e.target, r)) && t.getAttribute(r);\n              o && (\"#\" === t.getAttribute(\"href\") && e.preventDefault(), i.debounce(t, e, function () {\n                i.withinOwners(t, function (n, r) {\n                  n.pushEvent(\"click\", t, r, o, i.eventMeta(\"click\", e, t));\n                });\n              }));\n            }\n          }, n);\n        }\n      }, {\n        key: \"bindNav\",\n        value: function () {\n          var e = this;\n\n          if (ce.canPushState()) {\n            history.scrollRestoration && (history.scrollRestoration = \"manual\");\n            var t = null;\n            window.addEventListener(\"scroll\", function (e) {\n              clearTimeout(t), t = setTimeout(function () {\n                ce.updateCurrentState(function (e) {\n                  return Object.assign(e, {\n                    scroll: window.scrollY\n                  });\n                });\n              }, 100);\n            }), window.addEventListener(\"popstate\", function (t) {\n              if (e.registerNewLocation(window.location)) {\n                var n = t.state || {},\n                    i = n.type,\n                    r = n.id,\n                    o = n.root,\n                    a = n.scroll,\n                    u = window.location.href;\n                e.main.isConnected() && \"patch\" === i && r === e.main.id ? e.main.pushLinkPatch(u, null) : e.replaceMain(u, null, function () {\n                  o && e.replaceRootHistory(), \"number\" == typeof a && setTimeout(function () {\n                    window.scrollTo(0, a);\n                  }, 0);\n                });\n              }\n            }, !1), window.addEventListener(\"click\", function (t) {\n              var n = G(t.target, \"data-phx-link\"),\n                  i = n && n.getAttribute(\"data-phx-link\"),\n                  r = t.metaKey || t.ctrlKey || 1 === t.button;\n\n              if (i && e.isConnected() && e.main && !r) {\n                var o = n.href,\n                    a = n.getAttribute(\"data-phx-link-state\");\n                if (t.preventDefault(), e.pendingLink !== o) if (\"patch\" === i) e.pushHistoryPatch(o, a, n);else {\n                  if (\"redirect\" !== i) throw new Error(\"expected \".concat(\"data-phx-link\", ' to be \"patch\" or \"redirect\", got: ').concat(i));\n                  e.historyRedirect(o, a);\n                }\n              }\n            }, !1);\n          }\n        }\n      }, {\n        key: \"withPageLoading\",\n        value: function (e, t) {\n          le.dispatchEvent(window, \"phx:page-loading-start\", e);\n\n          var n = function () {\n            return le.dispatchEvent(window, \"phx:page-loading-stop\", e);\n          };\n\n          return t ? t(n) : n;\n        }\n      }, {\n        key: \"pushHistoryPatch\",\n        value: function (e, t, n) {\n          var i = this;\n          this.withPageLoading({\n            to: e,\n            kind: \"patch\"\n          }, function (r) {\n            i.main.pushLinkPatch(e, n, function () {\n              i.historyPatch(e, t), r();\n            });\n          });\n        }\n      }, {\n        key: \"historyPatch\",\n        value: function (e, t) {\n          ce.pushState(t, {\n            type: \"patch\",\n            id: this.main.id\n          }, e), this.registerNewLocation(window.location);\n        }\n      }, {\n        key: \"historyRedirect\",\n        value: function (e, t, n) {\n          var i = this,\n              r = window.scrollY;\n          this.withPageLoading({\n            to: e,\n            kind: \"redirect\"\n          }, function (o) {\n            i.replaceMain(e, n, function () {\n              ce.pushState(t, {\n                type: \"redirect\",\n                id: i.main.id,\n                scroll: r\n              }, e), i.registerNewLocation(window.location), o();\n            });\n          });\n        }\n      }, {\n        key: \"replaceRootHistory\",\n        value: function () {\n          ce.pushState(\"replace\", {\n            root: !0,\n            type: \"patch\",\n            id: this.main.id\n          });\n        }\n      }, {\n        key: \"registerNewLocation\",\n        value: function (e) {\n          var t = this.currentLocation;\n          return t.pathname + t.search !== e.pathname + e.search && (this.currentLocation = $(e), !0);\n        }\n      }, {\n        key: \"bindForms\",\n        value: function () {\n          var e = this,\n              t = 0;\n          this.on(\"submit\", function (t) {\n            var n = t.target.getAttribute(e.binding(\"submit\"));\n            n && (t.preventDefault(), t.target.disabled = !0, e.withinOwners(t.target, function (e, i) {\n              return e.submitForm(t.target, i, n);\n            }));\n          }, !1);\n\n          for (var n = function () {\n            var n = r[i];\n            e.on(n, function (i) {\n              var r = i.target,\n                  o = r.form && r.form.getAttribute(e.binding(\"change\"));\n\n              if (o && (\"number\" !== r.type || !r.validity || !r.validity.badInput)) {\n                var a = t;\n                t++;\n                var u = le.private(r, \"prev-iteration\") || {},\n                    s = u.at,\n                    c = u.type;\n                s === a - 1 && n !== c || (le.putPrivate(r, \"prev-iteration\", {\n                  at: a,\n                  type: n\n                }), e.debounce(r, i, function () {\n                  e.withinOwners(r.form, function (t, n) {\n                    le.putPrivate(r, \"phx-has-focused\", !0), le.isTextualInput(r) || e.setActiveElement(r), t.pushInput(r, n, o, i.target);\n                  });\n                }));\n              }\n            }, !1);\n          }, i = 0, r = [\"change\", \"input\"]; i < r.length; i++) n();\n        }\n      }, {\n        key: \"debounce\",\n        value: function (e, t, n) {\n          var i = this.binding(\"debounce\"),\n              r = this.binding(\"throttle\"),\n              o = this.defaults.debounce.toString(),\n              a = this.defaults.throttle.toString();\n          le.debounce(e, t, i, o, r, a, n);\n        }\n      }, {\n        key: \"silenceEvents\",\n        value: function (e) {\n          this.silenced = !0, e(), this.silenced = !1;\n        }\n      }, {\n        key: \"on\",\n        value: function (e, t) {\n          var n = this;\n          window.addEventListener(e, function (e) {\n            n.silenced || t(e);\n          });\n        }\n      }]), e;\n    }(),\n        ce = {\n      canPushState: function () {\n        return void 0 !== history.pushState;\n      },\n      dropLocal: function (e, t) {\n        return window.localStorage.removeItem(this.localKey(e, t));\n      },\n      updateLocal: function (e, t, n, i) {\n        var r = this.getLocal(e, t),\n            o = this.localKey(e, t),\n            a = null === r ? n : i(r);\n        return window.localStorage.setItem(o, JSON.stringify(a)), a;\n      },\n      getLocal: function (e, t) {\n        return JSON.parse(window.localStorage.getItem(this.localKey(e, t)));\n      },\n      fetchPage: function (e, t) {\n        var n = new XMLHttpRequest();\n        n.open(\"GET\", e, !0), n.timeout = 3e4, n.setRequestHeader(\"content-type\", \"text/html\"), n.setRequestHeader(\"cache-control\", \"max-age=0, no-cache, no-store, must-revalidate, post-check=0, pre-check=0\"), n.setRequestHeader(\"x-requested-with\", \"live-link\"), n.onerror = function () {\n          return t(400);\n        }, n.ontimeout = function () {\n          return t(504);\n        }, n.onreadystatechange = function () {\n          if (4 === n.readyState) {\n            var i = new URL(e),\n                r = i.pathname + i.search,\n                o = Z(n.getResponseHeader(\"x-response-url\") || n.responseURL, function (e) {\n              return new URL(e);\n            }),\n                a = o ? o.pathname + o.search : null;\n            return \"live-link\" !== n.getResponseHeader(\"x-requested-with\") ? t(400) : null === o || a != r ? t(302) : 200 !== n.status ? t(n.status) : void t(200, n.responseText);\n          }\n        }, n.send();\n      },\n      updateCurrentState: function (e) {\n        this.canPushState() && history.replaceState(e(history.state || {}), \"\", window.location.href);\n      },\n      pushState: function (e, t, n) {\n        if (this.canPushState()) {\n          if (n !== window.location.href) {\n            if (\"redirect\" == t.type && t.scroll) {\n              var i = history.state || {};\n              i.scroll = t.scroll, history.replaceState(i, \"\", window.location.href);\n            }\n\n            delete t.scroll, history[e + \"State\"](t, \"\", n || null);\n            var r = this.getHashTargetEl(window.location.hash);\n            r ? r.scrollIntoView() : \"redirect\" === t.type && window.scroll(0, 0);\n          }\n        } else this.redirect(n);\n      },\n      setCookie: function (e, t) {\n        document.cookie = \"\".concat(e, \"=\").concat(t);\n      },\n      getCookie: function (e) {\n        return document.cookie.replace(new RegExp(\"(?:(?:^|.*;s*)\".concat(e, \"s*=s*([^;]*).*$)|^.*$\")), \"$1\");\n      },\n      redirect: function (e, t) {\n        t && ce.setCookie(\"__phoenix_flash__\", t + \"; max-age=60000; path=/\"), window.location = e;\n      },\n      localKey: function (e, t) {\n        return \"\".concat(e, \"-\").concat(t);\n      },\n      getHashTargetEl: function (e) {\n        var t = e.toString().substring(1);\n        if (\"\" !== t) return document.getElementById(t) || document.querySelector('a[name=\"'.concat(t, '\"]'));\n      }\n    },\n        le = {\n      byId: function (e) {\n        return document.getElementById(e) || z(\"no id found for \".concat(e));\n      },\n      removeClass: function (e, t) {\n        e.classList.remove(t), 0 === e.classList.length && e.removeAttribute(\"class\");\n      },\n      all: function (e, t, n) {\n        var i = Array.from(e.querySelectorAll(t));\n        return n ? i.forEach(n) : i;\n      },\n      childNodeLength: function (e) {\n        var t = document.createElement(\"template\");\n        return t.innerHTML = e, t.content.childElementCount;\n      },\n      isUploadInput: function (e) {\n        return \"file\" === e.type && null !== e.getAttribute(M);\n      },\n      findUploadInputs: function (e) {\n        return this.all(e, 'input[type=\"file\"]['.concat(M, \"]\"));\n      },\n      findComponentNodeList: function (e, t) {\n        return this.filterWithinSameLiveView(this.all(e, \"[\".concat(H, '=\"').concat(t, '\"]')), e);\n      },\n      isPhxDestroyed: function (e) {\n        return !(!e.id || !le.private(e, \"destroyed\"));\n      },\n      markPhxChildDestroyed: function (e) {\n        e.setAttribute(\"data-phx-session\", \"\"), this.putPrivate(e, \"destroyed\", !0);\n      },\n      findPhxChildrenInFragment: function (e, t) {\n        var n = document.createElement(\"template\");\n        return n.innerHTML = e, this.findPhxChildren(n.content, t);\n      },\n      isIgnored: function (e, t) {\n        return \"ignore\" === (e.getAttribute(t) || e.getAttribute(\"data-phx-update\"));\n      },\n      isPhxUpdate: function (e, t, n) {\n        return e.getAttribute && n.indexOf(e.getAttribute(t)) >= 0;\n      },\n      findPhxChildren: function (e, t) {\n        return this.all(e, \"\".concat(U, \"[\").concat(\"data-phx-parent-id\", '=\"').concat(t, '\"]'));\n      },\n      findParentCIDs: function (e, t) {\n        var n = this,\n            i = new Set(t);\n        return t.reduce(function (t, i) {\n          var r = \"[\".concat(H, '=\"').concat(i, '\"] [').concat(H, \"]\");\n          return n.filterWithinSameLiveView(n.all(e, r), e).map(function (e) {\n            return parseInt(e.getAttribute(H));\n          }).forEach(function (e) {\n            return t.delete(e);\n          }), t;\n        }, i);\n      },\n      filterWithinSameLiveView: function (e, t) {\n        var n = this;\n        return t.querySelector(U) ? e.filter(function (e) {\n          return n.withinSameLiveView(e, t);\n        }) : e;\n      },\n      withinSameLiveView: function (e, t) {\n        for (; e = e.parentNode;) {\n          if (e.isSameNode(t)) return !0;\n          if (e.getAttribute(O)) return !1;\n        }\n      },\n      private: function (e, t) {\n        return e.phxPrivate && e.phxPrivate[t];\n      },\n      deletePrivate: function (e, t) {\n        e.phxPrivate && delete e.phxPrivate[t];\n      },\n      putPrivate: function (e, t, n) {\n        e.phxPrivate || (e.phxPrivate = {}), e.phxPrivate[t] = n;\n      },\n      copyPrivates: function (e, t) {\n        t.phxPrivate && (e.phxPrivate = $(t.phxPrivate));\n      },\n      putTitle: function (e) {\n        var t = document.querySelector(\"title\").dataset,\n            n = t.prefix,\n            i = t.suffix;\n        document.title = \"\".concat(n || \"\").concat(e).concat(i || \"\");\n      },\n      debounce: function (e, t, n, i, r, o, a) {\n        var u = this,\n            s = e.getAttribute(n),\n            c = e.getAttribute(r);\n        \"\" === s && (s = i), \"\" === c && (c = o);\n        var l = s || c;\n\n        switch (l) {\n          case null:\n            return a();\n\n          case \"blur\":\n            return void (this.once(e, \"debounce-blur\") && e.addEventListener(\"blur\", function () {\n              return a();\n            }));\n\n          default:\n            var d = parseInt(l),\n                h = this.incCycle(e, \"debounce-trigger\", function () {\n              return c ? u.deletePrivate(e, \"throttled\") : a();\n            });\n            if (isNaN(d)) return z(\"invalid throttle/debounce value: \".concat(l));\n\n            if (c) {\n              var f = !1;\n\n              if (\"keydown\" === t.type) {\n                var v = this.private(e, \"debounce-prev-key\");\n                this.putPrivate(e, \"debounce-prev-key\", t.key), f = v !== t.key;\n              }\n\n              if (!f && this.private(e, \"throttled\")) return !1;\n              a(), this.putPrivate(e, \"throttled\", !0), setTimeout(function () {\n                return u.triggerCycle(e, \"debounce-trigger\");\n              }, d);\n            } else setTimeout(function () {\n              return u.triggerCycle(e, \"debounce-trigger\", h);\n            }, d);\n\n            e.form && this.once(e.form, \"bind-debounce\") && e.form.addEventListener(\"submit\", function (t) {\n              Array.from(new FormData(e.form).entries(), function (t) {\n                var n = x(t, 2),\n                    i = n[0],\n                    r = (n[1], e.form.querySelector('[name=\"'.concat(i, '\"]')));\n                u.incCycle(r, \"debounce-trigger\"), u.deletePrivate(r, \"throttled\");\n              });\n            }), this.once(e, \"bind-debounce\") && e.addEventListener(\"blur\", function (t) {\n              return u.triggerCycle(e, \"debounce-trigger\");\n            });\n        }\n      },\n      triggerCycle: function (e, t, n) {\n        var i = x(this.private(e, t), 2),\n            r = i[0],\n            o = i[1];\n        n || (n = r), n === r && (this.incCycle(e, t), o());\n      },\n      once: function (e, t) {\n        return !0 !== this.private(e, t) && (this.putPrivate(e, t, !0), !0);\n      },\n      incCycle: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {},\n            i = x(this.private(e, t) || [0, n], 2),\n            r = i[0];\n        i[1];\n        return r++, this.putPrivate(e, t, [r, n]), r;\n      },\n      discardError: function (e, t, n) {\n        var i = t.getAttribute && t.getAttribute(n),\n            r = i && e.querySelector('[id=\"'.concat(i, '\"], [name=\"').concat(i, '\"]'));\n        r && (this.private(r, \"phx-has-focused\") || this.private(r.form, \"phx-has-submitted\") || t.classList.add(\"phx-no-feedback\"));\n      },\n      showError: function (e, t) {\n        var n = this;\n        (e.id || e.name) && this.all(e.form, \"[\".concat(t, '=\"').concat(e.id, '\"], [').concat(t, '=\"').concat(e.name, '\"]'), function (e) {\n          n.removeClass(e, \"phx-no-feedback\");\n        });\n      },\n      isPhxChild: function (e) {\n        return e.getAttribute && e.getAttribute(\"data-phx-parent-id\");\n      },\n      dispatchEvent: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n            i = new CustomEvent(t, {\n          bubbles: !0,\n          cancelable: !0,\n          detail: n\n        });\n        e.dispatchEvent(i);\n      },\n      cloneNode: function (e, t) {\n        if (void 0 === t) return e.cloneNode(!0);\n        var n = e.cloneNode(!1);\n        return n.innerHTML = t, n;\n      },\n      mergeAttrs: function (e, t) {\n        for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = n.exclude || [], r = n.isIgnored, o = t.attributes, a = o.length - 1; a >= 0; a--) {\n          var u = o[a].name;\n          i.indexOf(u) < 0 && e.setAttribute(u, t.getAttribute(u));\n        }\n\n        for (var s = e.attributes, c = s.length - 1; c >= 0; c--) {\n          var l = s[c].name;\n          r ? l.startsWith(\"data-\") && !t.hasAttribute(l) && e.removeAttribute(l) : t.hasAttribute(l) || e.removeAttribute(l);\n        }\n      },\n      mergeFocusedInput: function (e, t) {\n        e instanceof HTMLSelectElement || le.mergeAttrs(e, t, {\n          except: [\"value\"]\n        }), t.readOnly ? e.setAttribute(\"readonly\", !0) : e.removeAttribute(\"readonly\");\n      },\n      hasSelectionRange: function (e) {\n        return e.setSelectionRange && (\"text\" === e.type || \"textarea\" === e.type);\n      },\n      restoreFocus: function (e, t, n) {\n        if (le.isTextualInput(e)) {\n          var i = e.matches(\":focus\");\n          e.readOnly && e.blur(), i || e.focus(), this.hasSelectionRange(e) && e.setSelectionRange(t, n);\n        }\n      },\n      isFormInput: function (e) {\n        return /^(?:input|select|textarea)$/i.test(e.tagName) && \"button\" !== e.type;\n      },\n      syncAttrsToProps: function (e) {\n        e instanceof HTMLInputElement && J.indexOf(e.type.toLocaleLowerCase()) >= 0 && (e.checked = null !== e.getAttribute(\"checked\"));\n      },\n      isTextualInput: function (e) {\n        return B.indexOf(e.type) >= 0;\n      },\n      isNowTriggerFormExternal: function (e, t) {\n        return e.getAttribute && null !== e.getAttribute(t);\n      },\n      syncPendingRef: function (e, t, n) {\n        var i = e.getAttribute(F);\n        return null === i || (le.isFormInput(e) || null !== e.getAttribute(n) ? (le.isUploadInput(e) && le.mergeAttrs(e, t, {\n          isIgnored: !0\n        }), le.putPrivate(e, F, t), !1) : (j.forEach(function (n) {\n          e.classList.contains(n) && t.classList.add(n);\n        }), t.setAttribute(F, i), !0));\n      },\n      cleanChildNodes: function (e, t) {\n        if (le.isPhxUpdate(e, t, [\"append\", \"prepend\"])) {\n          var n = [];\n          e.childNodes.forEach(function (e) {\n            e.id || (e.nodeType === Node.TEXT_NODE && \"\" === e.nodeValue.trim() || z(\"only HTML element tags with an id are allowed inside containers with phx-update.\\n\\n\" + 'removing illegal node: \"'.concat((e.outerHTML || e.nodeValue).trim(), '\"\\n\\n')), n.push(e));\n          }), n.forEach(function (e) {\n            return e.remove();\n          });\n        }\n      }\n    },\n        de = function () {\n      function e(t, n, i) {\n        T(this, e);\n        var r = new Set(),\n            o = new Set(A(n.children).map(function (e) {\n          return e.id;\n        })),\n            a = [];\n        Array.from(t.children).forEach(function (e) {\n          if (e.id && (r.add(e.id), o.has(e.id))) {\n            var t = e.previousElementSibling && e.previousElementSibling.id;\n            a.push({\n              elementId: e.id,\n              previousElementId: t\n            });\n          }\n        }), this.containerId = n.id, this.updateType = i, this.elementsToModify = a, this.elementIdsToAdd = A(o).filter(function (e) {\n          return !r.has(e);\n        });\n      }\n\n      return _(e, [{\n        key: \"perform\",\n        value: function () {\n          var e = le.byId(this.containerId);\n          this.elementsToModify.forEach(function (t) {\n            t.previousElementId ? Z(document.getElementById(t.previousElementId), function (e) {\n              Z(document.getElementById(t.elementId), function (t) {\n                t.previousElementSibling && t.previousElementSibling.id == e.id || e.insertAdjacentElement(\"afterend\", t);\n              });\n            }) : Z(document.getElementById(t.elementId), function (t) {\n              null == t.previousElementSibling || e.insertAdjacentElement(\"afterbegin\", t);\n            });\n          }), \"prepend\" == this.updateType && this.elementIdsToAdd.reverse().forEach(function (t) {\n            Z(document.getElementById(t), function (t) {\n              return e.insertAdjacentElement(\"afterbegin\", t);\n            });\n          });\n        }\n      }]), e;\n    }(),\n        he = function () {\n      function e(t, n, i, r, o) {\n        T(this, e), this.view = t, this.liveSocket = t.liveSocket, this.container = n, this.id = i, this.rootID = t.root.id, this.html = r, this.targetCID = o, this.cidPatch = \"number\" == typeof this.targetCID, this.callbacks = {\n          beforeadded: [],\n          beforeupdated: [],\n          beforephxChildAdded: [],\n          afteradded: [],\n          afterupdated: [],\n          afterdiscarded: [],\n          afterphxChildAdded: []\n        };\n      }\n\n      return _(e, null, [{\n        key: \"patchEl\",\n        value: function (e, t, n) {\n          b(e, t, {\n            childrenOnly: !1,\n            onBeforeElUpdated: function (e, t) {\n              if (n && n.isSameNode(e) && le.isFormInput(e)) return le.mergeFocusedInput(e, t), !1;\n            }\n          });\n        }\n      }]), _(e, [{\n        key: \"before\",\n        value: function (e, t) {\n          this.callbacks[\"before\".concat(e)].push(t);\n        }\n      }, {\n        key: \"after\",\n        value: function (e, t) {\n          this.callbacks[\"after\".concat(e)].push(t);\n        }\n      }, {\n        key: \"trackBefore\",\n        value: function (e) {\n          for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];\n\n          this.callbacks[\"before\".concat(e)].forEach(function (e) {\n            return e.apply(void 0, n);\n          });\n        }\n      }, {\n        key: \"trackAfter\",\n        value: function (e) {\n          for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];\n\n          this.callbacks[\"after\".concat(e)].forEach(function (e) {\n            return e.apply(void 0, n);\n          });\n        }\n      }, {\n        key: \"markPrunableContentForRemoval\",\n        value: function () {\n          le.all(this.container, \"[phx-update=append] > *, [phx-update=prepend] > *\", function (e) {\n            e.setAttribute(\"data-phx-remove\", \"\");\n          });\n        }\n      }, {\n        key: \"perform\",\n        value: function () {\n          var e = this,\n              t = this.view,\n              n = this.liveSocket,\n              i = this.container,\n              r = this.html,\n              o = this.isCIDPatch() ? this.targetCIDContainer(r) : i;\n\n          if (!this.isCIDPatch() || o) {\n            var a = n.getActiveElement(),\n                u = a && le.hasSelectionRange(a) ? a : {},\n                s = u.selectionStart,\n                c = u.selectionEnd,\n                l = n.binding(\"update\"),\n                d = n.binding(\"feedback-for\"),\n                h = n.binding(\"disable-with\"),\n                f = n.binding(\"trigger-action\"),\n                v = [],\n                p = [],\n                g = [],\n                m = null,\n                y = n.time(\"premorph container prep\", function () {\n              return e.buildDiffHTML(i, r, l, o);\n            });\n            return this.trackBefore(\"added\", i), this.trackBefore(\"updated\", i, i), n.time(\"morphdom\", function () {\n              b(o, y, {\n                childrenOnly: null === o.getAttribute(H),\n                getNodeKey: function (e) {\n                  return le.isPhxDestroyed(e) ? null : e.id;\n                },\n                onBeforeNodeAdded: function (t) {\n                  return le.discardError(o, t, d), e.trackBefore(\"added\", t), t;\n                },\n                onNodeAdded: function (n) {\n                  le.isNowTriggerFormExternal(n, f) && (m = n), le.isPhxChild(n) && t.ownsElement(n) && e.trackAfter(\"phxChildAdded\", n), v.push(n);\n                },\n                onNodeDiscarded: function (t) {\n                  le.isPhxChild(t) && n.destroyViewByEl(t), e.trackAfter(\"discarded\", t);\n                },\n                onBeforeNodeDiscarded: function (t) {\n                  return !(!t.getAttribute || null === t.getAttribute(\"data-phx-remove\")) || (null === t.parentNode || !le.isPhxUpdate(t.parentNode, l, [\"append\", \"prepend\"]) || !t.id) && !e.skipCIDSibling(t);\n                },\n                onElUpdated: function (e) {\n                  le.isNowTriggerFormExternal(e, f) && (m = e), p.push(e);\n                },\n                onBeforeElUpdated: function (t, n) {\n                  if (le.cleanChildNodes(n, l), e.skipCIDSibling(n)) return !1;\n                  if (le.isIgnored(t, l)) return e.trackBefore(\"updated\", t, n), le.mergeAttrs(t, n, {\n                    isIgnored: !0\n                  }), p.push(t), !1;\n                  if (\"number\" === t.type && t.validity && t.validity.badInput) return !1;\n                  if (!le.syncPendingRef(t, n, h)) return le.isUploadInput(t) && (e.trackBefore(\"updated\", t, n), p.push(t)), !1;\n\n                  if (le.isPhxChild(n)) {\n                    var i = t.getAttribute(\"data-phx-session\");\n                    return le.mergeAttrs(t, n, {\n                      exclude: [\"data-phx-static\"]\n                    }), \"\" !== i && t.setAttribute(\"data-phx-session\", i), t.setAttribute(\"data-phx-root-id\", e.rootID), !1;\n                  }\n\n                  return le.copyPrivates(n, t), le.discardError(o, n, d), a && t.isSameNode(a) && le.isFormInput(t) && !e.forceFocusedSelectUpdate(t, n) ? (e.trackBefore(\"updated\", t, n), le.mergeFocusedInput(t, n), le.syncAttrsToProps(t), p.push(t), !1) : (le.isPhxUpdate(n, l, [\"append\", \"prepend\"]) && g.push(new de(t, n, n.getAttribute(l))), le.syncAttrsToProps(n), e.trackBefore(\"updated\", t, n), !0);\n                }\n              });\n            }), n.isDebugEnabled() && function () {\n              for (var e = new Set(), t = document.querySelectorAll(\"*[id]\"), n = 0, i = t.length; n < i; n++) e.has(t[n].id) ? console.error(\"Multiple IDs detected: \".concat(t[n].id, \". Ensure unique element ids.\")) : e.add(t[n].id);\n            }(), g.length > 0 && n.time(\"post-morph append/prepend restoration\", function () {\n              g.forEach(function (e) {\n                return e.perform();\n              });\n            }), n.silenceEvents(function () {\n              return le.restoreFocus(a, s, c);\n            }), le.dispatchEvent(document, \"phx:update\"), v.forEach(function (t) {\n              return e.trackAfter(\"added\", t);\n            }), p.forEach(function (t) {\n              return e.trackAfter(\"updated\", t);\n            }), m && (n.disconnect(), m.submit()), !0;\n          }\n        }\n      }, {\n        key: \"forceFocusedSelectUpdate\",\n        value: function (e, t) {\n          var n = [\"select\", \"select-one\", \"select-multiple\"].find(function (t) {\n            return t === e.type;\n          });\n          return !0 === e.multiple || n && e.innerHTML != t.innerHTML;\n        }\n      }, {\n        key: \"isCIDPatch\",\n        value: function () {\n          return this.cidPatch;\n        }\n      }, {\n        key: \"skipCIDSibling\",\n        value: function (e) {\n          return e.nodeType === Node.ELEMENT_NODE && null !== e.getAttribute(\"data-phx-skip\");\n        }\n      }, {\n        key: \"targetCIDContainer\",\n        value: function (e) {\n          if (this.isCIDPatch()) {\n            var t = k(le.findComponentNodeList(this.container, this.targetCID)),\n                n = t[0];\n            return 0 === t.slice(1).length && 1 === le.childNodeLength(e) ? n : n && n.parentNode;\n          }\n        }\n      }, {\n        key: \"buildDiffHTML\",\n        value: function (e, t, n, i) {\n          var r = this,\n              o = this.isCIDPatch(),\n              a = o && i.getAttribute(H) === this.targetCID.toString();\n          if (!o || a) return t;\n          var u = null,\n              s = document.createElement(\"template\");\n          u = le.cloneNode(i);\n          var c = k(le.findComponentNodeList(u, this.targetCID)),\n              l = c[0],\n              d = c.slice(1);\n          return s.innerHTML = t, d.forEach(function (e) {\n            return e.remove();\n          }), Array.from(u.childNodes).forEach(function (e) {\n            e.id && e.nodeType === Node.ELEMENT_NODE && e.getAttribute(H) !== r.targetCID.toString() && (e.setAttribute(\"data-phx-skip\", \"\"), e.innerHTML = \"\");\n          }), Array.from(s.content.childNodes).forEach(function (e) {\n            return u.insertBefore(e, l);\n          }), l.remove(), u.outerHTML;\n        }\n      }]), e;\n    }(),\n        fe = function () {\n      function e(t, n, i, r, o) {\n        var a = this;\n        T(this, e), this.liveSocket = n, this.flash = o, this.parent = i, this.root = i ? i.root : this, this.el = t, this.id = this.el.id, this.view = this.el.getAttribute(O), this.ref = 0, this.childJoins = 0, this.loaderTimer = null, this.pendingDiffs = [], this.pruningCIDs = [], this.href = r, this.joinCount = this.parent ? this.parent.joinCount - 1 : 0, this.joinPending = !0, this.destroyed = !1, this.joinCallback = function () {}, this.stopCallback = function () {}, this.pendingJoinOps = this.parent ? null : [], this.viewHooks = {}, this.uploaders = {}, this.formSubmits = [], this.children = this.parent ? null : {}, this.root.children[this.id] = {}, this.channel = this.liveSocket.channel(\"lv:\".concat(this.id), function () {\n          return {\n            url: a.href,\n            params: a.connectParams(),\n            session: a.getSession(),\n            static: a.getStatic(),\n            flash: a.flash\n          };\n        }), this.showLoader(this.liveSocket.loaderTimeout), this.bindChannel();\n      }\n\n      return _(e, [{\n        key: \"isMain\",\n        value: function () {\n          return this.liveSocket.main === this;\n        }\n      }, {\n        key: \"connectParams\",\n        value: function () {\n          var e = this.liveSocket.params(this.view),\n              t = le.all(document, \"[\".concat(this.binding(\"track-static\"), \"]\")).map(function (e) {\n            return e.src || e.href;\n          }).filter(function (e) {\n            return \"string\" == typeof e;\n          });\n          return t.length > 0 && (e._track_static = t), e._mounts = this.joinCount, e;\n        }\n      }, {\n        key: \"name\",\n        value: function () {\n          return this.view;\n        }\n      }, {\n        key: \"isConnected\",\n        value: function () {\n          return this.channel.canPush();\n        }\n      }, {\n        key: \"getSession\",\n        value: function () {\n          return this.el.getAttribute(\"data-phx-session\");\n        }\n      }, {\n        key: \"getStatic\",\n        value: function () {\n          var e = this.el.getAttribute(\"data-phx-static\");\n          return \"\" === e ? null : e;\n        }\n      }, {\n        key: \"destroy\",\n        value: function () {\n          var e = this,\n              t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {};\n          this.destroyAllChildren(), this.destroyed = !0, delete this.root.children[this.id], this.parent && delete this.root.children[this.parent.id][this.id], clearTimeout(this.loaderTimer);\n\n          var n = function () {\n            for (var n in t(), e.viewHooks) e.destroyHook(e.viewHooks[n]);\n          };\n\n          le.markPhxChildDestroyed(this.el), this.log(\"destroyed\", function () {\n            return [\"the child has been removed from the parent\"];\n          }), this.channel.leave().receive(\"ok\", n).receive(\"error\", n).receive(\"timeout\", n);\n        }\n      }, {\n        key: \"setContainerClasses\",\n        value: function () {\n          var e;\n          this.el.classList.remove(\"phx-connected\", \"phx-disconnected\", \"phx-error\"), (e = this.el.classList).add.apply(e, arguments);\n        }\n      }, {\n        key: \"isLoading\",\n        value: function () {\n          return this.el.classList.contains(\"phx-disconnected\");\n        }\n      }, {\n        key: \"showLoader\",\n        value: function (e) {\n          var t = this;\n          if (clearTimeout(this.loaderTimer), e) this.loaderTimer = setTimeout(function () {\n            return t.showLoader();\n          }, e);else {\n            for (var n in this.viewHooks) this.viewHooks[n].__disconnected();\n\n            this.setContainerClasses(\"phx-disconnected\");\n          }\n        }\n      }, {\n        key: \"hideLoader\",\n        value: function () {\n          clearTimeout(this.loaderTimer), this.setContainerClasses(\"phx-connected\");\n        }\n      }, {\n        key: \"triggerReconnected\",\n        value: function () {\n          for (var e in this.viewHooks) this.viewHooks[e].__reconnected();\n        }\n      }, {\n        key: \"log\",\n        value: function (e, t) {\n          this.liveSocket.log(this, e, t);\n        }\n      }, {\n        key: \"withinTargets\",\n        value: function (e, t) {\n          var n = this;\n\n          if (/^(0|[1-9]\\d*)$/.test(e)) {\n            var i = le.findComponentNodeList(this.el, e);\n            0 === i.length ? z(\"no component found matching phx-target of \".concat(e)) : t(this, i[0]);\n          } else {\n            var r = Array.from(document.querySelectorAll(e));\n            0 === r.length && z('nothing found matching the phx-target selector \"'.concat(e, '\"')), r.forEach(function (e) {\n              return n.liveSocket.owner(e, function (n) {\n                return t(n, e);\n              });\n            });\n          }\n        }\n      }, {\n        key: \"applyDiff\",\n        value: function (e, t, n) {\n          this.log(e, function () {\n            return [\"\", $(t)];\n          });\n          var i = ue.extract(t),\n              r = i.diff,\n              o = i.reply,\n              a = i.events,\n              u = i.title;\n          return u && le.putTitle(u), n({\n            diff: r,\n            reply: o,\n            events: a\n          }), o;\n        }\n      }, {\n        key: \"onJoin\",\n        value: function (e) {\n          var t = this,\n              n = e.rendered;\n          this.childJoins = 0, this.joinPending = !0, this.flash = null, ce.dropLocal(this.name(), \"consecutive-reloads\"), this.applyDiff(\"mount\", n, function (n) {\n            var i = n.diff,\n                r = n.events;\n            t.rendered = new ue(t.id, i);\n            var o = t.renderContainer(null, \"join\");\n            t.dropPendingRefs();\n            var a = t.formsForRecovery(o);\n            t.joinCount++, a.length > 0 ? a.forEach(function (e, n) {\n              t.pushFormRecovery(e, function (e) {\n                n === a.length - 1 && t.onJoinComplete(e, o, r);\n              });\n            }) : t.onJoinComplete(e, o, r);\n          });\n        }\n      }, {\n        key: \"dropPendingRefs\",\n        value: function () {\n          le.all(this.el, \"[\".concat(F, \"]\"), function (e) {\n            return e.removeAttribute(F);\n          });\n        }\n      }, {\n        key: \"onJoinComplete\",\n        value: function (e, t, n) {\n          var i = this,\n              r = e.live_patch;\n          if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) return this.applyJoinPatch(r, t, n);\n          0 === le.findPhxChildrenInFragment(t, this.id).filter(function (e) {\n            var t = e.id && i.el.querySelector(\"#\".concat(e.id)),\n                n = t && t.getAttribute(\"data-phx-static\");\n            return n && e.setAttribute(\"data-phx-static\", n), i.joinChild(e);\n          }).length ? this.parent ? (this.root.pendingJoinOps.push([this, function () {\n            return i.applyJoinPatch(r, t, n);\n          }]), this.parent.ackJoin(this)) : (this.onAllChildJoinsComplete(), this.applyJoinPatch(r, t, n)) : this.root.pendingJoinOps.push([this, function () {\n            return i.applyJoinPatch(r, t, n);\n          }]);\n        }\n      }, {\n        key: \"attachTrueDocEl\",\n        value: function () {\n          this.el = le.byId(this.id), this.el.setAttribute(\"data-phx-root-id\", this.root.id);\n        }\n      }, {\n        key: \"dispatchEvents\",\n        value: function (e) {\n          e.forEach(function (e) {\n            var t = x(e, 2),\n                n = t[0],\n                i = t[1];\n            window.dispatchEvent(new CustomEvent(\"phx:hook:\".concat(n), {\n              detail: i\n            }));\n          });\n        }\n      }, {\n        key: \"applyJoinPatch\",\n        value: function (e, t, n) {\n          var i = this;\n          this.attachTrueDocEl();\n          var r = new he(this, this.el, this.id, t, null);\n\n          if (r.markPrunableContentForRemoval(), this.performPatch(r, !1), this.joinNewChildren(), le.all(this.el, \"[\".concat(this.binding(\"hook\"), \"], [data-phx-\").concat(\"hook\", \"]\"), function (e) {\n            var t = i.addHook(e);\n            t && t.__mounted();\n          }), this.joinPending = !1, this.dispatchEvents(n), this.applyPendingUpdates(), e) {\n            var o = e.kind,\n                a = e.to;\n            this.liveSocket.historyPatch(a, o);\n          }\n\n          this.hideLoader(), this.joinCount > 1 && this.triggerReconnected(), this.stopCallback();\n        }\n      }, {\n        key: \"triggerBeforeUpdateHook\",\n        value: function (e, t) {\n          this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [e, t]);\n          var n = this.getHook(e),\n              i = n && le.isIgnored(e, this.binding(\"update\"));\n          if (n && !e.isEqualNode(t) && (!i || !function (e, t) {\n            return JSON.stringify(e) === JSON.stringify(t);\n          }(e.dataset, t.dataset))) return n.__beforeUpdate(), n;\n        }\n      }, {\n        key: \"performPatch\",\n        value: function (e, t) {\n          var n = this,\n              i = [],\n              r = !1,\n              o = new Set();\n          return e.after(\"added\", function (e) {\n            n.liveSocket.triggerDOM(\"onNodeAdded\", [e]);\n            var t = n.addHook(e);\n            t && t.__mounted();\n          }), e.after(\"phxChildAdded\", function (e) {\n            return r = !0;\n          }), e.before(\"updated\", function (e, t) {\n            n.triggerBeforeUpdateHook(e, t) && o.add(e.id);\n          }), e.after(\"updated\", function (e) {\n            o.has(e.id) && n.getHook(e).__updated();\n          }), e.after(\"discarded\", function (e) {\n            var t = n.componentID(e);\n            \"number\" == typeof t && -1 === i.indexOf(t) && i.push(t);\n            var r = n.getHook(e);\n            r && n.destroyHook(r);\n          }), e.perform(), t && this.maybePushComponentsDestroyed(i), r;\n        }\n      }, {\n        key: \"joinNewChildren\",\n        value: function () {\n          var e = this;\n          le.findPhxChildren(this.el, this.id).forEach(function (t) {\n            return e.joinChild(t);\n          });\n        }\n      }, {\n        key: \"getChildById\",\n        value: function (e) {\n          return this.root.children[this.id][e];\n        }\n      }, {\n        key: \"getDescendentByEl\",\n        value: function (e) {\n          return e.id === this.id ? this : this.children[e.getAttribute(\"data-phx-parent-id\")][e.id];\n        }\n      }, {\n        key: \"destroyDescendent\",\n        value: function (e) {\n          for (var t in this.root.children) for (var n in this.root.children[t]) if (n === e) return this.root.children[t][n].destroy();\n        }\n      }, {\n        key: \"joinChild\",\n        value: function (t) {\n          if (!this.getChildById(t.id)) {\n            var n = new e(t, this.liveSocket, this);\n            return this.root.children[this.id][n.id] = n, n.join(), this.childJoins++, !0;\n          }\n        }\n      }, {\n        key: \"isJoinPending\",\n        value: function () {\n          return this.joinPending;\n        }\n      }, {\n        key: \"ackJoin\",\n        value: function (e) {\n          this.childJoins--, 0 === this.childJoins && (this.parent ? this.parent.ackJoin(this) : this.onAllChildJoinsComplete());\n        }\n      }, {\n        key: \"onAllChildJoinsComplete\",\n        value: function () {\n          this.joinCallback(), this.pendingJoinOps.forEach(function (e) {\n            var t = x(e, 2),\n                n = t[0],\n                i = t[1];\n            n.isDestroyed() || i();\n          }), this.pendingJoinOps = [];\n        }\n      }, {\n        key: \"update\",\n        value: function (e, t) {\n          var n = this;\n          if (this.isJoinPending() || this.liveSocket.hasPendingLink()) return this.pendingDiffs.push({\n            diff: e,\n            events: t\n          });\n          this.rendered.mergeDiff(e);\n          var i = !1;\n          this.rendered.isComponentOnlyDiff(e) ? this.liveSocket.time(\"component patch complete\", function () {\n            le.findParentCIDs(n.el, n.rendered.componentCIDs(e)).forEach(function (t) {\n              n.componentPatch(n.rendered.getComponent(e, t), t) && (i = !0);\n            });\n          }) : Q(e) || this.liveSocket.time(\"full patch complete\", function () {\n            var t = n.renderContainer(e, \"update\"),\n                r = new he(n, n.el, n.id, t, null);\n            i = n.performPatch(r, !0);\n          }), this.dispatchEvents(t), i && this.joinNewChildren();\n        }\n      }, {\n        key: \"renderContainer\",\n        value: function (e, t) {\n          var n = this;\n          return this.liveSocket.time(\"toString diff (\".concat(t, \")\"), function () {\n            var t = n.el.tagName,\n                i = e ? n.rendered.componentCIDs(e).concat(n.pruningCIDs) : null,\n                r = n.rendered.toString(i);\n            return \"<\".concat(t, \">\").concat(r, \"</\").concat(t, \">\");\n          });\n        }\n      }, {\n        key: \"componentPatch\",\n        value: function (e, t) {\n          if (Q(e)) return !1;\n          var n = this.rendered.componentToString(t),\n              i = new he(this, this.el, this.id, n, t);\n          return this.performPatch(i, !0);\n        }\n      }, {\n        key: \"getHook\",\n        value: function (e) {\n          return this.viewHooks[pe.elementID(e)];\n        }\n      }, {\n        key: \"addHook\",\n        value: function (e) {\n          if (!pe.elementID(e) && e.getAttribute) {\n            var t = e.getAttribute(\"data-phx-\".concat(\"hook\")) || e.getAttribute(this.binding(\"hook\"));\n\n            if (!t || this.ownsElement(e)) {\n              var n = this.liveSocket.getHookCallbacks(t);\n\n              if (n) {\n                e.id || z('no DOM ID for hook \"'.concat(t, '\". Hooks require a unique ID on each element.'), e);\n                var i = new pe(this, e, n);\n                return this.viewHooks[pe.elementID(i.el)] = i, i;\n              }\n\n              null !== t && z('unknown hook found for \"'.concat(t, '\"'), e);\n            }\n          }\n        }\n      }, {\n        key: \"destroyHook\",\n        value: function (e) {\n          e.__destroyed(), e.__cleanup__(), delete this.viewHooks[pe.elementID(e.el)];\n        }\n      }, {\n        key: \"applyPendingUpdates\",\n        value: function () {\n          var e = this;\n          this.pendingDiffs.forEach(function (t) {\n            var n = t.diff,\n                i = t.events;\n            return e.update(n, i);\n          }), this.pendingDiffs = [];\n        }\n      }, {\n        key: \"onChannel\",\n        value: function (e, t) {\n          var n = this;\n          this.liveSocket.onChannel(this.channel, e, function (e) {\n            n.isJoinPending() ? n.root.pendingJoinOps.push([n, function () {\n              return t(e);\n            }]) : t(e);\n          });\n        }\n      }, {\n        key: \"bindChannel\",\n        value: function () {\n          var e = this;\n          this.liveSocket.onChannel(this.channel, \"diff\", function (t) {\n            e.applyDiff(\"update\", t, function (t) {\n              var n = t.diff,\n                  i = t.events;\n              return e.update(n, i);\n            });\n          }), this.onChannel(\"redirect\", function (t) {\n            var n = t.to,\n                i = t.flash;\n            return e.onRedirect({\n              to: n,\n              flash: i\n            });\n          }), this.onChannel(\"live_patch\", function (t) {\n            return e.onLivePatch(t);\n          }), this.onChannel(\"live_redirect\", function (t) {\n            return e.onLiveRedirect(t);\n          }), this.channel.onError(function (t) {\n            return e.onError(t);\n          }), this.channel.onClose(function (t) {\n            return e.onClose(t);\n          });\n        }\n      }, {\n        key: \"destroyAllChildren\",\n        value: function () {\n          for (var e in this.root.children[this.id]) this.getChildById(e).destroy();\n        }\n      }, {\n        key: \"onLiveRedirect\",\n        value: function (e) {\n          var t = e.to,\n              n = e.kind,\n              i = e.flash,\n              r = this.expandURL(t);\n          this.liveSocket.historyRedirect(r, n, i);\n        }\n      }, {\n        key: \"onLivePatch\",\n        value: function (e) {\n          var t = e.to,\n              n = e.kind;\n          this.href = this.expandURL(t), this.liveSocket.historyPatch(t, n);\n        }\n      }, {\n        key: \"expandURL\",\n        value: function (e) {\n          return e.startsWith(\"/\") ? \"\".concat(window.location.protocol, \"//\").concat(window.location.host).concat(e) : e;\n        }\n      }, {\n        key: \"onRedirect\",\n        value: function (e) {\n          var t = e.to,\n              n = e.flash;\n          this.liveSocket.redirect(t, n);\n        }\n      }, {\n        key: \"isDestroyed\",\n        value: function () {\n          return this.destroyed;\n        }\n      }, {\n        key: \"join\",\n        value: function (e) {\n          var t = this;\n          this.parent || (this.stopCallback = this.liveSocket.withPageLoading({\n            to: this.href,\n            kind: \"initial\"\n          })), this.joinCallback = function () {\n            return e && e(t, t.joinCount);\n          }, this.liveSocket.wrapPush(this, {\n            timeout: !1\n          }, function () {\n            return t.channel.join().receive(\"ok\", function (e) {\n              return t.onJoin(e);\n            }).receive(\"error\", function (e) {\n              return t.onJoinError(e);\n            }).receive(\"timeout\", function () {\n              return t.onJoinError({\n                reason: \"timeout\"\n              });\n            });\n          });\n        }\n      }, {\n        key: \"onJoinError\",\n        value: function (e) {\n          return (e.redirect || e.live_redirect) && (this.joinPending = !1, this.channel.leave()), e.redirect ? this.onRedirect(e.redirect) : e.live_redirect ? this.onLiveRedirect(e.live_redirect) : (this.log(\"error\", function () {\n            return [\"unable to join\", e];\n          }), this.liveSocket.reloadWithJitter(this));\n        }\n      }, {\n        key: \"onClose\",\n        value: function (e) {\n          if (!this.isDestroyed()) {\n            if (this.isJoinPending() || this.liveSocket.hasPendingLink() && \"leave\" !== e) return this.liveSocket.reloadWithJitter(this);\n            this.destroyAllChildren(), this.liveSocket.dropActiveElement(this), document.activeElement && document.activeElement.blur(), this.liveSocket.isUnloaded() && this.showLoader(200);\n          }\n        }\n      }, {\n        key: \"onError\",\n        value: function (e) {\n          this.onClose(e), this.log(\"error\", function () {\n            return [\"view crashed\", e];\n          }), this.liveSocket.isUnloaded() || this.displayError();\n        }\n      }, {\n        key: \"displayError\",\n        value: function () {\n          this.isMain() && le.dispatchEvent(window, \"phx:page-loading-start\", {\n            to: this.href,\n            kind: \"error\"\n          }), this.showLoader(), this.setContainerClasses(\"phx-disconnected\", \"phx-error\");\n        }\n      }, {\n        key: \"pushWithReply\",\n        value: function (e, t, n) {\n          var i = this,\n              r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {},\n              o = x(e ? e() : [null, []], 2),\n              a = o[0],\n              u = x(o[1], 1)[0],\n              s = function () {};\n\n          return u && null !== u.getAttribute(this.binding(\"page-loading\")) && (s = this.liveSocket.withPageLoading({\n            kind: \"element\",\n            target: u\n          })), \"number\" != typeof n.cid && delete n.cid, this.liveSocket.wrapPush(this, {\n            timeout: !0\n          }, function () {\n            return i.channel.push(t, n, 3e4).receive(\"ok\", function (e) {\n              var t = null;\n              null !== a && i.undoRefs(a), e.diff && (t = i.applyDiff(\"update\", e.diff, function (e) {\n                var t = e.diff,\n                    n = e.events;\n                i.update(t, n);\n              })), e.redirect && i.onRedirect(e.redirect), e.live_patch && i.onLivePatch(e.live_patch), e.live_redirect && i.onLiveRedirect(e.live_redirect), s(), r(e, t);\n            });\n          });\n        }\n      }, {\n        key: \"undoRefs\",\n        value: function (e) {\n          var t = this;\n          le.all(this.el, \"[\".concat(F, '=\"').concat(e, '\"]'), function (e) {\n            e.removeAttribute(F), null !== e.getAttribute(\"data-phx-readonly\") && (e.readOnly = !1, e.removeAttribute(\"data-phx-readonly\")), null !== e.getAttribute(\"data-phx-disabled\") && (e.disabled = !1, e.removeAttribute(\"data-phx-disabled\")), j.forEach(function (t) {\n              return le.removeClass(e, t);\n            });\n            var n = e.getAttribute(\"data-phx-disable-with-restore\");\n            null !== n && (e.innerText = n, e.removeAttribute(\"data-phx-disable-with-restore\"));\n            var i = le.private(e, F);\n\n            if (i) {\n              var r = t.triggerBeforeUpdateHook(e, i);\n              he.patchEl(e, i, t.liveSocket.getActiveElement()), r && r.__updated(), le.deletePrivate(e, F);\n            }\n          });\n        }\n      }, {\n        key: \"putRef\",\n        value: function (e, t) {\n          var n = this.ref++,\n              i = this.binding(\"disable-with\");\n          return e.forEach(function (e) {\n            e.classList.add(\"phx-\".concat(t, \"-loading\")), e.setAttribute(F, n);\n            var r = e.getAttribute(i);\n            null !== r && (e.getAttribute(\"data-phx-disable-with-restore\") || e.setAttribute(\"data-phx-disable-with-restore\", e.innerText), e.innerText = r);\n          }), [n, e];\n        }\n      }, {\n        key: \"componentID\",\n        value: function (e) {\n          var t = e.getAttribute && e.getAttribute(H);\n          return t ? parseInt(t) : null;\n        }\n      }, {\n        key: \"targetComponentID\",\n        value: function (e, t) {\n          return e.getAttribute(this.binding(\"target\")) ? this.closestComponentID(t) : null;\n        }\n      }, {\n        key: \"closestComponentID\",\n        value: function (e) {\n          var t = this;\n          return e ? Z(e.closest(\"[\".concat(H, \"]\")), function (e) {\n            return t.ownsElement(e) && t.componentID(e);\n          }) : null;\n        }\n      }, {\n        key: \"pushHookEvent\",\n        value: function (e, t, n, i) {\n          if (!this.isConnected()) return this.log(\"hook\", function () {\n            return [\"unable to push hook event. LiveView not connected\", t, n];\n          }), !1;\n          var r = x(this.putRef([], \"hook\"), 2),\n              o = r[0],\n              a = r[1];\n          return this.pushWithReply(function () {\n            return [o, a];\n          }, \"event\", {\n            type: \"hook\",\n            event: t,\n            value: n,\n            cid: this.closestComponentID(e)\n          }, function (e, t) {\n            return i(t, o);\n          }), o;\n        }\n      }, {\n        key: \"extractMeta\",\n        value: function (e, t) {\n          for (var n = this.binding(\"value-\"), i = 0; i < e.attributes.length; i++) {\n            var r = e.attributes[i].name;\n            r.startsWith(n) && (t[r.replace(n, \"\")] = e.getAttribute(r));\n          }\n\n          return void 0 !== e.value && (t.value = e.value, \"INPUT\" === e.tagName && J.indexOf(e.type) >= 0 && !e.checked && delete t.value), t;\n        }\n      }, {\n        key: \"pushEvent\",\n        value: function (e, t, n, i, r) {\n          var o = this;\n          this.pushWithReply(function () {\n            return o.putRef([t], e);\n          }, \"event\", {\n            type: e,\n            event: i,\n            value: this.extractMeta(t, r),\n            cid: this.targetComponentID(t, n)\n          });\n        }\n      }, {\n        key: \"pushKey\",\n        value: function (e, t, n, i, r) {\n          var o = this;\n          this.pushWithReply(function () {\n            return o.putRef([e], n);\n          }, \"event\", {\n            type: n,\n            event: i,\n            value: this.extractMeta(e, r),\n            cid: this.targetComponentID(e, t)\n          });\n        }\n      }, {\n        key: \"pushFileProgress\",\n        value: function (e, t, n) {\n          var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {};\n          this.liveSocket.withinOwners(e.form, function (r, o) {\n            r.pushWithReply(null, \"progress\", {\n              event: e.getAttribute(r.binding(\"progress\")),\n              ref: e.getAttribute(M),\n              entry_ref: t,\n              progress: n,\n              cid: r.targetComponentID(e.form, o)\n            }, i);\n          });\n        }\n      }, {\n        key: \"pushInput\",\n        value: function (e, t, n, i, r) {\n          var o = this,\n              a = this.targetComponentID(e.form, t),\n              u = function () {\n            return o.putRef([e, e.form], \"change\");\n          },\n              s = ae(e.form, {\n            _target: i.name\n          });\n\n          e.files && e.files.length > 0 && ie.trackFiles(e, Array.from(e.files));\n          var c = {\n            type: \"form\",\n            event: n,\n            value: s,\n            uploads: ie.serializeUploads(e),\n            cid: a\n          };\n          this.pushWithReply(u, \"event\", c, function (n) {\n            if (le.showError(e, o.liveSocket.binding(\"feedback-for\")), le.isUploadInput(e) && null !== e.getAttribute(\"data-phx-auto-upload\")) {\n              if (ie.filesAwaitingPreflight(e).length > 0) {\n                var i = x(u(), 2),\n                    s = i[0];\n                i[1];\n                o.uploadFiles(e.form, t, s, a, function (t) {\n                  r && r(n), o.triggerAwaitingSubmit(e.form);\n                });\n              }\n            } else r && r(n);\n          });\n        }\n      }, {\n        key: \"triggerAwaitingSubmit\",\n        value: function (e) {\n          var t = this.getScheduledSubmit(e);\n\n          if (t) {\n            var n = x(t, 3),\n                i = (n[0], n[1], n[2]);\n            this.cancelSubmit(e), i();\n          }\n        }\n      }, {\n        key: \"getScheduledSubmit\",\n        value: function (e) {\n          return this.formSubmits.find(function (t) {\n            var n = x(t, 2),\n                i = n[0];\n            n[1];\n            return i.isSameNode(e);\n          });\n        }\n      }, {\n        key: \"scheduleSubmit\",\n        value: function (e, t, n) {\n          if (this.getScheduledSubmit(e)) return !0;\n          this.formSubmits.push([e, t, n]);\n        }\n      }, {\n        key: \"cancelSubmit\",\n        value: function (e) {\n          var t = this;\n          this.formSubmits = this.formSubmits.filter(function (n) {\n            var i = x(n, 3),\n                r = i[0],\n                o = i[1];\n            i[2];\n            return !r.isSameNode(e) || (t.undoRefs(o), !1);\n          });\n        }\n      }, {\n        key: \"pushFormSubmit\",\n        value: function (e, t, n, i) {\n          var r = this,\n              o = function (e) {\n            return !(G(e, \"\".concat(r.binding(\"update\"), \"=ignore\"), e.form) || G(e, \"data-phx-update=ignore\", e.form));\n          },\n              a = function (e) {\n            return e.hasAttribute(r.binding(\"disable-with\"));\n          },\n              u = function (e) {\n            return \"BUTTON\" == e.tagName;\n          },\n              s = function (e) {\n            return [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(e.tagName);\n          },\n              c = function () {\n            var t = Array.from(e.elements),\n                n = t.filter(a),\n                i = t.filter(u).filter(o),\n                c = t.filter(s).filter(o);\n            return i.forEach(function (e) {\n              e.setAttribute(\"data-phx-disabled\", e.disabled), e.disabled = !0;\n            }), c.forEach(function (e) {\n              e.setAttribute(\"data-phx-readonly\", e.readOnly), e.readOnly = !0, e.files && (e.setAttribute(\"data-phx-disabled\", e.disabled), e.disabled = !0);\n            }), e.setAttribute(r.binding(\"page-loading\"), \"\"), r.putRef([e].concat(n).concat(i).concat(c), \"submit\");\n          },\n              l = this.targetComponentID(e, t);\n\n          if (ie.hasUploadsInProgress(e)) {\n            var d = x(c(), 2),\n                h = d[0];\n            d[1];\n            return this.scheduleSubmit(e, h, function () {\n              return r.pushFormSubmit(e, t, n, i);\n            });\n          }\n\n          if (ie.inputsAwaitingPreflight(e).length > 0) {\n            var f = x(c(), 2),\n                v = f[0],\n                p = f[1],\n                g = function () {\n              return [v, p];\n            };\n\n            this.uploadFiles(e, t, v, l, function (t) {\n              var o = ae(e, {});\n              r.pushWithReply(g, \"event\", {\n                type: \"form\",\n                event: n,\n                value: o,\n                cid: l\n              }, i);\n            });\n          } else {\n            var m = ae(e);\n            this.pushWithReply(c, \"event\", {\n              type: \"form\",\n              event: n,\n              value: m,\n              cid: l\n            }, i);\n          }\n        }\n      }, {\n        key: \"uploadFiles\",\n        value: function (e, t, n, i, r) {\n          var o = this,\n              a = this.joinCount;\n          ie.activeFileInputs(e).forEach(function (e) {\n            var i = new ie(e, o, r);\n            o.uploaders[e] = i;\n            var u = i.entries().map(function (e) {\n              return e.toPreflightPayload();\n            }),\n                s = {\n              ref: e.getAttribute(M),\n              entries: u,\n              cid: o.targetComponentID(e.form, t)\n            };\n            o.log(\"upload\", function () {\n              return [\"sending preflight request\", s];\n            }), o.pushWithReply(null, \"allow_upload\", s, function (e) {\n              if (o.log(\"upload\", function () {\n                return [\"got preflight response\", e];\n              }), e.error) {\n                o.undoRefs(n);\n                var t = x(e.error, 2),\n                    r = t[0],\n                    u = t[1];\n                o.log(\"upload\", function () {\n                  return [\"error for entry \".concat(r), u];\n                });\n              } else {\n                i.initAdapterUpload(e, function (e) {\n                  o.channel.onError(function () {\n                    o.joinCount === a && e();\n                  });\n                }, o.liveSocket);\n              }\n            });\n          });\n        }\n      }, {\n        key: \"pushFormRecovery\",\n        value: function (e, t) {\n          var n = this;\n          this.liveSocket.withinOwners(e, function (i, r) {\n            var o = e.elements[0],\n                a = e.getAttribute(n.binding(\"auto-recover\")) || e.getAttribute(n.binding(\"change\"));\n            i.pushInput(o, r, a, o, t);\n          });\n        }\n      }, {\n        key: \"pushLinkPatch\",\n        value: function (e, t, n) {\n          var i = this,\n              r = this.liveSocket.setPendingLink(e),\n              o = t ? function () {\n            return i.putRef([t], \"click\");\n          } : null;\n          this.pushWithReply(o, \"link\", {\n            url: e\n          }, function (t) {\n            t.link_redirect ? i.liveSocket.replaceMain(e, null, n, r) : i.liveSocket.commitPendingLink(r) && (i.href = e, i.applyPendingUpdates(), n && n());\n          }).receive(\"timeout\", function () {\n            return i.liveSocket.redirect(window.location.href);\n          });\n        }\n      }, {\n        key: \"formsForRecovery\",\n        value: function (e) {\n          var t = this;\n          if (0 === this.joinCount) return [];\n          var n = this.binding(\"change\"),\n              i = document.createElement(\"template\");\n          return i.innerHTML = e, le.all(this.el, \"form[\".concat(n, \"]\")).filter(function (e) {\n            return t.ownsElement(e);\n          }).filter(function (e) {\n            return e.elements.length > 0;\n          }).filter(function (e) {\n            return \"ignore\" !== e.getAttribute(t.binding(\"auto-recover\"));\n          }).filter(function (e) {\n            return i.content.querySelector(\"form[\".concat(n, '=\"').concat(e.getAttribute(n), '\"]'));\n          });\n        }\n      }, {\n        key: \"maybePushComponentsDestroyed\",\n        value: function (e) {\n          var t,\n              n = this,\n              i = e.filter(function (e) {\n            return 0 === le.findComponentNodeList(n.el, e).length;\n          });\n          i.length > 0 && ((t = this.pruningCIDs).push.apply(t, A(i)), this.pushWithReply(null, \"cids_will_destroy\", {\n            cids: i\n          }, function () {\n            n.pruningCIDs = n.pruningCIDs.filter(function (e) {\n              return -1 !== i.indexOf(e);\n            });\n            var e = i.filter(function (e) {\n              return 0 === le.findComponentNodeList(n.el, e).length;\n            });\n            e.length > 0 && n.pushWithReply(null, \"cids_destroyed\", {\n              cids: e\n            }, function (e) {\n              n.rendered.pruneCIDs(e.cids);\n            });\n          }));\n        }\n      }, {\n        key: \"ownsElement\",\n        value: function (e) {\n          return e.getAttribute(\"data-phx-parent-id\") === this.id || Z(e.closest(U), function (e) {\n            return e.id;\n          }) === this.id;\n        }\n      }, {\n        key: \"submitForm\",\n        value: function (e, t, n) {\n          var i = this;\n          le.putPrivate(e, \"phx-has-submitted\", !0), this.liveSocket.blurActiveElement(this), this.pushFormSubmit(e, t, n, function () {\n            i.liveSocket.restorePreviouslyActiveFocus();\n          });\n        }\n      }, {\n        key: \"binding\",\n        value: function (e) {\n          return this.liveSocket.binding(e);\n        }\n      }]), e;\n    }(),\n        ve = 1,\n        pe = function () {\n      function e(t, n, i) {\n        for (var r in T(this, e), this.__view = t, this.__liveSocket = t.liveSocket, this.__callbacks = i, this.__listeners = new Set(), this.__isDisconnected = !1, this.el = n, this.viewName = t.name(), this.el.phxHookId = this.constructor.makeID(), this.__callbacks) this[r] = this.__callbacks[r];\n      }\n\n      return _(e, null, [{\n        key: \"makeID\",\n        value: function () {\n          return ve++;\n        }\n      }, {\n        key: \"elementID\",\n        value: function (e) {\n          return e.phxHookId;\n        }\n      }]), _(e, [{\n        key: \"__mounted\",\n        value: function () {\n          this.mounted && this.mounted();\n        }\n      }, {\n        key: \"__updated\",\n        value: function () {\n          this.updated && this.updated();\n        }\n      }, {\n        key: \"__beforeUpdate\",\n        value: function () {\n          this.beforeUpdate && this.beforeUpdate();\n        }\n      }, {\n        key: \"__destroyed\",\n        value: function () {\n          this.destroyed && this.destroyed();\n        }\n      }, {\n        key: \"__reconnected\",\n        value: function () {\n          this.__isDisconnected && (this.__isDisconnected = !1, this.reconnected && this.reconnected());\n        }\n      }, {\n        key: \"__disconnected\",\n        value: function () {\n          this.__isDisconnected = !0, this.disconnected && this.disconnected();\n        }\n      }, {\n        key: \"pushEvent\",\n        value: function (e) {\n          var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},\n              n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function () {};\n          return this.__view.pushHookEvent(null, e, t, n);\n        }\n      }, {\n        key: \"pushEventTo\",\n        value: function (e, t) {\n          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n              i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : function () {};\n          return this.__view.withinTargets(e, function (e, r) {\n            return e.pushHookEvent(r, t, n, i);\n          });\n        }\n      }, {\n        key: \"handleEvent\",\n        value: function (e, t) {\n          var n = function (n, i) {\n            return i ? e : t(n.detail);\n          };\n\n          return window.addEventListener(\"phx:hook:\".concat(e), n), this.__listeners.add(n), n;\n        }\n      }, {\n        key: \"removeHandleEvent\",\n        value: function (e) {\n          var t = e(null, !0);\n          window.removeEventListener(\"phx:hook:\".concat(t), e), this.__listeners.delete(e);\n        }\n      }, {\n        key: \"__cleanup__\",\n        value: function () {\n          var e = this;\n\n          this.__listeners.forEach(function (t) {\n            return e.removeHandleEvent(t);\n          });\n        }\n      }]), e;\n    }();\n\n    t.default = se;\n  }, function (e, t) {\n    var n;\n\n    n = function () {\n      return this;\n    }();\n\n    try {\n      n = n || Function(\"return this\")() || (0, eval)(\"this\");\n    } catch (e) {\n      \"object\" == typeof window && (n = window);\n    }\n\n    e.exports = n;\n  }, function (e, t, n) {\n    (function (t) {\n      t.Phoenix || (t.Phoenix = {}), e.exports = t.Phoenix.LiveView = n(0);\n    }).call(this, n(1));\n  }]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9wcml2L3N0YXRpYy9waG9lbml4X2xpdmVfdmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8vaG9tZS9hbGVhay9zcmMvZmVlZGV4L2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvcHJpdi9zdGF0aWMvcGhvZW5peF9saXZlX3ZpZXcuanM/ZWY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLnBob2VuaXhfbGl2ZV92aWV3PXQoKTplLnBob2VuaXhfbGl2ZV92aWV3PXQoKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiBuKGkpe2lmKHRbaV0pcmV0dXJuIHRbaV0uZXhwb3J0czt2YXIgcj10W2ldPXtpOmksbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtpXS5jYWxsKHIuZXhwb3J0cyxyLHIuZXhwb3J0cyxuKSxyLmw9ITAsci5leHBvcnRzfXJldHVybiBuLm09ZSxuLmM9dCxuLmQ9ZnVuY3Rpb24oZSx0LGkpe24ubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6aX0pfSxuLnI9ZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LG4ubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbi5kKHQsXCJhXCIsdCksdH0sbi5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxuLnA9XCJcIixuKG4ucz0yKX0oW2Z1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtuLnIodCk7dmFyIGkscj0xMTt2YXIgbz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixhPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBkb2N1bWVudD92b2lkIDA6ZG9jdW1lbnQsdT0hIWEmJlwiY29udGVudFwiaW4gYS5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIikscz0hIWEmJmEuY3JlYXRlUmFuZ2UmJlwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50XCJpbiBhLmNyZWF0ZVJhbmdlKCk7ZnVuY3Rpb24gYyhlKXtyZXR1cm4gZT1lLnRyaW0oKSx1P2Z1bmN0aW9uKGUpe3ZhciB0PWEuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO3JldHVybiB0LmlubmVySFRNTD1lLHQuY29udGVudC5jaGlsZE5vZGVzWzBdfShlKTpzP2Z1bmN0aW9uKGUpe3JldHVybiBpfHwoaT1hLmNyZWF0ZVJhbmdlKCkpLnNlbGVjdE5vZGUoYS5ib2R5KSxpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChlKS5jaGlsZE5vZGVzWzBdfShlKTpmdW5jdGlvbihlKXt2YXIgdD1hLmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpO3JldHVybiB0LmlubmVySFRNTD1lLHQuY2hpbGROb2Rlc1swXX0oZSl9ZnVuY3Rpb24gbChlLHQpe3ZhciBuLGkscj1lLm5vZGVOYW1lLG89dC5ub2RlTmFtZTtyZXR1cm4gcj09PW98fChuPXIuY2hhckNvZGVBdCgwKSxpPW8uY2hhckNvZGVBdCgwKSxuPD05MCYmaT49OTc/cj09PW8udG9VcHBlckNhc2UoKTppPD05MCYmbj49OTcmJm89PT1yLnRvVXBwZXJDYXNlKCkpfWZ1bmN0aW9uIGQoZSx0LG4pe2Vbbl0hPT10W25dJiYoZVtuXT10W25dLGVbbl0/ZS5zZXRBdHRyaWJ1dGUobixcIlwiKTplLnJlbW92ZUF0dHJpYnV0ZShuKSl9dmFyIGg9e09QVElPTjpmdW5jdGlvbihlLHQpe3ZhciBuPWUucGFyZW50Tm9kZTtpZihuKXt2YXIgaT1uLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XCJPUFRHUk9VUFwiPT09aSYmKGk9KG49bi5wYXJlbnROb2RlKSYmbi5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpKSxcIlNFTEVDVFwiIT09aXx8bi5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKXx8KGUuaGFzQXR0cmlidXRlKFwic2VsZWN0ZWRcIikmJiF0LnNlbGVjdGVkJiYoZS5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLFwic2VsZWN0ZWRcIiksZS5yZW1vdmVBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKSksbi5zZWxlY3RlZEluZGV4PS0xKX1kKGUsdCxcInNlbGVjdGVkXCIpfSxJTlBVVDpmdW5jdGlvbihlLHQpe2QoZSx0LFwiY2hlY2tlZFwiKSxkKGUsdCxcImRpc2FibGVkXCIpLGUudmFsdWUhPT10LnZhbHVlJiYoZS52YWx1ZT10LnZhbHVlKSx0Lmhhc0F0dHJpYnV0ZShcInZhbHVlXCIpfHxlLnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpfSxURVhUQVJFQTpmdW5jdGlvbihlLHQpe3ZhciBuPXQudmFsdWU7ZS52YWx1ZSE9PW4mJihlLnZhbHVlPW4pO3ZhciBpPWUuZmlyc3RDaGlsZDtpZihpKXt2YXIgcj1pLm5vZGVWYWx1ZTtpZihyPT1ufHwhbiYmcj09ZS5wbGFjZWhvbGRlcilyZXR1cm47aS5ub2RlVmFsdWU9bn19LFNFTEVDVDpmdW5jdGlvbihlLHQpe2lmKCF0Lmhhc0F0dHJpYnV0ZShcIm11bHRpcGxlXCIpKXtmb3IodmFyIG4saSxyPS0xLG89MCxhPWUuZmlyc3RDaGlsZDthOylpZihcIk9QVEdST1VQXCI9PT0oaT1hLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkpKWE9KG49YSkuZmlyc3RDaGlsZDtlbHNle2lmKFwiT1BUSU9OXCI9PT1pKXtpZihhLmhhc0F0dHJpYnV0ZShcInNlbGVjdGVkXCIpKXtyPW87YnJlYWt9bysrfSEoYT1hLm5leHRTaWJsaW5nKSYmbiYmKGE9bi5uZXh0U2libGluZyxuPW51bGwpfWUuc2VsZWN0ZWRJbmRleD1yfX19LGY9MSx2PTExLHA9MyxnPTg7ZnVuY3Rpb24gbSgpe31mdW5jdGlvbiB5KGUpe2lmKGUpcmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZlLmdldEF0dHJpYnV0ZShcImlkXCIpfHxlLmlkfXZhciBiPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LG4saSl7aWYoaXx8KGk9e30pLFwic3RyaW5nXCI9PXR5cGVvZiBuKWlmKFwiI2RvY3VtZW50XCI9PT10Lm5vZGVOYW1lfHxcIkhUTUxcIj09PXQubm9kZU5hbWV8fFwiQk9EWVwiPT09dC5ub2RlTmFtZSl7dmFyIHI9bjsobj1hLmNyZWF0ZUVsZW1lbnQoXCJodG1sXCIpKS5pbm5lckhUTUw9cn1lbHNlIG49YyhuKTt2YXIgdT1pLmdldE5vZGVLZXl8fHkscz1pLm9uQmVmb3JlTm9kZUFkZGVkfHxtLGQ9aS5vbk5vZGVBZGRlZHx8bSxiPWkub25CZWZvcmVFbFVwZGF0ZWR8fG0saz1pLm9uRWxVcGRhdGVkfHxtLHc9aS5vbkJlZm9yZU5vZGVEaXNjYXJkZWR8fG0sRT1pLm9uTm9kZURpc2NhcmRlZHx8bSxBPWkub25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZHx8bSxTPSEwPT09aS5jaGlsZHJlbk9ubHkseD1PYmplY3QuY3JlYXRlKG51bGwpLEM9W107ZnVuY3Rpb24gUChlKXtDLnB1c2goZSl9ZnVuY3Rpb24gTChlLHQsbil7ITEhPT13KGUpJiYodCYmdC5yZW1vdmVDaGlsZChlKSxFKGUpLGZ1bmN0aW9uIGUodCxuKXtpZih0Lm5vZGVUeXBlPT09Zilmb3IodmFyIGk9dC5maXJzdENoaWxkO2k7KXt2YXIgcj12b2lkIDA7biYmKHI9dShpKSk/UChyKTooRShpKSxpLmZpcnN0Q2hpbGQmJmUoaSxuKSksaT1pLm5leHRTaWJsaW5nfX0oZSxuKSl9ZnVuY3Rpb24gSShlKXtkKGUpO2Zvcih2YXIgdD1lLmZpcnN0Q2hpbGQ7dDspe3ZhciBuPXQubmV4dFNpYmxpbmcsaT11KHQpO2lmKGkpe3ZhciByPXhbaV07ciYmbCh0LHIpPyh0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHIsdCksVChyLHQpKTpJKHQpfWVsc2UgSSh0KTt0PW59fWZ1bmN0aW9uIFQodCxuLGkpe3ZhciByPXUobik7aWYociYmZGVsZXRlIHhbcl0sIWkpe2lmKCExPT09Yih0LG4pKXJldHVybjtpZihlKHQsbiksayh0KSwhMT09PUEodCxuKSlyZXR1cm59XCJURVhUQVJFQVwiIT09dC5ub2RlTmFtZT9mdW5jdGlvbihlLHQpe3ZhciBuLGkscixvLGMsZD10LmZpcnN0Q2hpbGQsdj1lLmZpcnN0Q2hpbGQ7ZTpmb3IoO2Q7KXtmb3Iobz1kLm5leHRTaWJsaW5nLG49dShkKTt2Oyl7aWYocj12Lm5leHRTaWJsaW5nLGQuaXNTYW1lTm9kZSYmZC5pc1NhbWVOb2RlKHYpKXtkPW8sdj1yO2NvbnRpbnVlIGV9aT11KHYpO3ZhciBtPXYubm9kZVR5cGUseT12b2lkIDA7aWYobT09PWQubm9kZVR5cGUmJihtPT09Zj8obj9uIT09aSYmKChjPXhbbl0pP3I9PT1jP3k9ITE6KGUuaW5zZXJ0QmVmb3JlKGMsdiksaT9QKGkpOkwodixlLCEwKSx2PWMpOnk9ITEpOmkmJih5PSExKSwoeT0hMSE9PXkmJmwodixkKSkmJlQodixkKSk6bSE9PXAmJm0hPWd8fCh5PSEwLHYubm9kZVZhbHVlIT09ZC5ub2RlVmFsdWUmJih2Lm5vZGVWYWx1ZT1kLm5vZGVWYWx1ZSkpKSx5KXtkPW8sdj1yO2NvbnRpbnVlIGV9aT9QKGkpOkwodixlLCEwKSx2PXJ9aWYobiYmKGM9eFtuXSkmJmwoYyxkKSllLmFwcGVuZENoaWxkKGMpLFQoYyxkKTtlbHNle3ZhciBiPXMoZCk7ITEhPT1iJiYoYiYmKGQ9YiksZC5hY3R1YWxpemUmJihkPWQuYWN0dWFsaXplKGUub3duZXJEb2N1bWVudHx8YSkpLGUuYXBwZW5kQ2hpbGQoZCksSShkKSl9ZD1vLHY9cn0hZnVuY3Rpb24oZSx0LG4pe2Zvcig7dDspe3ZhciBpPXQubmV4dFNpYmxpbmc7KG49dSh0KSk/UChuKTpMKHQsZSwhMCksdD1pfX0oZSx2LGkpO3ZhciBrPWhbZS5ub2RlTmFtZV07ayYmayhlLHQpfSh0LG4pOmguVEVYVEFSRUEodCxuKX0hZnVuY3Rpb24gZSh0KXtpZih0Lm5vZGVUeXBlPT09Znx8dC5ub2RlVHlwZT09PXYpZm9yKHZhciBuPXQuZmlyc3RDaGlsZDtuOyl7dmFyIGk9dShuKTtpJiYoeFtpXT1uKSxlKG4pLG49bi5uZXh0U2libGluZ319KHQpO3ZhciBEPXQsXz1ELm5vZGVUeXBlLE49bi5ub2RlVHlwZTtpZighUylpZihfPT09ZilOPT09Zj9sKHQsbil8fChFKHQpLEQ9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49ZS5maXJzdENoaWxkO247KXt2YXIgaT1uLm5leHRTaWJsaW5nO3QuYXBwZW5kQ2hpbGQobiksbj1pfXJldHVybiB0fSh0LGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQmJnQhPT1vP2EuY3JlYXRlRWxlbWVudE5TKHQsZSk6YS5jcmVhdGVFbGVtZW50KGUpfShuLm5vZGVOYW1lLG4ubmFtZXNwYWNlVVJJKSkpOkQ9bjtlbHNlIGlmKF89PT1wfHxfPT09Zyl7aWYoTj09PV8pcmV0dXJuIEQubm9kZVZhbHVlIT09bi5ub2RlVmFsdWUmJihELm5vZGVWYWx1ZT1uLm5vZGVWYWx1ZSksRDtEPW59aWYoRD09PW4pRSh0KTtlbHNle2lmKG4uaXNTYW1lTm9kZSYmbi5pc1NhbWVOb2RlKEQpKXJldHVybjtpZihUKEQsbixTKSxDKWZvcih2YXIgUj0wLE89Qy5sZW5ndGg7UjxPO1IrKyl7dmFyIGo9eFtDW1JdXTtqJiZMKGosai5wYXJlbnROb2RlLCExKX19cmV0dXJuIVMmJkQhPT10JiZ0LnBhcmVudE5vZGUmJihELmFjdHVhbGl6ZSYmKEQ9RC5hY3R1YWxpemUodC5vd25lckRvY3VtZW50fHxhKSksdC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChELHQpKSxEfX0oZnVuY3Rpb24oZSx0KXt2YXIgbixpLG8sYSx1PXQuYXR0cmlidXRlcztpZih0Lm5vZGVUeXBlIT09ciYmZS5ub2RlVHlwZSE9PXIpe2Zvcih2YXIgcz11Lmxlbmd0aC0xO3M+PTA7cy0tKWk9KG49dVtzXSkubmFtZSxvPW4ubmFtZXNwYWNlVVJJLGE9bi52YWx1ZSxvPyhpPW4ubG9jYWxOYW1lfHxpLGUuZ2V0QXR0cmlidXRlTlMobyxpKSE9PWEmJihcInhtbG5zXCI9PT1uLnByZWZpeCYmKGk9bi5uYW1lKSxlLnNldEF0dHJpYnV0ZU5TKG8saSxhKSkpOmUuZ2V0QXR0cmlidXRlKGkpIT09YSYmZS5zZXRBdHRyaWJ1dGUoaSxhKTtmb3IodmFyIGM9ZS5hdHRyaWJ1dGVzLGw9Yy5sZW5ndGgtMTtsPj0wO2wtLSlpPShuPWNbbF0pLm5hbWUsKG89bi5uYW1lc3BhY2VVUkkpPyhpPW4ubG9jYWxOYW1lfHxpLHQuaGFzQXR0cmlidXRlTlMobyxpKXx8ZS5yZW1vdmVBdHRyaWJ1dGVOUyhvLGkpKTp0Lmhhc0F0dHJpYnV0ZShpKXx8ZS5yZW1vdmVBdHRyaWJ1dGUoaSl9fSk7ZnVuY3Rpb24gayhlKXtyZXR1cm4gUChlKXx8UyhlKXx8TChlKXx8QygpfWZ1bmN0aW9uIHcoZSx0KXt2YXIgbj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihpPWkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSxuLnB1c2guYXBwbHkobixpKX1yZXR1cm4gbn1mdW5jdGlvbiBFKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX1mdW5jdGlvbiBBKGUpe3JldHVybiBmdW5jdGlvbihlKXtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBJKGUpfShlKXx8UyhlKXx8TChlKXx8ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX0oKX1mdW5jdGlvbiBTKGUpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoZSkpcmV0dXJuIEFycmF5LmZyb20oZSl9ZnVuY3Rpb24geChlLHQpe3JldHVybiBQKGUpfHxmdW5jdGlvbihlLHQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTeW1ib2x8fCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChlKSkpcmV0dXJuO3ZhciBuPVtdLGk9ITAscj0hMSxvPXZvaWQgMDt0cnl7Zm9yKHZhciBhLHU9ZVtTeW1ib2wuaXRlcmF0b3JdKCk7IShpPShhPXUubmV4dCgpKS5kb25lKSYmKG4ucHVzaChhLnZhbHVlKSwhdHx8bi5sZW5ndGghPT10KTtpPSEwKTt9Y2F0Y2goZSl7cj0hMCxvPWV9ZmluYWxseXt0cnl7aXx8bnVsbD09dS5yZXR1cm58fHUucmV0dXJuKCl9ZmluYWxseXtpZihyKXRocm93IG99fXJldHVybiBufShlLHQpfHxMKGUsdCl8fEMoKX1mdW5jdGlvbiBDKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKX1mdW5jdGlvbiBQKGUpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGV9ZnVuY3Rpb24gTChlLHQpe2lmKGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBJKGUsdCk7dmFyIG49T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1uJiZlLmNvbnN0cnVjdG9yJiYobj1lLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1ufHxcIlNldFwiPT09bj9BcnJheS5mcm9tKGUpOlwiQXJndW1lbnRzXCI9PT1ufHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKT9JKGUsdCk6dm9pZCAwfX1mdW5jdGlvbiBJKGUsdCl7KG51bGw9PXR8fHQ+ZS5sZW5ndGgpJiYodD1lLmxlbmd0aCk7Zm9yKHZhciBuPTAsaT1uZXcgQXJyYXkodCk7bjx0O24rKylpW25dPWVbbl07cmV0dXJuIGl9ZnVuY3Rpb24gVChlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gRChlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgaT10W25dO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxpLmtleSxpKX19ZnVuY3Rpb24gXyhlLHQsbil7cmV0dXJuIHQmJkQoZS5wcm90b3R5cGUsdCksbiYmRChlLG4pLGV9ZnVuY3Rpb24gTihlKXtcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7cmV0dXJuKE49XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfW4uZCh0LFwiZGVidWdcIixmdW5jdGlvbigpe3JldHVybiBLfSksbi5kKHQsXCJSZW5kZXJlZFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHVlfSksbi5kKHQsXCJMaXZlU29ja2V0XCIsZnVuY3Rpb24oKXtyZXR1cm4gc2V9KSxuLmQodCxcIkJyb3dzZXJcIixmdW5jdGlvbigpe3JldHVybiBjZX0pLG4uZCh0LFwiRE9NXCIsZnVuY3Rpb24oKXtyZXR1cm4gbGV9KSxuLmQodCxcIlZpZXdcIixmdW5jdGlvbigpe3JldHVybiBmZX0pO3ZhciBSPVsxZTMsM2UzXSxPPVwiZGF0YS1waHgtdmlld1wiLGo9W1wicGh4LWNsaWNrLWxvYWRpbmdcIixcInBoeC1jaGFuZ2UtbG9hZGluZ1wiLFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIsXCJwaHgta2V5ZG93bi1sb2FkaW5nXCIsXCJwaHgta2V5dXAtbG9hZGluZ1wiLFwicGh4LWJsdXItbG9hZGluZ1wiLFwicGh4LWZvY3VzLWxvYWRpbmdcIl0sSD1cImRhdGEtcGh4LWNvbXBvbmVudFwiLEY9XCJkYXRhLXBoeC1yZWZcIixNPVwiZGF0YS1waHgtdXBsb2FkLXJlZlwiLFU9XCJbXCIuY29uY2F0KE8sXCJdXCIpLEI9W1widGV4dFwiLFwidGV4dGFyZWFcIixcIm51bWJlclwiLFwiZW1haWxcIixcInBhc3N3b3JkXCIsXCJzZWFyY2hcIixcInRlbFwiLFwidXJsXCIsXCJkYXRlXCIsXCJ0aW1lXCJdLEo9W1wiY2hlY2tib3hcIixcInJhZGlvXCJdLFY9MSxXPVwicGh4LVwiLHE9e2RlYm91bmNlOjMwMCx0aHJvdHRsZTozMDB9LHo9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gY29uc29sZS5lcnJvciYmY29uc29sZS5lcnJvcihlLHQpfTt2YXIgSz1mdW5jdGlvbihlLHQsbixpKXtlLmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSYmY29uc29sZS5sb2coXCJcIi5jb25jYXQoZS5pZCxcIiBcIikuY29uY2F0KHQsXCI6IFwiKS5jb25jYXQobixcIiAtIFwiKSxpKX0sWD1mdW5jdGlvbihlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2U6ZnVuY3Rpb24oKXtyZXR1cm4gZX19LCQ9ZnVuY3Rpb24oZSl7cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZSkpfSxHPWZ1bmN0aW9uKGUsdCxuKXtkb3tpZihlLm1hdGNoZXMoXCJbXCIuY29uY2F0KHQsXCJdXCIpKSlyZXR1cm4gZTtlPWUucGFyZW50RWxlbWVudHx8ZS5wYXJlbnROb2RlfXdoaWxlKG51bGwhPT1lJiYxPT09ZS5ub2RlVHlwZSYmIShuJiZuLmlzU2FtZU5vZGUoZSl8fGUubWF0Y2hlcyhVKSkpO3JldHVybiBudWxsfSxZPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT09ZSYmXCJvYmplY3RcIj09PU4oZSkmJiEoZSBpbnN0YW5jZW9mIEFycmF5KX0sUT1mdW5jdGlvbihlKXtmb3IodmFyIHQgaW4gZSlyZXR1cm4hMTtyZXR1cm4hMH0sWj1mdW5jdGlvbihlLHQpe3JldHVybiBlJiZ0KGUpfSxlZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLGkpe1QodGhpcyxlKSx0aGlzLnJlZj1pZS5nZW5GaWxlUmVmKG4pLHRoaXMuZmlsZUVsPXQsdGhpcy5maWxlPW4sdGhpcy52aWV3PWksdGhpcy5tZXRhPW51bGwsdGhpcy5faXNDYW5jZWxsZWQ9ITEsdGhpcy5faXNEb25lPSExLHRoaXMuX3Byb2dyZXNzPTAsdGhpcy5fb25Eb25lPWZ1bmN0aW9uKCl7fX1yZXR1cm4gXyhlLG51bGwsW3trZXk6XCJpc0FjdGl2ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dm9pZCAwPT09dC5fcGh4UmVmLGk9ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1hY3RpdmUtcmVmc1wiKS5zcGxpdChcIixcIikuaW5kZXhPZihpZS5nZW5GaWxlUmVmKHQpKT49MDtyZXR1cm4gdC5zaXplPjAmJihufHxpKX19LHtrZXk6XCJpc1ByZWZsaWdodGVkXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXByZWZsaWdodGVkLXJlZnNcIikuc3BsaXQoXCIsXCIpLmluZGV4T2YoaWUuZ2VuRmlsZVJlZih0KSk+PTA7cmV0dXJuIG4mJnRoaXMuaXNBY3RpdmUoZSx0KX19XSksXyhlLFt7a2V5OlwibWV0YWRhdGFcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1ldGF9fSx7a2V5OlwicHJvZ3Jlc3NcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3RoaXMuX3Byb2dyZXNzPU1hdGguZmxvb3IoZSksdGhpcy5fcHJvZ3Jlc3M+PTEwMD8odGhpcy5fcHJvZ3Jlc3M9MTAwLHRoaXMuX2lzRG9uZT0hMCx0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCx0aGlzLnJlZiwxMDAsZnVuY3Rpb24oKXtpZS51bnRyYWNrRmlsZSh0LmZpbGVFbCx0LmZpbGUpLHQuX29uRG9uZSgpfSkpOnRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLHRoaXMucmVmLHRoaXMuX3Byb2dyZXNzKX19LHtrZXk6XCJjYW5jZWxcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2lzQ2FuY2VsbGVkPSEwLHRoaXMuX2lzRG9uZT0hMCx0aGlzLl9vbkRvbmUoKX19LHtrZXk6XCJpc0RvbmVcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0RvbmV9fSx7a2V5OlwiZXJyb3JcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpcImZhaWxlZFwiO3RoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLHRoaXMucmVmLHtlcnJvcjplfSl9fSx7a2V5Olwib25Eb25lXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fb25Eb25lPWV9fSx7a2V5OlwidG9QcmVmbGlnaHRQYXlsb2FkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm57bGFzdF9tb2RpZmllZDp0aGlzLmZpbGUubGFzdE1vZGlmaWVkLG5hbWU6dGhpcy5maWxlLm5hbWUsc2l6ZTp0aGlzLmZpbGUuc2l6ZSx0eXBlOnRoaXMuZmlsZS50eXBlLHJlZjp0aGlzLnJlZn19fSx7a2V5OlwidXBsb2FkZXJcIix2YWx1ZTpmdW5jdGlvbihlKXtpZih0aGlzLm1ldGEudXBsb2FkZXIpe3ZhciB0PWVbdGhpcy5tZXRhLnVwbG9hZGVyXXx8eihcIm5vIHVwbG9hZGVyIGNvbmZpZ3VyZWQgZm9yIFwiLmNvbmNhdCh0aGlzLm1ldGEudXBsb2FkZXIpKTtyZXR1cm57bmFtZTp0aGlzLm1ldGEudXBsb2FkZXIsY2FsbGJhY2s6dH19cmV0dXJue25hbWU6XCJjaGFubmVsXCIsY2FsbGJhY2s6cmV9fX0se2tleTpcInppcFBvc3RGbGlnaHRcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLm1ldGE9ZS5lbnRyaWVzW3RoaXMucmVmXSx0aGlzLm1ldGF8fHooXCJubyBwcmVmbGlnaHQgdXBsb2FkIHJlc3BvbnNlIHJldHVybmVkIHdpdGggcmVmIFwiLmNvbmNhdCh0aGlzLnJlZikse2lucHV0OnRoaXMuZmlsZUVsLHJlc3BvbnNlOmV9KX19XSksZX0oKSx0ZT17TGl2ZUZpbGVVcGxvYWQ6e3ByZWZsaWdodGVkUmVmczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXByZWZsaWdodGVkLXJlZnNcIil9LG1vdW50ZWQ6ZnVuY3Rpb24oKXt0aGlzLnByZWZsaWdodGVkV2FzPXRoaXMucHJlZmxpZ2h0ZWRSZWZzKCl9LHVwZGF0ZWQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnByZWZsaWdodGVkUmVmcygpO3RoaXMucHJlZmxpZ2h0ZWRXYXMhPT1lJiYodGhpcy5wcmVmbGlnaHRlZFdhcz1lLFwiXCI9PT1lJiZ0aGlzLl9fdmlldy5jYW5jZWxTdWJtaXQodGhpcy5lbC5mb3JtKSl9fX07dGUuTGl2ZUltZ1ByZXZpZXc9e21vdW50ZWQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucmVmPXRoaXMuZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZW50cnktcmVmXCIpLHRoaXMuaW5wdXRFbD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmVsLmdldEF0dHJpYnV0ZShNKSksaWUuZ2V0RW50cnlEYXRhVVJMKHRoaXMuaW5wdXRFbCx0aGlzLnJlZixmdW5jdGlvbih0KXtyZXR1cm4gZS5lbC5zcmM9dH0pfX07dmFyIG5lPTAsaWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixpKXtUKHRoaXMsZSksdGhpcy52aWV3PW4sdGhpcy5vbkNvbXBsZXRlPWksdGhpcy5fZW50cmllcz1BcnJheS5mcm9tKGUuZmlsZXNBd2FpdGluZ1ByZWZsaWdodCh0KXx8W10pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IGVlKHQsZSxuKX0pLHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3M9dGhpcy5fZW50cmllcy5sZW5ndGh9cmV0dXJuIF8oZSxudWxsLFt7a2V5OlwiZ2VuRmlsZVJlZlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUuX3BoeFJlZjtyZXR1cm4gdm9pZCAwIT09dD90OihlLl9waHhSZWY9KG5lKyspLnRvU3RyaW5nKCksZS5fcGh4UmVmKX19LHtrZXk6XCJnZXRFbnRyeURhdGFVUkxcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcyxyPXRoaXMuYWN0aXZlRmlsZXMoZSkuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gaS5nZW5GaWxlUmVmKGUpPT09dH0pLG89bmV3IEZpbGVSZWFkZXI7by5vbmxvYWQ9ZnVuY3Rpb24oZSl7cmV0dXJuIG4oZS50YXJnZXQucmVzdWx0KX0sby5yZWFkQXNEYXRhVVJMKHIpfX0se2tleTpcImhhc1VwbG9hZHNJblByb2dyZXNzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9MDtyZXR1cm4gbGUuZmluZFVwbG9hZElucHV0cyhlKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtcHJlZmxpZ2h0ZWQtcmVmc1wiKSE9PWUuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZG9uZS1yZWZzXCIpJiZ0Kyt9KSx0PjB9fSx7a2V5Olwic2VyaWFsaXplVXBsb2Fkc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj17fTtyZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhlLFwic2VyaWFsaXplXCIpLmZvckVhY2goZnVuY3Rpb24oaSl7dmFyIHI9e3BhdGg6ZS5uYW1lfSxvPWUuZ2V0QXR0cmlidXRlKE0pO25bb109bltvXXx8W10sci5yZWY9dC5nZW5GaWxlUmVmKGkpLHIubmFtZT1pLm5hbWUsci50eXBlPWkudHlwZSxyLnNpemU9aS5zaXplLG5bb10ucHVzaChyKX0pLG59fSx7a2V5OlwiY2xlYXJGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2UudmFsdWU9bnVsbCxsZS5wdXRQcml2YXRlKGUsXCJmaWxlc1wiLFtdKX19LHtrZXk6XCJ1bnRyYWNrRmlsZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7bGUucHV0UHJpdmF0ZShlLFwiZmlsZXNcIixsZS5wcml2YXRlKGUsXCJmaWxlc1wiKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIU9iamVjdC5pcyhlLHQpfSkpfX0se2tleTpcInRyYWNrRmlsZXNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7aWYobnVsbCE9PWUuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikpe3ZhciBpPXQuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiFuLmFjdGl2ZUZpbGVzKGUpLmZpbmQoZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5pcyhlLHQpfSl9KTtsZS5wdXRQcml2YXRlKGUsXCJmaWxlc1wiLHRoaXMuYWN0aXZlRmlsZXMoZSkuY29uY2F0KGkpKSxlLnZhbHVlPW51bGx9ZWxzZSBsZS5wdXRQcml2YXRlKGUsXCJmaWxlc1wiLHQpfX0se2tleTpcImFjdGl2ZUZpbGVJbnB1dHNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLG49bGUuZmluZFVwbG9hZElucHV0cyhlKTtyZXR1cm4gQXJyYXkuZnJvbShuKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZmlsZXMmJnQuYWN0aXZlRmlsZXMoZSkubGVuZ3RoPjB9KX19LHtrZXk6XCJhY3RpdmVGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybihsZS5wcml2YXRlKGUsXCJmaWxlc1wiKXx8W10pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gZWUuaXNBY3RpdmUoZSx0KX0pfX0se2tleTpcImlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPWxlLmZpbmRVcGxvYWRJbnB1dHMoZSk7cmV0dXJuIEFycmF5LmZyb20obikuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB0LmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoZSkubGVuZ3RoPjB9KX19LHtrZXk6XCJmaWxlc0F3YWl0aW5nUHJlZmxpZ2h0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYWN0aXZlRmlsZXMoZSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiFlZS5pc1ByZWZsaWdodGVkKGUsdCl9KX19XSksXyhlLFt7a2V5OlwiZW50cmllc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2VudHJpZXN9fSx7a2V5OlwiaW5pdEFkYXB0ZXJVcGxvYWRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpczt0aGlzLl9lbnRyaWVzPXRoaXMuX2VudHJpZXMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnppcFBvc3RGbGlnaHQoZSksdC5vbkRvbmUoZnVuY3Rpb24oKXtpLm51bUVudHJpZXNJblByb2dyZXNzLS0sMD09PWkubnVtRW50cmllc0luUHJvZ3Jlc3MmJmkub25Db21wbGV0ZSgpfSksdH0pO3ZhciByPXRoaXMuX2VudHJpZXMucmVkdWNlKGZ1bmN0aW9uKGUsdCl7dmFyIGk9dC51cGxvYWRlcihuLnVwbG9hZGVycykscj1pLm5hbWUsbz1pLmNhbGxiYWNrO3JldHVybiBlW3JdPWVbcl18fHtjYWxsYmFjazpvLGVudHJpZXM6W119LGVbcl0uZW50cmllcy5wdXNoKHQpLGV9LHt9KTtmb3IodmFyIG8gaW4gcil7dmFyIGE9cltvXTsoMCxhLmNhbGxiYWNrKShhLmVudHJpZXMsdCxlLG4pfX19XSksZX0oKSxyZT1mdW5jdGlvbihlLHQsbixpKXtlLmZvckVhY2goZnVuY3Rpb24oZSl7bmV3IG9lKGUsbi5jb25maWcuY2h1bmtfc2l6ZSxpKS51cGxvYWQoKX0pfSxvZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxuLGkpe1QodGhpcyxlKSx0aGlzLmxpdmVTb2NrZXQ9aSx0aGlzLmVudHJ5PXQsdGhpcy5vZmZzZXQ9MCx0aGlzLmNodW5rU2l6ZT1uLHRoaXMudXBsb2FkQ2hhbm5lbD1pLmNoYW5uZWwoXCJsdnU6XCIuY29uY2F0KHQucmVmKSx7dG9rZW46dC5tZXRhZGF0YSgpfSl9cmV0dXJuIF8oZSxbe2tleTpcInVwbG9hZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnVwbG9hZENoYW5uZWwuam9pbigpLnJlY2VpdmUoXCJva1wiLGZ1bmN0aW9uKHQpe3JldHVybiBlLnJlYWROZXh0Q2h1bmsoKX0pLnJlY2VpdmUoXCJlcnJvclwiLGZ1bmN0aW9uKHQpe2UudXBsb2FkQ2hhbm5lbC5sZWF2ZSgpLGUuZW50cnkuZXJyb3IoKX0pfX0se2tleTpcImlzRG9uZVwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0Pj10aGlzLmVudHJ5LmZpbGUuc2l6ZX19LHtrZXk6XCJyZWFkTmV4dENodW5rXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9bmV3IHdpbmRvdy5GaWxlUmVhZGVyLG49dGhpcy5lbnRyeS5maWxlLnNsaWNlKHRoaXMub2Zmc2V0LHRoaXMuY2h1bmtTaXplK3RoaXMub2Zmc2V0KTt0Lm9ubG9hZD1mdW5jdGlvbih0KXtpZihudWxsIT09dC50YXJnZXQuZXJyb3IpcmV0dXJuIHooXCJSZWFkIGVycm9yOiBcIit0LnRhcmdldC5lcnJvcik7ZS5vZmZzZXQrPXQudGFyZ2V0LnJlc3VsdC5ieXRlTGVuZ3RoLGUucHVzaENodW5rKHQudGFyZ2V0LnJlc3VsdCl9LHQucmVhZEFzQXJyYXlCdWZmZXIobil9fSx7a2V5OlwicHVzaENodW5rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aGlzLnVwbG9hZENoYW5uZWwuaXNKb2luZWQoKSYmdGhpcy51cGxvYWRDaGFubmVsLnB1c2goXCJjaHVua1wiLGUpLnJlY2VpdmUoXCJva1wiLGZ1bmN0aW9uKCl7dC5lbnRyeS5wcm9ncmVzcyh0Lm9mZnNldC90LmVudHJ5LmZpbGUuc2l6ZSoxMDApLHQuaXNEb25lKCl8fHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gdC5yZWFkTmV4dENodW5rKCl9LHQubGl2ZVNvY2tldC5nZXRMYXRlbmN5U2ltKCl8fDApfSl9fV0pLGV9KCksYWU9ZnVuY3Rpb24oZSl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG49bmV3IEZvcm1EYXRhKGUpLGk9W107bi5mb3JFYWNoKGZ1bmN0aW9uKGUsdCxuKXtlIGluc3RhbmNlb2YgRmlsZSYmaS5wdXNoKHQpfSksaS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBuLmRlbGV0ZShlKX0pO3ZhciByLG89bmV3IFVSTFNlYXJjaFBhcmFtcyxhPWZ1bmN0aW9uKGUpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBTeW1ib2x8fG51bGw9PWVbU3ltYm9sLml0ZXJhdG9yXSl7aWYoQXJyYXkuaXNBcnJheShlKXx8KGU9TChlKSkpe3ZhciB0PTAsbj1mdW5jdGlvbigpe307cmV0dXJue3M6bixuOmZ1bmN0aW9uKCl7cmV0dXJuIHQ+PWUubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTplW3QrK119fSxlOmZ1bmN0aW9uKGUpe3Rocm93IGV9LGY6bn19dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpfXZhciBpLHIsbz0hMCxhPSExO3JldHVybntzOmZ1bmN0aW9uKCl7aT1lW1N5bWJvbC5pdGVyYXRvcl0oKX0sbjpmdW5jdGlvbigpe3ZhciBlPWkubmV4dCgpO3JldHVybiBvPWUuZG9uZSxlfSxlOmZ1bmN0aW9uKGUpe2E9ITAscj1lfSxmOmZ1bmN0aW9uKCl7dHJ5e298fG51bGw9PWkucmV0dXJufHxpLnJldHVybigpfWZpbmFsbHl7aWYoYSl0aHJvdyByfX19fShuLmVudHJpZXMoKSk7dHJ5e2ZvcihhLnMoKTshKHI9YS5uKCkpLmRvbmU7KXt2YXIgdT14KHIudmFsdWUsMikscz11WzBdLGM9dVsxXTtvLmFwcGVuZChzLGMpfX1jYXRjaChlKXthLmUoZSl9ZmluYWxseXthLmYoKX1mb3IodmFyIGwgaW4gdClvLmFwcGVuZChsLHRbbF0pO3JldHVybiBvLnRvU3RyaW5nKCl9LHVlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4pe1QodGhpcyxlKSx0aGlzLnZpZXdJZD10LHRoaXMucmVuZGVyZWQ9e30sdGhpcy5tZXJnZURpZmYobil9cmV0dXJuIF8oZSxudWxsLFt7a2V5OlwiZXh0cmFjdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUucixuPWUuZSxpPWUudDtyZXR1cm4gZGVsZXRlIGUucixkZWxldGUgZS5lLGRlbGV0ZSBlLnQse2RpZmY6ZSx0aXRsZTppLHJlcGx5OnR8fG51bGwsZXZlbnRzOm58fFtdfX19XSksXyhlLFt7a2V5OlwicGFyZW50Vmlld0lkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3SWR9fSx7a2V5OlwidG9TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWN1cnNpdmVUb1N0cmluZyh0aGlzLnJlbmRlcmVkLHRoaXMucmVuZGVyZWQuYyxlKX19LHtrZXk6XCJyZWN1cnNpdmVUb1N0cmluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTplLmMsbj1hcmd1bWVudHMubGVuZ3RoPjI/YXJndW1lbnRzWzJdOnZvaWQgMCxpPXtidWZmZXI6XCJcIixjb21wb25lbnRzOnQsb25seUNpZHM6bj1uP25ldyBTZXQobik6bnVsbH07cmV0dXJuIHRoaXMudG9PdXRwdXRCdWZmZXIoZSxpKSxpLmJ1ZmZlcn19LHtrZXk6XCJjb21wb25lbnRDSURzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUuY3x8e30pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSl9KX19LHtrZXk6XCJpc0NvbXBvbmVudE9ubHlEaWZmXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuISFlLmMmJjE9PT1PYmplY3Qua2V5cyhlKS5sZW5ndGh9fSx7a2V5OlwiZ2V0Q29tcG9uZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jW3RdfX0se2tleTpcIm1lcmdlRGlmZlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUuYztpZihkZWxldGUgZS5jLHRoaXMucmVuZGVyZWQ9dGhpcy5yZWN1cnNpdmVNZXJnZSh0aGlzLnJlbmRlcmVkLGUpLHRoaXMucmVuZGVyZWQuYz10aGlzLnJlbmRlcmVkLmN8fHt9LHQpe3ZhciBuPXRoaXMucmVuZGVyZWQuYztmb3IodmFyIGkgaW4gdCl7dmFyIHI9dFtpXSxvPXIsYT1vLnM7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEpe2Zvcig7XCJudW1iZXJcIj09dHlwZW9mIGE7KWE9KG89YT4wP3RbYV06blstYV0pLnM7bz0kKG8pLHRoaXMuZG9SZWN1cnNpdmVNZXJnZShvLHIpLG8ucz1hfWVsc2Ugbz1uW2ldfHx7fSxvPXRoaXMucmVjdXJzaXZlTWVyZ2UobyxyKTt0W2ldPW99Zm9yKHZhciB1IGluIHQpblt1XT10W3VdO2UuYz10fX19LHtrZXk6XCJyZWN1cnNpdmVNZXJnZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMCE9PXQucz90Oih0aGlzLmRvUmVjdXJzaXZlTWVyZ2UoZSx0KSxlKX19LHtrZXk6XCJkb1JlY3Vyc2l2ZU1lcmdlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG4gaW4gdCl7dmFyIGk9dFtuXSxyPWVbbl07WShpKSYmdm9pZCAwPT09aS5zJiZZKHIpP3RoaXMuZG9SZWN1cnNpdmVNZXJnZShyLGkpOmVbbl09aX19fSx7a2V5OlwiY29tcG9uZW50VG9TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyh0aGlzLnJlbmRlcmVkLmMsZSl9fSx7a2V5OlwicHJ1bmVDSURzXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztlLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGRlbGV0ZSB0LnJlbmRlcmVkLmNbZV19KX19LHtrZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlbmRlcmVkfX0se2tleTpcImlzTmV3RmluZ2VycHJpbnRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiEhKGFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSkuc319LHtrZXk6XCJ0b091dHB1dEJ1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoZS5kKXJldHVybiB0aGlzLmNvbXByZWhlbnNpb25Ub0J1ZmZlcihlLHQpO3ZhciBuPWUuczt0LmJ1ZmZlcis9blswXTtmb3IodmFyIGk9MTtpPG4ubGVuZ3RoO2krKyl0aGlzLmR5bmFtaWNUb0J1ZmZlcihlW2ktMV0sdCksdC5idWZmZXIrPW5baV19fSx7a2V5OlwiY29tcHJlaGVuc2lvblRvQnVmZmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49ZS5kLGk9ZS5zLHI9MDtyPG4ubGVuZ3RoO3IrKyl7dmFyIG89bltyXTt0LmJ1ZmZlcis9aVswXTtmb3IodmFyIGE9MTthPGkubGVuZ3RoO2ErKyl0aGlzLmR5bmFtaWNUb0J1ZmZlcihvW2EtMV0sdCksdC5idWZmZXIrPWlbYV19fX0se2tleTpcImR5bmFtaWNUb0J1ZmZlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7XCJudW1iZXJcIj09dHlwZW9mIGU/dC5idWZmZXIrPXRoaXMucmVjdXJzaXZlQ0lEVG9TdHJpbmcodC5jb21wb25lbnRzLGUsdC5vbmx5Q2lkcyk6WShlKT90aGlzLnRvT3V0cHV0QnVmZmVyKGUsdCk6dC5idWZmZXIrPWV9fSx7a2V5OlwicmVjdXJzaXZlQ0lEVG9TdHJpbmdcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcyxyPWVbdF18fHooXCJubyBjb21wb25lbnQgZm9yIENJRCBcIi5jb25jYXQodCksZSksbz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7by5pbm5lckhUTUw9dGhpcy5yZWN1cnNpdmVUb1N0cmluZyhyLGUsbik7dmFyIGE9by5jb250ZW50LHU9biYmIW4uaGFzKHQpLHM9eChBcnJheS5mcm9tKGEuY2hpbGROb2RlcykucmVkdWNlKGZ1bmN0aW9uKGUsbixyKXt2YXIgYT14KGUsMikscz1hWzBdLGM9YVsxXTtyZXR1cm4gbi5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFP24uZ2V0QXR0cmlidXRlKEgpP1tzLCEwXToobi5zZXRBdHRyaWJ1dGUoSCx0KSxuLmlkfHwobi5pZD1cIlwiLmNvbmNhdChpLnBhcmVudFZpZXdJZCgpLFwiLVwiKS5jb25jYXQodCxcIi1cIikuY29uY2F0KHIpKSx1JiYobi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1za2lwXCIsXCJcIiksbi5pbm5lckhUTUw9XCJcIiksWyEwLGNdKTpcIlwiIT09bi5ub2RlVmFsdWUudHJpbSgpPyh6KFwib25seSBIVE1MIGVsZW1lbnQgdGFncyBhcmUgYWxsb3dlZCBhdCB0aGUgcm9vdCBvZiBjb21wb25lbnRzLlxcblxcblwiKydnb3Q6IFwiJy5jb25jYXQobi5ub2RlVmFsdWUudHJpbSgpLCdcIlxcblxcbicpK1wid2l0aGluOlxcblwiLG8uaW5uZXJIVE1MLnRyaW0oKSksbi5yZXBsYWNlV2l0aChpLmNyZWF0ZVNwYW4obi5ub2RlVmFsdWUsdCkpLFshMCxjXSk6KG4ucmVtb3ZlKCksW3MsY10pfSxbITEsITFdKSwyKSxjPXNbMF0sbD1zWzFdO3JldHVybiBjfHxsPyFjJiZsPyh6KFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgZGlyZWN0bHkgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgb25seSBzdWJjb21wb25lbnRzIHdlcmUgZm91bmQuIEEgY29tcG9uZW50IG11c3QgcmVuZGVyIGF0IGxlYXN0IG9uZSBIVE1MIHRhZyBkaXJlY3RseSBpbnNpZGUgaXRzZWxmLlwiLG8uaW5uZXJIVE1MLnRyaW0oKSksby5pbm5lckhUTUwpOm8uaW5uZXJIVE1MOih6KFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgdGhlIGNvbXBvbmVudCBpcyBlbXB0eTpcXG5cIixvLmlubmVySFRNTC50cmltKCkpLHRoaXMuY3JlYXRlU3BhbihcIlwiLHQpLm91dGVySFRNTCl9fSx7a2V5OlwiY3JlYXRlU3BhblwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7cmV0dXJuIG4uaW5uZXJUZXh0PWUsbi5zZXRBdHRyaWJ1dGUoSCx0KSxufX1dKSxlfSgpLHNlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4pe3ZhciBpPXRoaXMscj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e307aWYoVCh0aGlzLGUpLHRoaXMudW5sb2FkZWQ9ITEsIW58fFwiT2JqZWN0XCI9PT1uLmNvbnN0cnVjdG9yLm5hbWUpdGhyb3cgbmV3IEVycm9yKCdcXG4gICAgICBhIHBob2VuaXggU29ja2V0IG11c3QgYmUgcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgTGl2ZVNvY2tldCBjb25zdHJ1Y3Rvci4gRm9yIGV4YW1wbGU6XFxuXFxuICAgICAgICAgIGltcG9ydCB7U29ja2V0fSBmcm9tIFwicGhvZW5peFwiXFxuICAgICAgICAgIGltcG9ydCB7TGl2ZVNvY2tldH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcXG4gICAgICAgICAgbGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwgey4uLn0pXFxuICAgICAgJyk7dGhpcy5zb2NrZXQ9bmV3IG4odCxyKSx0aGlzLmJpbmRpbmdQcmVmaXg9ci5iaW5kaW5nUHJlZml4fHxXLHRoaXMub3B0cz1yLHRoaXMucGFyYW1zPVgoci5wYXJhbXN8fHt9KSx0aGlzLnZpZXdMb2dnZXI9ci52aWV3TG9nZ2VyLHRoaXMubWV0YWRhdGFDYWxsYmFja3M9ci5tZXRhZGF0YXx8e30sdGhpcy5kZWZhdWx0cz1PYmplY3QuYXNzaWduKCQocSksci5kZWZhdWx0c3x8e30pLHRoaXMuYWN0aXZlRWxlbWVudD1udWxsLHRoaXMucHJldkFjdGl2ZT1udWxsLHRoaXMuc2lsZW5jZWQ9ITEsdGhpcy5tYWluPW51bGwsdGhpcy5saW5rUmVmPTAsdGhpcy5yb290cz17fSx0aGlzLmhyZWY9d2luZG93LmxvY2F0aW9uLmhyZWYsdGhpcy5wZW5kaW5nTGluaz1udWxsLHRoaXMuY3VycmVudExvY2F0aW9uPSQod2luZG93LmxvY2F0aW9uKSx0aGlzLmhvb2tzPXIuaG9va3N8fHt9LHRoaXMudXBsb2FkZXJzPXIudXBsb2FkZXJzfHx7fSx0aGlzLmxvYWRlclRpbWVvdXQ9ci5sb2FkZXJUaW1lb3V0fHxWLHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cz0hMSx0aGlzLmRvbUNhbGxiYWNrcz1PYmplY3QuYXNzaWduKHtvbk5vZGVBZGRlZDpYKCksb25CZWZvcmVFbFVwZGF0ZWQ6WCgpfSxyLmRvbXx8e30pLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsZnVuY3Rpb24oZSl7aS51bmxvYWRlZD0hMH0pLHRoaXMuc29ja2V0Lm9uT3BlbihmdW5jdGlvbigpe2kuaXNVbmxvYWRlZCgpJiZ3aW5kb3cubG9jYXRpb24ucmVsb2FkKCl9KX1yZXR1cm4gXyhlLFt7a2V5OlwiaXNQcm9maWxlRW5hYmxlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJ0cnVlXCI9PT1zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwicGh4OmxpdmUtc29ja2V0OnByb2ZpbGluZ1wiKX19LHtrZXk6XCJpc0RlYnVnRW5hYmxlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCJ0cnVlXCI9PT1zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwicGh4OmxpdmUtc29ja2V0OmRlYnVnXCIpfX0se2tleTpcImVuYWJsZURlYnVnXCIsdmFsdWU6ZnVuY3Rpb24oKXtzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwicGh4OmxpdmUtc29ja2V0OmRlYnVnXCIsXCJ0cnVlXCIpfX0se2tleTpcImVuYWJsZVByb2ZpbGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcInBoeDpsaXZlLXNvY2tldDpwcm9maWxpbmdcIixcInRydWVcIil9fSx7a2V5OlwiZGlzYWJsZURlYnVnXCIsdmFsdWU6ZnVuY3Rpb24oKXtzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFwicGh4OmxpdmUtc29ja2V0OmRlYnVnXCIpfX0se2tleTpcImRpc2FibGVQcm9maWxpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3Nlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oXCJwaHg6bGl2ZS1zb2NrZXQ6cHJvZmlsaW5nXCIpfX0se2tleTpcImVuYWJsZUxhdGVuY3lTaW1cIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLmVuYWJsZURlYnVnKCksY29uc29sZS5sb2coXCJsYXRlbmN5IHNpbXVsYXRvciBlbmFibGVkIGZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBicm93c2VyIHNlc3Npb24uIENhbGwgZGlzYWJsZUxhdGVuY3lTaW0oKSB0byBkaXNhYmxlXCIpLHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJwaHg6bGl2ZS1zb2NrZXQ6bGF0ZW5jeS1zaW1cIixlKX19LHtrZXk6XCJkaXNhYmxlTGF0ZW5jeVNpbVwiLHZhbHVlOmZ1bmN0aW9uKCl7c2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShcInBoeDpsaXZlLXNvY2tldDpsYXRlbmN5LXNpbVwiKX19LHtrZXk6XCJnZXRMYXRlbmN5U2ltXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwicGh4OmxpdmUtc29ja2V0OmxhdGVuY3ktc2ltXCIpO3JldHVybiBlP3BhcnNlSW50KGUpOm51bGx9fSx7a2V5OlwiZ2V0U29ja2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zb2NrZXR9fSx7a2V5OlwiY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PWZ1bmN0aW9uKCl7ZS5qb2luUm9vdFZpZXdzKCkmJihlLmJpbmRUb3BMZXZlbEV2ZW50cygpLGUuc29ja2V0LmNvbm5lY3QoKSl9O1tcImNvbXBsZXRlXCIsXCJsb2FkZWRcIixcImludGVyYWN0aXZlXCJdLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSk+PTA/dCgpOmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsZnVuY3Rpb24oKXtyZXR1cm4gdCgpfSl9fSx7a2V5OlwiZGlzY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuc29ja2V0LmRpc2Nvbm5lY3QoZSl9fSx7a2V5OlwidHJpZ2dlckRPTVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG47KG49dGhpcy5kb21DYWxsYmFja3MpW2VdLmFwcGx5KG4sQSh0KSl9fSx7a2V5OlwidGltZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7aWYoIXRoaXMuaXNQcm9maWxlRW5hYmxlZCgpfHwhY29uc29sZS50aW1lKXJldHVybiB0KCk7Y29uc29sZS50aW1lKGUpO3ZhciBuPXQoKTtyZXR1cm4gY29uc29sZS50aW1lRW5kKGUpLG59fSx7a2V5OlwibG9nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe2lmKHRoaXMudmlld0xvZ2dlcil7dmFyIGk9eChuKCksMikscj1pWzBdLG89aVsxXTt0aGlzLnZpZXdMb2dnZXIoZSx0LHIsbyl9ZWxzZSBpZih0aGlzLmlzRGVidWdFbmFibGVkKCkpe3ZhciBhPXgobigpLDIpLHU9YVswXSxzPWFbMV07SyhlLHQsdSxzKX19fSx7a2V5Olwib25DaGFubmVsXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXM7ZS5vbih0LGZ1bmN0aW9uKGUpe3ZhciB0PWkuZ2V0TGF0ZW5jeVNpbSgpO3Q/KGNvbnNvbGUubG9nKFwic2ltdWxhdGluZyBcIi5jb25jYXQodCxcIm1zIG9mIGxhdGVuY3kgZnJvbSBzZXJ2ZXIgdG8gY2xpZW50XCIpKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIG4oZSl9LHQpKTpuKGUpfSl9fSx7a2V5Olwid3JhcFB1c2hcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcyxyPXRoaXMuZ2V0TGF0ZW5jeVNpbSgpLG89ZS5qb2luQ291bnQ7aWYoIXIpcmV0dXJuIHQudGltZW91dD9uKCkucmVjZWl2ZShcInRpbWVvdXRcIixmdW5jdGlvbigpe2Uuam9pbkNvdW50PT09byYmaS5yZWxvYWRXaXRoSml0dGVyKGUsZnVuY3Rpb24oKXtpLmxvZyhlLFwidGltZW91dFwiLGZ1bmN0aW9uKCl7cmV0dXJuW1wicmVjZWl2ZWQgdGltZW91dCB3aGlsZSBjb21tdW5pY2F0aW5nIHdpdGggc2VydmVyLiBGYWxsaW5nIGJhY2sgdG8gaGFyZCByZWZyZXNoIGZvciByZWNvdmVyeVwiXX0pfSl9KTpuKCk7Y29uc29sZS5sb2coXCJzaW11bGF0aW5nIFwiLmNvbmNhdChyLFwibXMgb2YgbGF0ZW5jeSBmcm9tIGNsaWVudCB0byBzZXJ2ZXJcIikpO3ZhciBhPXtyZWNlaXZlczpbXSxyZWNlaXZlOmZ1bmN0aW9uKGUsdCl7dGhpcy5yZWNlaXZlcy5wdXNoKFtlLHRdKX19O3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YS5yZWNlaXZlcy5yZWR1Y2UoZnVuY3Rpb24oZSx0KXt2YXIgbj14KHQsMiksaT1uWzBdLHI9blsxXTtyZXR1cm4gZS5yZWNlaXZlKGkscil9LG4oKSl9LHIpLGF9fSx7a2V5OlwicmVsb2FkV2l0aEppdHRlclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztlLmRlc3Ryb3koKSx0aGlzLmRpc2Nvbm5lY3QoKTt2YXIgaT1SWzBdLHI9UlsxXSxvPU1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSooci1pKzEpKStpLGE9Y2UudXBkYXRlTG9jYWwoZS5uYW1lKCksXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCIsMCxmdW5jdGlvbihlKXtyZXR1cm4gZSsxfSk7dD90KCk6dGhpcy5sb2coZSxcImpvaW5cIixmdW5jdGlvbigpe3JldHVybltcImVuY291bnRlcmVkIFwiLmNvbmNhdChhLFwiIGNvbnNlY3V0aXZlIHJlbG9hZHNcIildfSksYT4xMCYmKHRoaXMubG9nKGUsXCJqb2luXCIsZnVuY3Rpb24oKXtyZXR1cm5bXCJleGNlZWRlZCBcIi5jb25jYXQoMTAsXCIgY29uc2VjdXRpdmUgcmVsb2Fkcy4gRW50ZXJpbmcgZmFpbHNhZmUgbW9kZVwiKV19KSxvPTNlNCksc2V0VGltZW91dChmdW5jdGlvbigpe24uaGFzUGVuZGluZ0xpbmsoKT93aW5kb3cubG9jYXRpb249bi5wZW5kaW5nTGluazp3aW5kb3cubG9jYXRpb24ucmVsb2FkKCl9LG8pfX0se2tleTpcImdldEhvb2tDYWxsYmFja3NcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5zdGFydHNXaXRoKFwiUGhvZW5peC5cIik/dGVbZS5zcGxpdChcIi5cIilbMV1dOnRoaXMuaG9va3NbZV19fSx7a2V5OlwiaXNVbmxvYWRlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5sb2FkZWR9fSx7a2V5OlwiaXNDb25uZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpfX0se2tleTpcImdldEJpbmRpbmdQcmVmaXhcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJpbmRpbmdQcmVmaXh9fSx7a2V5OlwiYmluZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwiXCIuY29uY2F0KHRoaXMuZ2V0QmluZGluZ1ByZWZpeCgpKS5jb25jYXQoZSl9fSx7a2V5OlwiY2hhbm5lbFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuc29ja2V0LmNoYW5uZWwoZSx0KX19LHtrZXk6XCJqb2luUm9vdFZpZXdzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLHQ9ITE7cmV0dXJuIGxlLmFsbChkb2N1bWVudCxcIlwiLmNvbmNhdChVLFwiOm5vdChbXCIpLmNvbmNhdChcImRhdGEtcGh4LXBhcmVudC1pZFwiLFwiXSlcIiksZnVuY3Rpb24obil7aWYoIWUuZ2V0Um9vdEJ5SWQobi5pZCkpe3ZhciBpPWUuam9pblJvb3RWaWV3KG4sZS5nZXRIcmVmKCkpO2Uucm9vdD1lLnJvb3R8fGksbi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1tYWluXCIpJiYoZS5tYWluPWkpfXQ9ITB9KSx0fX0se2tleTpcInJlZGlyZWN0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLmRpc2Nvbm5lY3QoKSxjZS5yZWRpcmVjdChlLHQpfX0se2tleTpcInJlcGxhY2VNYWluXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLGk9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGwscj1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106dGhpcy5zZXRQZW5kaW5nTGluayhlKSxvPXRoaXMubWFpbi5lbDt0aGlzLm1haW4uc2hvd0xvYWRlcih0aGlzLmxvYWRlclRpbWVvdXQpLHRoaXMubWFpbi5kZXN0cm95KCksY2UuZmV0Y2hQYWdlKGUsZnVuY3Rpb24oYSx1KXtpZigyMDAhPT1hKXJldHVybiBuLnJlZGlyZWN0KGUpO3ZhciBzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtzLmlubmVySFRNTD11O3ZhciBjPXMuY29udGVudC5jaGlsZE5vZGVzWzBdO2lmKCFjfHwhbi5pc1BoeFZpZXcoYykpcmV0dXJuIG4ucmVkaXJlY3QoZSk7bi5qb2luUm9vdFZpZXcoYyxlLHQsZnVuY3Rpb24oZSx0KXsxPT09dCYmKG4uY29tbWl0UGVuZGluZ0xpbmsocik/KG8ucmVwbGFjZVdpdGgoZS5lbCksbi5tYWluPWUsaSYmaSgpKTplLmRlc3Ryb3koKSl9KX0pfX0se2tleTpcImlzUGh4Vmlld1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEF0dHJpYnV0ZSYmbnVsbCE9PWUuZ2V0QXR0cmlidXRlKE8pfX0se2tleTpcImpvaW5Sb290Vmlld1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGkpe3ZhciByPW5ldyBmZShlLHRoaXMsbnVsbCx0LG4pO3JldHVybiB0aGlzLnJvb3RzW3IuaWRdPXIsci5qb2luKGkpLHJ9fSx7a2V5Olwib3duZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMsaT1aKGUuY2xvc2VzdChVKSxmdW5jdGlvbihlKXtyZXR1cm4gbi5nZXRWaWV3QnlFbChlKX0pO2kmJnQoaSl9fSx7a2V5Olwid2l0aGluT3duZXJzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3RoaXMub3duZXIoZSxmdW5jdGlvbihpKXt2YXIgcj1lLmdldEF0dHJpYnV0ZShuLmJpbmRpbmcoXCJ0YXJnZXRcIikpO251bGw9PT1yP3QoaSxlKTppLndpdGhpblRhcmdldHMocix0KX0pfX0se2tleTpcImdldFZpZXdCeUVsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yb290LWlkXCIpO3JldHVybiBaKHRoaXMuZ2V0Um9vdEJ5SWQodCksZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0RGVzY2VuZGVudEJ5RWwoZSl9KX19LHtrZXk6XCJnZXRSb290QnlJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJvb3RzW2VdfX0se2tleTpcImRlc3Ryb3lBbGxWaWV3c1wiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMucm9vdHMpdGhpcy5yb290c1tlXS5kZXN0cm95KCksZGVsZXRlIHRoaXMucm9vdHNbZV19fSx7a2V5OlwiZGVzdHJveVZpZXdCeUVsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRSb290QnlJZChlLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXJvb3QtaWRcIikpO3QmJnQuZGVzdHJveURlc2NlbmRlbnQoZS5pZCl9fSx7a2V5Olwic2V0QWN0aXZlRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYodGhpcy5hY3RpdmVFbGVtZW50IT09ZSl7dGhpcy5hY3RpdmVFbGVtZW50PWU7dmFyIG49ZnVuY3Rpb24oKXtlPT09dC5hY3RpdmVFbGVtZW50JiYodC5hY3RpdmVFbGVtZW50PW51bGwpLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0KSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLHQpfTtlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsbiksZS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIixuKX19fSx7a2V5OlwiZ2V0QWN0aXZlRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ9PT1kb2N1bWVudC5ib2R5P3RoaXMuYWN0aXZlRWxlbWVudHx8ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDpkb2N1bWVudC5hY3RpdmVFbGVtZW50fHxkb2N1bWVudC5ib2R5fX0se2tleTpcImRyb3BBY3RpdmVFbGVtZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5wcmV2QWN0aXZlJiZlLm93bnNFbGVtZW50KHRoaXMucHJldkFjdGl2ZSkmJih0aGlzLnByZXZBY3RpdmU9bnVsbCl9fSx7a2V5OlwicmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcmV2QWN0aXZlJiZ0aGlzLnByZXZBY3RpdmUhPT1kb2N1bWVudC5ib2R5JiZ0aGlzLnByZXZBY3RpdmUuZm9jdXMoKX19LHtrZXk6XCJibHVyQWN0aXZlRWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcmV2QWN0aXZlPXRoaXMuZ2V0QWN0aXZlRWxlbWVudCgpLHRoaXMucHJldkFjdGl2ZSE9PWRvY3VtZW50LmJvZHkmJnRoaXMucHJldkFjdGl2ZS5ibHVyKCl9fSx7a2V5OlwiYmluZFRvcExldmVsRXZlbnRzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuYm91bmRUb3BMZXZlbEV2ZW50c3x8KHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cz0hMCxkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKCl7fSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLGZ1bmN0aW9uKHQpe3QucGVyc2lzdGVkJiYoZS53aXRoUGFnZUxvYWRpbmcoe3RvOndpbmRvdy5sb2NhdGlvbi5ocmVmLGtpbmQ6XCJyZWRpcmVjdFwifSksd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpKX0pLHRoaXMuYmluZENsaWNrcygpLHRoaXMuYmluZE5hdigpLHRoaXMuYmluZEZvcm1zKCksdGhpcy5iaW5kKHtrZXl1cDpcImtleXVwXCIsa2V5ZG93bjpcImtleWRvd25cIn0sZnVuY3Rpb24odCxuLGkscixvLGEsdSl7dmFyIHM9ci5nZXRBdHRyaWJ1dGUoZS5iaW5kaW5nKFwia2V5XCIpKSxjPXQua2V5JiZ0LmtleS50b0xvd2VyQ2FzZSgpO3MmJnMudG9Mb3dlckNhc2UoKSE9PWN8fGkucHVzaEtleShyLG8sbixhLGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBuPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e307dCUyP3coT2JqZWN0KG4pLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe0UoZSx0LG5bdF0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSk6dyhPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCkpfSl9cmV0dXJuIGV9KHtrZXk6dC5rZXl9LGUuZXZlbnRNZXRhKG4sdCxyKSkpfSksdGhpcy5iaW5kKHtibHVyOlwiZm9jdXNvdXRcIixmb2N1czpcImZvY3VzaW5cIn0sZnVuY3Rpb24odCxuLGkscixvLGEsdSl7dXx8aS5wdXNoRXZlbnQobixyLG8sYSxlLmV2ZW50TWV0YShuLHQscikpfSksdGhpcy5iaW5kKHtibHVyOlwiYmx1clwiLGZvY3VzOlwiZm9jdXNcIn0sZnVuY3Rpb24odCxuLGkscixvLGEsdSl7dSYmXCJ3aW5kb3dcIiE9PSF1JiZpLnB1c2hFdmVudChuLHIsbyxhLGUuZXZlbnRNZXRhKG4sdCxyKSl9KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsZnVuY3Rpb24oZSl7cmV0dXJuIGUucHJldmVudERlZmF1bHQoKX0pLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLGZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKTt2YXIgbj1aKEcodC50YXJnZXQsZS5iaW5kaW5nKFwiZHJvcC10YXJnZXRcIikpLGZ1bmN0aW9uKHQpe3JldHVybiB0LmdldEF0dHJpYnV0ZShlLmJpbmRpbmcoXCJkcm9wLXRhcmdldFwiKSl9KSxpPW4mJmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG4pLHI9QXJyYXkuZnJvbSh0LmRhdGFUcmFuc2Zlci5maWxlc3x8W10pO2kmJiFpLmRpc2FibGVkJiYwIT09ci5sZW5ndGgmJmkuZmlsZXMgaW5zdGFuY2VvZiBGaWxlTGlzdCYmKGllLnRyYWNrRmlsZXMoaSxyKSxpLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiaW5wdXRcIix7YnViYmxlczohMH0pKSl9KSl9fSx7a2V5OlwiZXZlbnRNZXRhXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXMubWV0YWRhdGFDYWxsYmFja3NbZV07cmV0dXJuIGk/aSh0LG4pOnt9fX0se2tleTpcInNldFBlbmRpbmdMaW5rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGlua1JlZisrLHRoaXMucGVuZGluZ0xpbms9ZSx0aGlzLmxpbmtSZWZ9fSx7a2V5OlwiY29tbWl0UGVuZGluZ0xpbmtcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5saW5rUmVmPT09ZSYmKHRoaXMuaHJlZj10aGlzLnBlbmRpbmdMaW5rLHRoaXMucGVuZGluZ0xpbms9bnVsbCwhMCl9fSx7a2V5OlwiZ2V0SHJlZlwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaHJlZn19LHtrZXk6XCJoYXNQZW5kaW5nTGlua1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLnBlbmRpbmdMaW5rfX0se2tleTpcImJpbmRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMsaT1mdW5jdGlvbihpKXt2YXIgcj1lW2ldO24ub24ocixmdW5jdGlvbihlKXt2YXIgcj1uLmJpbmRpbmcoaSksbz1uLmJpbmRpbmcoXCJ3aW5kb3ctXCIuY29uY2F0KGkpKSxhPWUudGFyZ2V0LmdldEF0dHJpYnV0ZSYmZS50YXJnZXQuZ2V0QXR0cmlidXRlKHIpO2E/bi5kZWJvdW5jZShlLnRhcmdldCxlLGZ1bmN0aW9uKCl7bi53aXRoaW5Pd25lcnMoZS50YXJnZXQsZnVuY3Rpb24obixyKXt0KGUsaSxuLGUudGFyZ2V0LHIsYSxudWxsKX0pfSk6bGUuYWxsKGRvY3VtZW50LFwiW1wiLmNvbmNhdChvLFwiXVwiKSxmdW5jdGlvbihyKXt2YXIgYT1yLmdldEF0dHJpYnV0ZShvKTtuLmRlYm91bmNlKHIsZSxmdW5jdGlvbigpe24ud2l0aGluT3duZXJzKHIsZnVuY3Rpb24obixvKXt0KGUsaSxuLHIsbyxhLFwid2luZG93XCIpfSl9KX0pfSl9O2Zvcih2YXIgciBpbiBlKWkocil9fSx7a2V5OlwiYmluZENsaWNrc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5iaW5kQ2xpY2soXCJjbGlja1wiLFwiY2xpY2tcIiwhMSksdGhpcy5iaW5kQ2xpY2soXCJtb3VzZWRvd25cIixcImNhcHR1cmUtY2xpY2tcIiwhMCl9fSx7a2V5OlwiYmluZENsaWNrXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXMscj10aGlzLmJpbmRpbmcodCk7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZSxmdW5jdGlvbihlKXtpZihpLmlzQ29ubmVjdGVkKCkpe3ZhciB0PW51bGwsbz0odD1uP2UudGFyZ2V0Lm1hdGNoZXMoXCJbXCIuY29uY2F0KHIsXCJdXCIpKT9lLnRhcmdldDplLnRhcmdldC5xdWVyeVNlbGVjdG9yKFwiW1wiLmNvbmNhdChyLFwiXVwiKSk6RyhlLnRhcmdldCxyKSkmJnQuZ2V0QXR0cmlidXRlKHIpO28mJihcIiNcIj09PXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSYmZS5wcmV2ZW50RGVmYXVsdCgpLGkuZGVib3VuY2UodCxlLGZ1bmN0aW9uKCl7aS53aXRoaW5Pd25lcnModCxmdW5jdGlvbihuLHIpe24ucHVzaEV2ZW50KFwiY2xpY2tcIix0LHIsbyxpLmV2ZW50TWV0YShcImNsaWNrXCIsZSx0KSl9KX0pKX19LG4pfX0se2tleTpcImJpbmROYXZcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoY2UuY2FuUHVzaFN0YXRlKCkpe2hpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24mJihoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uPVwibWFudWFsXCIpO3ZhciB0PW51bGw7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixmdW5jdGlvbihlKXtjbGVhclRpbWVvdXQodCksdD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Y2UudXBkYXRlQ3VycmVudFN0YXRlKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuYXNzaWduKGUse3Njcm9sbDp3aW5kb3cuc2Nyb2xsWX0pfSl9LDEwMCl9KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsZnVuY3Rpb24odCl7aWYoZS5yZWdpc3Rlck5ld0xvY2F0aW9uKHdpbmRvdy5sb2NhdGlvbikpe3ZhciBuPXQuc3RhdGV8fHt9LGk9bi50eXBlLHI9bi5pZCxvPW4ucm9vdCxhPW4uc2Nyb2xsLHU9d2luZG93LmxvY2F0aW9uLmhyZWY7ZS5tYWluLmlzQ29ubmVjdGVkKCkmJlwicGF0Y2hcIj09PWkmJnI9PT1lLm1haW4uaWQ/ZS5tYWluLnB1c2hMaW5rUGF0Y2godSxudWxsKTplLnJlcGxhY2VNYWluKHUsbnVsbCxmdW5jdGlvbigpe28mJmUucmVwbGFjZVJvb3RIaXN0b3J5KCksXCJudW1iZXJcIj09dHlwZW9mIGEmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXt3aW5kb3cuc2Nyb2xsVG8oMCxhKX0sMCl9KX19LCExKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24odCl7dmFyIG49Ryh0LnRhcmdldCxcImRhdGEtcGh4LWxpbmtcIiksaT1uJiZuLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWxpbmtcIikscj10Lm1ldGFLZXl8fHQuY3RybEtleXx8MT09PXQuYnV0dG9uO2lmKGkmJmUuaXNDb25uZWN0ZWQoKSYmZS5tYWluJiYhcil7dmFyIG89bi5ocmVmLGE9bi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1saW5rLXN0YXRlXCIpO2lmKHQucHJldmVudERlZmF1bHQoKSxlLnBlbmRpbmdMaW5rIT09bylpZihcInBhdGNoXCI9PT1pKWUucHVzaEhpc3RvcnlQYXRjaChvLGEsbik7ZWxzZXtpZihcInJlZGlyZWN0XCIhPT1pKXRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIFwiLmNvbmNhdChcImRhdGEtcGh4LWxpbmtcIiwnIHRvIGJlIFwicGF0Y2hcIiBvciBcInJlZGlyZWN0XCIsIGdvdDogJykuY29uY2F0KGkpKTtlLmhpc3RvcnlSZWRpcmVjdChvLGEpfX19LCExKX19fSx7a2V5Olwid2l0aFBhZ2VMb2FkaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtsZS5kaXNwYXRjaEV2ZW50KHdpbmRvdyxcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIixlKTt2YXIgbj1mdW5jdGlvbigpe3JldHVybiBsZS5kaXNwYXRjaEV2ZW50KHdpbmRvdyxcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLGUpfTtyZXR1cm4gdD90KG4pOm59fSx7a2V5OlwicHVzaEhpc3RvcnlQYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzO3RoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzplLGtpbmQ6XCJwYXRjaFwifSxmdW5jdGlvbihyKXtpLm1haW4ucHVzaExpbmtQYXRjaChlLG4sZnVuY3Rpb24oKXtpLmhpc3RvcnlQYXRjaChlLHQpLHIoKX0pfSl9fSx7a2V5OlwiaGlzdG9yeVBhdGNoXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtjZS5wdXNoU3RhdGUodCx7dHlwZTpcInBhdGNoXCIsaWQ6dGhpcy5tYWluLmlkfSxlKSx0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKX19LHtrZXk6XCJoaXN0b3J5UmVkaXJlY3RcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcyxyPXdpbmRvdy5zY3JvbGxZO3RoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzplLGtpbmQ6XCJyZWRpcmVjdFwifSxmdW5jdGlvbihvKXtpLnJlcGxhY2VNYWluKGUsbixmdW5jdGlvbigpe2NlLnB1c2hTdGF0ZSh0LHt0eXBlOlwicmVkaXJlY3RcIixpZDppLm1haW4uaWQsc2Nyb2xsOnJ9LGUpLGkucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pLG8oKX0pfSl9fSx7a2V5OlwicmVwbGFjZVJvb3RIaXN0b3J5XCIsdmFsdWU6ZnVuY3Rpb24oKXtjZS5wdXNoU3RhdGUoXCJyZXBsYWNlXCIse3Jvb3Q6ITAsdHlwZTpcInBhdGNoXCIsaWQ6dGhpcy5tYWluLmlkfSl9fSx7a2V5OlwicmVnaXN0ZXJOZXdMb2NhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuY3VycmVudExvY2F0aW9uO3JldHVybiB0LnBhdGhuYW1lK3Quc2VhcmNoIT09ZS5wYXRobmFtZStlLnNlYXJjaCYmKHRoaXMuY3VycmVudExvY2F0aW9uPSQoZSksITApfX0se2tleTpcImJpbmRGb3Jtc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyx0PTA7dGhpcy5vbihcInN1Ym1pdFwiLGZ1bmN0aW9uKHQpe3ZhciBuPXQudGFyZ2V0LmdldEF0dHJpYnV0ZShlLmJpbmRpbmcoXCJzdWJtaXRcIikpO24mJih0LnByZXZlbnREZWZhdWx0KCksdC50YXJnZXQuZGlzYWJsZWQ9ITAsZS53aXRoaW5Pd25lcnModC50YXJnZXQsZnVuY3Rpb24oZSxpKXtyZXR1cm4gZS5zdWJtaXRGb3JtKHQudGFyZ2V0LGksbil9KSl9LCExKTtmb3IodmFyIG49ZnVuY3Rpb24oKXt2YXIgbj1yW2ldO2Uub24obixmdW5jdGlvbihpKXt2YXIgcj1pLnRhcmdldCxvPXIuZm9ybSYmci5mb3JtLmdldEF0dHJpYnV0ZShlLmJpbmRpbmcoXCJjaGFuZ2VcIikpO2lmKG8mJihcIm51bWJlclwiIT09ci50eXBlfHwhci52YWxpZGl0eXx8IXIudmFsaWRpdHkuYmFkSW5wdXQpKXt2YXIgYT10O3QrKzt2YXIgdT1sZS5wcml2YXRlKHIsXCJwcmV2LWl0ZXJhdGlvblwiKXx8e30scz11LmF0LGM9dS50eXBlO3M9PT1hLTEmJm4hPT1jfHwobGUucHV0UHJpdmF0ZShyLFwicHJldi1pdGVyYXRpb25cIix7YXQ6YSx0eXBlOm59KSxlLmRlYm91bmNlKHIsaSxmdW5jdGlvbigpe2Uud2l0aGluT3duZXJzKHIuZm9ybSxmdW5jdGlvbih0LG4pe2xlLnB1dFByaXZhdGUocixcInBoeC1oYXMtZm9jdXNlZFwiLCEwKSxsZS5pc1RleHR1YWxJbnB1dChyKXx8ZS5zZXRBY3RpdmVFbGVtZW50KHIpLHQucHVzaElucHV0KHIsbixvLGkudGFyZ2V0KX0pfSkpfX0sITEpfSxpPTAscj1bXCJjaGFuZ2VcIixcImlucHV0XCJdO2k8ci5sZW5ndGg7aSsrKW4oKX19LHtrZXk6XCJkZWJvdW5jZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzLmJpbmRpbmcoXCJkZWJvdW5jZVwiKSxyPXRoaXMuYmluZGluZyhcInRocm90dGxlXCIpLG89dGhpcy5kZWZhdWx0cy5kZWJvdW5jZS50b1N0cmluZygpLGE9dGhpcy5kZWZhdWx0cy50aHJvdHRsZS50b1N0cmluZygpO2xlLmRlYm91bmNlKGUsdCxpLG8scixhLG4pfX0se2tleTpcInNpbGVuY2VFdmVudHNcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLnNpbGVuY2VkPSEwLGUoKSx0aGlzLnNpbGVuY2VkPSExfX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKGUsZnVuY3Rpb24oZSl7bi5zaWxlbmNlZHx8dChlKX0pfX1dKSxlfSgpLGNlPXtjYW5QdXNoU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09aGlzdG9yeS5wdXNoU3RhdGV9LGRyb3BMb2NhbDpmdW5jdGlvbihlLHQpe3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5sb2NhbEtleShlLHQpKX0sdXBkYXRlTG9jYWw6ZnVuY3Rpb24oZSx0LG4saSl7dmFyIHI9dGhpcy5nZXRMb2NhbChlLHQpLG89dGhpcy5sb2NhbEtleShlLHQpLGE9bnVsbD09PXI/bjppKHIpO3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0obyxKU09OLnN0cmluZ2lmeShhKSksYX0sZ2V0TG9jYWw6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gSlNPTi5wYXJzZSh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5sb2NhbEtleShlLHQpKSl9LGZldGNoUGFnZTpmdW5jdGlvbihlLHQpe3ZhciBuPW5ldyBYTUxIdHRwUmVxdWVzdDtuLm9wZW4oXCJHRVRcIixlLCEwKSxuLnRpbWVvdXQ9M2U0LG4uc2V0UmVxdWVzdEhlYWRlcihcImNvbnRlbnQtdHlwZVwiLFwidGV4dC9odG1sXCIpLG4uc2V0UmVxdWVzdEhlYWRlcihcImNhY2hlLWNvbnRyb2xcIixcIm1heC1hZ2U9MCwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtdXN0LXJldmFsaWRhdGUsIHBvc3QtY2hlY2s9MCwgcHJlLWNoZWNrPTBcIiksbi5zZXRSZXF1ZXN0SGVhZGVyKFwieC1yZXF1ZXN0ZWQtd2l0aFwiLFwibGl2ZS1saW5rXCIpLG4ub25lcnJvcj1mdW5jdGlvbigpe3JldHVybiB0KDQwMCl9LG4ub250aW1lb3V0PWZ1bmN0aW9uKCl7cmV0dXJuIHQoNTA0KX0sbi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZig0PT09bi5yZWFkeVN0YXRlKXt2YXIgaT1uZXcgVVJMKGUpLHI9aS5wYXRobmFtZStpLnNlYXJjaCxvPVoobi5nZXRSZXNwb25zZUhlYWRlcihcIngtcmVzcG9uc2UtdXJsXCIpfHxuLnJlc3BvbnNlVVJMLGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgVVJMKGUpfSksYT1vP28ucGF0aG5hbWUrby5zZWFyY2g6bnVsbDtyZXR1cm5cImxpdmUtbGlua1wiIT09bi5nZXRSZXNwb25zZUhlYWRlcihcIngtcmVxdWVzdGVkLXdpdGhcIik/dCg0MDApOm51bGw9PT1vfHxhIT1yP3QoMzAyKToyMDAhPT1uLnN0YXR1cz90KG4uc3RhdHVzKTp2b2lkIHQoMjAwLG4ucmVzcG9uc2VUZXh0KX19LG4uc2VuZCgpfSx1cGRhdGVDdXJyZW50U3RhdGU6ZnVuY3Rpb24oZSl7dGhpcy5jYW5QdXNoU3RhdGUoKSYmaGlzdG9yeS5yZXBsYWNlU3RhdGUoZShoaXN0b3J5LnN0YXRlfHx7fSksXCJcIix3aW5kb3cubG9jYXRpb24uaHJlZil9LHB1c2hTdGF0ZTpmdW5jdGlvbihlLHQsbil7aWYodGhpcy5jYW5QdXNoU3RhdGUoKSl7aWYobiE9PXdpbmRvdy5sb2NhdGlvbi5ocmVmKXtpZihcInJlZGlyZWN0XCI9PXQudHlwZSYmdC5zY3JvbGwpe3ZhciBpPWhpc3Rvcnkuc3RhdGV8fHt9O2kuc2Nyb2xsPXQuc2Nyb2xsLGhpc3RvcnkucmVwbGFjZVN0YXRlKGksXCJcIix3aW5kb3cubG9jYXRpb24uaHJlZil9ZGVsZXRlIHQuc2Nyb2xsLGhpc3RvcnlbZStcIlN0YXRlXCJdKHQsXCJcIixufHxudWxsKTt2YXIgcj10aGlzLmdldEhhc2hUYXJnZXRFbCh3aW5kb3cubG9jYXRpb24uaGFzaCk7cj9yLnNjcm9sbEludG9WaWV3KCk6XCJyZWRpcmVjdFwiPT09dC50eXBlJiZ3aW5kb3cuc2Nyb2xsKDAsMCl9fWVsc2UgdGhpcy5yZWRpcmVjdChuKX0sc2V0Q29va2llOmZ1bmN0aW9uKGUsdCl7ZG9jdW1lbnQuY29va2llPVwiXCIuY29uY2F0KGUsXCI9XCIpLmNvbmNhdCh0KX0sZ2V0Q29va2llOmZ1bmN0aW9uKGUpe3JldHVybiBkb2N1bWVudC5jb29raWUucmVwbGFjZShuZXcgUmVnRXhwKFwiKD86KD86XnwuKjtzKilcIi5jb25jYXQoZSxcInMqPXMqKFteO10qKS4qJCl8Xi4qJFwiKSksXCIkMVwiKX0scmVkaXJlY3Q6ZnVuY3Rpb24oZSx0KXt0JiZjZS5zZXRDb29raWUoXCJfX3Bob2VuaXhfZmxhc2hfX1wiLHQrXCI7IG1heC1hZ2U9NjAwMDA7IHBhdGg9L1wiKSx3aW5kb3cubG9jYXRpb249ZX0sbG9jYWxLZXk6ZnVuY3Rpb24oZSx0KXtyZXR1cm5cIlwiLmNvbmNhdChlLFwiLVwiKS5jb25jYXQodCl9LGdldEhhc2hUYXJnZXRFbDpmdW5jdGlvbihlKXt2YXIgdD1lLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDEpO2lmKFwiXCIhPT10KXJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0KXx8ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYVtuYW1lPVwiJy5jb25jYXQodCwnXCJdJykpfX0sbGU9e2J5SWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGUpfHx6KFwibm8gaWQgZm91bmQgZm9yIFwiLmNvbmNhdChlKSl9LHJlbW92ZUNsYXNzOmZ1bmN0aW9uKGUsdCl7ZS5jbGFzc0xpc3QucmVtb3ZlKHQpLDA9PT1lLmNsYXNzTGlzdC5sZW5ndGgmJmUucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIil9LGFsbDpmdW5jdGlvbihlLHQsbil7dmFyIGk9QXJyYXkuZnJvbShlLnF1ZXJ5U2VsZWN0b3JBbGwodCkpO3JldHVybiBuP2kuZm9yRWFjaChuKTppfSxjaGlsZE5vZGVMZW5ndGg6ZnVuY3Rpb24oZSl7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO3JldHVybiB0LmlubmVySFRNTD1lLHQuY29udGVudC5jaGlsZEVsZW1lbnRDb3VudH0saXNVcGxvYWRJbnB1dDpmdW5jdGlvbihlKXtyZXR1cm5cImZpbGVcIj09PWUudHlwZSYmbnVsbCE9PWUuZ2V0QXR0cmlidXRlKE0pfSxmaW5kVXBsb2FkSW5wdXRzOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmFsbChlLCdpbnB1dFt0eXBlPVwiZmlsZVwiXVsnLmNvbmNhdChNLFwiXVwiKSl9LGZpbmRDb21wb25lbnROb2RlTGlzdDpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChlLFwiW1wiLmNvbmNhdChILCc9XCInKS5jb25jYXQodCwnXCJdJykpLGUpfSxpc1BoeERlc3Ryb3llZDpmdW5jdGlvbihlKXtyZXR1cm4hKCFlLmlkfHwhbGUucHJpdmF0ZShlLFwiZGVzdHJveWVkXCIpKX0sbWFya1BoeENoaWxkRGVzdHJveWVkOmZ1bmN0aW9uKGUpe2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1waHgtc2Vzc2lvblwiLFwiXCIpLHRoaXMucHV0UHJpdmF0ZShlLFwiZGVzdHJveWVkXCIsITApfSxmaW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50OmZ1bmN0aW9uKGUsdCl7dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO3JldHVybiBuLmlubmVySFRNTD1lLHRoaXMuZmluZFBoeENoaWxkcmVuKG4uY29udGVudCx0KX0saXNJZ25vcmVkOmZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJpZ25vcmVcIj09PShlLmdldEF0dHJpYnV0ZSh0KXx8ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC11cGRhdGVcIikpfSxpc1BoeFVwZGF0ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZuLmluZGV4T2YoZS5nZXRBdHRyaWJ1dGUodCkpPj0wfSxmaW5kUGh4Q2hpbGRyZW46ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hbGwoZSxcIlwiLmNvbmNhdChVLFwiW1wiKS5jb25jYXQoXCJkYXRhLXBoeC1wYXJlbnQtaWRcIiwnPVwiJykuY29uY2F0KHQsJ1wiXScpKX0sZmluZFBhcmVudENJRHM6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLGk9bmV3IFNldCh0KTtyZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24odCxpKXt2YXIgcj1cIltcIi5jb25jYXQoSCwnPVwiJykuY29uY2F0KGksJ1wiXSBbJykuY29uY2F0KEgsXCJdXCIpO3JldHVybiBuLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyhuLmFsbChlLHIpLGUpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZS5nZXRBdHRyaWJ1dGUoSCkpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5kZWxldGUoZSl9KSx0fSxpKX0sZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3OmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdC5xdWVyeVNlbGVjdG9yKFUpP2UuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBuLndpdGhpblNhbWVMaXZlVmlldyhlLHQpfSk6ZX0sd2l0aGluU2FtZUxpdmVWaWV3OmZ1bmN0aW9uKGUsdCl7Zm9yKDtlPWUucGFyZW50Tm9kZTspe2lmKGUuaXNTYW1lTm9kZSh0KSlyZXR1cm4hMDtpZihlLmdldEF0dHJpYnV0ZShPKSlyZXR1cm4hMX19LHByaXZhdGU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5waHhQcml2YXRlJiZlLnBoeFByaXZhdGVbdF19LGRlbGV0ZVByaXZhdGU6ZnVuY3Rpb24oZSx0KXtlLnBoeFByaXZhdGUmJmRlbGV0ZSBlLnBoeFByaXZhdGVbdF19LHB1dFByaXZhdGU6ZnVuY3Rpb24oZSx0LG4pe2UucGh4UHJpdmF0ZXx8KGUucGh4UHJpdmF0ZT17fSksZS5waHhQcml2YXRlW3RdPW59LGNvcHlQcml2YXRlczpmdW5jdGlvbihlLHQpe3QucGh4UHJpdmF0ZSYmKGUucGh4UHJpdmF0ZT0kKHQucGh4UHJpdmF0ZSkpfSxwdXRUaXRsZTpmdW5jdGlvbihlKXt2YXIgdD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGl0bGVcIikuZGF0YXNldCxuPXQucHJlZml4LGk9dC5zdWZmaXg7ZG9jdW1lbnQudGl0bGU9XCJcIi5jb25jYXQobnx8XCJcIikuY29uY2F0KGUpLmNvbmNhdChpfHxcIlwiKX0sZGVib3VuY2U6ZnVuY3Rpb24oZSx0LG4saSxyLG8sYSl7dmFyIHU9dGhpcyxzPWUuZ2V0QXR0cmlidXRlKG4pLGM9ZS5nZXRBdHRyaWJ1dGUocik7XCJcIj09PXMmJihzPWkpLFwiXCI9PT1jJiYoYz1vKTt2YXIgbD1zfHxjO3N3aXRjaChsKXtjYXNlIG51bGw6cmV0dXJuIGEoKTtjYXNlXCJibHVyXCI6cmV0dXJuIHZvaWQodGhpcy5vbmNlKGUsXCJkZWJvdW5jZS1ibHVyXCIpJiZlLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsZnVuY3Rpb24oKXtyZXR1cm4gYSgpfSkpO2RlZmF1bHQ6dmFyIGQ9cGFyc2VJbnQobCksaD10aGlzLmluY0N5Y2xlKGUsXCJkZWJvdW5jZS10cmlnZ2VyXCIsZnVuY3Rpb24oKXtyZXR1cm4gYz91LmRlbGV0ZVByaXZhdGUoZSxcInRocm90dGxlZFwiKTphKCl9KTtpZihpc05hTihkKSlyZXR1cm4geihcImludmFsaWQgdGhyb3R0bGUvZGVib3VuY2UgdmFsdWU6IFwiLmNvbmNhdChsKSk7aWYoYyl7dmFyIGY9ITE7aWYoXCJrZXlkb3duXCI9PT10LnR5cGUpe3ZhciB2PXRoaXMucHJpdmF0ZShlLFwiZGVib3VuY2UtcHJldi1rZXlcIik7dGhpcy5wdXRQcml2YXRlKGUsXCJkZWJvdW5jZS1wcmV2LWtleVwiLHQua2V5KSxmPXYhPT10LmtleX1pZighZiYmdGhpcy5wcml2YXRlKGUsXCJ0aHJvdHRsZWRcIikpcmV0dXJuITE7YSgpLHRoaXMucHV0UHJpdmF0ZShlLFwidGhyb3R0bGVkXCIsITApLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gdS50cmlnZ2VyQ3ljbGUoZSxcImRlYm91bmNlLXRyaWdnZXJcIil9LGQpfWVsc2Ugc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiB1LnRyaWdnZXJDeWNsZShlLFwiZGVib3VuY2UtdHJpZ2dlclwiLGgpfSxkKTtlLmZvcm0mJnRoaXMub25jZShlLmZvcm0sXCJiaW5kLWRlYm91bmNlXCIpJiZlLmZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLGZ1bmN0aW9uKHQpe0FycmF5LmZyb20obmV3IEZvcm1EYXRhKGUuZm9ybSkuZW50cmllcygpLGZ1bmN0aW9uKHQpe3ZhciBuPXgodCwyKSxpPW5bMF0scj0oblsxXSxlLmZvcm0ucXVlcnlTZWxlY3RvcignW25hbWU9XCInLmNvbmNhdChpLCdcIl0nKSkpO3UuaW5jQ3ljbGUocixcImRlYm91bmNlLXRyaWdnZXJcIiksdS5kZWxldGVQcml2YXRlKHIsXCJ0aHJvdHRsZWRcIil9KX0pLHRoaXMub25jZShlLFwiYmluZC1kZWJvdW5jZVwiKSYmZS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLGZ1bmN0aW9uKHQpe3JldHVybiB1LnRyaWdnZXJDeWNsZShlLFwiZGVib3VuY2UtdHJpZ2dlclwiKX0pfX0sdHJpZ2dlckN5Y2xlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT14KHRoaXMucHJpdmF0ZShlLHQpLDIpLHI9aVswXSxvPWlbMV07bnx8KG49ciksbj09PXImJih0aGlzLmluY0N5Y2xlKGUsdCksbygpKX0sb25jZTpmdW5jdGlvbihlLHQpe3JldHVybiEwIT09dGhpcy5wcml2YXRlKGUsdCkmJih0aGlzLnB1dFByaXZhdGUoZSx0LCEwKSwhMCl9LGluY0N5Y2xlOmZ1bmN0aW9uKGUsdCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOmZ1bmN0aW9uKCl7fSxpPXgodGhpcy5wcml2YXRlKGUsdCl8fFswLG5dLDIpLHI9aVswXTtpWzFdO3JldHVybiByKyssdGhpcy5wdXRQcml2YXRlKGUsdCxbcixuXSkscn0sZGlzY2FyZEVycm9yOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10LmdldEF0dHJpYnV0ZSYmdC5nZXRBdHRyaWJ1dGUobikscj1pJiZlLnF1ZXJ5U2VsZWN0b3IoJ1tpZD1cIicuY29uY2F0KGksJ1wiXSwgW25hbWU9XCInKS5jb25jYXQoaSwnXCJdJykpO3ImJih0aGlzLnByaXZhdGUocixcInBoeC1oYXMtZm9jdXNlZFwiKXx8dGhpcy5wcml2YXRlKHIuZm9ybSxcInBoeC1oYXMtc3VibWl0dGVkXCIpfHx0LmNsYXNzTGlzdC5hZGQoXCJwaHgtbm8tZmVlZGJhY2tcIikpfSxzaG93RXJyb3I6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzOyhlLmlkfHxlLm5hbWUpJiZ0aGlzLmFsbChlLmZvcm0sXCJbXCIuY29uY2F0KHQsJz1cIicpLmNvbmNhdChlLmlkLCdcIl0sIFsnKS5jb25jYXQodCwnPVwiJykuY29uY2F0KGUubmFtZSwnXCJdJyksZnVuY3Rpb24oZSl7bi5yZW1vdmVDbGFzcyhlLFwicGh4LW5vLWZlZWRiYWNrXCIpfSl9LGlzUGh4Q2hpbGQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZlLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXBhcmVudC1pZFwiKX0sZGlzcGF0Y2hFdmVudDpmdW5jdGlvbihlLHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fSxpPW5ldyBDdXN0b21FdmVudCh0LHtidWJibGVzOiEwLGNhbmNlbGFibGU6ITAsZGV0YWlsOm59KTtlLmRpc3BhdGNoRXZlbnQoaSl9LGNsb25lTm9kZTpmdW5jdGlvbihlLHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIGUuY2xvbmVOb2RlKCEwKTt2YXIgbj1lLmNsb25lTm9kZSghMSk7cmV0dXJuIG4uaW5uZXJIVE1MPXQsbn0sbWVyZ2VBdHRyczpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30saT1uLmV4Y2x1ZGV8fFtdLHI9bi5pc0lnbm9yZWQsbz10LmF0dHJpYnV0ZXMsYT1vLmxlbmd0aC0xO2E+PTA7YS0tKXt2YXIgdT1vW2FdLm5hbWU7aS5pbmRleE9mKHUpPDAmJmUuc2V0QXR0cmlidXRlKHUsdC5nZXRBdHRyaWJ1dGUodSkpfWZvcih2YXIgcz1lLmF0dHJpYnV0ZXMsYz1zLmxlbmd0aC0xO2M+PTA7Yy0tKXt2YXIgbD1zW2NdLm5hbWU7cj9sLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSYmIXQuaGFzQXR0cmlidXRlKGwpJiZlLnJlbW92ZUF0dHJpYnV0ZShsKTp0Lmhhc0F0dHJpYnV0ZShsKXx8ZS5yZW1vdmVBdHRyaWJ1dGUobCl9fSxtZXJnZUZvY3VzZWRJbnB1dDpmdW5jdGlvbihlLHQpe2UgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudHx8bGUubWVyZ2VBdHRycyhlLHQse2V4Y2VwdDpbXCJ2YWx1ZVwiXX0pLHQucmVhZE9ubHk/ZS5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCEwKTplLnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpfSxoYXNTZWxlY3Rpb25SYW5nZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5zZXRTZWxlY3Rpb25SYW5nZSYmKFwidGV4dFwiPT09ZS50eXBlfHxcInRleHRhcmVhXCI9PT1lLnR5cGUpfSxyZXN0b3JlRm9jdXM6ZnVuY3Rpb24oZSx0LG4pe2lmKGxlLmlzVGV4dHVhbElucHV0KGUpKXt2YXIgaT1lLm1hdGNoZXMoXCI6Zm9jdXNcIik7ZS5yZWFkT25seSYmZS5ibHVyKCksaXx8ZS5mb2N1cygpLHRoaXMuaGFzU2VsZWN0aW9uUmFuZ2UoZSkmJmUuc2V0U2VsZWN0aW9uUmFuZ2UodCxuKX19LGlzRm9ybUlucHV0OmZ1bmN0aW9uKGUpe3JldHVybi9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KGUudGFnTmFtZSkmJlwiYnV0dG9uXCIhPT1lLnR5cGV9LHN5bmNBdHRyc1RvUHJvcHM6ZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQmJkouaW5kZXhPZihlLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSk+PTAmJihlLmNoZWNrZWQ9bnVsbCE9PWUuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSl9LGlzVGV4dHVhbElucHV0OmZ1bmN0aW9uKGUpe3JldHVybiBCLmluZGV4T2YoZS50eXBlKT49MH0saXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlJiZudWxsIT09ZS5nZXRBdHRyaWJ1dGUodCl9LHN5bmNQZW5kaW5nUmVmOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT1lLmdldEF0dHJpYnV0ZShGKTtyZXR1cm4gbnVsbD09PWl8fChsZS5pc0Zvcm1JbnB1dChlKXx8bnVsbCE9PWUuZ2V0QXR0cmlidXRlKG4pPyhsZS5pc1VwbG9hZElucHV0KGUpJiZsZS5tZXJnZUF0dHJzKGUsdCx7aXNJZ25vcmVkOiEwfSksbGUucHV0UHJpdmF0ZShlLEYsdCksITEpOihqLmZvckVhY2goZnVuY3Rpb24obil7ZS5jbGFzc0xpc3QuY29udGFpbnMobikmJnQuY2xhc3NMaXN0LmFkZChuKX0pLHQuc2V0QXR0cmlidXRlKEYsaSksITApKX0sY2xlYW5DaGlsZE5vZGVzOmZ1bmN0aW9uKGUsdCl7aWYobGUuaXNQaHhVcGRhdGUoZSx0LFtcImFwcGVuZFwiLFwicHJlcGVuZFwiXSkpe3ZhciBuPVtdO2UuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuaWR8fChlLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUmJlwiXCI9PT1lLm5vZGVWYWx1ZS50cmltKCl8fHooXCJvbmx5IEhUTUwgZWxlbWVudCB0YWdzIHdpdGggYW4gaWQgYXJlIGFsbG93ZWQgaW5zaWRlIGNvbnRhaW5lcnMgd2l0aCBwaHgtdXBkYXRlLlxcblxcblwiKydyZW1vdmluZyBpbGxlZ2FsIG5vZGU6IFwiJy5jb25jYXQoKGUub3V0ZXJIVE1MfHxlLm5vZGVWYWx1ZSkudHJpbSgpLCdcIlxcblxcbicpKSxuLnB1c2goZSkpfSksbi5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlbW92ZSgpfSl9fX0sZGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixpKXtUKHRoaXMsZSk7dmFyIHI9bmV3IFNldCxvPW5ldyBTZXQoQShuLmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaWR9KSksYT1bXTtBcnJheS5mcm9tKHQuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoZS5pZCYmKHIuYWRkKGUuaWQpLG8uaGFzKGUuaWQpKSl7dmFyIHQ9ZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nJiZlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQ7YS5wdXNoKHtlbGVtZW50SWQ6ZS5pZCxwcmV2aW91c0VsZW1lbnRJZDp0fSl9fSksdGhpcy5jb250YWluZXJJZD1uLmlkLHRoaXMudXBkYXRlVHlwZT1pLHRoaXMuZWxlbWVudHNUb01vZGlmeT1hLHRoaXMuZWxlbWVudElkc1RvQWRkPUEobykuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiFyLmhhcyhlKX0pfXJldHVybiBfKGUsW3trZXk6XCJwZXJmb3JtXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1sZS5ieUlkKHRoaXMuY29udGFpbmVySWQpO3RoaXMuZWxlbWVudHNUb01vZGlmeS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QucHJldmlvdXNFbGVtZW50SWQ/Wihkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0LnByZXZpb3VzRWxlbWVudElkKSxmdW5jdGlvbihlKXtaKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQuZWxlbWVudElkKSxmdW5jdGlvbih0KXt0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcmJnQucHJldmlvdXNFbGVtZW50U2libGluZy5pZD09ZS5pZHx8ZS5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmVuZFwiLHQpfSl9KTpaKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQuZWxlbWVudElkKSxmdW5jdGlvbih0KXtudWxsPT10LnByZXZpb3VzRWxlbWVudFNpYmxpbmd8fGUuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLHQpfSl9KSxcInByZXBlbmRcIj09dGhpcy51cGRhdGVUeXBlJiZ0aGlzLmVsZW1lbnRJZHNUb0FkZC5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbih0KXtaKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQpLGZ1bmN0aW9uKHQpe3JldHVybiBlLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIix0KX0pfSl9fV0pLGV9KCksaGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixpLHIsbyl7VCh0aGlzLGUpLHRoaXMudmlldz10LHRoaXMubGl2ZVNvY2tldD10LmxpdmVTb2NrZXQsdGhpcy5jb250YWluZXI9bix0aGlzLmlkPWksdGhpcy5yb290SUQ9dC5yb290LmlkLHRoaXMuaHRtbD1yLHRoaXMudGFyZ2V0Q0lEPW8sdGhpcy5jaWRQYXRjaD1cIm51bWJlclwiPT10eXBlb2YgdGhpcy50YXJnZXRDSUQsdGhpcy5jYWxsYmFja3M9e2JlZm9yZWFkZGVkOltdLGJlZm9yZXVwZGF0ZWQ6W10sYmVmb3JlcGh4Q2hpbGRBZGRlZDpbXSxhZnRlcmFkZGVkOltdLGFmdGVydXBkYXRlZDpbXSxhZnRlcmRpc2NhcmRlZDpbXSxhZnRlcnBoeENoaWxkQWRkZWQ6W119fXJldHVybiBfKGUsbnVsbCxbe2tleTpcInBhdGNoRWxcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7YihlLHQse2NoaWxkcmVuT25seTohMSxvbkJlZm9yZUVsVXBkYXRlZDpmdW5jdGlvbihlLHQpe2lmKG4mJm4uaXNTYW1lTm9kZShlKSYmbGUuaXNGb3JtSW5wdXQoZSkpcmV0dXJuIGxlLm1lcmdlRm9jdXNlZElucHV0KGUsdCksITF9fSl9fV0pLF8oZSxbe2tleTpcImJlZm9yZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5jYWxsYmFja3NbXCJiZWZvcmVcIi5jb25jYXQoZSldLnB1c2godCl9fSx7a2V5OlwiYWZ0ZXJcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuY2FsbGJhY2tzW1wiYWZ0ZXJcIi5jb25jYXQoZSldLnB1c2godCl9fSx7a2V5OlwidHJhY2tCZWZvcmVcIix2YWx1ZTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxuPW5ldyBBcnJheSh0PjE/dC0xOjApLGk9MTtpPHQ7aSsrKW5baS0xXT1hcmd1bWVudHNbaV07dGhpcy5jYWxsYmFja3NbXCJiZWZvcmVcIi5jb25jYXQoZSldLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIGUuYXBwbHkodm9pZCAwLG4pfSl9fSx7a2V5OlwidHJhY2tBZnRlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLG49bmV3IEFycmF5KHQ+MT90LTE6MCksaT0xO2k8dDtpKyspbltpLTFdPWFyZ3VtZW50c1tpXTt0aGlzLmNhbGxiYWNrc1tcImFmdGVyXCIuY29uY2F0KGUpXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmFwcGx5KHZvaWQgMCxuKX0pfX0se2tleTpcIm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsXCIsdmFsdWU6ZnVuY3Rpb24oKXtsZS5hbGwodGhpcy5jb250YWluZXIsXCJbcGh4LXVwZGF0ZT1hcHBlbmRdID4gKiwgW3BoeC11cGRhdGU9cHJlcGVuZF0gPiAqXCIsZnVuY3Rpb24oZSl7ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yZW1vdmVcIixcIlwiKX0pfX0se2tleTpcInBlcmZvcm1cIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzLnZpZXcsbj10aGlzLmxpdmVTb2NrZXQsaT10aGlzLmNvbnRhaW5lcixyPXRoaXMuaHRtbCxvPXRoaXMuaXNDSURQYXRjaCgpP3RoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKHIpOmk7aWYoIXRoaXMuaXNDSURQYXRjaCgpfHxvKXt2YXIgYT1uLmdldEFjdGl2ZUVsZW1lbnQoKSx1PWEmJmxlLmhhc1NlbGVjdGlvblJhbmdlKGEpP2E6e30scz11LnNlbGVjdGlvblN0YXJ0LGM9dS5zZWxlY3Rpb25FbmQsbD1uLmJpbmRpbmcoXCJ1cGRhdGVcIiksZD1uLmJpbmRpbmcoXCJmZWVkYmFjay1mb3JcIiksaD1uLmJpbmRpbmcoXCJkaXNhYmxlLXdpdGhcIiksZj1uLmJpbmRpbmcoXCJ0cmlnZ2VyLWFjdGlvblwiKSx2PVtdLHA9W10sZz1bXSxtPW51bGwseT1uLnRpbWUoXCJwcmVtb3JwaCBjb250YWluZXIgcHJlcFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGUuYnVpbGREaWZmSFRNTChpLHIsbCxvKX0pO3JldHVybiB0aGlzLnRyYWNrQmVmb3JlKFwiYWRkZWRcIixpKSx0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLGksaSksbi50aW1lKFwibW9ycGhkb21cIixmdW5jdGlvbigpe2Iobyx5LHtjaGlsZHJlbk9ubHk6bnVsbD09PW8uZ2V0QXR0cmlidXRlKEgpLGdldE5vZGVLZXk6ZnVuY3Rpb24oZSl7cmV0dXJuIGxlLmlzUGh4RGVzdHJveWVkKGUpP251bGw6ZS5pZH0sb25CZWZvcmVOb2RlQWRkZWQ6ZnVuY3Rpb24odCl7cmV0dXJuIGxlLmRpc2NhcmRFcnJvcihvLHQsZCksZS50cmFja0JlZm9yZShcImFkZGVkXCIsdCksdH0sb25Ob2RlQWRkZWQ6ZnVuY3Rpb24obil7bGUuaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKG4sZikmJihtPW4pLGxlLmlzUGh4Q2hpbGQobikmJnQub3duc0VsZW1lbnQobikmJmUudHJhY2tBZnRlcihcInBoeENoaWxkQWRkZWRcIixuKSx2LnB1c2gobil9LG9uTm9kZURpc2NhcmRlZDpmdW5jdGlvbih0KXtsZS5pc1BoeENoaWxkKHQpJiZuLmRlc3Ryb3lWaWV3QnlFbCh0KSxlLnRyYWNrQWZ0ZXIoXCJkaXNjYXJkZWRcIix0KX0sb25CZWZvcmVOb2RlRGlzY2FyZGVkOmZ1bmN0aW9uKHQpe3JldHVybiEoIXQuZ2V0QXR0cmlidXRlfHxudWxsPT09dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yZW1vdmVcIikpfHwobnVsbD09PXQucGFyZW50Tm9kZXx8IWxlLmlzUGh4VXBkYXRlKHQucGFyZW50Tm9kZSxsLFtcImFwcGVuZFwiLFwicHJlcGVuZFwiXSl8fCF0LmlkKSYmIWUuc2tpcENJRFNpYmxpbmcodCl9LG9uRWxVcGRhdGVkOmZ1bmN0aW9uKGUpe2xlLmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlLGYpJiYobT1lKSxwLnB1c2goZSl9LG9uQmVmb3JlRWxVcGRhdGVkOmZ1bmN0aW9uKHQsbil7aWYobGUuY2xlYW5DaGlsZE5vZGVzKG4sbCksZS5za2lwQ0lEU2libGluZyhuKSlyZXR1cm4hMTtpZihsZS5pc0lnbm9yZWQodCxsKSlyZXR1cm4gZS50cmFja0JlZm9yZShcInVwZGF0ZWRcIix0LG4pLGxlLm1lcmdlQXR0cnModCxuLHtpc0lnbm9yZWQ6ITB9KSxwLnB1c2godCksITE7aWYoXCJudW1iZXJcIj09PXQudHlwZSYmdC52YWxpZGl0eSYmdC52YWxpZGl0eS5iYWRJbnB1dClyZXR1cm4hMTtpZighbGUuc3luY1BlbmRpbmdSZWYodCxuLGgpKXJldHVybiBsZS5pc1VwbG9hZElucHV0KHQpJiYoZS50cmFja0JlZm9yZShcInVwZGF0ZWRcIix0LG4pLHAucHVzaCh0KSksITE7aWYobGUuaXNQaHhDaGlsZChuKSl7dmFyIGk9dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1zZXNzaW9uXCIpO3JldHVybiBsZS5tZXJnZUF0dHJzKHQsbix7ZXhjbHVkZTpbXCJkYXRhLXBoeC1zdGF0aWNcIl19KSxcIlwiIT09aSYmdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1zZXNzaW9uXCIsaSksdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yb290LWlkXCIsZS5yb290SUQpLCExfXJldHVybiBsZS5jb3B5UHJpdmF0ZXMobix0KSxsZS5kaXNjYXJkRXJyb3IobyxuLGQpLGEmJnQuaXNTYW1lTm9kZShhKSYmbGUuaXNGb3JtSW5wdXQodCkmJiFlLmZvcmNlRm9jdXNlZFNlbGVjdFVwZGF0ZSh0LG4pPyhlLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLHQsbiksbGUubWVyZ2VGb2N1c2VkSW5wdXQodCxuKSxsZS5zeW5jQXR0cnNUb1Byb3BzKHQpLHAucHVzaCh0KSwhMSk6KGxlLmlzUGh4VXBkYXRlKG4sbCxbXCJhcHBlbmRcIixcInByZXBlbmRcIl0pJiZnLnB1c2gobmV3IGRlKHQsbixuLmdldEF0dHJpYnV0ZShsKSkpLGxlLnN5bmNBdHRyc1RvUHJvcHMobiksZS50cmFja0JlZm9yZShcInVwZGF0ZWRcIix0LG4pLCEwKX19KX0pLG4uaXNEZWJ1Z0VuYWJsZWQoKSYmZnVuY3Rpb24oKXtmb3IodmFyIGU9bmV3IFNldCx0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKSxuPTAsaT10Lmxlbmd0aDtuPGk7bisrKWUuaGFzKHRbbl0uaWQpP2NvbnNvbGUuZXJyb3IoXCJNdWx0aXBsZSBJRHMgZGV0ZWN0ZWQ6IFwiLmNvbmNhdCh0W25dLmlkLFwiLiBFbnN1cmUgdW5pcXVlIGVsZW1lbnQgaWRzLlwiKSk6ZS5hZGQodFtuXS5pZCl9KCksZy5sZW5ndGg+MCYmbi50aW1lKFwicG9zdC1tb3JwaCBhcHBlbmQvcHJlcGVuZCByZXN0b3JhdGlvblwiLGZ1bmN0aW9uKCl7Zy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnBlcmZvcm0oKX0pfSksbi5zaWxlbmNlRXZlbnRzKGZ1bmN0aW9uKCl7cmV0dXJuIGxlLnJlc3RvcmVGb2N1cyhhLHMsYyl9KSxsZS5kaXNwYXRjaEV2ZW50KGRvY3VtZW50LFwicGh4OnVwZGF0ZVwiKSx2LmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUudHJhY2tBZnRlcihcImFkZGVkXCIsdCl9KSxwLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIGUudHJhY2tBZnRlcihcInVwZGF0ZWRcIix0KX0pLG0mJihuLmRpc2Nvbm5lY3QoKSxtLnN1Ym1pdCgpKSwhMH19fSx7a2V5OlwiZm9yY2VGb2N1c2VkU2VsZWN0VXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1bXCJzZWxlY3RcIixcInNlbGVjdC1vbmVcIixcInNlbGVjdC1tdWx0aXBsZVwiXS5maW5kKGZ1bmN0aW9uKHQpe3JldHVybiB0PT09ZS50eXBlfSk7cmV0dXJuITA9PT1lLm11bHRpcGxlfHxuJiZlLmlubmVySFRNTCE9dC5pbm5lckhUTUx9fSx7a2V5OlwiaXNDSURQYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2lkUGF0Y2h9fSx7a2V5Olwic2tpcENJRFNpYmxpbmdcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZudWxsIT09ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1za2lwXCIpfX0se2tleTpcInRhcmdldENJRENvbnRhaW5lclwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKHRoaXMuaXNDSURQYXRjaCgpKXt2YXIgdD1rKGxlLmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmNvbnRhaW5lcix0aGlzLnRhcmdldENJRCkpLG49dFswXTtyZXR1cm4gMD09PXQuc2xpY2UoMSkubGVuZ3RoJiYxPT09bGUuY2hpbGROb2RlTGVuZ3RoKGUpP246biYmbi5wYXJlbnROb2RlfX19LHtrZXk6XCJidWlsZERpZmZIVE1MXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSl7dmFyIHI9dGhpcyxvPXRoaXMuaXNDSURQYXRjaCgpLGE9byYmaS5nZXRBdHRyaWJ1dGUoSCk9PT10aGlzLnRhcmdldENJRC50b1N0cmluZygpO2lmKCFvfHxhKXJldHVybiB0O3ZhciB1PW51bGwscz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7dT1sZS5jbG9uZU5vZGUoaSk7dmFyIGM9ayhsZS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodSx0aGlzLnRhcmdldENJRCkpLGw9Y1swXSxkPWMuc2xpY2UoMSk7cmV0dXJuIHMuaW5uZXJIVE1MPXQsZC5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBlLnJlbW92ZSgpfSksQXJyYXkuZnJvbSh1LmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5pZCYmZS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZlLmdldEF0dHJpYnV0ZShIKSE9PXIudGFyZ2V0Q0lELnRvU3RyaW5nKCkmJihlLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LXNraXBcIixcIlwiKSxlLmlubmVySFRNTD1cIlwiKX0pLEFycmF5LmZyb20ocy5jb250ZW50LmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHUuaW5zZXJ0QmVmb3JlKGUsbCl9KSxsLnJlbW92ZSgpLHUub3V0ZXJIVE1MfX1dKSxlfSgpLGZlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4saSxyLG8pe3ZhciBhPXRoaXM7VCh0aGlzLGUpLHRoaXMubGl2ZVNvY2tldD1uLHRoaXMuZmxhc2g9byx0aGlzLnBhcmVudD1pLHRoaXMucm9vdD1pP2kucm9vdDp0aGlzLHRoaXMuZWw9dCx0aGlzLmlkPXRoaXMuZWwuaWQsdGhpcy52aWV3PXRoaXMuZWwuZ2V0QXR0cmlidXRlKE8pLHRoaXMucmVmPTAsdGhpcy5jaGlsZEpvaW5zPTAsdGhpcy5sb2FkZXJUaW1lcj1udWxsLHRoaXMucGVuZGluZ0RpZmZzPVtdLHRoaXMucHJ1bmluZ0NJRHM9W10sdGhpcy5ocmVmPXIsdGhpcy5qb2luQ291bnQ9dGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQuam9pbkNvdW50LTE6MCx0aGlzLmpvaW5QZW5kaW5nPSEwLHRoaXMuZGVzdHJveWVkPSExLHRoaXMuam9pbkNhbGxiYWNrPWZ1bmN0aW9uKCl7fSx0aGlzLnN0b3BDYWxsYmFjaz1mdW5jdGlvbigpe30sdGhpcy5wZW5kaW5nSm9pbk9wcz10aGlzLnBhcmVudD9udWxsOltdLHRoaXMudmlld0hvb2tzPXt9LHRoaXMudXBsb2FkZXJzPXt9LHRoaXMuZm9ybVN1Ym1pdHM9W10sdGhpcy5jaGlsZHJlbj10aGlzLnBhcmVudD9udWxsOnt9LHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXT17fSx0aGlzLmNoYW5uZWw9dGhpcy5saXZlU29ja2V0LmNoYW5uZWwoXCJsdjpcIi5jb25jYXQodGhpcy5pZCksZnVuY3Rpb24oKXtyZXR1cm57dXJsOmEuaHJlZixwYXJhbXM6YS5jb25uZWN0UGFyYW1zKCksc2Vzc2lvbjphLmdldFNlc3Npb24oKSxzdGF0aWM6YS5nZXRTdGF0aWMoKSxmbGFzaDphLmZsYXNofX0pLHRoaXMuc2hvd0xvYWRlcih0aGlzLmxpdmVTb2NrZXQubG9hZGVyVGltZW91dCksdGhpcy5iaW5kQ2hhbm5lbCgpfXJldHVybiBfKGUsW3trZXk6XCJpc01haW5cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpdmVTb2NrZXQubWFpbj09PXRoaXN9fSx7a2V5OlwiY29ubmVjdFBhcmFtc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5saXZlU29ja2V0LnBhcmFtcyh0aGlzLnZpZXcpLHQ9bGUuYWxsKGRvY3VtZW50LFwiW1wiLmNvbmNhdCh0aGlzLmJpbmRpbmcoXCJ0cmFjay1zdGF0aWNcIiksXCJdXCIpKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3JjfHxlLmhyZWZ9KS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGV9KTtyZXR1cm4gdC5sZW5ndGg+MCYmKGUuX3RyYWNrX3N0YXRpYz10KSxlLl9tb3VudHM9dGhpcy5qb2luQ291bnQsZX19LHtrZXk6XCJuYW1lXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52aWV3fX0se2tleTpcImlzQ29ubmVjdGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGFubmVsLmNhblB1c2goKX19LHtrZXk6XCJnZXRTZXNzaW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1zZXNzaW9uXCIpfX0se2tleTpcImdldFN0YXRpY1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5lbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1zdGF0aWNcIik7cmV0dXJuXCJcIj09PWU/bnVsbDplfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06ZnVuY3Rpb24oKXt9O3RoaXMuZGVzdHJveUFsbENoaWxkcmVuKCksdGhpcy5kZXN0cm95ZWQ9ITAsZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSx0aGlzLnBhcmVudCYmZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLnBhcmVudC5pZF1bdGhpcy5pZF0sY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpO3ZhciBuPWZ1bmN0aW9uKCl7Zm9yKHZhciBuIGluIHQoKSxlLnZpZXdIb29rcyllLmRlc3Ryb3lIb29rKGUudmlld0hvb2tzW25dKX07bGUubWFya1BoeENoaWxkRGVzdHJveWVkKHRoaXMuZWwpLHRoaXMubG9nKFwiZGVzdHJveWVkXCIsZnVuY3Rpb24oKXtyZXR1cm5bXCJ0aGUgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnRcIl19KSx0aGlzLmNoYW5uZWwubGVhdmUoKS5yZWNlaXZlKFwib2tcIixuKS5yZWNlaXZlKFwiZXJyb3JcIixuKS5yZWNlaXZlKFwidGltZW91dFwiLG4pfX0se2tleTpcInNldENvbnRhaW5lckNsYXNzZXNcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlO3RoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcInBoeC1jb25uZWN0ZWRcIixcInBoeC1kaXNjb25uZWN0ZWRcIixcInBoeC1lcnJvclwiKSwoZT10aGlzLmVsLmNsYXNzTGlzdCkuYWRkLmFwcGx5KGUsYXJndW1lbnRzKX19LHtrZXk6XCJpc0xvYWRpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucyhcInBoeC1kaXNjb25uZWN0ZWRcIil9fSx7a2V5Olwic2hvd0xvYWRlclwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYoY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpLGUpdGhpcy5sb2FkZXJUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIHQuc2hvd0xvYWRlcigpfSxlKTtlbHNle2Zvcih2YXIgbiBpbiB0aGlzLnZpZXdIb29rcyl0aGlzLnZpZXdIb29rc1tuXS5fX2Rpc2Nvbm5lY3RlZCgpO3RoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhcInBoeC1kaXNjb25uZWN0ZWRcIil9fX0se2tleTpcImhpZGVMb2FkZXJcIix2YWx1ZTpmdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKSx0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoXCJwaHgtY29ubmVjdGVkXCIpfX0se2tleTpcInRyaWdnZXJSZWNvbm5lY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMudmlld0hvb2tzKXRoaXMudmlld0hvb2tzW2VdLl9fcmVjb25uZWN0ZWQoKX19LHtrZXk6XCJsb2dcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMubGl2ZVNvY2tldC5sb2codGhpcyxlLHQpfX0se2tleTpcIndpdGhpblRhcmdldHNcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7aWYoL14oMHxbMS05XVxcZCopJC8udGVzdChlKSl7dmFyIGk9bGUuZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsZSk7MD09PWkubGVuZ3RoP3ooXCJubyBjb21wb25lbnQgZm91bmQgbWF0Y2hpbmcgcGh4LXRhcmdldCBvZiBcIi5jb25jYXQoZSkpOnQodGhpcyxpWzBdKX1lbHNle3ZhciByPUFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKSk7MD09PXIubGVuZ3RoJiZ6KCdub3RoaW5nIGZvdW5kIG1hdGNoaW5nIHRoZSBwaHgtdGFyZ2V0IHNlbGVjdG9yIFwiJy5jb25jYXQoZSwnXCInKSksci5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiBuLmxpdmVTb2NrZXQub3duZXIoZSxmdW5jdGlvbihuKXtyZXR1cm4gdChuLGUpfSl9KX19fSx7a2V5OlwiYXBwbHlEaWZmXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3RoaXMubG9nKGUsZnVuY3Rpb24oKXtyZXR1cm5bXCJcIiwkKHQpXX0pO3ZhciBpPXVlLmV4dHJhY3QodCkscj1pLmRpZmYsbz1pLnJlcGx5LGE9aS5ldmVudHMsdT1pLnRpdGxlO3JldHVybiB1JiZsZS5wdXRUaXRsZSh1KSxuKHtkaWZmOnIscmVwbHk6byxldmVudHM6YX0pLG99fSx7a2V5Olwib25Kb2luXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPWUucmVuZGVyZWQ7dGhpcy5jaGlsZEpvaW5zPTAsdGhpcy5qb2luUGVuZGluZz0hMCx0aGlzLmZsYXNoPW51bGwsY2UuZHJvcExvY2FsKHRoaXMubmFtZSgpLFwiY29uc2VjdXRpdmUtcmVsb2Fkc1wiKSx0aGlzLmFwcGx5RGlmZihcIm1vdW50XCIsbixmdW5jdGlvbihuKXt2YXIgaT1uLmRpZmYscj1uLmV2ZW50czt0LnJlbmRlcmVkPW5ldyB1ZSh0LmlkLGkpO3ZhciBvPXQucmVuZGVyQ29udGFpbmVyKG51bGwsXCJqb2luXCIpO3QuZHJvcFBlbmRpbmdSZWZzKCk7dmFyIGE9dC5mb3Jtc0ZvclJlY292ZXJ5KG8pO3Quam9pbkNvdW50KyssYS5sZW5ndGg+MD9hLmZvckVhY2goZnVuY3Rpb24oZSxuKXt0LnB1c2hGb3JtUmVjb3ZlcnkoZSxmdW5jdGlvbihlKXtuPT09YS5sZW5ndGgtMSYmdC5vbkpvaW5Db21wbGV0ZShlLG8scil9KX0pOnQub25Kb2luQ29tcGxldGUoZSxvLHIpfSl9fSx7a2V5OlwiZHJvcFBlbmRpbmdSZWZzXCIsdmFsdWU6ZnVuY3Rpb24oKXtsZS5hbGwodGhpcy5lbCxcIltcIi5jb25jYXQoRixcIl1cIiksZnVuY3Rpb24oZSl7cmV0dXJuIGUucmVtb3ZlQXR0cmlidXRlKEYpfSl9fSx7a2V5Olwib25Kb2luQ29tcGxldGVcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpcyxyPWUubGl2ZV9wYXRjaDtpZih0aGlzLmpvaW5Db3VudD4xfHx0aGlzLnBhcmVudCYmIXRoaXMucGFyZW50LmlzSm9pblBlbmRpbmcoKSlyZXR1cm4gdGhpcy5hcHBseUpvaW5QYXRjaChyLHQsbik7MD09PWxlLmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQodCx0aGlzLmlkKS5maWx0ZXIoZnVuY3Rpb24oZSl7dmFyIHQ9ZS5pZCYmaS5lbC5xdWVyeVNlbGVjdG9yKFwiI1wiLmNvbmNhdChlLmlkKSksbj10JiZ0LmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXN0YXRpY1wiKTtyZXR1cm4gbiYmZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1zdGF0aWNcIixuKSxpLmpvaW5DaGlsZChlKX0pLmxlbmd0aD90aGlzLnBhcmVudD8odGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsZnVuY3Rpb24oKXtyZXR1cm4gaS5hcHBseUpvaW5QYXRjaChyLHQsbil9XSksdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKSk6KHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKSx0aGlzLmFwcGx5Sm9pblBhdGNoKHIsdCxuKSk6dGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsZnVuY3Rpb24oKXtyZXR1cm4gaS5hcHBseUpvaW5QYXRjaChyLHQsbil9XSl9fSx7a2V5OlwiYXR0YWNoVHJ1ZURvY0VsXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmVsPWxlLmJ5SWQodGhpcy5pZCksdGhpcy5lbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yb290LWlkXCIsdGhpcy5yb290LmlkKX19LHtrZXk6XCJkaXNwYXRjaEV2ZW50c1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2UuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD14KGUsMiksbj10WzBdLGk9dFsxXTt3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6aG9vazpcIi5jb25jYXQobikse2RldGFpbDppfSkpfSl9fSx7a2V5OlwiYXBwbHlKb2luUGF0Y2hcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7dmFyIGk9dGhpczt0aGlzLmF0dGFjaFRydWVEb2NFbCgpO3ZhciByPW5ldyBoZSh0aGlzLHRoaXMuZWwsdGhpcy5pZCx0LG51bGwpO2lmKHIubWFya1BydW5hYmxlQ29udGVudEZvclJlbW92YWwoKSx0aGlzLnBlcmZvcm1QYXRjaChyLCExKSx0aGlzLmpvaW5OZXdDaGlsZHJlbigpLGxlLmFsbCh0aGlzLmVsLFwiW1wiLmNvbmNhdCh0aGlzLmJpbmRpbmcoXCJob29rXCIpLFwiXSwgW2RhdGEtcGh4LVwiKS5jb25jYXQoXCJob29rXCIsXCJdXCIpLGZ1bmN0aW9uKGUpe3ZhciB0PWkuYWRkSG9vayhlKTt0JiZ0Ll9fbW91bnRlZCgpfSksdGhpcy5qb2luUGVuZGluZz0hMSx0aGlzLmRpc3BhdGNoRXZlbnRzKG4pLHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpLGUpe3ZhciBvPWUua2luZCxhPWUudG87dGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaChhLG8pfXRoaXMuaGlkZUxvYWRlcigpLHRoaXMuam9pbkNvdW50PjEmJnRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCksdGhpcy5zdG9wQ2FsbGJhY2soKX19LHtrZXk6XCJ0cmlnZ2VyQmVmb3JlVXBkYXRlSG9va1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dGhpcy5saXZlU29ja2V0LnRyaWdnZXJET00oXCJvbkJlZm9yZUVsVXBkYXRlZFwiLFtlLHRdKTt2YXIgbj10aGlzLmdldEhvb2soZSksaT1uJiZsZS5pc0lnbm9yZWQoZSx0aGlzLmJpbmRpbmcoXCJ1cGRhdGVcIikpO2lmKG4mJiFlLmlzRXF1YWxOb2RlKHQpJiYoIWl8fCFmdW5jdGlvbihlLHQpe3JldHVybiBKU09OLnN0cmluZ2lmeShlKT09PUpTT04uc3RyaW5naWZ5KHQpfShlLmRhdGFzZXQsdC5kYXRhc2V0KSkpcmV0dXJuIG4uX19iZWZvcmVVcGRhdGUoKSxufX0se2tleTpcInBlcmZvcm1QYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcyxpPVtdLHI9ITEsbz1uZXcgU2V0O3JldHVybiBlLmFmdGVyKFwiYWRkZWRcIixmdW5jdGlvbihlKXtuLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsW2VdKTt2YXIgdD1uLmFkZEhvb2soZSk7dCYmdC5fX21vdW50ZWQoKX0pLGUuYWZ0ZXIoXCJwaHhDaGlsZEFkZGVkXCIsZnVuY3Rpb24oZSl7cmV0dXJuIHI9ITB9KSxlLmJlZm9yZShcInVwZGF0ZWRcIixmdW5jdGlvbihlLHQpe24udHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZSx0KSYmby5hZGQoZS5pZCl9KSxlLmFmdGVyKFwidXBkYXRlZFwiLGZ1bmN0aW9uKGUpe28uaGFzKGUuaWQpJiZuLmdldEhvb2soZSkuX191cGRhdGVkKCl9KSxlLmFmdGVyKFwiZGlzY2FyZGVkXCIsZnVuY3Rpb24oZSl7dmFyIHQ9bi5jb21wb25lbnRJRChlKTtcIm51bWJlclwiPT10eXBlb2YgdCYmLTE9PT1pLmluZGV4T2YodCkmJmkucHVzaCh0KTt2YXIgcj1uLmdldEhvb2soZSk7ciYmbi5kZXN0cm95SG9vayhyKX0pLGUucGVyZm9ybSgpLHQmJnRoaXMubWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChpKSxyfX0se2tleTpcImpvaW5OZXdDaGlsZHJlblwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztsZS5maW5kUGh4Q2hpbGRyZW4odGhpcy5lbCx0aGlzLmlkKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiBlLmpvaW5DaGlsZCh0KX0pfX0se2tleTpcImdldENoaWxkQnlJZFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bZV19fSx7a2V5OlwiZ2V0RGVzY2VuZGVudEJ5RWxcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5pZD09PXRoaXMuaWQ/dGhpczp0aGlzLmNoaWxkcmVuW2UuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtcGFyZW50LWlkXCIpXVtlLmlkXX19LHtrZXk6XCJkZXN0cm95RGVzY2VuZGVudFwiLHZhbHVlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pZm9yKHZhciBuIGluIHRoaXMucm9vdC5jaGlsZHJlblt0XSlpZihuPT09ZSlyZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3RdW25dLmRlc3Ryb3koKX19LHtrZXk6XCJqb2luQ2hpbGRcIix2YWx1ZTpmdW5jdGlvbih0KXtpZighdGhpcy5nZXRDaGlsZEJ5SWQodC5pZCkpe3ZhciBuPW5ldyBlKHQsdGhpcy5saXZlU29ja2V0LHRoaXMpO3JldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1bbi5pZF09bixuLmpvaW4oKSx0aGlzLmNoaWxkSm9pbnMrKywhMH19fSx7a2V5OlwiaXNKb2luUGVuZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuam9pblBlbmRpbmd9fSx7a2V5OlwiYWNrSm9pblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuY2hpbGRKb2lucy0tLDA9PT10aGlzLmNoaWxkSm9pbnMmJih0aGlzLnBhcmVudD90aGlzLnBhcmVudC5hY2tKb2luKHRoaXMpOnRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKSl9fSx7a2V5Olwib25BbGxDaGlsZEpvaW5zQ29tcGxldGVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuam9pbkNhbGxiYWNrKCksdGhpcy5wZW5kaW5nSm9pbk9wcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXgoZSwyKSxuPXRbMF0saT10WzFdO24uaXNEZXN0cm95ZWQoKXx8aSgpfSksdGhpcy5wZW5kaW5nSm9pbk9wcz1bXX19LHtrZXk6XCJ1cGRhdGVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7aWYodGhpcy5pc0pvaW5QZW5kaW5nKCl8fHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpKXJldHVybiB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKHtkaWZmOmUsZXZlbnRzOnR9KTt0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihlKTt2YXIgaT0hMTt0aGlzLnJlbmRlcmVkLmlzQ29tcG9uZW50T25seURpZmYoZSk/dGhpcy5saXZlU29ja2V0LnRpbWUoXCJjb21wb25lbnQgcGF0Y2ggY29tcGxldGVcIixmdW5jdGlvbigpe2xlLmZpbmRQYXJlbnRDSURzKG4uZWwsbi5yZW5kZXJlZC5jb21wb25lbnRDSURzKGUpKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe24uY29tcG9uZW50UGF0Y2gobi5yZW5kZXJlZC5nZXRDb21wb25lbnQoZSx0KSx0KSYmKGk9ITApfSl9KTpRKGUpfHx0aGlzLmxpdmVTb2NrZXQudGltZShcImZ1bGwgcGF0Y2ggY29tcGxldGVcIixmdW5jdGlvbigpe3ZhciB0PW4ucmVuZGVyQ29udGFpbmVyKGUsXCJ1cGRhdGVcIikscj1uZXcgaGUobixuLmVsLG4uaWQsdCxudWxsKTtpPW4ucGVyZm9ybVBhdGNoKHIsITApfSksdGhpcy5kaXNwYXRjaEV2ZW50cyh0KSxpJiZ0aGlzLmpvaW5OZXdDaGlsZHJlbigpfX0se2tleTpcInJlbmRlckNvbnRhaW5lclwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztyZXR1cm4gdGhpcy5saXZlU29ja2V0LnRpbWUoXCJ0b1N0cmluZyBkaWZmIChcIi5jb25jYXQodCxcIilcIiksZnVuY3Rpb24oKXt2YXIgdD1uLmVsLnRhZ05hbWUsaT1lP24ucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhlKS5jb25jYXQobi5wcnVuaW5nQ0lEcyk6bnVsbCxyPW4ucmVuZGVyZWQudG9TdHJpbmcoaSk7cmV0dXJuXCI8XCIuY29uY2F0KHQsXCI+XCIpLmNvbmNhdChyLFwiPC9cIikuY29uY2F0KHQsXCI+XCIpfSl9fSx7a2V5OlwiY29tcG9uZW50UGF0Y2hcIix2YWx1ZTpmdW5jdGlvbihlLHQpe2lmKFEoZSkpcmV0dXJuITE7dmFyIG49dGhpcy5yZW5kZXJlZC5jb21wb25lbnRUb1N0cmluZyh0KSxpPW5ldyBoZSh0aGlzLHRoaXMuZWwsdGhpcy5pZCxuLHQpO3JldHVybiB0aGlzLnBlcmZvcm1QYXRjaChpLCEwKX19LHtrZXk6XCJnZXRIb29rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudmlld0hvb2tzW3BlLmVsZW1lbnRJRChlKV19fSx7a2V5OlwiYWRkSG9va1wiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKCFwZS5lbGVtZW50SUQoZSkmJmUuZ2V0QXR0cmlidXRlKXt2YXIgdD1lLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LVwiLmNvbmNhdChcImhvb2tcIikpfHxlLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJob29rXCIpKTtpZighdHx8dGhpcy5vd25zRWxlbWVudChlKSl7dmFyIG49dGhpcy5saXZlU29ja2V0LmdldEhvb2tDYWxsYmFja3ModCk7aWYobil7ZS5pZHx8eignbm8gRE9NIElEIGZvciBob29rIFwiJy5jb25jYXQodCwnXCIuIEhvb2tzIHJlcXVpcmUgYSB1bmlxdWUgSUQgb24gZWFjaCBlbGVtZW50LicpLGUpO3ZhciBpPW5ldyBwZSh0aGlzLGUsbik7cmV0dXJuIHRoaXMudmlld0hvb2tzW3BlLmVsZW1lbnRJRChpLmVsKV09aSxpfW51bGwhPT10JiZ6KCd1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJy5jb25jYXQodCwnXCInKSxlKX19fX0se2tleTpcImRlc3Ryb3lIb29rXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZS5fX2Rlc3Ryb3llZCgpLGUuX19jbGVhbnVwX18oKSxkZWxldGUgdGhpcy52aWV3SG9va3NbcGUuZWxlbWVudElEKGUuZWwpXX19LHtrZXk6XCJhcHBseVBlbmRpbmdVcGRhdGVzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goZnVuY3Rpb24odCl7dmFyIG49dC5kaWZmLGk9dC5ldmVudHM7cmV0dXJuIGUudXBkYXRlKG4saSl9KSx0aGlzLnBlbmRpbmdEaWZmcz1bXX19LHtrZXk6XCJvbkNoYW5uZWxcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXM7dGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsZSxmdW5jdGlvbihlKXtuLmlzSm9pblBlbmRpbmcoKT9uLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbbixmdW5jdGlvbigpe3JldHVybiB0KGUpfV0pOnQoZSl9KX19LHtrZXk6XCJiaW5kQ2hhbm5lbFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLmxpdmVTb2NrZXQub25DaGFubmVsKHRoaXMuY2hhbm5lbCxcImRpZmZcIixmdW5jdGlvbih0KXtlLmFwcGx5RGlmZihcInVwZGF0ZVwiLHQsZnVuY3Rpb24odCl7dmFyIG49dC5kaWZmLGk9dC5ldmVudHM7cmV0dXJuIGUudXBkYXRlKG4saSl9KX0pLHRoaXMub25DaGFubmVsKFwicmVkaXJlY3RcIixmdW5jdGlvbih0KXt2YXIgbj10LnRvLGk9dC5mbGFzaDtyZXR1cm4gZS5vblJlZGlyZWN0KHt0bzpuLGZsYXNoOml9KX0pLHRoaXMub25DaGFubmVsKFwibGl2ZV9wYXRjaFwiLGZ1bmN0aW9uKHQpe3JldHVybiBlLm9uTGl2ZVBhdGNoKHQpfSksdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsZnVuY3Rpb24odCl7cmV0dXJuIGUub25MaXZlUmVkaXJlY3QodCl9KSx0aGlzLmNoYW5uZWwub25FcnJvcihmdW5jdGlvbih0KXtyZXR1cm4gZS5vbkVycm9yKHQpfSksdGhpcy5jaGFubmVsLm9uQ2xvc2UoZnVuY3Rpb24odCl7cmV0dXJuIGUub25DbG9zZSh0KX0pfX0se2tleTpcImRlc3Ryb3lBbGxDaGlsZHJlblwiLHZhbHVlOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLmlkXSl0aGlzLmdldENoaWxkQnlJZChlKS5kZXN0cm95KCl9fSx7a2V5Olwib25MaXZlUmVkaXJlY3RcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLnRvLG49ZS5raW5kLGk9ZS5mbGFzaCxyPXRoaXMuZXhwYW5kVVJMKHQpO3RoaXMubGl2ZVNvY2tldC5oaXN0b3J5UmVkaXJlY3QocixuLGkpfX0se2tleTpcIm9uTGl2ZVBhdGNoXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50byxuPWUua2luZDt0aGlzLmhyZWY9dGhpcy5leHBhbmRVUkwodCksdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlQYXRjaCh0LG4pfX0se2tleTpcImV4cGFuZFVSTFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiBlLnN0YXJ0c1dpdGgoXCIvXCIpP1wiXCIuY29uY2F0KHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCxcIi8vXCIpLmNvbmNhdCh3aW5kb3cubG9jYXRpb24uaG9zdCkuY29uY2F0KGUpOmV9fSx7a2V5Olwib25SZWRpcmVjdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWUudG8sbj1lLmZsYXNoO3RoaXMubGl2ZVNvY2tldC5yZWRpcmVjdCh0LG4pfX0se2tleTpcImlzRGVzdHJveWVkXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZXN0cm95ZWR9fSx7a2V5Olwiam9pblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7dGhpcy5wYXJlbnR8fCh0aGlzLnN0b3BDYWxsYmFjaz10aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHt0bzp0aGlzLmhyZWYsa2luZDpcImluaXRpYWxcIn0pKSx0aGlzLmpvaW5DYWxsYmFjaz1mdW5jdGlvbigpe3JldHVybiBlJiZlKHQsdC5qb2luQ291bnQpfSx0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcyx7dGltZW91dDohMX0sZnVuY3Rpb24oKXtyZXR1cm4gdC5jaGFubmVsLmpvaW4oKS5yZWNlaXZlKFwib2tcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5vbkpvaW4oZSl9KS5yZWNlaXZlKFwiZXJyb3JcIixmdW5jdGlvbihlKXtyZXR1cm4gdC5vbkpvaW5FcnJvcihlKX0pLnJlY2VpdmUoXCJ0aW1lb3V0XCIsZnVuY3Rpb24oKXtyZXR1cm4gdC5vbkpvaW5FcnJvcih7cmVhc29uOlwidGltZW91dFwifSl9KX0pfX0se2tleTpcIm9uSm9pbkVycm9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuKGUucmVkaXJlY3R8fGUubGl2ZV9yZWRpcmVjdCkmJih0aGlzLmpvaW5QZW5kaW5nPSExLHRoaXMuY2hhbm5lbC5sZWF2ZSgpKSxlLnJlZGlyZWN0P3RoaXMub25SZWRpcmVjdChlLnJlZGlyZWN0KTplLmxpdmVfcmVkaXJlY3Q/dGhpcy5vbkxpdmVSZWRpcmVjdChlLmxpdmVfcmVkaXJlY3QpOih0aGlzLmxvZyhcImVycm9yXCIsZnVuY3Rpb24oKXtyZXR1cm5bXCJ1bmFibGUgdG8gam9pblwiLGVdfSksdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcykpfX0se2tleTpcIm9uQ2xvc2VcIix2YWx1ZTpmdW5jdGlvbihlKXtpZighdGhpcy5pc0Rlc3Ryb3llZCgpKXtpZih0aGlzLmlzSm9pblBlbmRpbmcoKXx8dGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkmJlwibGVhdmVcIiE9PWUpcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpO3RoaXMuZGVzdHJveUFsbENoaWxkcmVuKCksdGhpcy5saXZlU29ja2V0LmRyb3BBY3RpdmVFbGVtZW50KHRoaXMpLGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQmJmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpLHRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkmJnRoaXMuc2hvd0xvYWRlcigyMDApfX19LHtrZXk6XCJvbkVycm9yXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5vbkNsb3NlKGUpLHRoaXMubG9nKFwiZXJyb3JcIixmdW5jdGlvbigpe3JldHVybltcInZpZXcgY3Jhc2hlZFwiLGVdfSksdGhpcy5saXZlU29ja2V0LmlzVW5sb2FkZWQoKXx8dGhpcy5kaXNwbGF5RXJyb3IoKX19LHtrZXk6XCJkaXNwbGF5RXJyb3JcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaXNNYWluKCkmJmxlLmRpc3BhdGNoRXZlbnQod2luZG93LFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLHt0bzp0aGlzLmhyZWYsa2luZDpcImVycm9yXCJ9KSx0aGlzLnNob3dMb2FkZXIoKSx0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoXCJwaHgtZGlzY29ubmVjdGVkXCIsXCJwaHgtZXJyb3JcIil9fSx7a2V5OlwicHVzaFdpdGhSZXBseVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXt2YXIgaT10aGlzLHI9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOmZ1bmN0aW9uKCl7fSxvPXgoZT9lKCk6W251bGwsW11dLDIpLGE9b1swXSx1PXgob1sxXSwxKVswXSxzPWZ1bmN0aW9uKCl7fTtyZXR1cm4gdSYmbnVsbCE9PXUuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInBhZ2UtbG9hZGluZ1wiKSkmJihzPXRoaXMubGl2ZVNvY2tldC53aXRoUGFnZUxvYWRpbmcoe2tpbmQ6XCJlbGVtZW50XCIsdGFyZ2V0OnV9KSksXCJudW1iZXJcIiE9dHlwZW9mIG4uY2lkJiZkZWxldGUgbi5jaWQsdGhpcy5saXZlU29ja2V0LndyYXBQdXNoKHRoaXMse3RpbWVvdXQ6ITB9LGZ1bmN0aW9uKCl7cmV0dXJuIGkuY2hhbm5lbC5wdXNoKHQsbiwzZTQpLnJlY2VpdmUoXCJva1wiLGZ1bmN0aW9uKGUpe3ZhciB0PW51bGw7bnVsbCE9PWEmJmkudW5kb1JlZnMoYSksZS5kaWZmJiYodD1pLmFwcGx5RGlmZihcInVwZGF0ZVwiLGUuZGlmZixmdW5jdGlvbihlKXt2YXIgdD1lLmRpZmYsbj1lLmV2ZW50cztpLnVwZGF0ZSh0LG4pfSkpLGUucmVkaXJlY3QmJmkub25SZWRpcmVjdChlLnJlZGlyZWN0KSxlLmxpdmVfcGF0Y2gmJmkub25MaXZlUGF0Y2goZS5saXZlX3BhdGNoKSxlLmxpdmVfcmVkaXJlY3QmJmkub25MaXZlUmVkaXJlY3QoZS5saXZlX3JlZGlyZWN0KSxzKCkscihlLHQpfSl9KX19LHtrZXk6XCJ1bmRvUmVmc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7bGUuYWxsKHRoaXMuZWwsXCJbXCIuY29uY2F0KEYsJz1cIicpLmNvbmNhdChlLCdcIl0nKSxmdW5jdGlvbihlKXtlLnJlbW92ZUF0dHJpYnV0ZShGKSxudWxsIT09ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yZWFkb25seVwiKSYmKGUucmVhZE9ubHk9ITEsZS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXBoeC1yZWFkb25seVwiKSksbnVsbCE9PWUuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZGlzYWJsZWRcIikmJihlLmRpc2FibGVkPSExLGUucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1waHgtZGlzYWJsZWRcIikpLGouZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gbGUucmVtb3ZlQ2xhc3MoZSx0KX0pO3ZhciBuPWUuZ2V0QXR0cmlidXRlKFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIik7bnVsbCE9PW4mJihlLmlubmVyVGV4dD1uLGUucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIikpO3ZhciBpPWxlLnByaXZhdGUoZSxGKTtpZihpKXt2YXIgcj10LnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGUsaSk7aGUucGF0Y2hFbChlLGksdC5saXZlU29ja2V0LmdldEFjdGl2ZUVsZW1lbnQoKSksciYmci5fX3VwZGF0ZWQoKSxsZS5kZWxldGVQcml2YXRlKGUsRil9fSl9fSx7a2V5OlwicHV0UmVmXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLnJlZisrLGk9dGhpcy5iaW5kaW5nKFwiZGlzYWJsZS13aXRoXCIpO3JldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5jbGFzc0xpc3QuYWRkKFwicGh4LVwiLmNvbmNhdCh0LFwiLWxvYWRpbmdcIikpLGUuc2V0QXR0cmlidXRlKEYsbik7dmFyIHI9ZS5nZXRBdHRyaWJ1dGUoaSk7bnVsbCE9PXImJihlLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCIpfHxlLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCIsZS5pbm5lclRleHQpLGUuaW5uZXJUZXh0PXIpfSksW24sZV19fSx7a2V5OlwiY29tcG9uZW50SURcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lLmdldEF0dHJpYnV0ZSYmZS5nZXRBdHRyaWJ1dGUoSCk7cmV0dXJuIHQ/cGFyc2VJbnQodCk6bnVsbH19LHtrZXk6XCJ0YXJnZXRDb21wb25lbnRJRFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInRhcmdldFwiKSk/dGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodCk6bnVsbH19LHtrZXk6XCJjbG9zZXN0Q29tcG9uZW50SURcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiBlP1ooZS5jbG9zZXN0KFwiW1wiLmNvbmNhdChILFwiXVwiKSksZnVuY3Rpb24oZSl7cmV0dXJuIHQub3duc0VsZW1lbnQoZSkmJnQuY29tcG9uZW50SUQoZSl9KTpudWxsfX0se2tleTpcInB1c2hIb29rRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpKXtpZighdGhpcy5pc0Nvbm5lY3RlZCgpKXJldHVybiB0aGlzLmxvZyhcImhvb2tcIixmdW5jdGlvbigpe3JldHVybltcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIix0LG5dfSksITE7dmFyIHI9eCh0aGlzLnB1dFJlZihbXSxcImhvb2tcIiksMiksbz1yWzBdLGE9clsxXTtyZXR1cm4gdGhpcy5wdXNoV2l0aFJlcGx5KGZ1bmN0aW9uKCl7cmV0dXJuW28sYV19LFwiZXZlbnRcIix7dHlwZTpcImhvb2tcIixldmVudDp0LHZhbHVlOm4sY2lkOnRoaXMuY2xvc2VzdENvbXBvbmVudElEKGUpfSxmdW5jdGlvbihlLHQpe3JldHVybiBpKHQsbyl9KSxvfX0se2tleTpcImV4dHJhY3RNZXRhXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49dGhpcy5iaW5kaW5nKFwidmFsdWUtXCIpLGk9MDtpPGUuYXR0cmlidXRlcy5sZW5ndGg7aSsrKXt2YXIgcj1lLmF0dHJpYnV0ZXNbaV0ubmFtZTtyLnN0YXJ0c1dpdGgobikmJih0W3IucmVwbGFjZShuLFwiXCIpXT1lLmdldEF0dHJpYnV0ZShyKSl9cmV0dXJuIHZvaWQgMCE9PWUudmFsdWUmJih0LnZhbHVlPWUudmFsdWUsXCJJTlBVVFwiPT09ZS50YWdOYW1lJiZKLmluZGV4T2YoZS50eXBlKT49MCYmIWUuY2hlY2tlZCYmZGVsZXRlIHQudmFsdWUpLHR9fSx7a2V5OlwicHVzaEV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxyKXt2YXIgbz10aGlzO3RoaXMucHVzaFdpdGhSZXBseShmdW5jdGlvbigpe3JldHVybiBvLnB1dFJlZihbdF0sZSl9LFwiZXZlbnRcIix7dHlwZTplLGV2ZW50OmksdmFsdWU6dGhpcy5leHRyYWN0TWV0YSh0LHIpLGNpZDp0aGlzLnRhcmdldENvbXBvbmVudElEKHQsbil9KX19LHtrZXk6XCJwdXNoS2V5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxyKXt2YXIgbz10aGlzO3RoaXMucHVzaFdpdGhSZXBseShmdW5jdGlvbigpe3JldHVybiBvLnB1dFJlZihbZV0sbil9LFwiZXZlbnRcIix7dHlwZTpuLGV2ZW50OmksdmFsdWU6dGhpcy5leHRyYWN0TWV0YShlLHIpLGNpZDp0aGlzLnRhcmdldENvbXBvbmVudElEKGUsdCl9KX19LHtrZXk6XCJwdXNoRmlsZVByb2dyZXNzXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpmdW5jdGlvbigpe307dGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhlLmZvcm0sZnVuY3Rpb24ocixvKXtyLnB1c2hXaXRoUmVwbHkobnVsbCxcInByb2dyZXNzXCIse2V2ZW50OmUuZ2V0QXR0cmlidXRlKHIuYmluZGluZyhcInByb2dyZXNzXCIpKSxyZWY6ZS5nZXRBdHRyaWJ1dGUoTSksZW50cnlfcmVmOnQscHJvZ3Jlc3M6bixjaWQ6ci50YXJnZXRDb21wb25lbnRJRChlLmZvcm0sbyl9LGkpfSl9fSx7a2V5OlwicHVzaElucHV0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4saSxyKXt2YXIgbz10aGlzLGE9dGhpcy50YXJnZXRDb21wb25lbnRJRChlLmZvcm0sdCksdT1mdW5jdGlvbigpe3JldHVybiBvLnB1dFJlZihbZSxlLmZvcm1dLFwiY2hhbmdlXCIpfSxzPWFlKGUuZm9ybSx7X3RhcmdldDppLm5hbWV9KTtlLmZpbGVzJiZlLmZpbGVzLmxlbmd0aD4wJiZpZS50cmFja0ZpbGVzKGUsQXJyYXkuZnJvbShlLmZpbGVzKSk7dmFyIGM9e3R5cGU6XCJmb3JtXCIsZXZlbnQ6bix2YWx1ZTpzLHVwbG9hZHM6aWUuc2VyaWFsaXplVXBsb2FkcyhlKSxjaWQ6YX07dGhpcy5wdXNoV2l0aFJlcGx5KHUsXCJldmVudFwiLGMsZnVuY3Rpb24obil7aWYobGUuc2hvd0Vycm9yKGUsby5saXZlU29ja2V0LmJpbmRpbmcoXCJmZWVkYmFjay1mb3JcIikpLGxlLmlzVXBsb2FkSW5wdXQoZSkmJm51bGwhPT1lLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWF1dG8tdXBsb2FkXCIpKXtpZihpZS5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGUpLmxlbmd0aD4wKXt2YXIgaT14KHUoKSwyKSxzPWlbMF07aVsxXTtvLnVwbG9hZEZpbGVzKGUuZm9ybSx0LHMsYSxmdW5jdGlvbih0KXtyJiZyKG4pLG8udHJpZ2dlckF3YWl0aW5nU3VibWl0KGUuZm9ybSl9KX19ZWxzZSByJiZyKG4pfSl9fSx7a2V5OlwidHJpZ2dlckF3YWl0aW5nU3VibWl0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZSk7aWYodCl7dmFyIG49eCh0LDMpLGk9KG5bMF0sblsxXSxuWzJdKTt0aGlzLmNhbmNlbFN1Ym1pdChlKSxpKCl9fX0se2tleTpcImdldFNjaGVkdWxlZFN1Ym1pdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmZvcm1TdWJtaXRzLmZpbmQoZnVuY3Rpb24odCl7dmFyIG49eCh0LDIpLGk9blswXTtuWzFdO3JldHVybiBpLmlzU2FtZU5vZGUoZSl9KX19LHtrZXk6XCJzY2hlZHVsZVN1Ym1pdFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtpZih0aGlzLmdldFNjaGVkdWxlZFN1Ym1pdChlKSlyZXR1cm4hMDt0aGlzLmZvcm1TdWJtaXRzLnB1c2goW2UsdCxuXSl9fSx7a2V5OlwiY2FuY2VsU3VibWl0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpczt0aGlzLmZvcm1TdWJtaXRzPXRoaXMuZm9ybVN1Ym1pdHMuZmlsdGVyKGZ1bmN0aW9uKG4pe3ZhciBpPXgobiwzKSxyPWlbMF0sbz1pWzFdO2lbMl07cmV0dXJuIXIuaXNTYW1lTm9kZShlKXx8KHQudW5kb1JlZnMobyksITEpfSl9fSx7a2V5OlwicHVzaEZvcm1TdWJtaXRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbixpKXt2YXIgcj10aGlzLG89ZnVuY3Rpb24oZSl7cmV0dXJuIShHKGUsXCJcIi5jb25jYXQoci5iaW5kaW5nKFwidXBkYXRlXCIpLFwiPWlnbm9yZVwiKSxlLmZvcm0pfHxHKGUsXCJkYXRhLXBoeC11cGRhdGU9aWdub3JlXCIsZS5mb3JtKSl9LGE9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuaGFzQXR0cmlidXRlKHIuYmluZGluZyhcImRpc2FibGUtd2l0aFwiKSl9LHU9ZnVuY3Rpb24oZSl7cmV0dXJuXCJCVVRUT05cIj09ZS50YWdOYW1lfSxzPWZ1bmN0aW9uKGUpe3JldHVybltcIklOUFVUXCIsXCJURVhUQVJFQVwiLFwiU0VMRUNUXCJdLmluY2x1ZGVzKGUudGFnTmFtZSl9LGM9ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5mcm9tKGUuZWxlbWVudHMpLG49dC5maWx0ZXIoYSksaT10LmZpbHRlcih1KS5maWx0ZXIobyksYz10LmZpbHRlcihzKS5maWx0ZXIobyk7cmV0dXJuIGkuZm9yRWFjaChmdW5jdGlvbihlKXtlLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWRpc2FibGVkXCIsZS5kaXNhYmxlZCksZS5kaXNhYmxlZD0hMH0pLGMuZm9yRWFjaChmdW5jdGlvbihlKXtlLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LXJlYWRvbmx5XCIsZS5yZWFkT25seSksZS5yZWFkT25seT0hMCxlLmZpbGVzJiYoZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1kaXNhYmxlZFwiLGUuZGlzYWJsZWQpLGUuZGlzYWJsZWQ9ITApfSksZS5zZXRBdHRyaWJ1dGUoci5iaW5kaW5nKFwicGFnZS1sb2FkaW5nXCIpLFwiXCIpLHIucHV0UmVmKFtlXS5jb25jYXQobikuY29uY2F0KGkpLmNvbmNhdChjKSxcInN1Ym1pdFwiKX0sbD10aGlzLnRhcmdldENvbXBvbmVudElEKGUsdCk7aWYoaWUuaGFzVXBsb2Fkc0luUHJvZ3Jlc3MoZSkpe3ZhciBkPXgoYygpLDIpLGg9ZFswXTtkWzFdO3JldHVybiB0aGlzLnNjaGVkdWxlU3VibWl0KGUsaCxmdW5jdGlvbigpe3JldHVybiByLnB1c2hGb3JtU3VibWl0KGUsdCxuLGkpfSl9aWYoaWUuaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZSkubGVuZ3RoPjApe3ZhciBmPXgoYygpLDIpLHY9ZlswXSxwPWZbMV0sZz1mdW5jdGlvbigpe3JldHVyblt2LHBdfTt0aGlzLnVwbG9hZEZpbGVzKGUsdCx2LGwsZnVuY3Rpb24odCl7dmFyIG89YWUoZSx7fSk7ci5wdXNoV2l0aFJlcGx5KGcsXCJldmVudFwiLHt0eXBlOlwiZm9ybVwiLGV2ZW50Om4sdmFsdWU6byxjaWQ6bH0saSl9KX1lbHNle3ZhciBtPWFlKGUpO3RoaXMucHVzaFdpdGhSZXBseShjLFwiZXZlbnRcIix7dHlwZTpcImZvcm1cIixldmVudDpuLHZhbHVlOm0sY2lkOmx9LGkpfX19LHtrZXk6XCJ1cGxvYWRGaWxlc1wiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLGkscil7dmFyIG89dGhpcyxhPXRoaXMuam9pbkNvdW50O2llLmFjdGl2ZUZpbGVJbnB1dHMoZSkuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgaT1uZXcgaWUoZSxvLHIpO28udXBsb2FkZXJzW2VdPWk7dmFyIHU9aS5lbnRyaWVzKCkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBlLnRvUHJlZmxpZ2h0UGF5bG9hZCgpfSkscz17cmVmOmUuZ2V0QXR0cmlidXRlKE0pLGVudHJpZXM6dSxjaWQ6by50YXJnZXRDb21wb25lbnRJRChlLmZvcm0sdCl9O28ubG9nKFwidXBsb2FkXCIsZnVuY3Rpb24oKXtyZXR1cm5bXCJzZW5kaW5nIHByZWZsaWdodCByZXF1ZXN0XCIsc119KSxvLnB1c2hXaXRoUmVwbHkobnVsbCxcImFsbG93X3VwbG9hZFwiLHMsZnVuY3Rpb24oZSl7aWYoby5sb2coXCJ1cGxvYWRcIixmdW5jdGlvbigpe3JldHVybltcImdvdCBwcmVmbGlnaHQgcmVzcG9uc2VcIixlXX0pLGUuZXJyb3Ipe28udW5kb1JlZnMobik7dmFyIHQ9eChlLmVycm9yLDIpLHI9dFswXSx1PXRbMV07by5sb2coXCJ1cGxvYWRcIixmdW5jdGlvbigpe3JldHVybltcImVycm9yIGZvciBlbnRyeSBcIi5jb25jYXQociksdV19KX1lbHNle2kuaW5pdEFkYXB0ZXJVcGxvYWQoZSxmdW5jdGlvbihlKXtvLmNoYW5uZWwub25FcnJvcihmdW5jdGlvbigpe28uam9pbkNvdW50PT09YSYmZSgpfSl9LG8ubGl2ZVNvY2tldCl9fSl9KX19LHtrZXk6XCJwdXNoRm9ybVJlY292ZXJ5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3RoaXMubGl2ZVNvY2tldC53aXRoaW5Pd25lcnMoZSxmdW5jdGlvbihpLHIpe3ZhciBvPWUuZWxlbWVudHNbMF0sYT1lLmdldEF0dHJpYnV0ZShuLmJpbmRpbmcoXCJhdXRvLXJlY292ZXJcIikpfHxlLmdldEF0dHJpYnV0ZShuLmJpbmRpbmcoXCJjaGFuZ2VcIikpO2kucHVzaElucHV0KG8scixhLG8sdCl9KX19LHtrZXk6XCJwdXNoTGlua1BhdGNoXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXMscj10aGlzLmxpdmVTb2NrZXQuc2V0UGVuZGluZ0xpbmsoZSksbz10P2Z1bmN0aW9uKCl7cmV0dXJuIGkucHV0UmVmKFt0XSxcImNsaWNrXCIpfTpudWxsO3RoaXMucHVzaFdpdGhSZXBseShvLFwibGlua1wiLHt1cmw6ZX0sZnVuY3Rpb24odCl7dC5saW5rX3JlZGlyZWN0P2kubGl2ZVNvY2tldC5yZXBsYWNlTWFpbihlLG51bGwsbixyKTppLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsocikmJihpLmhyZWY9ZSxpLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKSxuJiZuKCkpfSkucmVjZWl2ZShcInRpbWVvdXRcIixmdW5jdGlvbigpe3JldHVybiBpLmxpdmVTb2NrZXQucmVkaXJlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpfSl9fSx7a2V5OlwiZm9ybXNGb3JSZWNvdmVyeVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7aWYoMD09PXRoaXMuam9pbkNvdW50KXJldHVybltdO3ZhciBuPXRoaXMuYmluZGluZyhcImNoYW5nZVwiKSxpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtyZXR1cm4gaS5pbm5lckhUTUw9ZSxsZS5hbGwodGhpcy5lbCxcImZvcm1bXCIuY29uY2F0KG4sXCJdXCIpKS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHQub3duc0VsZW1lbnQoZSl9KS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZWxlbWVudHMubGVuZ3RoPjB9KS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuXCJpZ25vcmVcIiE9PWUuZ2V0QXR0cmlidXRlKHQuYmluZGluZyhcImF1dG8tcmVjb3ZlclwiKSl9KS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGkuY29udGVudC5xdWVyeVNlbGVjdG9yKFwiZm9ybVtcIi5jb25jYXQobiwnPVwiJykuY29uY2F0KGUuZ2V0QXR0cmlidXRlKG4pLCdcIl0nKSl9KX19LHtrZXk6XCJtYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQsbj10aGlzLGk9ZS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIDA9PT1sZS5maW5kQ29tcG9uZW50Tm9kZUxpc3Qobi5lbCxlKS5sZW5ndGh9KTtpLmxlbmd0aD4wJiYoKHQ9dGhpcy5wcnVuaW5nQ0lEcykucHVzaC5hcHBseSh0LEEoaSkpLHRoaXMucHVzaFdpdGhSZXBseShudWxsLFwiY2lkc193aWxsX2Rlc3Ryb3lcIix7Y2lkczppfSxmdW5jdGlvbigpe24ucHJ1bmluZ0NJRHM9bi5wcnVuaW5nQ0lEcy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuLTEhPT1pLmluZGV4T2YoZSl9KTt2YXIgZT1pLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gMD09PWxlLmZpbmRDb21wb25lbnROb2RlTGlzdChuLmVsLGUpLmxlbmd0aH0pO2UubGVuZ3RoPjAmJm4ucHVzaFdpdGhSZXBseShudWxsLFwiY2lkc19kZXN0cm95ZWRcIix7Y2lkczplfSxmdW5jdGlvbihlKXtuLnJlbmRlcmVkLnBydW5lQ0lEcyhlLmNpZHMpfSl9KSl9fSx7a2V5Olwib3duc0VsZW1lbnRcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1wYXJlbnQtaWRcIik9PT10aGlzLmlkfHxaKGUuY2xvc2VzdChVKSxmdW5jdGlvbihlKXtyZXR1cm4gZS5pZH0pPT09dGhpcy5pZH19LHtrZXk6XCJzdWJtaXRGb3JtXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3ZhciBpPXRoaXM7bGUucHV0UHJpdmF0ZShlLFwicGh4LWhhcy1zdWJtaXR0ZWRcIiwhMCksdGhpcy5saXZlU29ja2V0LmJsdXJBY3RpdmVFbGVtZW50KHRoaXMpLHRoaXMucHVzaEZvcm1TdWJtaXQoZSx0LG4sZnVuY3Rpb24oKXtpLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpfSl9fSx7a2V5OlwiYmluZGluZ1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmxpdmVTb2NrZXQuYmluZGluZyhlKX19XSksZX0oKSx2ZT0xLHBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4saSl7Zm9yKHZhciByIGluIFQodGhpcyxlKSx0aGlzLl9fdmlldz10LHRoaXMuX19saXZlU29ja2V0PXQubGl2ZVNvY2tldCx0aGlzLl9fY2FsbGJhY2tzPWksdGhpcy5fX2xpc3RlbmVycz1uZXcgU2V0LHRoaXMuX19pc0Rpc2Nvbm5lY3RlZD0hMSx0aGlzLmVsPW4sdGhpcy52aWV3TmFtZT10Lm5hbWUoKSx0aGlzLmVsLnBoeEhvb2tJZD10aGlzLmNvbnN0cnVjdG9yLm1ha2VJRCgpLHRoaXMuX19jYWxsYmFja3MpdGhpc1tyXT10aGlzLl9fY2FsbGJhY2tzW3JdfXJldHVybiBfKGUsbnVsbCxbe2tleTpcIm1ha2VJRFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHZlKyt9fSx7a2V5OlwiZWxlbWVudElEXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUucGh4SG9va0lkfX1dKSxfKGUsW3trZXk6XCJfX21vdW50ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMubW91bnRlZCYmdGhpcy5tb3VudGVkKCl9fSx7a2V5OlwiX191cGRhdGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZWQmJnRoaXMudXBkYXRlZCgpfX0se2tleTpcIl9fYmVmb3JlVXBkYXRlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmJlZm9yZVVwZGF0ZSYmdGhpcy5iZWZvcmVVcGRhdGUoKX19LHtrZXk6XCJfX2Rlc3Ryb3llZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5kZXN0cm95ZWQmJnRoaXMuZGVzdHJveWVkKCl9fSx7a2V5OlwiX19yZWNvbm5lY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fX2lzRGlzY29ubmVjdGVkJiYodGhpcy5fX2lzRGlzY29ubmVjdGVkPSExLHRoaXMucmVjb25uZWN0ZWQmJnRoaXMucmVjb25uZWN0ZWQoKSl9fSx7a2V5OlwiX19kaXNjb25uZWN0ZWRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX19pc0Rpc2Nvbm5lY3RlZD0hMCx0aGlzLmRpc2Nvbm5lY3RlZCYmdGhpcy5kaXNjb25uZWN0ZWQoKX19LHtrZXk6XCJwdXNoRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06ZnVuY3Rpb24oKXt9O3JldHVybiB0aGlzLl9fdmlldy5wdXNoSG9va0V2ZW50KG51bGwsZSx0LG4pfX0se2tleTpcInB1c2hFdmVudFRvXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30saT1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106ZnVuY3Rpb24oKXt9O3JldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKGUsZnVuY3Rpb24oZSxyKXtyZXR1cm4gZS5wdXNoSG9va0V2ZW50KHIsdCxuLGkpfSl9fSx7a2V5OlwiaGFuZGxlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuPWZ1bmN0aW9uKG4saSl7cmV0dXJuIGk/ZTp0KG4uZGV0YWlsKX07cmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4Omhvb2s6XCIuY29uY2F0KGUpLG4pLHRoaXMuX19saXN0ZW5lcnMuYWRkKG4pLG59fSx7a2V5OlwicmVtb3ZlSGFuZGxlRXZlbnRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1lKG51bGwsITApO3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGh4Omhvb2s6XCIuY29uY2F0KHQpLGUpLHRoaXMuX19saXN0ZW5lcnMuZGVsZXRlKGUpfX0se2tleTpcIl9fY2xlYW51cF9fXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuX19saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbih0KXtyZXR1cm4gZS5yZW1vdmVIYW5kbGVFdmVudCh0KX0pfX1dKSxlfSgpO3QuZGVmYXVsdD1zZX0sZnVuY3Rpb24oZSx0KXt2YXIgbjtuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e249bnx8RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfHwoMCxldmFsKShcInRoaXNcIil9Y2F0Y2goZSl7XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmKG49d2luZG93KX1lLmV4cG9ydHM9bn0sZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbih0KXt0LlBob2VuaXh8fCh0LlBob2VuaXg9e30pLGUuZXhwb3J0cz10LlBob2VuaXguTGl2ZVZpZXc9bigwKX0pLmNhbGwodGhpcyxuKDEpKX1dKX0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../../deps/phoenix_live_view/priv/static/phoenix_live_view.js\n");

/***/ }),

/***/ "./css/app.scss":
/*!**********************!*\
  !*** ./css/app.scss ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jc3MvYXBwLnNjc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvYXBwLnNjc3M/NDY2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./css/app.scss\n");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.scss */ \"./css/app.scss\");\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! alpinejs */ \"./node_modules/alpinejs/dist/alpine.js\");\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(alpinejs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! phoenix_html */ \"../../../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! phoenix */ \"../../../deps/phoenix/priv/static/phoenix.js\");\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(phoenix__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nprogress */ \"./node_modules/nprogress/nprogress.js\");\n/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(nprogress__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! phoenix_live_view */ \"../../../deps/phoenix_live_view/priv/static/phoenix_live_view.js\");\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(phoenix_live_view__WEBPACK_IMPORTED_MODULE_5__);\n// We need to import the CSS so that webpack will load it.\n// The MiniCssExtractPlugin is used to separate it out into\n// its own CSS file.\n\n // webpack automatically bundles all modules in your\n// entry points. Those entry points can be configured\n// in \"webpack.config.js\".\n//\n// Import deps with the dep name or local files with a relative path, for example:\n//\n//     import {Socket} from \"phoenix\"\n//     import socket from \"./socket\"\n//\n\n\n\n\n\nvar csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\");\nvar liveSocket = new phoenix_live_view__WEBPACK_IMPORTED_MODULE_5__[\"LiveSocket\"](\"/live\", phoenix__WEBPACK_IMPORTED_MODULE_3__[\"Socket\"], {\n  params: {\n    _csrf_token: csrfToken\n  }\n}); // Show progress bar on live navigation and form submits\n\nwindow.addEventListener(\"phx:page-loading-start\", function (info) {\n  return nprogress__WEBPACK_IMPORTED_MODULE_4___default.a.start();\n});\nwindow.addEventListener(\"phx:page-loading-stop\", function (info) {\n  return nprogress__WEBPACK_IMPORTED_MODULE_4___default.a.done();\n}); // connect if there are any LiveViews on the page\n\nliveSocket.connect(); // expose liveSocket on window for web console debug logs and latency simulation:\n// >> liveSocket.enableDebug()\n// >> liveSocket.enableLatencySim(1000)  // enabled for duration of browser session\n// >> liveSocket.disableLatencySim()\n\nwindow.liveSocket = liveSocket;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9hcHAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hcHAuanM/NzQ3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSBuZWVkIHRvIGltcG9ydCB0aGUgQ1NTIHNvIHRoYXQgd2VicGFjayB3aWxsIGxvYWQgaXQuXG4vLyBUaGUgTWluaUNzc0V4dHJhY3RQbHVnaW4gaXMgdXNlZCB0byBzZXBhcmF0ZSBpdCBvdXQgaW50b1xuLy8gaXRzIG93biBDU1MgZmlsZS5cbmltcG9ydCBcIi4uL2Nzcy9hcHAuc2Nzc1wiXG5pbXBvcnQgXCJhbHBpbmVqc1wiXG5cbi8vIHdlYnBhY2sgYXV0b21hdGljYWxseSBidW5kbGVzIGFsbCBtb2R1bGVzIGluIHlvdXJcbi8vIGVudHJ5IHBvaW50cy4gVGhvc2UgZW50cnkgcG9pbnRzIGNhbiBiZSBjb25maWd1cmVkXG4vLyBpbiBcIndlYnBhY2suY29uZmlnLmpzXCIuXG4vL1xuLy8gSW1wb3J0IGRlcHMgd2l0aCB0aGUgZGVwIG5hbWUgb3IgbG9jYWwgZmlsZXMgd2l0aCBhIHJlbGF0aXZlIHBhdGgsIGZvciBleGFtcGxlOlxuLy9cbi8vICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuLy8gICAgIGltcG9ydCBzb2NrZXQgZnJvbSBcIi4vc29ja2V0XCJcbi8vXG5pbXBvcnQgXCJwaG9lbml4X2h0bWxcIlxuaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbmltcG9ydCBOUHJvZ3Jlc3MgZnJvbSBcIm5wcm9ncmVzc1wiXG5pbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG5cbmxldCBjc3JmVG9rZW4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWV0YVtuYW1lPSdjc3JmLXRva2VuJ11cIikuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKVxubGV0IGxpdmVTb2NrZXQgPSBuZXcgTGl2ZVNvY2tldChcIi9saXZlXCIsIFNvY2tldCwge3BhcmFtczoge19jc3JmX3Rva2VuOiBjc3JmVG9rZW59fSlcblxuLy8gU2hvdyBwcm9ncmVzcyBiYXIgb24gbGl2ZSBuYXZpZ2F0aW9uIGFuZCBmb3JtIHN1Ym1pdHNcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCBpbmZvID0+IE5Qcm9ncmVzcy5zdGFydCgpKVxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgaW5mbyA9PiBOUHJvZ3Jlc3MuZG9uZSgpKVxuXG4vLyBjb25uZWN0IGlmIHRoZXJlIGFyZSBhbnkgTGl2ZVZpZXdzIG9uIHRoZSBwYWdlXG5saXZlU29ja2V0LmNvbm5lY3QoKVxuXG4vLyBleHBvc2UgbGl2ZVNvY2tldCBvbiB3aW5kb3cgZm9yIHdlYiBjb25zb2xlIGRlYnVnIGxvZ3MgYW5kIGxhdGVuY3kgc2ltdWxhdGlvbjpcbi8vID4+IGxpdmVTb2NrZXQuZW5hYmxlRGVidWcoKVxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVMYXRlbmN5U2ltKDEwMDApICAvLyBlbmFibGVkIGZvciBkdXJhdGlvbiBvZiBicm93c2VyIHNlc3Npb25cbi8vID4+IGxpdmVTb2NrZXQuZGlzYWJsZUxhdGVuY3lTaW0oKVxud2luZG93LmxpdmVTb2NrZXQgPSBsaXZlU29ja2V0XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/app.js\n");

/***/ }),

/***/ "./node_modules/alpinejs/dist/alpine.js":
/*!**********************************************!*\
  !*** ./node_modules/alpinejs/dist/alpine.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, (function () { 'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  // Thanks @stimulus:\n  // https://github.com/stimulusjs/stimulus/blob/master/packages/%40stimulus/core/src/application.ts\n  function domReady() {\n    return new Promise(resolve => {\n      if (document.readyState == \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n  function arrayUnique(array) {\n    return Array.from(new Set(array));\n  }\n  function isTesting() {\n    return navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\");\n  }\n  function checkedAttrLooseCompare(valueA, valueB) {\n    return valueA == valueB;\n  }\n  function warnIfMalformedTemplate(el, directive) {\n    if (el.tagName.toLowerCase() !== 'template') {\n      console.warn(`Alpine: [${directive}] directive should only be added to <template> tags. See https://github.com/alpinejs/alpine#${directive}`);\n    } else if (el.content.childElementCount !== 1) {\n      console.warn(`Alpine: <template> tag with [${directive}] encountered with multiple element roots. Make sure <template> only has a single child element.`);\n    }\n  }\n  function kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\\s]/, '-').toLowerCase();\n  }\n  function camelCase(subject) {\n    return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n  }\n  function walk(el, callback) {\n    if (callback(el) === false) return;\n    let node = el.firstElementChild;\n\n    while (node) {\n      walk(node, callback);\n      node = node.nextElementSibling;\n    }\n  }\n  function debounce(func, wait) {\n    var timeout;\n    return function () {\n      var context = this,\n          args = arguments;\n\n      var later = function later() {\n        timeout = null;\n        func.apply(context, args);\n      };\n\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  }\n\n  const handleError = (el, expression, error) => {\n    console.warn(`Alpine Error: \"${error}\"\\n\\nExpression: \"${expression}\"\\nElement:`, el);\n\n    if (!isTesting()) {\n      throw error;\n    }\n  };\n\n  function tryCatch(cb, {\n    el,\n    expression\n  }) {\n    try {\n      const value = cb();\n      return value instanceof Promise ? value.catch(e => handleError(el, expression, e)) : value;\n    } catch (e) {\n      handleError(el, expression, e);\n    }\n  }\n\n  function saferEval(el, expression, dataContext, additionalHelperVariables = {}) {\n    return tryCatch(() => {\n      if (typeof expression === 'function') {\n        return expression.call(dataContext);\n      }\n\n      return new Function(['$data', ...Object.keys(additionalHelperVariables)], `var __alpine_result; with($data) { __alpine_result = ${expression} }; return __alpine_result`)(dataContext, ...Object.values(additionalHelperVariables));\n    }, {\n      el,\n      expression\n    });\n  }\n  function saferEvalNoReturn(el, expression, dataContext, additionalHelperVariables = {}) {\n    return tryCatch(() => {\n      if (typeof expression === 'function') {\n        return Promise.resolve(expression.call(dataContext, additionalHelperVariables['$event']));\n      }\n\n      let AsyncFunction = Function;\n      /* MODERN-ONLY:START */\n\n      AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\n      /* MODERN-ONLY:END */\n      // For the cases when users pass only a function reference to the caller: `x-on:click=\"foo\"`\n      // Where \"foo\" is a function. Also, we'll pass the function the event instance when we call it.\n\n      if (Object.keys(dataContext).includes(expression)) {\n        let methodReference = new Function(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { return ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables));\n\n        if (typeof methodReference === 'function') {\n          return Promise.resolve(methodReference.call(dataContext, additionalHelperVariables['$event']));\n        } else {\n          return Promise.resolve();\n        }\n      }\n\n      return Promise.resolve(new AsyncFunction(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables)));\n    }, {\n      el,\n      expression\n    });\n  }\n  const xAttrRE = /^x-(on|bind|data|text|html|model|if|for|show|cloak|transition|ref|spread)\\b/;\n  function isXAttr(attr) {\n    const name = replaceAtAndColonWithStandardSyntax(attr.name);\n    return xAttrRE.test(name);\n  }\n  function getXAttrs(el, component, type) {\n    let directives = Array.from(el.attributes).filter(isXAttr).map(parseHtmlAttribute); // Get an object of directives from x-spread.\n\n    let spreadDirective = directives.filter(directive => directive.type === 'spread')[0];\n\n    if (spreadDirective) {\n      let spreadObject = saferEval(el, spreadDirective.expression, component.$data); // Add x-spread directives to the pile of existing directives.\n\n      directives = directives.concat(Object.entries(spreadObject).map(([name, value]) => parseHtmlAttribute({\n        name,\n        value\n      })));\n    }\n\n    if (type) return directives.filter(i => i.type === type);\n    return sortDirectives(directives);\n  }\n\n  function sortDirectives(directives) {\n    let directiveOrder = ['bind', 'model', 'show', 'catch-all'];\n    return directives.sort((a, b) => {\n      let typeA = directiveOrder.indexOf(a.type) === -1 ? 'catch-all' : a.type;\n      let typeB = directiveOrder.indexOf(b.type) === -1 ? 'catch-all' : b.type;\n      return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n    });\n  }\n\n  function parseHtmlAttribute({\n    name,\n    value\n  }) {\n    const normalizedName = replaceAtAndColonWithStandardSyntax(name);\n    const typeMatch = normalizedName.match(xAttrRE);\n    const valueMatch = normalizedName.match(/:([a-zA-Z0-9\\-:]+)/);\n    const modifiers = normalizedName.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map(i => i.replace('.', '')),\n      expression: value\n    };\n  }\n  function isBooleanAttr(attrName) {\n    // As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute\n    // Array roughly ordered by estimated usage\n    const booleanAttributes = ['disabled', 'checked', 'required', 'readonly', 'hidden', 'open', 'selected', 'autofocus', 'itemscope', 'multiple', 'novalidate', 'allowfullscreen', 'allowpaymentrequest', 'formnovalidate', 'autoplay', 'controls', 'loop', 'muted', 'playsinline', 'default', 'ismap', 'reversed', 'async', 'defer', 'nomodule'];\n    return booleanAttributes.includes(attrName);\n  }\n  function replaceAtAndColonWithStandardSyntax(name) {\n    if (name.startsWith('@')) {\n      return name.replace('@', 'x-on:');\n    } else if (name.startsWith(':')) {\n      return name.replace(':', 'x-bind:');\n    }\n\n    return name;\n  }\n  function convertClassStringToArray(classList, filterFn = Boolean) {\n    return classList.split(' ').filter(filterFn);\n  }\n  const TRANSITION_TYPE_IN = 'in';\n  const TRANSITION_TYPE_OUT = 'out';\n  const TRANSITION_CANCELLED = 'cancelled';\n  function transitionIn(el, show, reject, component, forceSkip = false) {\n    // We don't want to transition on the initial page load.\n    if (forceSkip) return show();\n\n    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_IN) {\n      // there is already a similar transition going on, this was probably triggered by\n      // a change in a different property, let's just leave the previous one doing its job\n      return;\n    }\n\n    const attrs = getXAttrs(el, component, 'transition');\n    const showAttr = getXAttrs(el, component, 'show')[0]; // If this is triggered by a x-show.transition.\n\n    if (showAttr && showAttr.modifiers.includes('transition')) {\n      let modifiers = showAttr.modifiers; // If x-show.transition.out, we'll skip the \"in\" transition.\n\n      if (modifiers.includes('out') && !modifiers.includes('in')) return show();\n      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out'); // If x-show.transition.in...out... only use \"in\" related modifiers for this transition.\n\n      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index < modifiers.indexOf('out')) : modifiers;\n      transitionHelperIn(el, modifiers, show, reject); // Otherwise, we can assume x-transition:enter.\n    } else if (attrs.some(attr => ['enter', 'enter-start', 'enter-end'].includes(attr.value))) {\n      transitionClassesIn(el, component, attrs, show, reject);\n    } else {\n      // If neither, just show that damn thing.\n      show();\n    }\n  }\n  function transitionOut(el, hide, reject, component, forceSkip = false) {\n    // We don't want to transition on the initial page load.\n    if (forceSkip) return hide();\n\n    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_OUT) {\n      // there is already a similar transition going on, this was probably triggered by\n      // a change in a different property, let's just leave the previous one doing its job\n      return;\n    }\n\n    const attrs = getXAttrs(el, component, 'transition');\n    const showAttr = getXAttrs(el, component, 'show')[0];\n\n    if (showAttr && showAttr.modifiers.includes('transition')) {\n      let modifiers = showAttr.modifiers;\n      if (modifiers.includes('in') && !modifiers.includes('out')) return hide();\n      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out');\n      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index > modifiers.indexOf('out')) : modifiers;\n      transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hide, reject);\n    } else if (attrs.some(attr => ['leave', 'leave-start', 'leave-end'].includes(attr.value))) {\n      transitionClassesOut(el, component, attrs, hide, reject);\n    } else {\n      hide();\n    }\n  }\n  function transitionHelperIn(el, modifiers, showCallback, reject) {\n    // Default values inspired by: https://material.io/design/motion/speed.html#duration\n    const styleValues = {\n      duration: modifierValue(modifiers, 'duration', 150),\n      origin: modifierValue(modifiers, 'origin', 'center'),\n      first: {\n        opacity: 0,\n        scale: modifierValue(modifiers, 'scale', 95)\n      },\n      second: {\n        opacity: 1,\n        scale: 100\n      }\n    };\n    transitionHelper(el, modifiers, showCallback, () => {}, reject, styleValues, TRANSITION_TYPE_IN);\n  }\n  function transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hideCallback, reject) {\n    // Make the \"out\" transition .5x slower than the \"in\". (Visually better)\n    // HOWEVER, if they explicitly set a duration for the \"out\" transition,\n    // use that.\n    const duration = settingBothSidesOfTransition ? modifierValue(modifiers, 'duration', 150) : modifierValue(modifiers, 'duration', 150) / 2;\n    const styleValues = {\n      duration: duration,\n      origin: modifierValue(modifiers, 'origin', 'center'),\n      first: {\n        opacity: 1,\n        scale: 100\n      },\n      second: {\n        opacity: 0,\n        scale: modifierValue(modifiers, 'scale', 95)\n      }\n    };\n    transitionHelper(el, modifiers, () => {}, hideCallback, reject, styleValues, TRANSITION_TYPE_OUT);\n  }\n\n  function modifierValue(modifiers, key, fallback) {\n    // If the modifier isn't present, use the default.\n    if (modifiers.indexOf(key) === -1) return fallback; // If it IS present, grab the value after it: x-show.transition.duration.500ms\n\n    const rawValue = modifiers[modifiers.indexOf(key) + 1];\n    if (!rawValue) return fallback;\n\n    if (key === 'scale') {\n      // Check if the very next value is NOT a number and return the fallback.\n      // If x-show.transition.scale, we'll use the default scale value.\n      // That is how a user opts out of the opacity transition.\n      if (!isNumeric(rawValue)) return fallback;\n    }\n\n    if (key === 'duration') {\n      // Support x-show.transition.duration.500ms && duration.500\n      let match = rawValue.match(/([0-9]+)ms/);\n      if (match) return match[1];\n    }\n\n    if (key === 'origin') {\n      // Support chaining origin directions: x-show.transition.top.right\n      if (['top', 'right', 'left', 'center', 'bottom'].includes(modifiers[modifiers.indexOf(key) + 2])) {\n        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(' ');\n      }\n    }\n\n    return rawValue;\n  }\n\n  function transitionHelper(el, modifiers, hook1, hook2, reject, styleValues, type) {\n    // clear the previous transition if exists to avoid caching the wrong styles\n    if (el.__x_transition) {\n      el.__x_transition.cancel && el.__x_transition.cancel();\n    } // If the user set these style values, we'll put them back when we're done with them.\n\n\n    const opacityCache = el.style.opacity;\n    const transformCache = el.style.transform;\n    const transformOriginCache = el.style.transformOrigin; // If no modifiers are present: x-show.transition, we'll default to both opacity and scale.\n\n    const noModifiers = !modifiers.includes('opacity') && !modifiers.includes('scale');\n    const transitionOpacity = noModifiers || modifiers.includes('opacity');\n    const transitionScale = noModifiers || modifiers.includes('scale'); // These are the explicit stages of a transition (same stages for in and for out).\n    // This way you can get a birds eye view of the hooks, and the differences\n    // between them.\n\n    const stages = {\n      start() {\n        if (transitionOpacity) el.style.opacity = styleValues.first.opacity;\n        if (transitionScale) el.style.transform = `scale(${styleValues.first.scale / 100})`;\n      },\n\n      during() {\n        if (transitionScale) el.style.transformOrigin = styleValues.origin;\n        el.style.transitionProperty = [transitionOpacity ? `opacity` : ``, transitionScale ? `transform` : ``].join(' ').trim();\n        el.style.transitionDuration = `${styleValues.duration / 1000}s`;\n        el.style.transitionTimingFunction = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n      },\n\n      show() {\n        hook1();\n      },\n\n      end() {\n        if (transitionOpacity) el.style.opacity = styleValues.second.opacity;\n        if (transitionScale) el.style.transform = `scale(${styleValues.second.scale / 100})`;\n      },\n\n      hide() {\n        hook2();\n      },\n\n      cleanup() {\n        if (transitionOpacity) el.style.opacity = opacityCache;\n        if (transitionScale) el.style.transform = transformCache;\n        if (transitionScale) el.style.transformOrigin = transformOriginCache;\n        el.style.transitionProperty = null;\n        el.style.transitionDuration = null;\n        el.style.transitionTimingFunction = null;\n      }\n\n    };\n    transition(el, stages, type, reject);\n  }\n\n  const ensureStringExpression = (expression, el, component) => {\n    return typeof expression === 'function' ? component.evaluateReturnExpression(el, expression) : expression;\n  };\n\n  function transitionClassesIn(el, component, directives, showCallback, reject) {\n    const enter = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter') || {\n      expression: ''\n    }).expression, el, component));\n    const enterStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-start') || {\n      expression: ''\n    }).expression, el, component));\n    const enterEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-end') || {\n      expression: ''\n    }).expression, el, component));\n    transitionClasses(el, enter, enterStart, enterEnd, showCallback, () => {}, TRANSITION_TYPE_IN, reject);\n  }\n  function transitionClassesOut(el, component, directives, hideCallback, reject) {\n    const leave = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave') || {\n      expression: ''\n    }).expression, el, component));\n    const leaveStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-start') || {\n      expression: ''\n    }).expression, el, component));\n    const leaveEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-end') || {\n      expression: ''\n    }).expression, el, component));\n    transitionClasses(el, leave, leaveStart, leaveEnd, () => {}, hideCallback, TRANSITION_TYPE_OUT, reject);\n  }\n  function transitionClasses(el, classesDuring, classesStart, classesEnd, hook1, hook2, type, reject) {\n    // clear the previous transition if exists to avoid caching the wrong classes\n    if (el.__x_transition) {\n      el.__x_transition.cancel && el.__x_transition.cancel();\n    }\n\n    const originalClasses = el.__x_original_classes || [];\n    const stages = {\n      start() {\n        el.classList.add(...classesStart);\n      },\n\n      during() {\n        el.classList.add(...classesDuring);\n      },\n\n      show() {\n        hook1();\n      },\n\n      end() {\n        // Don't remove classes that were in the original class attribute.\n        el.classList.remove(...classesStart.filter(i => !originalClasses.includes(i)));\n        el.classList.add(...classesEnd);\n      },\n\n      hide() {\n        hook2();\n      },\n\n      cleanup() {\n        el.classList.remove(...classesDuring.filter(i => !originalClasses.includes(i)));\n        el.classList.remove(...classesEnd.filter(i => !originalClasses.includes(i)));\n      }\n\n    };\n    transition(el, stages, type, reject);\n  }\n  function transition(el, stages, type, reject) {\n    const finish = once(() => {\n      stages.hide(); // Adding an \"isConnected\" check, in case the callback\n      // removed the element from the DOM.\n\n      if (el.isConnected) {\n        stages.cleanup();\n      }\n\n      delete el.__x_transition;\n    });\n    el.__x_transition = {\n      // Set transition type so we can avoid clearing transition if the direction is the same\n      type: type,\n      // create a callback for the last stages of the transition so we can call it\n      // from different point and early terminate it. Once will ensure that function\n      // is only called one time.\n      cancel: once(() => {\n        reject(TRANSITION_CANCELLED);\n        finish();\n      }),\n      finish,\n      // This store the next animation frame so we can cancel it\n      nextFrame: null\n    };\n    stages.start();\n    stages.during();\n    el.__x_transition.nextFrame = requestAnimationFrame(() => {\n      // Note: Safari's transitionDuration property will list out comma separated transition durations\n      // for every single transition property. Let's grab the first one and call it a day.\n      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000;\n\n      if (duration === 0) {\n        duration = Number(getComputedStyle(el).animationDuration.replace('s', '')) * 1000;\n      }\n\n      stages.show();\n      el.__x_transition.nextFrame = requestAnimationFrame(() => {\n        stages.end();\n        setTimeout(el.__x_transition.finish, duration);\n      });\n    });\n  }\n  function isNumeric(subject) {\n    return !Array.isArray(subject) && !isNaN(subject);\n  } // Thanks @vuejs\n  // https://github.com/vuejs/vue/blob/4de4649d9637262a9b007720b59f80ac72a5620c/src/shared/util.js\n\n  function once(callback) {\n    let called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        callback.apply(this, arguments);\n      }\n    };\n  }\n\n  function handleForDirective(component, templateEl, expression, initialUpdate, extraVars) {\n    warnIfMalformedTemplate(templateEl, 'x-for');\n    let iteratorNames = typeof expression === 'function' ? parseForExpression(component.evaluateReturnExpression(templateEl, expression)) : parseForExpression(expression);\n    let items = evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, templateEl, iteratorNames, extraVars); // As we walk the array, we'll also walk the DOM (updating/creating as we go).\n\n    let currentEl = templateEl;\n    items.forEach((item, index) => {\n      let iterationScopeVariables = getIterationScopeVariables(iteratorNames, item, index, items, extraVars());\n      let currentKey = generateKeyForIteration(component, templateEl, index, iterationScopeVariables);\n      let nextEl = lookAheadForMatchingKeyedElementAndMoveItIfFound(currentEl.nextElementSibling, currentKey); // If we haven't found a matching key, insert the element at the current position.\n\n      if (!nextEl) {\n        nextEl = addElementInLoopAfterCurrentEl(templateEl, currentEl); // And transition it in if it's not the first page load.\n\n        transitionIn(nextEl, () => {}, () => {}, component, initialUpdate);\n        nextEl.__x_for = iterationScopeVariables;\n        component.initializeElements(nextEl, () => nextEl.__x_for); // Otherwise update the element we found.\n      } else {\n        // Temporarily remove the key indicator to allow the normal \"updateElements\" to work.\n        delete nextEl.__x_for_key;\n        nextEl.__x_for = iterationScopeVariables;\n        component.updateElements(nextEl, () => nextEl.__x_for);\n      }\n\n      currentEl = nextEl;\n      currentEl.__x_for_key = currentKey;\n    });\n    removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component);\n  } // This was taken from VueJS 2.* core. Thanks Vue!\n\n  function parseForExpression(expression) {\n    let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n    let stripParensRE = /^\\(|\\)$/g;\n    let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n    let inMatch = expression.match(forAliasRE);\n    if (!inMatch) return;\n    let res = {};\n    res.items = inMatch[2].trim();\n    let item = inMatch[1].trim().replace(stripParensRE, '');\n    let iteratorMatch = item.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.item = item.replace(forIteratorRE, '').trim();\n      res.index = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.collection = iteratorMatch[2].trim();\n      }\n    } else {\n      res.item = item;\n    }\n\n    return res;\n  }\n\n  function getIterationScopeVariables(iteratorNames, item, index, items, extraVars) {\n    // We must create a new object, so each iteration has a new scope\n    let scopeVariables = extraVars ? _objectSpread2({}, extraVars) : {};\n    scopeVariables[iteratorNames.item] = item;\n    if (iteratorNames.index) scopeVariables[iteratorNames.index] = index;\n    if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items;\n    return scopeVariables;\n  }\n\n  function generateKeyForIteration(component, el, index, iterationScopeVariables) {\n    let bindKeyAttribute = getXAttrs(el, component, 'bind').filter(attr => attr.value === 'key')[0]; // If the dev hasn't specified a key, just return the index of the iteration.\n\n    if (!bindKeyAttribute) return index;\n    return component.evaluateReturnExpression(el, bindKeyAttribute.expression, () => iterationScopeVariables);\n  }\n\n  function evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, el, iteratorNames, extraVars) {\n    let ifAttribute = getXAttrs(el, component, 'if')[0];\n\n    if (ifAttribute && !component.evaluateReturnExpression(el, ifAttribute.expression)) {\n      return [];\n    }\n\n    let items = component.evaluateReturnExpression(el, iteratorNames.items, extraVars); // This adds support for the `i in n` syntax.\n\n    if (isNumeric(items) && items > 0) {\n      items = Array.from(Array(items).keys(), i => i + 1);\n    }\n\n    return items;\n  }\n\n  function addElementInLoopAfterCurrentEl(templateEl, currentEl) {\n    let clone = document.importNode(templateEl.content, true);\n    currentEl.parentElement.insertBefore(clone, currentEl.nextElementSibling);\n    return currentEl.nextElementSibling;\n  }\n\n  function lookAheadForMatchingKeyedElementAndMoveItIfFound(nextEl, currentKey) {\n    if (!nextEl) return; // If we are already past the x-for generated elements, we don't need to look ahead.\n\n    if (nextEl.__x_for_key === undefined) return; // If the the key's DO match, no need to look ahead.\n\n    if (nextEl.__x_for_key === currentKey) return nextEl; // If they don't, we'll look ahead for a match.\n    // If we find it, we'll move it to the current position in the loop.\n\n    let tmpNextEl = nextEl;\n\n    while (tmpNextEl) {\n      if (tmpNextEl.__x_for_key === currentKey) {\n        return tmpNextEl.parentElement.insertBefore(tmpNextEl, nextEl);\n      }\n\n      tmpNextEl = tmpNextEl.nextElementSibling && tmpNextEl.nextElementSibling.__x_for_key !== undefined ? tmpNextEl.nextElementSibling : false;\n    }\n  }\n\n  function removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component) {\n    var nextElementFromOldLoop = currentEl.nextElementSibling && currentEl.nextElementSibling.__x_for_key !== undefined ? currentEl.nextElementSibling : false;\n\n    while (nextElementFromOldLoop) {\n      let nextElementFromOldLoopImmutable = nextElementFromOldLoop;\n      let nextSibling = nextElementFromOldLoop.nextElementSibling;\n      transitionOut(nextElementFromOldLoop, () => {\n        nextElementFromOldLoopImmutable.remove();\n      }, () => {}, component);\n      nextElementFromOldLoop = nextSibling && nextSibling.__x_for_key !== undefined ? nextSibling : false;\n    }\n  }\n\n  function handleAttributeBindingDirective(component, el, attrName, expression, extraVars, attrType, modifiers) {\n    var value = component.evaluateReturnExpression(el, expression, extraVars);\n\n    if (attrName === 'value') {\n      if (Alpine.ignoreFocusedForValueBinding && document.activeElement.isSameNode(el)) return; // If nested model key is undefined, set the default value to empty string.\n\n      if (value === undefined && expression.match(/\\./)) {\n        value = '';\n      }\n\n      if (el.type === 'radio') {\n        // Set radio value from x-bind:value, if no \"value\" attribute exists.\n        // If there are any initial state values, radio will have a correct\n        // \"checked\" value since x-bind:value is processed before x-model.\n        if (el.attributes.value === undefined && attrType === 'bind') {\n          el.value = value;\n        } else if (attrType !== 'bind') {\n          el.checked = checkedAttrLooseCompare(el.value, value);\n        }\n      } else if (el.type === 'checkbox') {\n        // If we are explicitly binding a string to the :value, set the string,\n        // If the value is a boolean, leave it alone, it will be set to \"on\"\n        // automatically.\n        if (typeof value !== 'boolean' && ![null, undefined].includes(value) && attrType === 'bind') {\n          el.value = String(value);\n        } else if (attrType !== 'bind') {\n          if (Array.isArray(value)) {\n            // I'm purposely not using Array.includes here because it's\n            // strict, and because of Numeric/String mis-casting, I\n            // want the \"includes\" to be \"fuzzy\".\n            el.checked = value.some(val => checkedAttrLooseCompare(val, el.value));\n          } else {\n            el.checked = !!value;\n          }\n        }\n      } else if (el.tagName === 'SELECT') {\n        updateSelect(el, value);\n      } else {\n        if (el.value === value) return;\n        el.value = value;\n      }\n    } else if (attrName === 'class') {\n      if (Array.isArray(value)) {\n        const originalClasses = el.__x_original_classes || [];\n        el.setAttribute('class', arrayUnique(originalClasses.concat(value)).join(' '));\n      } else if (typeof value === 'object') {\n        // Sorting the keys / class names by their boolean value will ensure that\n        // anything that evaluates to `false` and needs to remove classes is run first.\n        const keysSortedByBooleanValue = Object.keys(value).sort((a, b) => value[a] - value[b]);\n        keysSortedByBooleanValue.forEach(classNames => {\n          if (value[classNames]) {\n            convertClassStringToArray(classNames).forEach(className => el.classList.add(className));\n          } else {\n            convertClassStringToArray(classNames).forEach(className => el.classList.remove(className));\n          }\n        });\n      } else {\n        const originalClasses = el.__x_original_classes || [];\n        const newClasses = value ? convertClassStringToArray(value) : [];\n        el.setAttribute('class', arrayUnique(originalClasses.concat(newClasses)).join(' '));\n      }\n    } else {\n      attrName = modifiers.includes('camel') ? camelCase(attrName) : attrName; // If an attribute's bound value is null, undefined or false, remove the attribute\n\n      if ([null, undefined, false].includes(value)) {\n        el.removeAttribute(attrName);\n      } else {\n        isBooleanAttr(attrName) ? setIfChanged(el, attrName, attrName) : setIfChanged(el, attrName, value);\n      }\n    }\n  }\n\n  function setIfChanged(el, attrName, value) {\n    if (el.getAttribute(attrName) != value) {\n      el.setAttribute(attrName, value);\n    }\n  }\n\n  function updateSelect(el, value) {\n    const arrayWrappedValue = [].concat(value).map(value => {\n      return value + '';\n    });\n    Array.from(el.options).forEach(option => {\n      option.selected = arrayWrappedValue.includes(option.value || option.text);\n    });\n  }\n\n  function handleTextDirective(el, output, expression) {\n    // If nested model key is undefined, set the default value to empty string.\n    if (output === undefined && expression.match(/\\./)) {\n      output = '';\n    }\n\n    el.textContent = output;\n  }\n\n  function handleHtmlDirective(component, el, expression, extraVars) {\n    el.innerHTML = component.evaluateReturnExpression(el, expression, extraVars);\n  }\n\n  function handleShowDirective(component, el, value, modifiers, initialUpdate = false) {\n    const hide = () => {\n      el.style.display = 'none';\n      el.__x_is_shown = false;\n    };\n\n    const show = () => {\n      if (el.style.length === 1 && el.style.display === 'none') {\n        el.removeAttribute('style');\n      } else {\n        el.style.removeProperty('display');\n      }\n\n      el.__x_is_shown = true;\n    };\n\n    if (initialUpdate === true) {\n      if (value) {\n        show();\n      } else {\n        hide();\n      }\n\n      return;\n    }\n\n    const handle = (resolve, reject) => {\n      if (value) {\n        if (el.style.display === 'none' || el.__x_transition) {\n          transitionIn(el, () => {\n            show();\n          }, reject, component);\n        }\n\n        resolve(() => {});\n      } else {\n        if (el.style.display !== 'none') {\n          transitionOut(el, () => {\n            resolve(() => {\n              hide();\n            });\n          }, reject, component);\n        } else {\n          resolve(() => {});\n        }\n      }\n    }; // The working of x-show is a bit complex because we need to\n    // wait for any child transitions to finish before hiding\n    // some element. Also, this has to be done recursively.\n    // If x-show.immediate, foregoe the waiting.\n\n\n    if (modifiers.includes('immediate')) {\n      handle(finish => finish(), () => {});\n      return;\n    } // x-show is encountered during a DOM tree walk. If an element\n    // we encounter is NOT a child of another x-show element we\n    // can execute the previous x-show stack (if one exists).\n\n\n    if (component.showDirectiveLastElement && !component.showDirectiveLastElement.contains(el)) {\n      component.executeAndClearRemainingShowDirectiveStack();\n    }\n\n    component.showDirectiveStack.push(handle);\n    component.showDirectiveLastElement = el;\n  }\n\n  function handleIfDirective(component, el, expressionResult, initialUpdate, extraVars) {\n    warnIfMalformedTemplate(el, 'x-if');\n    const elementHasAlreadyBeenAdded = el.nextElementSibling && el.nextElementSibling.__x_inserted_me === true;\n\n    if (expressionResult && (!elementHasAlreadyBeenAdded || el.__x_transition)) {\n      const clone = document.importNode(el.content, true);\n      el.parentElement.insertBefore(clone, el.nextElementSibling);\n      transitionIn(el.nextElementSibling, () => {}, () => {}, component, initialUpdate);\n      component.initializeElements(el.nextElementSibling, extraVars);\n      el.nextElementSibling.__x_inserted_me = true;\n    } else if (!expressionResult && elementHasAlreadyBeenAdded) {\n      transitionOut(el.nextElementSibling, () => {\n        el.nextElementSibling.remove();\n      }, () => {}, component, initialUpdate);\n    }\n  }\n\n  function registerListener(component, el, event, modifiers, expression, extraVars = {}) {\n    const options = {\n      passive: modifiers.includes('passive')\n    };\n\n    if (modifiers.includes('camel')) {\n      event = camelCase(event);\n    }\n\n    if (modifiers.includes('away')) {\n      let handler = e => {\n        // Don't do anything if the click came from the element or within it.\n        if (el.contains(e.target)) return; // Don't do anything if this element isn't currently visible.\n\n        if (el.offsetWidth < 1 && el.offsetHeight < 1) return; // Now that we are sure the element is visible, AND the click\n        // is from outside it, let's run the expression.\n\n        runListenerHandler(component, expression, e, extraVars);\n\n        if (modifiers.includes('once')) {\n          document.removeEventListener(event, handler, options);\n        }\n      }; // Listen for this event at the root level.\n\n\n      document.addEventListener(event, handler, options);\n    } else {\n      let listenerTarget = modifiers.includes('window') ? window : modifiers.includes('document') ? document : el;\n\n      let handler = e => {\n        // Remove this global event handler if the element that declared it\n        // has been removed. It's now stale.\n        if (listenerTarget === window || listenerTarget === document) {\n          if (!document.body.contains(el)) {\n            listenerTarget.removeEventListener(event, handler, options);\n            return;\n          }\n        }\n\n        if (isKeyEvent(event)) {\n          if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n            return;\n          }\n        }\n\n        if (modifiers.includes('prevent')) e.preventDefault();\n        if (modifiers.includes('stop')) e.stopPropagation(); // If the .self modifier isn't present, or if it is present and\n        // the target element matches the element we are registering the\n        // event on, run the handler\n\n        if (!modifiers.includes('self') || e.target === el) {\n          const returnValue = runListenerHandler(component, expression, e, extraVars);\n          returnValue.then(value => {\n            if (value === false) {\n              e.preventDefault();\n            } else {\n              if (modifiers.includes('once')) {\n                listenerTarget.removeEventListener(event, handler, options);\n              }\n            }\n          });\n        }\n      };\n\n      if (modifiers.includes('debounce')) {\n        let nextModifier = modifiers[modifiers.indexOf('debounce') + 1] || 'invalid-wait';\n        let wait = isNumeric(nextModifier.split('ms')[0]) ? Number(nextModifier.split('ms')[0]) : 250;\n        handler = debounce(handler, wait);\n      }\n\n      listenerTarget.addEventListener(event, handler, options);\n    }\n  }\n\n  function runListenerHandler(component, expression, e, extraVars) {\n    return component.evaluateCommandExpression(e.target, expression, () => {\n      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        '$event': e\n      });\n    });\n  }\n\n  function isKeyEvent(event) {\n    return ['keydown', 'keyup'].includes(event);\n  }\n\n  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n    let keyModifiers = modifiers.filter(i => {\n      return !['window', 'document', 'prevent', 'stop'].includes(i);\n    });\n\n    if (keyModifiers.includes('debounce')) {\n      let debounceIndex = keyModifiers.indexOf('debounce');\n      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || 'invalid-wait').split('ms')[0]) ? 2 : 1);\n    } // If no modifier is specified, we'll call it a press.\n\n\n    if (keyModifiers.length === 0) return false; // If one is passed, AND it matches the key pressed, we'll call it a press.\n\n    if (keyModifiers.length === 1 && keyModifiers[0] === keyToModifier(e.key)) return false; // The user is listening for key combinations.\n\n    const systemKeyModifiers = ['ctrl', 'shift', 'alt', 'meta', 'cmd', 'super'];\n    const selectedSystemKeyModifiers = systemKeyModifiers.filter(modifier => keyModifiers.includes(modifier));\n    keyModifiers = keyModifiers.filter(i => !selectedSystemKeyModifiers.includes(i));\n\n    if (selectedSystemKeyModifiers.length > 0) {\n      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter(modifier => {\n        // Alias \"cmd\" and \"super\" to \"meta\"\n        if (modifier === 'cmd' || modifier === 'super') modifier = 'meta';\n        return e[`${modifier}Key`];\n      }); // If all the modifiers selected are pressed, ...\n\n      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n        // AND the remaining key is pressed as well. It's a press.\n        if (keyModifiers[0] === keyToModifier(e.key)) return false;\n      }\n    } // We'll call it NOT a valid keypress.\n\n\n    return true;\n  }\n\n  function keyToModifier(key) {\n    switch (key) {\n      case '/':\n        return 'slash';\n\n      case ' ':\n      case 'Spacebar':\n        return 'space';\n\n      default:\n        return key && kebabCase(key);\n    }\n  }\n\n  function registerModelListener(component, el, modifiers, expression, extraVars) {\n    // If the element we are binding to is a select, a radio, or checkbox\n    // we'll listen for the change event instead of the \"input\" event.\n    var event = el.tagName.toLowerCase() === 'select' || ['checkbox', 'radio'].includes(el.type) || modifiers.includes('lazy') ? 'change' : 'input';\n    const listenerExpression = `${expression} = rightSideOfExpression($event, ${expression})`;\n    registerListener(component, el, event, modifiers, listenerExpression, () => {\n      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        rightSideOfExpression: generateModelAssignmentFunction(el, modifiers, expression)\n      });\n    });\n  }\n\n  function generateModelAssignmentFunction(el, modifiers, expression) {\n    if (el.type === 'radio') {\n      // Radio buttons only work properly when they share a name attribute.\n      // People might assume we take care of that for them, because\n      // they already set a shared \"x-model\" attribute.\n      if (!el.hasAttribute('name')) el.setAttribute('name', expression);\n    }\n\n    return (event, currentValue) => {\n      // Check for event.detail due to an issue where IE11 handles other events as a CustomEvent.\n      if (event instanceof CustomEvent && event.detail) {\n        return event.detail;\n      } else if (el.type === 'checkbox') {\n        // If the data we are binding to is an array, toggle its value inside the array.\n        if (Array.isArray(currentValue)) {\n          const newValue = modifiers.includes('number') ? safeParseNumber(event.target.value) : event.target.value;\n          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter(el => !checkedAttrLooseCompare(el, newValue));\n        } else {\n          return event.target.checked;\n        }\n      } else if (el.tagName.toLowerCase() === 'select' && el.multiple) {\n        return modifiers.includes('number') ? Array.from(event.target.selectedOptions).map(option => {\n          const rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        }) : Array.from(event.target.selectedOptions).map(option => {\n          return option.value || option.text;\n        });\n      } else {\n        const rawValue = event.target.value;\n        return modifiers.includes('number') ? safeParseNumber(rawValue) : modifiers.includes('trim') ? rawValue.trim() : rawValue;\n      }\n    };\n  }\n\n  function safeParseNumber(rawValue) {\n    const number = rawValue ? parseFloat(rawValue) : null;\n    return isNumeric(number) ? number : rawValue;\n  }\n\n  /**\n   * Copyright (C) 2017 salesforce.com, inc.\n   */\n  const { isArray } = Array;\n  const { getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, defineProperties: ObjectDefineProperties, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty, } = Object;\n  const { push: ArrayPush, concat: ArrayConcat, map: ArrayMap, } = Array.prototype;\n  function isUndefined(obj) {\n      return obj === undefined;\n  }\n  function isFunction(obj) {\n      return typeof obj === 'function';\n  }\n  function isObject(obj) {\n      return typeof obj === 'object';\n  }\n  const proxyToValueMap = new WeakMap();\n  function registerProxy(proxy, value) {\n      proxyToValueMap.set(proxy, value);\n  }\n  const unwrap = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\n  function wrapValue(membrane, value) {\n      return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;\n  }\n  /**\n   * Unwrap property descriptors will set value on original descriptor\n   * We only need to unwrap if value is specified\n   * @param descriptor external descrpitor provided to define new property on original value\n   */\n  function unwrapDescriptor(descriptor) {\n      if (hasOwnProperty.call(descriptor, 'value')) {\n          descriptor.value = unwrap(descriptor.value);\n      }\n      return descriptor;\n  }\n  function lockShadowTarget(membrane, shadowTarget, originalTarget) {\n      const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      targetKeys.forEach((key) => {\n          let descriptor = getOwnPropertyDescriptor(originalTarget, key);\n          // We do not need to wrap the descriptor if configurable\n          // Because we can deal with wrapping it when user goes through\n          // Get own property descriptor. There is also a chance that this descriptor\n          // could change sometime in the future, so we can defer wrapping\n          // until we need to\n          if (!descriptor.configurable) {\n              descriptor = wrapDescriptor(membrane, descriptor, wrapValue);\n          }\n          ObjectDefineProperty(shadowTarget, key, descriptor);\n      });\n      preventExtensions(shadowTarget);\n  }\n  class ReactiveProxyHandler {\n      constructor(membrane, value) {\n          this.originalTarget = value;\n          this.membrane = membrane;\n      }\n      get(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const value = originalTarget[key];\n          const { valueObserved } = membrane;\n          valueObserved(originalTarget, key);\n          return membrane.getProxy(value);\n      }\n      set(shadowTarget, key, value) {\n          const { originalTarget, membrane: { valueMutated } } = this;\n          const oldValue = originalTarget[key];\n          if (oldValue !== value) {\n              originalTarget[key] = value;\n              valueMutated(originalTarget, key);\n          }\n          else if (key === 'length' && isArray(originalTarget)) {\n              // fix for issue #236: push will add the new index, and by the time length\n              // is updated, the internal length is already equal to the new length value\n              // therefore, the oldValue is equal to the value. This is the forking logic\n              // to support this use case.\n              valueMutated(originalTarget, key);\n          }\n          return true;\n      }\n      deleteProperty(shadowTarget, key) {\n          const { originalTarget, membrane: { valueMutated } } = this;\n          delete originalTarget[key];\n          valueMutated(originalTarget, key);\n          return true;\n      }\n      apply(shadowTarget, thisArg, argArray) {\n          /* No op */\n      }\n      construct(target, argArray, newTarget) {\n          /* No op */\n      }\n      has(shadowTarget, key) {\n          const { originalTarget, membrane: { valueObserved } } = this;\n          valueObserved(originalTarget, key);\n          return key in originalTarget;\n      }\n      ownKeys(shadowTarget) {\n          const { originalTarget } = this;\n          return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      }\n      isExtensible(shadowTarget) {\n          const shadowIsExtensible = isExtensible(shadowTarget);\n          if (!shadowIsExtensible) {\n              return shadowIsExtensible;\n          }\n          const { originalTarget, membrane } = this;\n          const targetIsExtensible = isExtensible(originalTarget);\n          if (!targetIsExtensible) {\n              lockShadowTarget(membrane, shadowTarget, originalTarget);\n          }\n          return targetIsExtensible;\n      }\n      setPrototypeOf(shadowTarget, prototype) {\n      }\n      getPrototypeOf(shadowTarget) {\n          const { originalTarget } = this;\n          return getPrototypeOf(originalTarget);\n      }\n      getOwnPropertyDescriptor(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const { valueObserved } = this.membrane;\n          // keys looked up via hasOwnProperty need to be reactive\n          valueObserved(originalTarget, key);\n          let desc = getOwnPropertyDescriptor(originalTarget, key);\n          if (isUndefined(desc)) {\n              return desc;\n          }\n          const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);\n          if (!isUndefined(shadowDescriptor)) {\n              return shadowDescriptor;\n          }\n          // Note: by accessing the descriptor, the key is marked as observed\n          // but access to the value, setter or getter (if available) cannot observe\n          // mutations, just like regular methods, in which case we just do nothing.\n          desc = wrapDescriptor(membrane, desc, wrapValue);\n          if (!desc.configurable) {\n              // If descriptor from original target is not configurable,\n              // We must copy the wrapped descriptor over to the shadow target.\n              // Otherwise, proxy will throw an invariant error.\n              // This is our last chance to lock the value.\n              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n              ObjectDefineProperty(shadowTarget, key, desc);\n          }\n          return desc;\n      }\n      preventExtensions(shadowTarget) {\n          const { originalTarget, membrane } = this;\n          lockShadowTarget(membrane, shadowTarget, originalTarget);\n          preventExtensions(originalTarget);\n          return true;\n      }\n      defineProperty(shadowTarget, key, descriptor) {\n          const { originalTarget, membrane } = this;\n          const { valueMutated } = membrane;\n          const { configurable } = descriptor;\n          // We have to check for value in descriptor\n          // because Object.freeze(proxy) calls this method\n          // with only { configurable: false, writeable: false }\n          // Additionally, method will only be called with writeable:false\n          // if the descriptor has a value, as opposed to getter/setter\n          // So we can just check if writable is present and then see if\n          // value is present. This eliminates getter and setter descriptors\n          if (hasOwnProperty.call(descriptor, 'writable') && !hasOwnProperty.call(descriptor, 'value')) {\n              const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);\n              descriptor.value = originalDescriptor.value;\n          }\n          ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));\n          if (configurable === false) {\n              ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));\n          }\n          valueMutated(originalTarget, key);\n          return true;\n      }\n  }\n\n  function wrapReadOnlyValue(membrane, value) {\n      return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;\n  }\n  class ReadOnlyHandler {\n      constructor(membrane, value) {\n          this.originalTarget = value;\n          this.membrane = membrane;\n      }\n      get(shadowTarget, key) {\n          const { membrane, originalTarget } = this;\n          const value = originalTarget[key];\n          const { valueObserved } = membrane;\n          valueObserved(originalTarget, key);\n          return membrane.getReadOnlyProxy(value);\n      }\n      set(shadowTarget, key, value) {\n          return false;\n      }\n      deleteProperty(shadowTarget, key) {\n          return false;\n      }\n      apply(shadowTarget, thisArg, argArray) {\n          /* No op */\n      }\n      construct(target, argArray, newTarget) {\n          /* No op */\n      }\n      has(shadowTarget, key) {\n          const { originalTarget, membrane: { valueObserved } } = this;\n          valueObserved(originalTarget, key);\n          return key in originalTarget;\n      }\n      ownKeys(shadowTarget) {\n          const { originalTarget } = this;\n          return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      }\n      setPrototypeOf(shadowTarget, prototype) {\n      }\n      getOwnPropertyDescriptor(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const { valueObserved } = membrane;\n          // keys looked up via hasOwnProperty need to be reactive\n          valueObserved(originalTarget, key);\n          let desc = getOwnPropertyDescriptor(originalTarget, key);\n          if (isUndefined(desc)) {\n              return desc;\n          }\n          const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);\n          if (!isUndefined(shadowDescriptor)) {\n              return shadowDescriptor;\n          }\n          // Note: by accessing the descriptor, the key is marked as observed\n          // but access to the value or getter (if available) cannot be observed,\n          // just like regular methods, in which case we just do nothing.\n          desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);\n          if (hasOwnProperty.call(desc, 'set')) {\n              desc.set = undefined; // readOnly membrane does not allow setters\n          }\n          if (!desc.configurable) {\n              // If descriptor from original target is not configurable,\n              // We must copy the wrapped descriptor over to the shadow target.\n              // Otherwise, proxy will throw an invariant error.\n              // This is our last chance to lock the value.\n              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n              ObjectDefineProperty(shadowTarget, key, desc);\n          }\n          return desc;\n      }\n      preventExtensions(shadowTarget) {\n          return false;\n      }\n      defineProperty(shadowTarget, key, descriptor) {\n          return false;\n      }\n  }\n  function createShadowTarget(value) {\n      let shadowTarget = undefined;\n      if (isArray(value)) {\n          shadowTarget = [];\n      }\n      else if (isObject(value)) {\n          shadowTarget = {};\n      }\n      return shadowTarget;\n  }\n  const ObjectDotPrototype = Object.prototype;\n  function defaultValueIsObservable(value) {\n      // intentionally checking for null\n      if (value === null) {\n          return false;\n      }\n      // treat all non-object types, including undefined, as non-observable values\n      if (typeof value !== 'object') {\n          return false;\n      }\n      if (isArray(value)) {\n          return true;\n      }\n      const proto = getPrototypeOf(value);\n      return (proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null);\n  }\n  const defaultValueObserved = (obj, key) => {\n      /* do nothing */\n  };\n  const defaultValueMutated = (obj, key) => {\n      /* do nothing */\n  };\n  const defaultValueDistortion = (value) => value;\n  function wrapDescriptor(membrane, descriptor, getValue) {\n      const { set, get } = descriptor;\n      if (hasOwnProperty.call(descriptor, 'value')) {\n          descriptor.value = getValue(membrane, descriptor.value);\n      }\n      else {\n          if (!isUndefined(get)) {\n              descriptor.get = function () {\n                  // invoking the original getter with the original target\n                  return getValue(membrane, get.call(unwrap(this)));\n              };\n          }\n          if (!isUndefined(set)) {\n              descriptor.set = function (value) {\n                  // At this point we don't have a clear indication of whether\n                  // or not a valid mutation will occur, we don't have the key,\n                  // and we are not sure why and how they are invoking this setter.\n                  // Nevertheless we preserve the original semantics by invoking the\n                  // original setter with the original target and the unwrapped value\n                  set.call(unwrap(this), membrane.unwrapProxy(value));\n              };\n          }\n      }\n      return descriptor;\n  }\n  class ReactiveMembrane {\n      constructor(options) {\n          this.valueDistortion = defaultValueDistortion;\n          this.valueMutated = defaultValueMutated;\n          this.valueObserved = defaultValueObserved;\n          this.valueIsObservable = defaultValueIsObservable;\n          this.objectGraph = new WeakMap();\n          if (!isUndefined(options)) {\n              const { valueDistortion, valueMutated, valueObserved, valueIsObservable } = options;\n              this.valueDistortion = isFunction(valueDistortion) ? valueDistortion : defaultValueDistortion;\n              this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;\n              this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;\n              this.valueIsObservable = isFunction(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;\n          }\n      }\n      getProxy(value) {\n          const unwrappedValue = unwrap(value);\n          const distorted = this.valueDistortion(unwrappedValue);\n          if (this.valueIsObservable(distorted)) {\n              const o = this.getReactiveState(unwrappedValue, distorted);\n              // when trying to extract the writable version of a readonly\n              // we return the readonly.\n              return o.readOnly === value ? value : o.reactive;\n          }\n          return distorted;\n      }\n      getReadOnlyProxy(value) {\n          value = unwrap(value);\n          const distorted = this.valueDistortion(value);\n          if (this.valueIsObservable(distorted)) {\n              return this.getReactiveState(value, distorted).readOnly;\n          }\n          return distorted;\n      }\n      unwrapProxy(p) {\n          return unwrap(p);\n      }\n      getReactiveState(value, distortedValue) {\n          const { objectGraph, } = this;\n          let reactiveState = objectGraph.get(distortedValue);\n          if (reactiveState) {\n              return reactiveState;\n          }\n          const membrane = this;\n          reactiveState = {\n              get reactive() {\n                  const reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue);\n                  // caching the reactive proxy after the first time it is accessed\n                  const proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);\n                  registerProxy(proxy, value);\n                  ObjectDefineProperty(this, 'reactive', { value: proxy });\n                  return proxy;\n              },\n              get readOnly() {\n                  const readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue);\n                  // caching the readOnly proxy after the first time it is accessed\n                  const proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);\n                  registerProxy(proxy, value);\n                  ObjectDefineProperty(this, 'readOnly', { value: proxy });\n                  return proxy;\n              }\n          };\n          objectGraph.set(distortedValue, reactiveState);\n          return reactiveState;\n      }\n  }\n  /** version: 0.26.0 */\n\n  function wrap(data, mutationCallback) {\n\n    let membrane = new ReactiveMembrane({\n      valueMutated(target, key) {\n        mutationCallback(target, key);\n      }\n\n    });\n    return {\n      data: membrane.getProxy(data),\n      membrane: membrane\n    };\n  }\n  function unwrap$1(membrane, observable) {\n    let unwrappedData = membrane.unwrapProxy(observable);\n    let copy = {};\n    Object.keys(unwrappedData).forEach(key => {\n      if (['$el', '$refs', '$nextTick', '$watch'].includes(key)) return;\n      copy[key] = unwrappedData[key];\n    });\n    return copy;\n  }\n\n  class Component {\n    constructor(el, componentForClone = null) {\n      this.$el = el;\n      const dataAttr = this.$el.getAttribute('x-data');\n      const dataExpression = dataAttr === '' ? '{}' : dataAttr;\n      const initExpression = this.$el.getAttribute('x-init');\n      let dataExtras = {\n        $el: this.$el\n      };\n      let canonicalComponentElementReference = componentForClone ? componentForClone.$el : this.$el;\n      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        Object.defineProperty(dataExtras, `$${name}`, {\n          get: function get() {\n            return callback(canonicalComponentElementReference);\n          }\n        });\n      });\n      this.unobservedData = componentForClone ? componentForClone.getUnobservedData() : saferEval(el, dataExpression, dataExtras);\n      // Construct a Proxy-based observable. This will be used to handle reactivity.\n\n      let {\n        membrane,\n        data\n      } = this.wrapDataInObservable(this.unobservedData);\n      this.$data = data;\n      this.membrane = membrane; // After making user-supplied data methods reactive, we can now add\n      // our magic properties to the original data for access.\n\n      this.unobservedData.$el = this.$el;\n      this.unobservedData.$refs = this.getRefsProxy();\n      this.nextTickStack = [];\n\n      this.unobservedData.$nextTick = callback => {\n        this.nextTickStack.push(callback);\n      };\n\n      this.watchers = {};\n\n      this.unobservedData.$watch = (property, callback) => {\n        if (!this.watchers[property]) this.watchers[property] = [];\n        this.watchers[property].push(callback);\n      };\n      /* MODERN-ONLY:START */\n      // We remove this piece of code from the legacy build.\n      // In IE11, we have already defined our helpers at this point.\n      // Register custom magic properties.\n\n\n      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        Object.defineProperty(this.unobservedData, `$${name}`, {\n          get: function get() {\n            return callback(canonicalComponentElementReference, this.$el);\n          }\n        });\n      });\n      /* MODERN-ONLY:END */\n\n      this.showDirectiveStack = [];\n      this.showDirectiveLastElement;\n      componentForClone || Alpine.onBeforeComponentInitializeds.forEach(callback => callback(this));\n      var initReturnedCallback; // If x-init is present AND we aren't cloning (skip x-init on clone)\n\n      if (initExpression && !componentForClone) {\n        // We want to allow data manipulation, but not trigger DOM updates just yet.\n        // We haven't even initialized the elements with their Alpine bindings. I mean c'mon.\n        this.pauseReactivity = true;\n        initReturnedCallback = this.evaluateReturnExpression(this.$el, initExpression);\n        this.pauseReactivity = false;\n      } // Register all our listeners and set all our attribute bindings.\n\n\n      this.initializeElements(this.$el); // Use mutation observer to detect new elements being added within this component at run-time.\n      // Alpine's just so darn flexible amirite?\n\n      this.listenForNewElementsToInitialize();\n\n      if (typeof initReturnedCallback === 'function') {\n        // Run the callback returned from the \"x-init\" hook to allow the user to do stuff after\n        // Alpine's got it's grubby little paws all over everything.\n        initReturnedCallback.call(this.$data);\n      }\n\n      componentForClone || setTimeout(() => {\n        Alpine.onComponentInitializeds.forEach(callback => callback(this));\n      }, 0);\n    }\n\n    getUnobservedData() {\n      return unwrap$1(this.membrane, this.$data);\n    }\n\n    wrapDataInObservable(data) {\n      var self = this;\n      let updateDom = debounce(function () {\n        self.updateElements(self.$el);\n      }, 0);\n      return wrap(data, (target, key) => {\n        if (self.watchers[key]) {\n          // If there's a watcher for this specific key, run it.\n          self.watchers[key].forEach(callback => callback(target[key]));\n        } else if (Array.isArray(target)) {\n          // Arrays are special cases, if any of the items change, we consider the array as mutated.\n          Object.keys(self.watchers).forEach(fullDotNotationKey => {\n            let dotNotationParts = fullDotNotationKey.split('.'); // Ignore length mutations since they would result in duplicate calls.\n            // For example, when calling push, we would get a mutation for the item's key\n            // and a second mutation for the length property.\n\n            if (key === 'length') return;\n            dotNotationParts.reduce((comparisonData, part) => {\n              if (Object.is(target, comparisonData[part])) {\n                self.watchers[fullDotNotationKey].forEach(callback => callback(target));\n              }\n\n              return comparisonData[part];\n            }, self.unobservedData);\n          });\n        } else {\n          // Let's walk through the watchers with \"dot-notation\" (foo.bar) and see\n          // if this mutation fits any of them.\n          Object.keys(self.watchers).filter(i => i.includes('.')).forEach(fullDotNotationKey => {\n            let dotNotationParts = fullDotNotationKey.split('.'); // If this dot-notation watcher's last \"part\" doesn't match the current\n            // key, then skip it early for performance reasons.\n\n            if (key !== dotNotationParts[dotNotationParts.length - 1]) return; // Now, walk through the dot-notation \"parts\" recursively to find\n            // a match, and call the watcher if one's found.\n\n            dotNotationParts.reduce((comparisonData, part) => {\n              if (Object.is(target, comparisonData)) {\n                // Run the watchers.\n                self.watchers[fullDotNotationKey].forEach(callback => callback(target[key]));\n              }\n\n              return comparisonData[part];\n            }, self.unobservedData);\n          });\n        } // Don't react to data changes for cases like the `x-created` hook.\n\n\n        if (self.pauseReactivity) return;\n        updateDom();\n      });\n    }\n\n    walkAndSkipNestedComponents(el, callback, initializeComponentCallback = () => {}) {\n      walk(el, el => {\n        // We've hit a component.\n        if (el.hasAttribute('x-data')) {\n          // If it's not the current one.\n          if (!el.isSameNode(this.$el)) {\n            // Initialize it if it's not.\n            if (!el.__x) initializeComponentCallback(el); // Now we'll let that sub-component deal with itself.\n\n            return false;\n          }\n        }\n\n        return callback(el);\n      });\n    }\n\n    initializeElements(rootEl, extraVars = () => {}) {\n      this.walkAndSkipNestedComponents(rootEl, el => {\n        // Don't touch spawns from for loop\n        if (el.__x_for_key !== undefined) return false; // Don't touch spawns from if directives\n\n        if (el.__x_inserted_me !== undefined) return false;\n        this.initializeElement(el, extraVars);\n      }, el => {\n        el.__x = new Component(el);\n      });\n      this.executeAndClearRemainingShowDirectiveStack();\n      this.executeAndClearNextTickStack(rootEl);\n    }\n\n    initializeElement(el, extraVars) {\n      // To support class attribute merging, we have to know what the element's\n      // original class attribute looked like for reference.\n      if (el.hasAttribute('class') && getXAttrs(el, this).length > 0) {\n        el.__x_original_classes = convertClassStringToArray(el.getAttribute('class'));\n      }\n\n      this.registerListeners(el, extraVars);\n      this.resolveBoundAttributes(el, true, extraVars);\n    }\n\n    updateElements(rootEl, extraVars = () => {}) {\n      this.walkAndSkipNestedComponents(rootEl, el => {\n        // Don't touch spawns from for loop (and check if the root is actually a for loop in a parent, don't skip it.)\n        if (el.__x_for_key !== undefined && !el.isSameNode(this.$el)) return false;\n        this.updateElement(el, extraVars);\n      }, el => {\n        el.__x = new Component(el);\n      });\n      this.executeAndClearRemainingShowDirectiveStack();\n      this.executeAndClearNextTickStack(rootEl);\n    }\n\n    executeAndClearNextTickStack(el) {\n      // Skip spawns from alpine directives\n      if (el === this.$el && this.nextTickStack.length > 0) {\n        // We run the tick stack after the next frame to allow any\n        // running transitions to pass the initial show stage.\n        requestAnimationFrame(() => {\n          while (this.nextTickStack.length > 0) {\n            this.nextTickStack.shift()();\n          }\n        });\n      }\n    }\n\n    executeAndClearRemainingShowDirectiveStack() {\n      // The goal here is to start all the x-show transitions\n      // and build a nested promise chain so that elements\n      // only hide when the children are finished hiding.\n      this.showDirectiveStack.reverse().map(handler => {\n        return new Promise((resolve, reject) => {\n          handler(resolve, reject);\n        });\n      }).reduce((promiseChain, promise) => {\n        return promiseChain.then(() => {\n          return promise.then(finishElement => {\n            finishElement();\n          });\n        });\n      }, Promise.resolve(() => {})).catch(e => {\n        if (e !== TRANSITION_CANCELLED) throw e;\n      }); // We've processed the handler stack. let's clear it.\n\n      this.showDirectiveStack = [];\n      this.showDirectiveLastElement = undefined;\n    }\n\n    updateElement(el, extraVars) {\n      this.resolveBoundAttributes(el, false, extraVars);\n    }\n\n    registerListeners(el, extraVars) {\n      getXAttrs(el, this).forEach(({\n        type,\n        value,\n        modifiers,\n        expression\n      }) => {\n        switch (type) {\n          case 'on':\n            registerListener(this, el, value, modifiers, expression, extraVars);\n            break;\n\n          case 'model':\n            registerModelListener(this, el, modifiers, expression, extraVars);\n            break;\n        }\n      });\n    }\n\n    resolveBoundAttributes(el, initialUpdate = false, extraVars) {\n      let attrs = getXAttrs(el, this);\n      attrs.forEach(({\n        type,\n        value,\n        modifiers,\n        expression\n      }) => {\n        switch (type) {\n          case 'model':\n            handleAttributeBindingDirective(this, el, 'value', expression, extraVars, type, modifiers);\n            break;\n\n          case 'bind':\n            // The :key binding on an x-for is special, ignore it.\n            if (el.tagName.toLowerCase() === 'template' && value === 'key') return;\n            handleAttributeBindingDirective(this, el, value, expression, extraVars, type, modifiers);\n            break;\n\n          case 'text':\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleTextDirective(el, output, expression);\n            break;\n\n          case 'html':\n            handleHtmlDirective(this, el, expression, extraVars);\n            break;\n\n          case 'show':\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleShowDirective(this, el, output, modifiers, initialUpdate);\n            break;\n\n          case 'if':\n            // If this element also has x-for on it, don't process x-if.\n            // We will let the \"x-for\" directive handle the \"if\"ing.\n            if (attrs.some(i => i.type === 'for')) return;\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleIfDirective(this, el, output, initialUpdate, extraVars);\n            break;\n\n          case 'for':\n            handleForDirective(this, el, expression, initialUpdate, extraVars);\n            break;\n\n          case 'cloak':\n            el.removeAttribute('x-cloak');\n            break;\n        }\n      });\n    }\n\n    evaluateReturnExpression(el, expression, extraVars = () => {}) {\n      return saferEval(el, expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        $dispatch: this.getDispatchFunction(el)\n      }));\n    }\n\n    evaluateCommandExpression(el, expression, extraVars = () => {}) {\n      return saferEvalNoReturn(el, expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        $dispatch: this.getDispatchFunction(el)\n      }));\n    }\n\n    getDispatchFunction(el) {\n      return (event, detail = {}) => {\n        el.dispatchEvent(new CustomEvent(event, {\n          detail,\n          bubbles: true\n        }));\n      };\n    }\n\n    listenForNewElementsToInitialize() {\n      const targetNode = this.$el;\n      const observerOptions = {\n        childList: true,\n        attributes: true,\n        subtree: true\n      };\n      const observer = new MutationObserver(mutations => {\n        for (let i = 0; i < mutations.length; i++) {\n          // Filter out mutations triggered from child components.\n          const closestParentComponent = mutations[i].target.closest('[x-data]');\n          if (!(closestParentComponent && closestParentComponent.isSameNode(this.$el))) continue;\n\n          if (mutations[i].type === 'attributes' && mutations[i].attributeName === 'x-data') {\n            const xAttr = mutations[i].target.getAttribute('x-data') || '{}';\n            const rawData = saferEval(this.$el, xAttr, {\n              $el: this.$el\n            });\n            Object.keys(rawData).forEach(key => {\n              if (this.$data[key] !== rawData[key]) {\n                this.$data[key] = rawData[key];\n              }\n            });\n          }\n\n          if (mutations[i].addedNodes.length > 0) {\n            mutations[i].addedNodes.forEach(node => {\n              if (node.nodeType !== 1 || node.__x_inserted_me) return;\n\n              if (node.matches('[x-data]') && !node.__x) {\n                node.__x = new Component(node);\n                return;\n              }\n\n              this.initializeElements(node);\n            });\n          }\n        }\n      });\n      observer.observe(targetNode, observerOptions);\n    }\n\n    getRefsProxy() {\n      var self = this;\n      var refObj = {};\n      // One of the goals of this is to not hold elements in memory, but rather re-evaluate\n      // the DOM when the system needs something from it. This way, the framework is flexible and\n      // friendly to outside DOM changes from libraries like Vue/Livewire.\n      // For this reason, I'm using an \"on-demand\" proxy to fake a \"$refs\" object.\n\n      return new Proxy(refObj, {\n        get(object, property) {\n          if (property === '$isAlpineProxy') return true;\n          var ref; // We can't just query the DOM because it's hard to filter out refs in\n          // nested components.\n\n          self.walkAndSkipNestedComponents(self.$el, el => {\n            if (el.hasAttribute('x-ref') && el.getAttribute('x-ref') === property) {\n              ref = el;\n            }\n          });\n          return ref;\n        }\n\n      });\n    }\n\n  }\n\n  const Alpine = {\n    version: \"2.8.0\",\n    pauseMutationObserver: false,\n    magicProperties: {},\n    onComponentInitializeds: [],\n    onBeforeComponentInitializeds: [],\n    ignoreFocusedForValueBinding: false,\n    start: async function start() {\n      if (!isTesting()) {\n        await domReady();\n      }\n\n      this.discoverComponents(el => {\n        this.initializeComponent(el);\n      }); // It's easier and more performant to just support Turbolinks than listen\n      // to MutationObserver mutations at the document level.\n\n      document.addEventListener(\"turbolinks:load\", () => {\n        this.discoverUninitializedComponents(el => {\n          this.initializeComponent(el);\n        });\n      });\n      this.listenForNewUninitializedComponentsAtRunTime();\n    },\n    discoverComponents: function discoverComponents(callback) {\n      const rootEls = document.querySelectorAll('[x-data]');\n      rootEls.forEach(rootEl => {\n        callback(rootEl);\n      });\n    },\n    discoverUninitializedComponents: function discoverUninitializedComponents(callback, el = null) {\n      const rootEls = (el || document).querySelectorAll('[x-data]');\n      Array.from(rootEls).filter(el => el.__x === undefined).forEach(rootEl => {\n        callback(rootEl);\n      });\n    },\n    listenForNewUninitializedComponentsAtRunTime: function listenForNewUninitializedComponentsAtRunTime() {\n      const targetNode = document.querySelector('body');\n      const observerOptions = {\n        childList: true,\n        attributes: true,\n        subtree: true\n      };\n      const observer = new MutationObserver(mutations => {\n        if (this.pauseMutationObserver) return;\n\n        for (let i = 0; i < mutations.length; i++) {\n          if (mutations[i].addedNodes.length > 0) {\n            mutations[i].addedNodes.forEach(node => {\n              // Discard non-element nodes (like line-breaks)\n              if (node.nodeType !== 1) return; // Discard any changes happening within an existing component.\n              // They will take care of themselves.\n\n              if (node.parentElement && node.parentElement.closest('[x-data]')) return;\n              this.discoverUninitializedComponents(el => {\n                this.initializeComponent(el);\n              }, node.parentElement);\n            });\n          }\n        }\n      });\n      observer.observe(targetNode, observerOptions);\n    },\n    initializeComponent: function initializeComponent(el) {\n      if (!el.__x) {\n        // Wrap in a try/catch so that we don't prevent other components\n        // from initializing when one component contains an error.\n        try {\n          el.__x = new Component(el);\n        } catch (error) {\n          setTimeout(() => {\n            throw error;\n          }, 0);\n        }\n      }\n    },\n    clone: function clone(component, newEl) {\n      if (!newEl.__x) {\n        newEl.__x = new Component(newEl, component);\n      }\n    },\n    addMagicProperty: function addMagicProperty(name, callback) {\n      this.magicProperties[name] = callback;\n    },\n    onComponentInitialized: function onComponentInitialized(callback) {\n      this.onComponentInitializeds.push(callback);\n    },\n    onBeforeComponentInitialized: function onBeforeComponentInitialized(callback) {\n      this.onBeforeComponentInitializeds.push(callback);\n    }\n  };\n\n  if (!isTesting()) {\n    window.Alpine = Alpine;\n\n    if (window.deferLoadingAlpine) {\n      window.deferLoadingAlpine(function () {\n        window.Alpine.start();\n      });\n    } else {\n      window.Alpine.start();\n    }\n  }\n\n  return Alpine;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9hbHBpbmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9hbHBpbmUuanM/ZGYyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkFscGluZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICAgIGlmIChpICUgMikge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8vIFRoYW5rcyBAc3RpbXVsdXM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGltdWx1c2pzL3N0aW11bHVzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzLyU0MHN0aW11bHVzL2NvcmUvc3JjL2FwcGxpY2F0aW9uLnRzXG4gIGZ1bmN0aW9uIGRvbVJlYWR5KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIHJlc29sdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFycmF5VW5pcXVlKGFycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnJheSkpO1xuICB9XG4gIGZ1bmN0aW9uIGlzVGVzdGluZygpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIk5vZGUuanNcIikgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKHZhbHVlQSwgdmFsdWVCKSB7XG4gICAgcmV0dXJuIHZhbHVlQSA9PSB2YWx1ZUI7XG4gIH1cbiAgZnVuY3Rpb24gd2FybklmTWFsZm9ybWVkVGVtcGxhdGUoZWwsIGRpcmVjdGl2ZSkge1xuICAgIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQWxwaW5lOiBbJHtkaXJlY3RpdmV9XSBkaXJlY3RpdmUgc2hvdWxkIG9ubHkgYmUgYWRkZWQgdG8gPHRlbXBsYXRlPiB0YWdzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FscGluZWpzL2FscGluZSMke2RpcmVjdGl2ZX1gKTtcbiAgICB9IGVsc2UgaWYgKGVsLmNvbnRlbnQuY2hpbGRFbGVtZW50Q291bnQgIT09IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQWxwaW5lOiA8dGVtcGxhdGU+IHRhZyB3aXRoIFske2RpcmVjdGl2ZX1dIGVuY291bnRlcmVkIHdpdGggbXVsdGlwbGUgZWxlbWVudCByb290cy4gTWFrZSBzdXJlIDx0ZW1wbGF0ZT4gb25seSBoYXMgYSBzaW5nbGUgY2hpbGQgZWxlbWVudC5gKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24ga2ViYWJDYXNlKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS5yZXBsYWNlKC9bX1xcc10vLCAnLScpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2FtZWxDYXNlKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oXFx3KS9nLCAobWF0Y2gsIGNoYXIpID0+IGNoYXIudG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgZnVuY3Rpb24gd2FsayhlbCwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2soZWwpID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGxldCBub2RlID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgd2Fsayhub2RlLCBjYWxsYmFjayk7XG4gICAgICBub2RlID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLFxuICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH07XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZWwsIGV4cHJlc3Npb24sIGVycm9yKSA9PiB7XG4gICAgY29uc29sZS53YXJuKGBBbHBpbmUgRXJyb3I6IFwiJHtlcnJvcn1cIlxcblxcbkV4cHJlc3Npb246IFwiJHtleHByZXNzaW9ufVwiXFxuRWxlbWVudDpgLCBlbCk7XG5cbiAgICBpZiAoIWlzVGVzdGluZygpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goY2IsIHtcbiAgICBlbCxcbiAgICBleHByZXNzaW9uXG4gIH0pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjYigpO1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSA/IHZhbHVlLmNhdGNoKGUgPT4gaGFuZGxlRXJyb3IoZWwsIGV4cHJlc3Npb24sIGUpKSA6IHZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVsLCBleHByZXNzaW9uLCBlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlckV2YWwoZWwsIGV4cHJlc3Npb24sIGRhdGFDb250ZXh0LCBhZGRpdGlvbmFsSGVscGVyVmFyaWFibGVzID0ge30pIHtcbiAgICByZXR1cm4gdHJ5Q2F0Y2goKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uLmNhbGwoZGF0YUNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFsnJGRhdGEnLCAuLi5PYmplY3Qua2V5cyhhZGRpdGlvbmFsSGVscGVyVmFyaWFibGVzKV0sIGB2YXIgX19hbHBpbmVfcmVzdWx0OyB3aXRoKCRkYXRhKSB7IF9fYWxwaW5lX3Jlc3VsdCA9ICR7ZXhwcmVzc2lvbn0gfTsgcmV0dXJuIF9fYWxwaW5lX3Jlc3VsdGApKGRhdGFDb250ZXh0LCAuLi5PYmplY3QudmFsdWVzKGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMpKTtcbiAgICB9LCB7XG4gICAgICBlbCxcbiAgICAgIGV4cHJlc3Npb25cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzYWZlckV2YWxOb1JldHVybihlbCwgZXhwcmVzc2lvbiwgZGF0YUNvbnRleHQsIGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMgPSB7fSkge1xuICAgIHJldHVybiB0cnlDYXRjaCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShleHByZXNzaW9uLmNhbGwoZGF0YUNvbnRleHQsIGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXNbJyRldmVudCddKSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBBc3luY0Z1bmN0aW9uID0gRnVuY3Rpb247XG4gICAgICAvKiBNT0RFUk4tT05MWTpTVEFSVCAqL1xuXG4gICAgICBBc3luY0Z1bmN0aW9uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGFzeW5jIGZ1bmN0aW9uICgpIHt9KS5jb25zdHJ1Y3RvcjtcbiAgICAgIC8qIE1PREVSTi1PTkxZOkVORCAqL1xuICAgICAgLy8gRm9yIHRoZSBjYXNlcyB3aGVuIHVzZXJzIHBhc3Mgb25seSBhIGZ1bmN0aW9uIHJlZmVyZW5jZSB0byB0aGUgY2FsbGVyOiBgeC1vbjpjbGljaz1cImZvb1wiYFxuICAgICAgLy8gV2hlcmUgXCJmb29cIiBpcyBhIGZ1bmN0aW9uLiBBbHNvLCB3ZSdsbCBwYXNzIHRoZSBmdW5jdGlvbiB0aGUgZXZlbnQgaW5zdGFuY2Ugd2hlbiB3ZSBjYWxsIGl0LlxuXG4gICAgICBpZiAoT2JqZWN0LmtleXMoZGF0YUNvbnRleHQpLmluY2x1ZGVzKGV4cHJlc3Npb24pKSB7XG4gICAgICAgIGxldCBtZXRob2RSZWZlcmVuY2UgPSBuZXcgRnVuY3Rpb24oWydkYXRhQ29udGV4dCcsIC4uLk9iamVjdC5rZXlzKGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMpXSwgYHdpdGgoZGF0YUNvbnRleHQpIHsgcmV0dXJuICR7ZXhwcmVzc2lvbn0gfWApKGRhdGFDb250ZXh0LCAuLi5PYmplY3QudmFsdWVzKGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMpKTtcblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZFJlZmVyZW5jZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWV0aG9kUmVmZXJlbmNlLmNhbGwoZGF0YUNvbnRleHQsIGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXNbJyRldmVudCddKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEFzeW5jRnVuY3Rpb24oWydkYXRhQ29udGV4dCcsIC4uLk9iamVjdC5rZXlzKGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMpXSwgYHdpdGgoZGF0YUNvbnRleHQpIHsgJHtleHByZXNzaW9ufSB9YCkoZGF0YUNvbnRleHQsIC4uLk9iamVjdC52YWx1ZXMoYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcykpKTtcbiAgICB9LCB7XG4gICAgICBlbCxcbiAgICAgIGV4cHJlc3Npb25cbiAgICB9KTtcbiAgfVxuICBjb25zdCB4QXR0clJFID0gL154LShvbnxiaW5kfGRhdGF8dGV4dHxodG1sfG1vZGVsfGlmfGZvcnxzaG93fGNsb2FrfHRyYW5zaXRpb258cmVmfHNwcmVhZClcXGIvO1xuICBmdW5jdGlvbiBpc1hBdHRyKGF0dHIpIHtcbiAgICBjb25zdCBuYW1lID0gcmVwbGFjZUF0QW5kQ29sb25XaXRoU3RhbmRhcmRTeW50YXgoYXR0ci5uYW1lKTtcbiAgICByZXR1cm4geEF0dHJSRS50ZXN0KG5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFhBdHRycyhlbCwgY29tcG9uZW50LCB0eXBlKSB7XG4gICAgbGV0IGRpcmVjdGl2ZXMgPSBBcnJheS5mcm9tKGVsLmF0dHJpYnV0ZXMpLmZpbHRlcihpc1hBdHRyKS5tYXAocGFyc2VIdG1sQXR0cmlidXRlKTsgLy8gR2V0IGFuIG9iamVjdCBvZiBkaXJlY3RpdmVzIGZyb20geC1zcHJlYWQuXG5cbiAgICBsZXQgc3ByZWFkRGlyZWN0aXZlID0gZGlyZWN0aXZlcy5maWx0ZXIoZGlyZWN0aXZlID0+IGRpcmVjdGl2ZS50eXBlID09PSAnc3ByZWFkJylbMF07XG5cbiAgICBpZiAoc3ByZWFkRGlyZWN0aXZlKSB7XG4gICAgICBsZXQgc3ByZWFkT2JqZWN0ID0gc2FmZXJFdmFsKGVsLCBzcHJlYWREaXJlY3RpdmUuZXhwcmVzc2lvbiwgY29tcG9uZW50LiRkYXRhKTsgLy8gQWRkIHgtc3ByZWFkIGRpcmVjdGl2ZXMgdG8gdGhlIHBpbGUgb2YgZXhpc3RpbmcgZGlyZWN0aXZlcy5cblxuICAgICAgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXMuY29uY2F0KE9iamVjdC5lbnRyaWVzKHNwcmVhZE9iamVjdCkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiBwYXJzZUh0bWxBdHRyaWJ1dGUoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSkpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSkgcmV0dXJuIGRpcmVjdGl2ZXMuZmlsdGVyKGkgPT4gaS50eXBlID09PSB0eXBlKTtcbiAgICByZXR1cm4gc29ydERpcmVjdGl2ZXMoZGlyZWN0aXZlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBzb3J0RGlyZWN0aXZlcyhkaXJlY3RpdmVzKSB7XG4gICAgbGV0IGRpcmVjdGl2ZU9yZGVyID0gWydiaW5kJywgJ21vZGVsJywgJ3Nob3cnLCAnY2F0Y2gtYWxsJ107XG4gICAgcmV0dXJuIGRpcmVjdGl2ZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgbGV0IHR5cGVBID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihhLnR5cGUpID09PSAtMSA/ICdjYXRjaC1hbGwnIDogYS50eXBlO1xuICAgICAgbGV0IHR5cGVCID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihiLnR5cGUpID09PSAtMSA/ICdjYXRjaC1hbGwnIDogYi50eXBlO1xuICAgICAgcmV0dXJuIGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YodHlwZUEpIC0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZih0eXBlQik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUh0bWxBdHRyaWJ1dGUoe1xuICAgIG5hbWUsXG4gICAgdmFsdWVcbiAgfSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gcmVwbGFjZUF0QW5kQ29sb25XaXRoU3RhbmRhcmRTeW50YXgobmFtZSk7XG4gICAgY29uc3QgdHlwZU1hdGNoID0gbm9ybWFsaXplZE5hbWUubWF0Y2goeEF0dHJSRSk7XG4gICAgY29uc3QgdmFsdWVNYXRjaCA9IG5vcm1hbGl6ZWROYW1lLm1hdGNoKC86KFthLXpBLVowLTlcXC06XSspLyk7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gbm9ybWFsaXplZE5hbWUubWF0Y2goL1xcLlteLlxcXV0rKD89W15cXF1dKiQpL2cpIHx8IFtdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlTWF0Y2ggPyB0eXBlTWF0Y2hbMV0gOiBudWxsLFxuICAgICAgdmFsdWU6IHZhbHVlTWF0Y2ggPyB2YWx1ZU1hdGNoWzFdIDogbnVsbCxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLm1hcChpID0+IGkucmVwbGFjZSgnLicsICcnKSksXG4gICAgICBleHByZXNzaW9uOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaXNCb29sZWFuQXR0cihhdHRyTmFtZSkge1xuICAgIC8vIEFzIHBlciBIVE1MIHNwZWMgdGFibGUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2F0dHJpYnV0ZXMtMzpib29sZWFuLWF0dHJpYnV0ZVxuICAgIC8vIEFycmF5IHJvdWdobHkgb3JkZXJlZCBieSBlc3RpbWF0ZWQgdXNhZ2VcbiAgICBjb25zdCBib29sZWFuQXR0cmlidXRlcyA9IFsnZGlzYWJsZWQnLCAnY2hlY2tlZCcsICdyZXF1aXJlZCcsICdyZWFkb25seScsICdoaWRkZW4nLCAnb3BlbicsICdzZWxlY3RlZCcsICdhdXRvZm9jdXMnLCAnaXRlbXNjb3BlJywgJ211bHRpcGxlJywgJ25vdmFsaWRhdGUnLCAnYWxsb3dmdWxsc2NyZWVuJywgJ2FsbG93cGF5bWVudHJlcXVlc3QnLCAnZm9ybW5vdmFsaWRhdGUnLCAnYXV0b3BsYXknLCAnY29udHJvbHMnLCAnbG9vcCcsICdtdXRlZCcsICdwbGF5c2lubGluZScsICdkZWZhdWx0JywgJ2lzbWFwJywgJ3JldmVyc2VkJywgJ2FzeW5jJywgJ2RlZmVyJywgJ25vbW9kdWxlJ107XG4gICAgcmV0dXJuIGJvb2xlYW5BdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHJOYW1lKTtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlQXRBbmRDb2xvbldpdGhTdGFuZGFyZFN5bnRheChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnQCcpKSB7XG4gICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKCdAJywgJ3gtb246Jyk7XG4gICAgfSBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJzonKSkge1xuICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgnOicsICd4LWJpbmQ6Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShjbGFzc0xpc3QsIGZpbHRlckZuID0gQm9vbGVhbikge1xuICAgIHJldHVybiBjbGFzc0xpc3Quc3BsaXQoJyAnKS5maWx0ZXIoZmlsdGVyRm4pO1xuICB9XG4gIGNvbnN0IFRSQU5TSVRJT05fVFlQRV9JTiA9ICdpbic7XG4gIGNvbnN0IFRSQU5TSVRJT05fVFlQRV9PVVQgPSAnb3V0JztcbiAgY29uc3QgVFJBTlNJVElPTl9DQU5DRUxMRUQgPSAnY2FuY2VsbGVkJztcbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkluKGVsLCBzaG93LCByZWplY3QsIGNvbXBvbmVudCwgZm9yY2VTa2lwID0gZmFsc2UpIHtcbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRyYW5zaXRpb24gb24gdGhlIGluaXRpYWwgcGFnZSBsb2FkLlxuICAgIGlmIChmb3JjZVNraXApIHJldHVybiBzaG93KCk7XG5cbiAgICBpZiAoZWwuX194X3RyYW5zaXRpb24gJiYgZWwuX194X3RyYW5zaXRpb24udHlwZSA9PT0gVFJBTlNJVElPTl9UWVBFX0lOKSB7XG4gICAgICAvLyB0aGVyZSBpcyBhbHJlYWR5IGEgc2ltaWxhciB0cmFuc2l0aW9uIGdvaW5nIG9uLCB0aGlzIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgYnlcbiAgICAgIC8vIGEgY2hhbmdlIGluIGEgZGlmZmVyZW50IHByb3BlcnR5LCBsZXQncyBqdXN0IGxlYXZlIHRoZSBwcmV2aW91cyBvbmUgZG9pbmcgaXRzIGpvYlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJzID0gZ2V0WEF0dHJzKGVsLCBjb21wb25lbnQsICd0cmFuc2l0aW9uJyk7XG4gICAgY29uc3Qgc2hvd0F0dHIgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ3Nob3cnKVswXTsgLy8gSWYgdGhpcyBpcyB0cmlnZ2VyZWQgYnkgYSB4LXNob3cudHJhbnNpdGlvbi5cblxuICAgIGlmIChzaG93QXR0ciAmJiBzaG93QXR0ci5tb2RpZmllcnMuaW5jbHVkZXMoJ3RyYW5zaXRpb24nKSkge1xuICAgICAgbGV0IG1vZGlmaWVycyA9IHNob3dBdHRyLm1vZGlmaWVyczsgLy8gSWYgeC1zaG93LnRyYW5zaXRpb24ub3V0LCB3ZSdsbCBza2lwIHRoZSBcImluXCIgdHJhbnNpdGlvbi5cblxuICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnb3V0JykgJiYgIW1vZGlmaWVycy5pbmNsdWRlcygnaW4nKSkgcmV0dXJuIHNob3coKTtcbiAgICAgIGNvbnN0IHNldHRpbmdCb3RoU2lkZXNPZlRyYW5zaXRpb24gPSBtb2RpZmllcnMuaW5jbHVkZXMoJ2luJykgJiYgbW9kaWZpZXJzLmluY2x1ZGVzKCdvdXQnKTsgLy8gSWYgeC1zaG93LnRyYW5zaXRpb24uaW4uLi5vdXQuLi4gb25seSB1c2UgXCJpblwiIHJlbGF0ZWQgbW9kaWZpZXJzIGZvciB0aGlzIHRyYW5zaXRpb24uXG5cbiAgICAgIG1vZGlmaWVycyA9IHNldHRpbmdCb3RoU2lkZXNPZlRyYW5zaXRpb24gPyBtb2RpZmllcnMuZmlsdGVyKChpLCBpbmRleCkgPT4gaW5kZXggPCBtb2RpZmllcnMuaW5kZXhPZignb3V0JykpIDogbW9kaWZpZXJzO1xuICAgICAgdHJhbnNpdGlvbkhlbHBlckluKGVsLCBtb2RpZmllcnMsIHNob3csIHJlamVjdCk7IC8vIE90aGVyd2lzZSwgd2UgY2FuIGFzc3VtZSB4LXRyYW5zaXRpb246ZW50ZXIuXG4gICAgfSBlbHNlIGlmIChhdHRycy5zb21lKGF0dHIgPT4gWydlbnRlcicsICdlbnRlci1zdGFydCcsICdlbnRlci1lbmQnXS5pbmNsdWRlcyhhdHRyLnZhbHVlKSkpIHtcbiAgICAgIHRyYW5zaXRpb25DbGFzc2VzSW4oZWwsIGNvbXBvbmVudCwgYXR0cnMsIHNob3csIHJlamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5laXRoZXIsIGp1c3Qgc2hvdyB0aGF0IGRhbW4gdGhpbmcuXG4gICAgICBzaG93KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25PdXQoZWwsIGhpZGUsIHJlamVjdCwgY29tcG9uZW50LCBmb3JjZVNraXAgPSBmYWxzZSkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJhbnNpdGlvbiBvbiB0aGUgaW5pdGlhbCBwYWdlIGxvYWQuXG4gICAgaWYgKGZvcmNlU2tpcCkgcmV0dXJuIGhpZGUoKTtcblxuICAgIGlmIChlbC5fX3hfdHJhbnNpdGlvbiAmJiBlbC5fX3hfdHJhbnNpdGlvbi50eXBlID09PSBUUkFOU0lUSU9OX1RZUEVfT1VUKSB7XG4gICAgICAvLyB0aGVyZSBpcyBhbHJlYWR5IGEgc2ltaWxhciB0cmFuc2l0aW9uIGdvaW5nIG9uLCB0aGlzIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgYnlcbiAgICAgIC8vIGEgY2hhbmdlIGluIGEgZGlmZmVyZW50IHByb3BlcnR5LCBsZXQncyBqdXN0IGxlYXZlIHRoZSBwcmV2aW91cyBvbmUgZG9pbmcgaXRzIGpvYlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJzID0gZ2V0WEF0dHJzKGVsLCBjb21wb25lbnQsICd0cmFuc2l0aW9uJyk7XG4gICAgY29uc3Qgc2hvd0F0dHIgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ3Nob3cnKVswXTtcblxuICAgIGlmIChzaG93QXR0ciAmJiBzaG93QXR0ci5tb2RpZmllcnMuaW5jbHVkZXMoJ3RyYW5zaXRpb24nKSkge1xuICAgICAgbGV0IG1vZGlmaWVycyA9IHNob3dBdHRyLm1vZGlmaWVycztcbiAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2luJykgJiYgIW1vZGlmaWVycy5pbmNsdWRlcygnb3V0JykpIHJldHVybiBoaWRlKCk7XG4gICAgICBjb25zdCBzZXR0aW5nQm90aFNpZGVzT2ZUcmFuc2l0aW9uID0gbW9kaWZpZXJzLmluY2x1ZGVzKCdpbicpICYmIG1vZGlmaWVycy5pbmNsdWRlcygnb3V0Jyk7XG4gICAgICBtb2RpZmllcnMgPSBzZXR0aW5nQm90aFNpZGVzT2ZUcmFuc2l0aW9uID8gbW9kaWZpZXJzLmZpbHRlcigoaSwgaW5kZXgpID0+IGluZGV4ID4gbW9kaWZpZXJzLmluZGV4T2YoJ291dCcpKSA6IG1vZGlmaWVycztcbiAgICAgIHRyYW5zaXRpb25IZWxwZXJPdXQoZWwsIG1vZGlmaWVycywgc2V0dGluZ0JvdGhTaWRlc09mVHJhbnNpdGlvbiwgaGlkZSwgcmVqZWN0KTtcbiAgICB9IGVsc2UgaWYgKGF0dHJzLnNvbWUoYXR0ciA9PiBbJ2xlYXZlJywgJ2xlYXZlLXN0YXJ0JywgJ2xlYXZlLWVuZCddLmluY2x1ZGVzKGF0dHIudmFsdWUpKSkge1xuICAgICAgdHJhbnNpdGlvbkNsYXNzZXNPdXQoZWwsIGNvbXBvbmVudCwgYXR0cnMsIGhpZGUsIHJlamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkhlbHBlckluKGVsLCBtb2RpZmllcnMsIHNob3dDYWxsYmFjaywgcmVqZWN0KSB7XG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgaW5zcGlyZWQgYnk6IGh0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL21vdGlvbi9zcGVlZC5odG1sI2R1cmF0aW9uXG4gICAgY29uc3Qgc3R5bGVWYWx1ZXMgPSB7XG4gICAgICBkdXJhdGlvbjogbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdkdXJhdGlvbicsIDE1MCksXG4gICAgICBvcmlnaW46IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCAnb3JpZ2luJywgJ2NlbnRlcicpLFxuICAgICAgZmlyc3Q6IHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgc2NhbGU6IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCAnc2NhbGUnLCA5NSlcbiAgICAgIH0sXG4gICAgICBzZWNvbmQ6IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc2NhbGU6IDEwMFxuICAgICAgfVxuICAgIH07XG4gICAgdHJhbnNpdGlvbkhlbHBlcihlbCwgbW9kaWZpZXJzLCBzaG93Q2FsbGJhY2ssICgpID0+IHt9LCByZWplY3QsIHN0eWxlVmFsdWVzLCBUUkFOU0lUSU9OX1RZUEVfSU4pO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25IZWxwZXJPdXQoZWwsIG1vZGlmaWVycywgc2V0dGluZ0JvdGhTaWRlc09mVHJhbnNpdGlvbiwgaGlkZUNhbGxiYWNrLCByZWplY3QpIHtcbiAgICAvLyBNYWtlIHRoZSBcIm91dFwiIHRyYW5zaXRpb24gLjV4IHNsb3dlciB0aGFuIHRoZSBcImluXCIuIChWaXN1YWxseSBiZXR0ZXIpXG4gICAgLy8gSE9XRVZFUiwgaWYgdGhleSBleHBsaWNpdGx5IHNldCBhIGR1cmF0aW9uIGZvciB0aGUgXCJvdXRcIiB0cmFuc2l0aW9uLFxuICAgIC8vIHVzZSB0aGF0LlxuICAgIGNvbnN0IGR1cmF0aW9uID0gc2V0dGluZ0JvdGhTaWRlc09mVHJhbnNpdGlvbiA/IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCAnZHVyYXRpb24nLCAxNTApIDogbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdkdXJhdGlvbicsIDE1MCkgLyAyO1xuICAgIGNvbnN0IHN0eWxlVmFsdWVzID0ge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgb3JpZ2luOiBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgJ29yaWdpbicsICdjZW50ZXInKSxcbiAgICAgIGZpcnN0OiB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHNjYWxlOiAxMDBcbiAgICAgIH0sXG4gICAgICBzZWNvbmQ6IHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgc2NhbGU6IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCAnc2NhbGUnLCA5NSlcbiAgICAgIH1cbiAgICB9O1xuICAgIHRyYW5zaXRpb25IZWxwZXIoZWwsIG1vZGlmaWVycywgKCkgPT4ge30sIGhpZGVDYWxsYmFjaywgcmVqZWN0LCBzdHlsZVZhbHVlcywgVFJBTlNJVElPTl9UWVBFX09VVCk7XG4gIH1cblxuICBmdW5jdGlvbiBtb2RpZmllclZhbHVlKG1vZGlmaWVycywga2V5LCBmYWxsYmFjaykge1xuICAgIC8vIElmIHRoZSBtb2RpZmllciBpc24ndCBwcmVzZW50LCB1c2UgdGhlIGRlZmF1bHQuXG4gICAgaWYgKG1vZGlmaWVycy5pbmRleE9mKGtleSkgPT09IC0xKSByZXR1cm4gZmFsbGJhY2s7IC8vIElmIGl0IElTIHByZXNlbnQsIGdyYWIgdGhlIHZhbHVlIGFmdGVyIGl0OiB4LXNob3cudHJhbnNpdGlvbi5kdXJhdGlvbi41MDBtc1xuXG4gICAgY29uc3QgcmF3VmFsdWUgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDFdO1xuICAgIGlmICghcmF3VmFsdWUpIHJldHVybiBmYWxsYmFjaztcblxuICAgIGlmIChrZXkgPT09ICdzY2FsZScpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSB2ZXJ5IG5leHQgdmFsdWUgaXMgTk9UIGEgbnVtYmVyIGFuZCByZXR1cm4gdGhlIGZhbGxiYWNrLlxuICAgICAgLy8gSWYgeC1zaG93LnRyYW5zaXRpb24uc2NhbGUsIHdlJ2xsIHVzZSB0aGUgZGVmYXVsdCBzY2FsZSB2YWx1ZS5cbiAgICAgIC8vIFRoYXQgaXMgaG93IGEgdXNlciBvcHRzIG91dCBvZiB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICAgICAgaWYgKCFpc051bWVyaWMocmF3VmFsdWUpKSByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ2R1cmF0aW9uJykge1xuICAgICAgLy8gU3VwcG9ydCB4LXNob3cudHJhbnNpdGlvbi5kdXJhdGlvbi41MDBtcyAmJiBkdXJhdGlvbi41MDBcbiAgICAgIGxldCBtYXRjaCA9IHJhd1ZhbHVlLm1hdGNoKC8oWzAtOV0rKW1zLyk7XG4gICAgICBpZiAobWF0Y2gpIHJldHVybiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnb3JpZ2luJykge1xuICAgICAgLy8gU3VwcG9ydCBjaGFpbmluZyBvcmlnaW4gZGlyZWN0aW9uczogeC1zaG93LnRyYW5zaXRpb24udG9wLnJpZ2h0XG4gICAgICBpZiAoWyd0b3AnLCAncmlnaHQnLCAnbGVmdCcsICdjZW50ZXInLCAnYm90dG9tJ10uaW5jbHVkZXMobW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAyXSkpIHtcbiAgICAgICAgcmV0dXJuIFtyYXdWYWx1ZSwgbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAyXV0uam9pbignICcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdWYWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25IZWxwZXIoZWwsIG1vZGlmaWVycywgaG9vazEsIGhvb2syLCByZWplY3QsIHN0eWxlVmFsdWVzLCB0eXBlKSB7XG4gICAgLy8gY2xlYXIgdGhlIHByZXZpb3VzIHRyYW5zaXRpb24gaWYgZXhpc3RzIHRvIGF2b2lkIGNhY2hpbmcgdGhlIHdyb25nIHN0eWxlc1xuICAgIGlmIChlbC5fX3hfdHJhbnNpdGlvbikge1xuICAgICAgZWwuX194X3RyYW5zaXRpb24uY2FuY2VsICYmIGVsLl9feF90cmFuc2l0aW9uLmNhbmNlbCgpO1xuICAgIH0gLy8gSWYgdGhlIHVzZXIgc2V0IHRoZXNlIHN0eWxlIHZhbHVlcywgd2UnbGwgcHV0IHRoZW0gYmFjayB3aGVuIHdlJ3JlIGRvbmUgd2l0aCB0aGVtLlxuXG5cbiAgICBjb25zdCBvcGFjaXR5Q2FjaGUgPSBlbC5zdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHRyYW5zZm9ybUNhY2hlID0gZWwuc3R5bGUudHJhbnNmb3JtO1xuICAgIGNvbnN0IHRyYW5zZm9ybU9yaWdpbkNhY2hlID0gZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luOyAvLyBJZiBubyBtb2RpZmllcnMgYXJlIHByZXNlbnQ6IHgtc2hvdy50cmFuc2l0aW9uLCB3ZSdsbCBkZWZhdWx0IHRvIGJvdGggb3BhY2l0eSBhbmQgc2NhbGUuXG5cbiAgICBjb25zdCBub01vZGlmaWVycyA9ICFtb2RpZmllcnMuaW5jbHVkZXMoJ29wYWNpdHknKSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKCdzY2FsZScpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25PcGFjaXR5ID0gbm9Nb2RpZmllcnMgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKCdvcGFjaXR5Jyk7XG4gICAgY29uc3QgdHJhbnNpdGlvblNjYWxlID0gbm9Nb2RpZmllcnMgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKCdzY2FsZScpOyAvLyBUaGVzZSBhcmUgdGhlIGV4cGxpY2l0IHN0YWdlcyBvZiBhIHRyYW5zaXRpb24gKHNhbWUgc3RhZ2VzIGZvciBpbiBhbmQgZm9yIG91dCkuXG4gICAgLy8gVGhpcyB3YXkgeW91IGNhbiBnZXQgYSBiaXJkcyBleWUgdmlldyBvZiB0aGUgaG9va3MsIGFuZCB0aGUgZGlmZmVyZW5jZXNcbiAgICAvLyBiZXR3ZWVuIHRoZW0uXG5cbiAgICBjb25zdCBzdGFnZXMgPSB7XG4gICAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25PcGFjaXR5KSBlbC5zdHlsZS5vcGFjaXR5ID0gc3R5bGVWYWx1ZXMuZmlyc3Qub3BhY2l0eTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25TY2FsZSkgZWwuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7c3R5bGVWYWx1ZXMuZmlyc3Quc2NhbGUgLyAxMDB9KWA7XG4gICAgICB9LFxuXG4gICAgICBkdXJpbmcoKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uU2NhbGUpIGVsLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlVmFsdWVzLm9yaWdpbjtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gW3RyYW5zaXRpb25PcGFjaXR5ID8gYG9wYWNpdHlgIDogYGAsIHRyYW5zaXRpb25TY2FsZSA/IGB0cmFuc2Zvcm1gIDogYGBdLmpvaW4oJyAnKS50cmltKCk7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke3N0eWxlVmFsdWVzLmR1cmF0aW9uIC8gMTAwMH1zYDtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID0gYGN1YmljLWJlemllcigwLjQsIDAuMCwgMC4yLCAxKWA7XG4gICAgICB9LFxuXG4gICAgICBzaG93KCkge1xuICAgICAgICBob29rMSgpO1xuICAgICAgfSxcblxuICAgICAgZW5kKCkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbk9wYWNpdHkpIGVsLnN0eWxlLm9wYWNpdHkgPSBzdHlsZVZhbHVlcy5zZWNvbmQub3BhY2l0eTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25TY2FsZSkgZWwuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7c3R5bGVWYWx1ZXMuc2Vjb25kLnNjYWxlIC8gMTAwfSlgO1xuICAgICAgfSxcblxuICAgICAgaGlkZSgpIHtcbiAgICAgICAgaG9vazIoKTtcbiAgICAgIH0sXG5cbiAgICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uT3BhY2l0eSkgZWwuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHlDYWNoZTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25TY2FsZSkgZWwuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtQ2FjaGU7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uU2NhbGUpIGVsLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHRyYW5zZm9ybU9yaWdpbkNhY2hlO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBudWxsO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgfTtcbiAgICB0cmFuc2l0aW9uKGVsLCBzdGFnZXMsIHR5cGUsIHJlamVjdCk7XG4gIH1cblxuICBjb25zdCBlbnN1cmVTdHJpbmdFeHByZXNzaW9uID0gKGV4cHJlc3Npb24sIGVsLCBjb21wb25lbnQpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGV4cHJlc3Npb24gPT09ICdmdW5jdGlvbicgPyBjb21wb25lbnQuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBleHByZXNzaW9uKSA6IGV4cHJlc3Npb247XG4gIH07XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkNsYXNzZXNJbihlbCwgY29tcG9uZW50LCBkaXJlY3RpdmVzLCBzaG93Q2FsbGJhY2ssIHJlamVjdCkge1xuICAgIGNvbnN0IGVudGVyID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnZW50ZXInKSB8fCB7XG4gICAgICBleHByZXNzaW9uOiAnJ1xuICAgIH0pLmV4cHJlc3Npb24sIGVsLCBjb21wb25lbnQpKTtcbiAgICBjb25zdCBlbnRlclN0YXJ0ID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnZW50ZXItc3RhcnQnKSB8fCB7XG4gICAgICBleHByZXNzaW9uOiAnJ1xuICAgIH0pLmV4cHJlc3Npb24sIGVsLCBjb21wb25lbnQpKTtcbiAgICBjb25zdCBlbnRlckVuZCA9IGNvbnZlcnRDbGFzc1N0cmluZ1RvQXJyYXkoZW5zdXJlU3RyaW5nRXhwcmVzc2lvbigoZGlyZWN0aXZlcy5maW5kKGkgPT4gaS52YWx1ZSA9PT0gJ2VudGVyLWVuZCcpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIHRyYW5zaXRpb25DbGFzc2VzKGVsLCBlbnRlciwgZW50ZXJTdGFydCwgZW50ZXJFbmQsIHNob3dDYWxsYmFjaywgKCkgPT4ge30sIFRSQU5TSVRJT05fVFlQRV9JTiwgcmVqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2l0aW9uQ2xhc3Nlc091dChlbCwgY29tcG9uZW50LCBkaXJlY3RpdmVzLCBoaWRlQ2FsbGJhY2ssIHJlamVjdCkge1xuICAgIGNvbnN0IGxlYXZlID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnbGVhdmUnKSB8fCB7XG4gICAgICBleHByZXNzaW9uOiAnJ1xuICAgIH0pLmV4cHJlc3Npb24sIGVsLCBjb21wb25lbnQpKTtcbiAgICBjb25zdCBsZWF2ZVN0YXJ0ID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnbGVhdmUtc3RhcnQnKSB8fCB7XG4gICAgICBleHByZXNzaW9uOiAnJ1xuICAgIH0pLmV4cHJlc3Npb24sIGVsLCBjb21wb25lbnQpKTtcbiAgICBjb25zdCBsZWF2ZUVuZCA9IGNvbnZlcnRDbGFzc1N0cmluZ1RvQXJyYXkoZW5zdXJlU3RyaW5nRXhwcmVzc2lvbigoZGlyZWN0aXZlcy5maW5kKGkgPT4gaS52YWx1ZSA9PT0gJ2xlYXZlLWVuZCcpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIHRyYW5zaXRpb25DbGFzc2VzKGVsLCBsZWF2ZSwgbGVhdmVTdGFydCwgbGVhdmVFbmQsICgpID0+IHt9LCBoaWRlQ2FsbGJhY2ssIFRSQU5TSVRJT05fVFlQRV9PVVQsIHJlamVjdCk7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkNsYXNzZXMoZWwsIGNsYXNzZXNEdXJpbmcsIGNsYXNzZXNTdGFydCwgY2xhc3Nlc0VuZCwgaG9vazEsIGhvb2syLCB0eXBlLCByZWplY3QpIHtcbiAgICAvLyBjbGVhciB0aGUgcHJldmlvdXMgdHJhbnNpdGlvbiBpZiBleGlzdHMgdG8gYXZvaWQgY2FjaGluZyB0aGUgd3JvbmcgY2xhc3Nlc1xuICAgIGlmIChlbC5fX3hfdHJhbnNpdGlvbikge1xuICAgICAgZWwuX194X3RyYW5zaXRpb24uY2FuY2VsICYmIGVsLl9feF90cmFuc2l0aW9uLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsQ2xhc3NlcyA9IGVsLl9feF9vcmlnaW5hbF9jbGFzc2VzIHx8IFtdO1xuICAgIGNvbnN0IHN0YWdlcyA9IHtcbiAgICAgIHN0YXJ0KCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNTdGFydCk7XG4gICAgICB9LFxuXG4gICAgICBkdXJpbmcoKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlc0R1cmluZyk7XG4gICAgICB9LFxuXG4gICAgICBzaG93KCkge1xuICAgICAgICBob29rMSgpO1xuICAgICAgfSxcblxuICAgICAgZW5kKCkge1xuICAgICAgICAvLyBEb24ndCByZW1vdmUgY2xhc3NlcyB0aGF0IHdlcmUgaW4gdGhlIG9yaWdpbmFsIGNsYXNzIGF0dHJpYnV0ZS5cbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzU3RhcnQuZmlsdGVyKGkgPT4gIW9yaWdpbmFsQ2xhc3Nlcy5pbmNsdWRlcyhpKSkpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNFbmQpO1xuICAgICAgfSxcblxuICAgICAgaGlkZSgpIHtcbiAgICAgICAgaG9vazIoKTtcbiAgICAgIH0sXG5cbiAgICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlc0R1cmluZy5maWx0ZXIoaSA9PiAhb3JpZ2luYWxDbGFzc2VzLmluY2x1ZGVzKGkpKSk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlc0VuZC5maWx0ZXIoaSA9PiAhb3JpZ2luYWxDbGFzc2VzLmluY2x1ZGVzKGkpKSk7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHRyYW5zaXRpb24oZWwsIHN0YWdlcywgdHlwZSwgcmVqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2l0aW9uKGVsLCBzdGFnZXMsIHR5cGUsIHJlamVjdCkge1xuICAgIGNvbnN0IGZpbmlzaCA9IG9uY2UoKCkgPT4ge1xuICAgICAgc3RhZ2VzLmhpZGUoKTsgLy8gQWRkaW5nIGFuIFwiaXNDb25uZWN0ZWRcIiBjaGVjaywgaW4gY2FzZSB0aGUgY2FsbGJhY2tcbiAgICAgIC8vIHJlbW92ZWQgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuXG4gICAgICBpZiAoZWwuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgc3RhZ2VzLmNsZWFudXAoKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGVsLl9feF90cmFuc2l0aW9uO1xuICAgIH0pO1xuICAgIGVsLl9feF90cmFuc2l0aW9uID0ge1xuICAgICAgLy8gU2V0IHRyYW5zaXRpb24gdHlwZSBzbyB3ZSBjYW4gYXZvaWQgY2xlYXJpbmcgdHJhbnNpdGlvbiBpZiB0aGUgZGlyZWN0aW9uIGlzIHRoZSBzYW1lXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgLy8gY3JlYXRlIGEgY2FsbGJhY2sgZm9yIHRoZSBsYXN0IHN0YWdlcyBvZiB0aGUgdHJhbnNpdGlvbiBzbyB3ZSBjYW4gY2FsbCBpdFxuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgcG9pbnQgYW5kIGVhcmx5IHRlcm1pbmF0ZSBpdC4gT25jZSB3aWxsIGVuc3VyZSB0aGF0IGZ1bmN0aW9uXG4gICAgICAvLyBpcyBvbmx5IGNhbGxlZCBvbmUgdGltZS5cbiAgICAgIGNhbmNlbDogb25jZSgoKSA9PiB7XG4gICAgICAgIHJlamVjdChUUkFOU0lUSU9OX0NBTkNFTExFRCk7XG4gICAgICAgIGZpbmlzaCgpO1xuICAgICAgfSksXG4gICAgICBmaW5pc2gsXG4gICAgICAvLyBUaGlzIHN0b3JlIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSBzbyB3ZSBjYW4gY2FuY2VsIGl0XG4gICAgICBuZXh0RnJhbWU6IG51bGxcbiAgICB9O1xuICAgIHN0YWdlcy5zdGFydCgpO1xuICAgIHN0YWdlcy5kdXJpbmcoKTtcbiAgICBlbC5fX3hfdHJhbnNpdGlvbi5uZXh0RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgLy8gTm90ZTogU2FmYXJpJ3MgdHJhbnNpdGlvbkR1cmF0aW9uIHByb3BlcnR5IHdpbGwgbGlzdCBvdXQgY29tbWEgc2VwYXJhdGVkIHRyYW5zaXRpb24gZHVyYXRpb25zXG4gICAgICAvLyBmb3IgZXZlcnkgc2luZ2xlIHRyYW5zaXRpb24gcHJvcGVydHkuIExldCdzIGdyYWIgdGhlIGZpcnN0IG9uZSBhbmQgY2FsbCBpdCBhIGRheS5cbiAgICAgIGxldCBkdXJhdGlvbiA9IE51bWJlcihnZXRDb21wdXRlZFN0eWxlKGVsKS50cmFuc2l0aW9uRHVyYXRpb24ucmVwbGFjZSgvLC4qLywgJycpLnJlcGxhY2UoJ3MnLCAnJykpICogMTAwMDtcblxuICAgICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgIGR1cmF0aW9uID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLmFuaW1hdGlvbkR1cmF0aW9uLnJlcGxhY2UoJ3MnLCAnJykpICogMTAwMDtcbiAgICAgIH1cblxuICAgICAgc3RhZ2VzLnNob3coKTtcbiAgICAgIGVsLl9feF90cmFuc2l0aW9uLm5leHRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHN0YWdlcy5lbmQoKTtcbiAgICAgICAgc2V0VGltZW91dChlbC5fX3hfdHJhbnNpdGlvbi5maW5pc2gsIGR1cmF0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGlzTnVtZXJpYyhzdWJqZWN0KSB7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbiAgfSAvLyBUaGFua3MgQHZ1ZWpzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvYmxvYi80ZGU0NjQ5ZDk2MzcyNjJhOWIwMDc3MjBiNTlmODBhYzcyYTU2MjBjL3NyYy9zaGFyZWQvdXRpbC5qc1xuXG4gIGZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUZvckRpcmVjdGl2ZShjb21wb25lbnQsIHRlbXBsYXRlRWwsIGV4cHJlc3Npb24sIGluaXRpYWxVcGRhdGUsIGV4dHJhVmFycykge1xuICAgIHdhcm5JZk1hbGZvcm1lZFRlbXBsYXRlKHRlbXBsYXRlRWwsICd4LWZvcicpO1xuICAgIGxldCBpdGVyYXRvck5hbWVzID0gdHlwZW9mIGV4cHJlc3Npb24gPT09ICdmdW5jdGlvbicgPyBwYXJzZUZvckV4cHJlc3Npb24oY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbih0ZW1wbGF0ZUVsLCBleHByZXNzaW9uKSkgOiBwYXJzZUZvckV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgbGV0IGl0ZW1zID0gZXZhbHVhdGVJdGVtc0FuZFJldHVybkVtcHR5SWZYSWZJc1ByZXNlbnRBbmRGYWxzZU9uRWxlbWVudChjb21wb25lbnQsIHRlbXBsYXRlRWwsIGl0ZXJhdG9yTmFtZXMsIGV4dHJhVmFycyk7IC8vIEFzIHdlIHdhbGsgdGhlIGFycmF5LCB3ZSdsbCBhbHNvIHdhbGsgdGhlIERPTSAodXBkYXRpbmcvY3JlYXRpbmcgYXMgd2UgZ28pLlxuXG4gICAgbGV0IGN1cnJlbnRFbCA9IHRlbXBsYXRlRWw7XG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGxldCBpdGVyYXRpb25TY29wZVZhcmlhYmxlcyA9IGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIGl0ZW0sIGluZGV4LCBpdGVtcywgZXh0cmFWYXJzKCkpO1xuICAgICAgbGV0IGN1cnJlbnRLZXkgPSBnZW5lcmF0ZUtleUZvckl0ZXJhdGlvbihjb21wb25lbnQsIHRlbXBsYXRlRWwsIGluZGV4LCBpdGVyYXRpb25TY29wZVZhcmlhYmxlcyk7XG4gICAgICBsZXQgbmV4dEVsID0gbG9va0FoZWFkRm9yTWF0Y2hpbmdLZXllZEVsZW1lbnRBbmRNb3ZlSXRJZkZvdW5kKGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmcsIGN1cnJlbnRLZXkpOyAvLyBJZiB3ZSBoYXZlbid0IGZvdW5kIGEgbWF0Y2hpbmcga2V5LCBpbnNlcnQgdGhlIGVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG5cbiAgICAgIGlmICghbmV4dEVsKSB7XG4gICAgICAgIG5leHRFbCA9IGFkZEVsZW1lbnRJbkxvb3BBZnRlckN1cnJlbnRFbCh0ZW1wbGF0ZUVsLCBjdXJyZW50RWwpOyAvLyBBbmQgdHJhbnNpdGlvbiBpdCBpbiBpZiBpdCdzIG5vdCB0aGUgZmlyc3QgcGFnZSBsb2FkLlxuXG4gICAgICAgIHRyYW5zaXRpb25JbihuZXh0RWwsICgpID0+IHt9LCAoKSA9PiB7fSwgY29tcG9uZW50LCBpbml0aWFsVXBkYXRlKTtcbiAgICAgICAgbmV4dEVsLl9feF9mb3IgPSBpdGVyYXRpb25TY29wZVZhcmlhYmxlcztcbiAgICAgICAgY29tcG9uZW50LmluaXRpYWxpemVFbGVtZW50cyhuZXh0RWwsICgpID0+IG5leHRFbC5fX3hfZm9yKTsgLy8gT3RoZXJ3aXNlIHVwZGF0ZSB0aGUgZWxlbWVudCB3ZSBmb3VuZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IHJlbW92ZSB0aGUga2V5IGluZGljYXRvciB0byBhbGxvdyB0aGUgbm9ybWFsIFwidXBkYXRlRWxlbWVudHNcIiB0byB3b3JrLlxuICAgICAgICBkZWxldGUgbmV4dEVsLl9feF9mb3Jfa2V5O1xuICAgICAgICBuZXh0RWwuX194X2ZvciA9IGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzO1xuICAgICAgICBjb21wb25lbnQudXBkYXRlRWxlbWVudHMobmV4dEVsLCAoKSA9PiBuZXh0RWwuX194X2Zvcik7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRFbCA9IG5leHRFbDtcbiAgICAgIGN1cnJlbnRFbC5fX3hfZm9yX2tleSA9IGN1cnJlbnRLZXk7XG4gICAgfSk7XG4gICAgcmVtb3ZlQW55TGVmdE92ZXJFbGVtZW50c0Zyb21QcmV2aW91c1VwZGF0ZShjdXJyZW50RWwsIGNvbXBvbmVudCk7XG4gIH0gLy8gVGhpcyB3YXMgdGFrZW4gZnJvbSBWdWVKUyAyLiogY29yZS4gVGhhbmtzIFZ1ZSFcblxuICBmdW5jdGlvbiBwYXJzZUZvckV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIGxldCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuICAgIGxldCBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuICAgIGxldCBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xuICAgIGxldCBpbk1hdGNoID0gZXhwcmVzc2lvbi5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpIHJldHVybjtcbiAgICBsZXQgcmVzID0ge307XG4gICAgcmVzLml0ZW1zID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgbGV0IGl0ZW0gPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcbiAgICBsZXQgaXRlcmF0b3JNYXRjaCA9IGl0ZW0ubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG5cbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgcmVzLml0ZW0gPSBpdGVtLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICAgIHJlcy5pbmRleCA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuXG4gICAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgICByZXMuY29sbGVjdGlvbiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMuaXRlbSA9IGl0ZW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIGl0ZW0sIGluZGV4LCBpdGVtcywgZXh0cmFWYXJzKSB7XG4gICAgLy8gV2UgbXVzdCBjcmVhdGUgYSBuZXcgb2JqZWN0LCBzbyBlYWNoIGl0ZXJhdGlvbiBoYXMgYSBuZXcgc2NvcGVcbiAgICBsZXQgc2NvcGVWYXJpYWJsZXMgPSBleHRyYVZhcnMgPyBfb2JqZWN0U3ByZWFkMih7fSwgZXh0cmFWYXJzKSA6IHt9O1xuICAgIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuaXRlbV0gPSBpdGVtO1xuICAgIGlmIChpdGVyYXRvck5hbWVzLmluZGV4KSBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLmluZGV4XSA9IGluZGV4O1xuICAgIGlmIChpdGVyYXRvck5hbWVzLmNvbGxlY3Rpb24pIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuY29sbGVjdGlvbl0gPSBpdGVtcztcbiAgICByZXR1cm4gc2NvcGVWYXJpYWJsZXM7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUtleUZvckl0ZXJhdGlvbihjb21wb25lbnQsIGVsLCBpbmRleCwgaXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMpIHtcbiAgICBsZXQgYmluZEtleUF0dHJpYnV0ZSA9IGdldFhBdHRycyhlbCwgY29tcG9uZW50LCAnYmluZCcpLmZpbHRlcihhdHRyID0+IGF0dHIudmFsdWUgPT09ICdrZXknKVswXTsgLy8gSWYgdGhlIGRldiBoYXNuJ3Qgc3BlY2lmaWVkIGEga2V5LCBqdXN0IHJldHVybiB0aGUgaW5kZXggb2YgdGhlIGl0ZXJhdGlvbi5cblxuICAgIGlmICghYmluZEtleUF0dHJpYnV0ZSkgcmV0dXJuIGluZGV4O1xuICAgIHJldHVybiBjb21wb25lbnQuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBiaW5kS2V5QXR0cmlidXRlLmV4cHJlc3Npb24sICgpID0+IGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV2YWx1YXRlSXRlbXNBbmRSZXR1cm5FbXB0eUlmWElmSXNQcmVzZW50QW5kRmFsc2VPbkVsZW1lbnQoY29tcG9uZW50LCBlbCwgaXRlcmF0b3JOYW1lcywgZXh0cmFWYXJzKSB7XG4gICAgbGV0IGlmQXR0cmlidXRlID0gZ2V0WEF0dHJzKGVsLCBjb21wb25lbnQsICdpZicpWzBdO1xuXG4gICAgaWYgKGlmQXR0cmlidXRlICYmICFjb21wb25lbnQuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBpZkF0dHJpYnV0ZS5leHByZXNzaW9uKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCBpdGVtcyA9IGNvbXBvbmVudC5ldmFsdWF0ZVJldHVybkV4cHJlc3Npb24oZWwsIGl0ZXJhdG9yTmFtZXMuaXRlbXMsIGV4dHJhVmFycyk7IC8vIFRoaXMgYWRkcyBzdXBwb3J0IGZvciB0aGUgYGkgaW4gbmAgc3ludGF4LlxuXG4gICAgaWYgKGlzTnVtZXJpYyhpdGVtcykgJiYgaXRlbXMgPiAwKSB7XG4gICAgICBpdGVtcyA9IEFycmF5LmZyb20oQXJyYXkoaXRlbXMpLmtleXMoKSwgaSA9PiBpICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRWxlbWVudEluTG9vcEFmdGVyQ3VycmVudEVsKHRlbXBsYXRlRWwsIGN1cnJlbnRFbCkge1xuICAgIGxldCBjbG9uZSA9IGRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGVFbC5jb250ZW50LCB0cnVlKTtcbiAgICBjdXJyZW50RWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICAgIHJldHVybiBjdXJyZW50RWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9va0FoZWFkRm9yTWF0Y2hpbmdLZXllZEVsZW1lbnRBbmRNb3ZlSXRJZkZvdW5kKG5leHRFbCwgY3VycmVudEtleSkge1xuICAgIGlmICghbmV4dEVsKSByZXR1cm47IC8vIElmIHdlIGFyZSBhbHJlYWR5IHBhc3QgdGhlIHgtZm9yIGdlbmVyYXRlZCBlbGVtZW50cywgd2UgZG9uJ3QgbmVlZCB0byBsb29rIGFoZWFkLlxuXG4gICAgaWYgKG5leHRFbC5fX3hfZm9yX2tleSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIElmIHRoZSB0aGUga2V5J3MgRE8gbWF0Y2gsIG5vIG5lZWQgdG8gbG9vayBhaGVhZC5cblxuICAgIGlmIChuZXh0RWwuX194X2Zvcl9rZXkgPT09IGN1cnJlbnRLZXkpIHJldHVybiBuZXh0RWw7IC8vIElmIHRoZXkgZG9uJ3QsIHdlJ2xsIGxvb2sgYWhlYWQgZm9yIGEgbWF0Y2guXG4gICAgLy8gSWYgd2UgZmluZCBpdCwgd2UnbGwgbW92ZSBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgbG9vcC5cblxuICAgIGxldCB0bXBOZXh0RWwgPSBuZXh0RWw7XG5cbiAgICB3aGlsZSAodG1wTmV4dEVsKSB7XG4gICAgICBpZiAodG1wTmV4dEVsLl9feF9mb3Jfa2V5ID09PSBjdXJyZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB0bXBOZXh0RWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodG1wTmV4dEVsLCBuZXh0RWwpO1xuICAgICAgfVxuXG4gICAgICB0bXBOZXh0RWwgPSB0bXBOZXh0RWwubmV4dEVsZW1lbnRTaWJsaW5nICYmIHRtcE5leHRFbC5uZXh0RWxlbWVudFNpYmxpbmcuX194X2Zvcl9rZXkgIT09IHVuZGVmaW5lZCA/IHRtcE5leHRFbC5uZXh0RWxlbWVudFNpYmxpbmcgOiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbnlMZWZ0T3ZlckVsZW1lbnRzRnJvbVByZXZpb3VzVXBkYXRlKGN1cnJlbnRFbCwgY29tcG9uZW50KSB7XG4gICAgdmFyIG5leHRFbGVtZW50RnJvbU9sZExvb3AgPSBjdXJyZW50RWwubmV4dEVsZW1lbnRTaWJsaW5nICYmIGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmcuX194X2Zvcl9rZXkgIT09IHVuZGVmaW5lZCA/IGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmcgOiBmYWxzZTtcblxuICAgIHdoaWxlIChuZXh0RWxlbWVudEZyb21PbGRMb29wKSB7XG4gICAgICBsZXQgbmV4dEVsZW1lbnRGcm9tT2xkTG9vcEltbXV0YWJsZSA9IG5leHRFbGVtZW50RnJvbU9sZExvb3A7XG4gICAgICBsZXQgbmV4dFNpYmxpbmcgPSBuZXh0RWxlbWVudEZyb21PbGRMb29wLm5leHRFbGVtZW50U2libGluZztcbiAgICAgIHRyYW5zaXRpb25PdXQobmV4dEVsZW1lbnRGcm9tT2xkTG9vcCwgKCkgPT4ge1xuICAgICAgICBuZXh0RWxlbWVudEZyb21PbGRMb29wSW1tdXRhYmxlLnJlbW92ZSgpO1xuICAgICAgfSwgKCkgPT4ge30sIGNvbXBvbmVudCk7XG4gICAgICBuZXh0RWxlbWVudEZyb21PbGRMb29wID0gbmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcuX194X2Zvcl9rZXkgIT09IHVuZGVmaW5lZCA/IG5leHRTaWJsaW5nIDogZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlQmluZGluZ0RpcmVjdGl2ZShjb21wb25lbnQsIGVsLCBhdHRyTmFtZSwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzLCBhdHRyVHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgdmFyIHZhbHVlID0gY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcblxuICAgIGlmIChhdHRyTmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgaWYgKEFscGluZS5pZ25vcmVGb2N1c2VkRm9yVmFsdWVCaW5kaW5nICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaXNTYW1lTm9kZShlbCkpIHJldHVybjsgLy8gSWYgbmVzdGVkIG1vZGVsIGtleSBpcyB1bmRlZmluZWQsIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSB0byBlbXB0eSBzdHJpbmcuXG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGV4cHJlc3Npb24ubWF0Y2goL1xcLi8pKSB7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgIC8vIFNldCByYWRpbyB2YWx1ZSBmcm9tIHgtYmluZDp2YWx1ZSwgaWYgbm8gXCJ2YWx1ZVwiIGF0dHJpYnV0ZSBleGlzdHMuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgaW5pdGlhbCBzdGF0ZSB2YWx1ZXMsIHJhZGlvIHdpbGwgaGF2ZSBhIGNvcnJlY3RcbiAgICAgICAgLy8gXCJjaGVja2VkXCIgdmFsdWUgc2luY2UgeC1iaW5kOnZhbHVlIGlzIHByb2Nlc3NlZCBiZWZvcmUgeC1tb2RlbC5cbiAgICAgICAgaWYgKGVsLmF0dHJpYnV0ZXMudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBhdHRyVHlwZSA9PT0gJ2JpbmQnKSB7XG4gICAgICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChhdHRyVHlwZSAhPT0gJ2JpbmQnKSB7XG4gICAgICAgICAgZWwuY2hlY2tlZCA9IGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKGVsLnZhbHVlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAvLyBJZiB3ZSBhcmUgZXhwbGljaXRseSBiaW5kaW5nIGEgc3RyaW5nIHRvIHRoZSA6dmFsdWUsIHNldCB0aGUgc3RyaW5nLFxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuLCBsZWF2ZSBpdCBhbG9uZSwgaXQgd2lsbCBiZSBzZXQgdG8gXCJvblwiXG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJyAmJiAhW251bGwsIHVuZGVmaW5lZF0uaW5jbHVkZXModmFsdWUpICYmIGF0dHJUeXBlID09PSAnYmluZCcpIHtcbiAgICAgICAgICBlbC52YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0clR5cGUgIT09ICdiaW5kJykge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gSSdtIHB1cnBvc2VseSBub3QgdXNpbmcgQXJyYXkuaW5jbHVkZXMgaGVyZSBiZWNhdXNlIGl0J3NcbiAgICAgICAgICAgIC8vIHN0cmljdCwgYW5kIGJlY2F1c2Ugb2YgTnVtZXJpYy9TdHJpbmcgbWlzLWNhc3RpbmcsIElcbiAgICAgICAgICAgIC8vIHdhbnQgdGhlIFwiaW5jbHVkZXNcIiB0byBiZSBcImZ1enp5XCIuXG4gICAgICAgICAgICBlbC5jaGVja2VkID0gdmFsdWUuc29tZSh2YWwgPT4gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUodmFsLCBlbC52YWx1ZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5jaGVja2VkID0gISF2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWwudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0KGVsLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWwudmFsdWUgPT09IHZhbHVlKSByZXR1cm47XG4gICAgICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ2xhc3NlcyA9IGVsLl9feF9vcmlnaW5hbF9jbGFzc2VzIHx8IFtdO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYXJyYXlVbmlxdWUob3JpZ2luYWxDbGFzc2VzLmNvbmNhdCh2YWx1ZSkpLmpvaW4oJyAnKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gU29ydGluZyB0aGUga2V5cyAvIGNsYXNzIG5hbWVzIGJ5IHRoZWlyIGJvb2xlYW4gdmFsdWUgd2lsbCBlbnN1cmUgdGhhdFxuICAgICAgICAvLyBhbnl0aGluZyB0aGF0IGV2YWx1YXRlcyB0byBgZmFsc2VgIGFuZCBuZWVkcyB0byByZW1vdmUgY2xhc3NlcyBpcyBydW4gZmlyc3QuXG4gICAgICAgIGNvbnN0IGtleXNTb3J0ZWRCeUJvb2xlYW5WYWx1ZSA9IE9iamVjdC5rZXlzKHZhbHVlKS5zb3J0KChhLCBiKSA9PiB2YWx1ZVthXSAtIHZhbHVlW2JdKTtcbiAgICAgICAga2V5c1NvcnRlZEJ5Qm9vbGVhblZhbHVlLmZvckVhY2goY2xhc3NOYW1lcyA9PiB7XG4gICAgICAgICAgaWYgKHZhbHVlW2NsYXNzTmFtZXNdKSB7XG4gICAgICAgICAgICBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGNsYXNzTmFtZXMpLmZvckVhY2goY2xhc3NOYW1lID0+IGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnZlcnRDbGFzc1N0cmluZ1RvQXJyYXkoY2xhc3NOYW1lcykuZm9yRWFjaChjbGFzc05hbWUgPT4gZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDbGFzc2VzID0gZWwuX194X29yaWdpbmFsX2NsYXNzZXMgfHwgW107XG4gICAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSB2YWx1ZSA/IGNvbnZlcnRDbGFzc1N0cmluZ1RvQXJyYXkodmFsdWUpIDogW107XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBhcnJheVVuaXF1ZShvcmlnaW5hbENsYXNzZXMuY29uY2F0KG5ld0NsYXNzZXMpKS5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyTmFtZSA9IG1vZGlmaWVycy5pbmNsdWRlcygnY2FtZWwnKSA/IGNhbWVsQ2FzZShhdHRyTmFtZSkgOiBhdHRyTmFtZTsgLy8gSWYgYW4gYXR0cmlidXRlJ3MgYm91bmQgdmFsdWUgaXMgbnVsbCwgdW5kZWZpbmVkIG9yIGZhbHNlLCByZW1vdmUgdGhlIGF0dHJpYnV0ZVxuXG4gICAgICBpZiAoW251bGwsIHVuZGVmaW5lZCwgZmFsc2VdLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNCb29sZWFuQXR0cihhdHRyTmFtZSkgPyBzZXRJZkNoYW5nZWQoZWwsIGF0dHJOYW1lLCBhdHRyTmFtZSkgOiBzZXRJZkNoYW5nZWQoZWwsIGF0dHJOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0SWZDaGFuZ2VkKGVsLCBhdHRyTmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSAhPSB2YWx1ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0KGVsLCB2YWx1ZSkge1xuICAgIGNvbnN0IGFycmF5V3JhcHBlZFZhbHVlID0gW10uY29uY2F0KHZhbHVlKS5tYXAodmFsdWUgPT4ge1xuICAgICAgcmV0dXJuIHZhbHVlICsgJyc7XG4gICAgfSk7XG4gICAgQXJyYXkuZnJvbShlbC5vcHRpb25zKS5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPSBhcnJheVdyYXBwZWRWYWx1ZS5pbmNsdWRlcyhvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVGV4dERpcmVjdGl2ZShlbCwgb3V0cHV0LCBleHByZXNzaW9uKSB7XG4gICAgLy8gSWYgbmVzdGVkIG1vZGVsIGtleSBpcyB1bmRlZmluZWQsIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSB0byBlbXB0eSBzdHJpbmcuXG4gICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkICYmIGV4cHJlc3Npb24ubWF0Y2goL1xcLi8pKSB7XG4gICAgICBvdXRwdXQgPSAnJztcbiAgICB9XG5cbiAgICBlbC50ZXh0Q29udGVudCA9IG91dHB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUh0bWxEaXJlY3RpdmUoY29tcG9uZW50LCBlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVNob3dEaXJlY3RpdmUoY29tcG9uZW50LCBlbCwgdmFsdWUsIG1vZGlmaWVycywgaW5pdGlhbFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgaGlkZSA9ICgpID0+IHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBlbC5fX3hfaXNfc2hvd24gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2hvdyA9ICgpID0+IHtcbiAgICAgIGlmIChlbC5zdHlsZS5sZW5ndGggPT09IDEgJiYgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdkaXNwbGF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGVsLl9feF9pc19zaG93biA9IHRydWU7XG4gICAgfTtcblxuICAgIGlmIChpbml0aWFsVXBkYXRlID09PSB0cnVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlkZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlID0gKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgZWwuX194X3RyYW5zaXRpb24pIHtcbiAgICAgICAgICB0cmFuc2l0aW9uSW4oZWwsICgpID0+IHtcbiAgICAgICAgICAgIHNob3coKTtcbiAgICAgICAgICB9LCByZWplY3QsIGNvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKCgpID0+IHt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uT3V0KGVsLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCgpID0+IHtcbiAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgcmVqZWN0LCBjb21wb25lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKCkgPT4ge30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gVGhlIHdvcmtpbmcgb2YgeC1zaG93IGlzIGEgYml0IGNvbXBsZXggYmVjYXVzZSB3ZSBuZWVkIHRvXG4gICAgLy8gd2FpdCBmb3IgYW55IGNoaWxkIHRyYW5zaXRpb25zIHRvIGZpbmlzaCBiZWZvcmUgaGlkaW5nXG4gICAgLy8gc29tZSBlbGVtZW50LiBBbHNvLCB0aGlzIGhhcyB0byBiZSBkb25lIHJlY3Vyc2l2ZWx5LlxuICAgIC8vIElmIHgtc2hvdy5pbW1lZGlhdGUsIGZvcmVnb2UgdGhlIHdhaXRpbmcuXG5cblxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2ltbWVkaWF0ZScpKSB7XG4gICAgICBoYW5kbGUoZmluaXNoID0+IGZpbmlzaCgpLCAoKSA9PiB7fSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB4LXNob3cgaXMgZW5jb3VudGVyZWQgZHVyaW5nIGEgRE9NIHRyZWUgd2Fsay4gSWYgYW4gZWxlbWVudFxuICAgIC8vIHdlIGVuY291bnRlciBpcyBOT1QgYSBjaGlsZCBvZiBhbm90aGVyIHgtc2hvdyBlbGVtZW50IHdlXG4gICAgLy8gY2FuIGV4ZWN1dGUgdGhlIHByZXZpb3VzIHgtc2hvdyBzdGFjayAoaWYgb25lIGV4aXN0cykuXG5cblxuICAgIGlmIChjb21wb25lbnQuc2hvd0RpcmVjdGl2ZUxhc3RFbGVtZW50ICYmICFjb21wb25lbnQuc2hvd0RpcmVjdGl2ZUxhc3RFbGVtZW50LmNvbnRhaW5zKGVsKSkge1xuICAgICAgY29tcG9uZW50LmV4ZWN1dGVBbmRDbGVhclJlbWFpbmluZ1Nob3dEaXJlY3RpdmVTdGFjaygpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudC5zaG93RGlyZWN0aXZlU3RhY2sucHVzaChoYW5kbGUpO1xuICAgIGNvbXBvbmVudC5zaG93RGlyZWN0aXZlTGFzdEVsZW1lbnQgPSBlbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUlmRGlyZWN0aXZlKGNvbXBvbmVudCwgZWwsIGV4cHJlc3Npb25SZXN1bHQsIGluaXRpYWxVcGRhdGUsIGV4dHJhVmFycykge1xuICAgIHdhcm5JZk1hbGZvcm1lZFRlbXBsYXRlKGVsLCAneC1pZicpO1xuICAgIGNvbnN0IGVsZW1lbnRIYXNBbHJlYWR5QmVlbkFkZGVkID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nICYmIGVsLm5leHRFbGVtZW50U2libGluZy5fX3hfaW5zZXJ0ZWRfbWUgPT09IHRydWU7XG5cbiAgICBpZiAoZXhwcmVzc2lvblJlc3VsdCAmJiAoIWVsZW1lbnRIYXNBbHJlYWR5QmVlbkFkZGVkIHx8IGVsLl9feF90cmFuc2l0aW9uKSkge1xuICAgICAgY29uc3QgY2xvbmUgPSBkb2N1bWVudC5pbXBvcnROb2RlKGVsLmNvbnRlbnQsIHRydWUpO1xuICAgICAgZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIGVsLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICB0cmFuc2l0aW9uSW4oZWwubmV4dEVsZW1lbnRTaWJsaW5nLCAoKSA9PiB7fSwgKCkgPT4ge30sIGNvbXBvbmVudCwgaW5pdGlhbFVwZGF0ZSk7XG4gICAgICBjb21wb25lbnQuaW5pdGlhbGl6ZUVsZW1lbnRzKGVsLm5leHRFbGVtZW50U2libGluZywgZXh0cmFWYXJzKTtcbiAgICAgIGVsLm5leHRFbGVtZW50U2libGluZy5fX3hfaW5zZXJ0ZWRfbWUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWV4cHJlc3Npb25SZXN1bHQgJiYgZWxlbWVudEhhc0FscmVhZHlCZWVuQWRkZWQpIHtcbiAgICAgIHRyYW5zaXRpb25PdXQoZWwubmV4dEVsZW1lbnRTaWJsaW5nLCAoKSA9PiB7XG4gICAgICAgIGVsLm5leHRFbGVtZW50U2libGluZy5yZW1vdmUoKTtcbiAgICAgIH0sICgpID0+IHt9LCBjb21wb25lbnQsIGluaXRpYWxVcGRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXIoY29tcG9uZW50LCBlbCwgZXZlbnQsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgZXh0cmFWYXJzID0ge30pIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogbW9kaWZpZXJzLmluY2x1ZGVzKCdwYXNzaXZlJylcbiAgICB9O1xuXG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnY2FtZWwnKSkge1xuICAgICAgZXZlbnQgPSBjYW1lbENhc2UoZXZlbnQpO1xuICAgIH1cblxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2F3YXknKSkge1xuICAgICAgbGV0IGhhbmRsZXIgPSBlID0+IHtcbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIGNsaWNrIGNhbWUgZnJvbSB0aGUgZWxlbWVudCBvciB3aXRoaW4gaXQuXG4gICAgICAgIGlmIChlbC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjsgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhpcyBlbGVtZW50IGlzbid0IGN1cnJlbnRseSB2aXNpYmxlLlxuXG4gICAgICAgIGlmIChlbC5vZmZzZXRXaWR0aCA8IDEgJiYgZWwub2Zmc2V0SGVpZ2h0IDwgMSkgcmV0dXJuOyAvLyBOb3cgdGhhdCB3ZSBhcmUgc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlLCBBTkQgdGhlIGNsaWNrXG4gICAgICAgIC8vIGlzIGZyb20gb3V0c2lkZSBpdCwgbGV0J3MgcnVuIHRoZSBleHByZXNzaW9uLlxuXG4gICAgICAgIHJ1bkxpc3RlbmVySGFuZGxlcihjb21wb25lbnQsIGV4cHJlc3Npb24sIGUsIGV4dHJhVmFycyk7XG5cbiAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnb25jZScpKSB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIExpc3RlbiBmb3IgdGhpcyBldmVudCBhdCB0aGUgcm9vdCBsZXZlbC5cblxuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGxpc3RlbmVyVGFyZ2V0ID0gbW9kaWZpZXJzLmluY2x1ZGVzKCd3aW5kb3cnKSA/IHdpbmRvdyA6IG1vZGlmaWVycy5pbmNsdWRlcygnZG9jdW1lbnQnKSA/IGRvY3VtZW50IDogZWw7XG5cbiAgICAgIGxldCBoYW5kbGVyID0gZSA9PiB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGlzIGdsb2JhbCBldmVudCBoYW5kbGVyIGlmIHRoZSBlbGVtZW50IHRoYXQgZGVjbGFyZWQgaXRcbiAgICAgICAgLy8gaGFzIGJlZW4gcmVtb3ZlZC4gSXQncyBub3cgc3RhbGUuXG4gICAgICAgIGlmIChsaXN0ZW5lclRhcmdldCA9PT0gd2luZG93IHx8IGxpc3RlbmVyVGFyZ2V0ID09PSBkb2N1bWVudCkge1xuICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhlbCkpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0tleUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIGlmIChpc0xpc3RlbmluZ0ZvckFTcGVjaWZpY0tleVRoYXRIYXNudEJlZW5QcmVzc2VkKGUsIG1vZGlmaWVycykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdwcmV2ZW50JykpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnc3RvcCcpKSBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBJZiB0aGUgLnNlbGYgbW9kaWZpZXIgaXNuJ3QgcHJlc2VudCwgb3IgaWYgaXQgaXMgcHJlc2VudCBhbmRcbiAgICAgICAgLy8gdGhlIHRhcmdldCBlbGVtZW50IG1hdGNoZXMgdGhlIGVsZW1lbnQgd2UgYXJlIHJlZ2lzdGVyaW5nIHRoZVxuICAgICAgICAvLyBldmVudCBvbiwgcnVuIHRoZSBoYW5kbGVyXG5cbiAgICAgICAgaWYgKCFtb2RpZmllcnMuaW5jbHVkZXMoJ3NlbGYnKSB8fCBlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IHJ1bkxpc3RlbmVySGFuZGxlcihjb21wb25lbnQsIGV4cHJlc3Npb24sIGUsIGV4dHJhVmFycyk7XG4gICAgICAgICAgcmV0dXJuVmFsdWUudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ29uY2UnKSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2RlYm91bmNlJykpIHtcbiAgICAgICAgbGV0IG5leHRNb2RpZmllciA9IG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZignZGVib3VuY2UnKSArIDFdIHx8ICdpbnZhbGlkLXdhaXQnO1xuICAgICAgICBsZXQgd2FpdCA9IGlzTnVtZXJpYyhuZXh0TW9kaWZpZXIuc3BsaXQoJ21zJylbMF0pID8gTnVtYmVyKG5leHRNb2RpZmllci5zcGxpdCgnbXMnKVswXSkgOiAyNTA7XG4gICAgICAgIGhhbmRsZXIgPSBkZWJvdW5jZShoYW5kbGVyLCB3YWl0KTtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuTGlzdGVuZXJIYW5kbGVyKGNvbXBvbmVudCwgZXhwcmVzc2lvbiwgZSwgZXh0cmFWYXJzKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5ldmFsdWF0ZUNvbW1hbmRFeHByZXNzaW9uKGUudGFyZ2V0LCBleHByZXNzaW9uLCAoKSA9PiB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGV4dHJhVmFycygpKSwge30sIHtcbiAgICAgICAgJyRldmVudCc6IGVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNLZXlFdmVudChldmVudCkge1xuICAgIHJldHVybiBbJ2tleWRvd24nLCAna2V5dXAnXS5pbmNsdWRlcyhldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xpc3RlbmluZ0ZvckFTcGVjaWZpY0tleVRoYXRIYXNudEJlZW5QcmVzc2VkKGUsIG1vZGlmaWVycykge1xuICAgIGxldCBrZXlNb2RpZmllcnMgPSBtb2RpZmllcnMuZmlsdGVyKGkgPT4ge1xuICAgICAgcmV0dXJuICFbJ3dpbmRvdycsICdkb2N1bWVudCcsICdwcmV2ZW50JywgJ3N0b3AnXS5pbmNsdWRlcyhpKTtcbiAgICB9KTtcblxuICAgIGlmIChrZXlNb2RpZmllcnMuaW5jbHVkZXMoJ2RlYm91bmNlJykpIHtcbiAgICAgIGxldCBkZWJvdW5jZUluZGV4ID0ga2V5TW9kaWZpZXJzLmluZGV4T2YoJ2RlYm91bmNlJyk7XG4gICAgICBrZXlNb2RpZmllcnMuc3BsaWNlKGRlYm91bmNlSW5kZXgsIGlzTnVtZXJpYygoa2V5TW9kaWZpZXJzW2RlYm91bmNlSW5kZXggKyAxXSB8fCAnaW52YWxpZC13YWl0Jykuc3BsaXQoJ21zJylbMF0pID8gMiA6IDEpO1xuICAgIH0gLy8gSWYgbm8gbW9kaWZpZXIgaXMgc3BlY2lmaWVkLCB3ZSdsbCBjYWxsIGl0IGEgcHJlc3MuXG5cblxuICAgIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7IC8vIElmIG9uZSBpcyBwYXNzZWQsIEFORCBpdCBtYXRjaGVzIHRoZSBrZXkgcHJlc3NlZCwgd2UnbGwgY2FsbCBpdCBhIHByZXNzLlxuXG4gICAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggPT09IDEgJiYga2V5TW9kaWZpZXJzWzBdID09PSBrZXlUb01vZGlmaWVyKGUua2V5KSkgcmV0dXJuIGZhbHNlOyAvLyBUaGUgdXNlciBpcyBsaXN0ZW5pbmcgZm9yIGtleSBjb21iaW5hdGlvbnMuXG5cbiAgICBjb25zdCBzeXN0ZW1LZXlNb2RpZmllcnMgPSBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnLCAnY21kJywgJ3N1cGVyJ107XG4gICAgY29uc3Qgc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMgPSBzeXN0ZW1LZXlNb2RpZmllcnMuZmlsdGVyKG1vZGlmaWVyID0+IGtleU1vZGlmaWVycy5pbmNsdWRlcyhtb2RpZmllcikpO1xuICAgIGtleU1vZGlmaWVycyA9IGtleU1vZGlmaWVycy5maWx0ZXIoaSA9PiAhc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMuaW5jbHVkZXMoaSkpO1xuXG4gICAgaWYgKHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGFjdGl2ZWx5UHJlc3NlZEtleU1vZGlmaWVycyA9IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmZpbHRlcihtb2RpZmllciA9PiB7XG4gICAgICAgIC8vIEFsaWFzIFwiY21kXCIgYW5kIFwic3VwZXJcIiB0byBcIm1ldGFcIlxuICAgICAgICBpZiAobW9kaWZpZXIgPT09ICdjbWQnIHx8IG1vZGlmaWVyID09PSAnc3VwZXInKSBtb2RpZmllciA9ICdtZXRhJztcbiAgICAgICAgcmV0dXJuIGVbYCR7bW9kaWZpZXJ9S2V5YF07XG4gICAgICB9KTsgLy8gSWYgYWxsIHRoZSBtb2RpZmllcnMgc2VsZWN0ZWQgYXJlIHByZXNzZWQsIC4uLlxuXG4gICAgICBpZiAoYWN0aXZlbHlQcmVzc2VkS2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIEFORCB0aGUgcmVtYWluaW5nIGtleSBpcyBwcmVzc2VkIGFzIHdlbGwuIEl0J3MgYSBwcmVzcy5cbiAgICAgICAgaWYgKGtleU1vZGlmaWVyc1swXSA9PT0ga2V5VG9Nb2RpZmllcihlLmtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IC8vIFdlJ2xsIGNhbGwgaXQgTk9UIGEgdmFsaWQga2V5cHJlc3MuXG5cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24ga2V5VG9Nb2RpZmllcihrZXkpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSAnLyc6XG4gICAgICAgIHJldHVybiAnc2xhc2gnO1xuXG4gICAgICBjYXNlICcgJzpcbiAgICAgIGNhc2UgJ1NwYWNlYmFyJzpcbiAgICAgICAgcmV0dXJuICdzcGFjZSc7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBrZXkgJiYga2ViYWJDYXNlKGtleSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJNb2RlbExpc3RlbmVyKGNvbXBvbmVudCwgZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKSB7XG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgd2UgYXJlIGJpbmRpbmcgdG8gaXMgYSBzZWxlY3QsIGEgcmFkaW8sIG9yIGNoZWNrYm94XG4gICAgLy8gd2UnbGwgbGlzdGVuIGZvciB0aGUgY2hhbmdlIGV2ZW50IGluc3RlYWQgb2YgdGhlIFwiaW5wdXRcIiBldmVudC5cbiAgICB2YXIgZXZlbnQgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnIHx8IFsnY2hlY2tib3gnLCAncmFkaW8nXS5pbmNsdWRlcyhlbC50eXBlKSB8fCBtb2RpZmllcnMuaW5jbHVkZXMoJ2xhenknKSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBjb25zdCBsaXN0ZW5lckV4cHJlc3Npb24gPSBgJHtleHByZXNzaW9ufSA9IHJpZ2h0U2lkZU9mRXhwcmVzc2lvbigkZXZlbnQsICR7ZXhwcmVzc2lvbn0pYDtcbiAgICByZWdpc3Rlckxpc3RlbmVyKGNvbXBvbmVudCwgZWwsIGV2ZW50LCBtb2RpZmllcnMsIGxpc3RlbmVyRXhwcmVzc2lvbiwgKCkgPT4ge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYVZhcnMoKSksIHt9LCB7XG4gICAgICAgIHJpZ2h0U2lkZU9mRXhwcmVzc2lvbjogZ2VuZXJhdGVNb2RlbEFzc2lnbm1lbnRGdW5jdGlvbihlbCwgbW9kaWZpZXJzLCBleHByZXNzaW9uKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZU1vZGVsQXNzaWdubWVudEZ1bmN0aW9uKGVsLCBtb2RpZmllcnMsIGV4cHJlc3Npb24pIHtcbiAgICBpZiAoZWwudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgLy8gUmFkaW8gYnV0dG9ucyBvbmx5IHdvcmsgcHJvcGVybHkgd2hlbiB0aGV5IHNoYXJlIGEgbmFtZSBhdHRyaWJ1dGUuXG4gICAgICAvLyBQZW9wbGUgbWlnaHQgYXNzdW1lIHdlIHRha2UgY2FyZSBvZiB0aGF0IGZvciB0aGVtLCBiZWNhdXNlXG4gICAgICAvLyB0aGV5IGFscmVhZHkgc2V0IGEgc2hhcmVkIFwieC1tb2RlbFwiIGF0dHJpYnV0ZS5cbiAgICAgIGlmICghZWwuaGFzQXR0cmlidXRlKCduYW1lJykpIGVsLnNldEF0dHJpYnV0ZSgnbmFtZScsIGV4cHJlc3Npb24pO1xuICAgIH1cblxuICAgIHJldHVybiAoZXZlbnQsIGN1cnJlbnRWYWx1ZSkgPT4ge1xuICAgICAgLy8gQ2hlY2sgZm9yIGV2ZW50LmRldGFpbCBkdWUgdG8gYW4gaXNzdWUgd2hlcmUgSUUxMSBoYW5kbGVzIG90aGVyIGV2ZW50cyBhcyBhIEN1c3RvbUV2ZW50LlxuICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgQ3VzdG9tRXZlbnQgJiYgZXZlbnQuZGV0YWlsKSB7XG4gICAgICAgIHJldHVybiBldmVudC5kZXRhaWw7XG4gICAgICB9IGVsc2UgaWYgKGVsLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgLy8gSWYgdGhlIGRhdGEgd2UgYXJlIGJpbmRpbmcgdG8gaXMgYW4gYXJyYXksIHRvZ2dsZSBpdHMgdmFsdWUgaW5zaWRlIHRoZSBhcnJheS5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbW9kaWZpZXJzLmluY2x1ZGVzKCdudW1iZXInKSA/IHNhZmVQYXJzZU51bWJlcihldmVudC50YXJnZXQudmFsdWUpIDogZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQuY2hlY2tlZCA/IGN1cnJlbnRWYWx1ZS5jb25jYXQoW25ld1ZhbHVlXSkgOiBjdXJyZW50VmFsdWUuZmlsdGVyKGVsID0+ICFjaGVja2VkQXR0ckxvb3NlQ29tcGFyZShlbCwgbmV3VmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0JyAmJiBlbC5tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXJzLmluY2x1ZGVzKCdudW1iZXInKSA/IEFycmF5LmZyb20oZXZlbnQudGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykubWFwKG9wdGlvbiA9PiB7XG4gICAgICAgICAgY29uc3QgcmF3VmFsdWUgPSBvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQ7XG4gICAgICAgICAgcmV0dXJuIHNhZmVQYXJzZU51bWJlcihyYXdWYWx1ZSk7XG4gICAgICAgIH0pIDogQXJyYXkuZnJvbShldmVudC50YXJnZXQuc2VsZWN0ZWRPcHRpb25zKS5tYXAob3B0aW9uID0+IHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICByZXR1cm4gbW9kaWZpZXJzLmluY2x1ZGVzKCdudW1iZXInKSA/IHNhZmVQYXJzZU51bWJlcihyYXdWYWx1ZSkgOiBtb2RpZmllcnMuaW5jbHVkZXMoJ3RyaW0nKSA/IHJhd1ZhbHVlLnRyaW0oKSA6IHJhd1ZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpIHtcbiAgICBjb25zdCBudW1iZXIgPSByYXdWYWx1ZSA/IHBhcnNlRmxvYXQocmF3VmFsdWUpIDogbnVsbDtcbiAgICByZXR1cm4gaXNOdW1lcmljKG51bWJlcikgPyBudW1iZXIgOiByYXdWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3B5cmlnaHQgKEMpIDIwMTcgc2FsZXNmb3JjZS5jb20sIGluYy5cbiAgICovXG4gIGNvbnN0IHsgaXNBcnJheSB9ID0gQXJyYXk7XG4gIGNvbnN0IHsgZ2V0UHJvdG90eXBlT2YsIGNyZWF0ZTogT2JqZWN0Q3JlYXRlLCBkZWZpbmVQcm9wZXJ0eTogT2JqZWN0RGVmaW5lUHJvcGVydHksIGRlZmluZVByb3BlcnRpZXM6IE9iamVjdERlZmluZVByb3BlcnRpZXMsIGlzRXh0ZW5zaWJsZSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBnZXRPd25Qcm9wZXJ0eU5hbWVzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIHByZXZlbnRFeHRlbnNpb25zLCBoYXNPd25Qcm9wZXJ0eSwgfSA9IE9iamVjdDtcbiAgY29uc3QgeyBwdXNoOiBBcnJheVB1c2gsIGNvbmNhdDogQXJyYXlDb25jYXQsIG1hcDogQXJyYXlNYXAsIH0gPSBBcnJheS5wcm90b3R5cGU7XG4gIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JztcbiAgfVxuICBjb25zdCBwcm94eVRvVmFsdWVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICBmdW5jdGlvbiByZWdpc3RlclByb3h5KHByb3h5LCB2YWx1ZSkge1xuICAgICAgcHJveHlUb1ZhbHVlTWFwLnNldChwcm94eSwgdmFsdWUpO1xuICB9XG4gIGNvbnN0IHVud3JhcCA9IChyZXBsaWNhT3JBbnkpID0+IHByb3h5VG9WYWx1ZU1hcC5nZXQocmVwbGljYU9yQW55KSB8fCByZXBsaWNhT3JBbnk7XG5cbiAgZnVuY3Rpb24gd3JhcFZhbHVlKG1lbWJyYW5lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG1lbWJyYW5lLnZhbHVlSXNPYnNlcnZhYmxlKHZhbHVlKSA/IG1lbWJyYW5lLmdldFByb3h5KHZhbHVlKSA6IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBVbndyYXAgcHJvcGVydHkgZGVzY3JpcHRvcnMgd2lsbCBzZXQgdmFsdWUgb24gb3JpZ2luYWwgZGVzY3JpcHRvclxuICAgKiBXZSBvbmx5IG5lZWQgdG8gdW53cmFwIGlmIHZhbHVlIGlzIHNwZWNpZmllZFxuICAgKiBAcGFyYW0gZGVzY3JpcHRvciBleHRlcm5hbCBkZXNjcnBpdG9yIHByb3ZpZGVkIHRvIGRlZmluZSBuZXcgcHJvcGVydHkgb24gb3JpZ2luYWwgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIHVud3JhcERlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZGVzY3JpcHRvciwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gdW53cmFwKGRlc2NyaXB0b3IudmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH1cbiAgZnVuY3Rpb24gbG9ja1NoYWRvd1RhcmdldChtZW1icmFuZSwgc2hhZG93VGFyZ2V0LCBvcmlnaW5hbFRhcmdldCkge1xuICAgICAgY29uc3QgdGFyZ2V0S2V5cyA9IEFycmF5Q29uY2F0LmNhbGwoZ2V0T3duUHJvcGVydHlOYW1lcyhvcmlnaW5hbFRhcmdldCksIGdldE93blByb3BlcnR5U3ltYm9scyhvcmlnaW5hbFRhcmdldCkpO1xuICAgICAgdGFyZ2V0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBsZXQgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCB0byB3cmFwIHRoZSBkZXNjcmlwdG9yIGlmIGNvbmZpZ3VyYWJsZVxuICAgICAgICAgIC8vIEJlY2F1c2Ugd2UgY2FuIGRlYWwgd2l0aCB3cmFwcGluZyBpdCB3aGVuIHVzZXIgZ29lcyB0aHJvdWdoXG4gICAgICAgICAgLy8gR2V0IG93biBwcm9wZXJ0eSBkZXNjcmlwdG9yLiBUaGVyZSBpcyBhbHNvIGEgY2hhbmNlIHRoYXQgdGhpcyBkZXNjcmlwdG9yXG4gICAgICAgICAgLy8gY291bGQgY2hhbmdlIHNvbWV0aW1lIGluIHRoZSBmdXR1cmUsIHNvIHdlIGNhbiBkZWZlciB3cmFwcGluZ1xuICAgICAgICAgIC8vIHVudGlsIHdlIG5lZWQgdG9cbiAgICAgICAgICBpZiAoIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSB3cmFwRGVzY3JpcHRvcihtZW1icmFuZSwgZGVzY3JpcHRvciwgd3JhcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkoc2hhZG93VGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfSk7XG4gICAgICBwcmV2ZW50RXh0ZW5zaW9ucyhzaGFkb3dUYXJnZXQpO1xuICB9XG4gIGNsYXNzIFJlYWN0aXZlUHJveHlIYW5kbGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lbWJyYW5lLCB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMub3JpZ2luYWxUYXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLm1lbWJyYW5lID0gbWVtYnJhbmU7XG4gICAgICB9XG4gICAgICBnZXQoc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZSB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9yaWdpbmFsVGFyZ2V0W2tleV07XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZU9ic2VydmVkIH0gPSBtZW1icmFuZTtcbiAgICAgICAgICB2YWx1ZU9ic2VydmVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIHJldHVybiBtZW1icmFuZS5nZXRQcm94eSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBzZXQoc2hhZG93VGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmU6IHsgdmFsdWVNdXRhdGVkIH0gfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBvcmlnaW5hbFRhcmdldFtrZXldO1xuICAgICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxUYXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICB2YWx1ZU11dGF0ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2xlbmd0aCcgJiYgaXNBcnJheShvcmlnaW5hbFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgLy8gZml4IGZvciBpc3N1ZSAjMjM2OiBwdXNoIHdpbGwgYWRkIHRoZSBuZXcgaW5kZXgsIGFuZCBieSB0aGUgdGltZSBsZW5ndGhcbiAgICAgICAgICAgICAgLy8gaXMgdXBkYXRlZCwgdGhlIGludGVybmFsIGxlbmd0aCBpcyBhbHJlYWR5IGVxdWFsIHRvIHRoZSBuZXcgbGVuZ3RoIHZhbHVlXG4gICAgICAgICAgICAgIC8vIHRoZXJlZm9yZSwgdGhlIG9sZFZhbHVlIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZS4gVGhpcyBpcyB0aGUgZm9ya2luZyBsb2dpY1xuICAgICAgICAgICAgICAvLyB0byBzdXBwb3J0IHRoaXMgdXNlIGNhc2UuXG4gICAgICAgICAgICAgIHZhbHVlTXV0YXRlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBkZWxldGVQcm9wZXJ0eShzaGFkb3dUYXJnZXQsIGtleSkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lOiB7IHZhbHVlTXV0YXRlZCB9IH0gPSB0aGlzO1xuICAgICAgICAgIGRlbGV0ZSBvcmlnaW5hbFRhcmdldFtrZXldO1xuICAgICAgICAgIHZhbHVlTXV0YXRlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGFwcGx5KHNoYWRvd1RhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgICAgICAvKiBObyBvcCAqL1xuICAgICAgfVxuICAgICAgY29uc3RydWN0KHRhcmdldCwgYXJnQXJyYXksIG5ld1RhcmdldCkge1xuICAgICAgICAgIC8qIE5vIG9wICovXG4gICAgICB9XG4gICAgICBoYXMoc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZTogeyB2YWx1ZU9ic2VydmVkIH0gfSA9IHRoaXM7XG4gICAgICAgICAgdmFsdWVPYnNlcnZlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICByZXR1cm4ga2V5IGluIG9yaWdpbmFsVGFyZ2V0O1xuICAgICAgfVxuICAgICAgb3duS2V5cyhzaGFkb3dUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0IH0gPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBBcnJheUNvbmNhdC5jYWxsKGdldE93blByb3BlcnR5TmFtZXMob3JpZ2luYWxUYXJnZXQpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob3JpZ2luYWxUYXJnZXQpKTtcbiAgICAgIH1cbiAgICAgIGlzRXh0ZW5zaWJsZShzaGFkb3dUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCBzaGFkb3dJc0V4dGVuc2libGUgPSBpc0V4dGVuc2libGUoc2hhZG93VGFyZ2V0KTtcbiAgICAgICAgICBpZiAoIXNoYWRvd0lzRXh0ZW5zaWJsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2hhZG93SXNFeHRlbnNpYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZSB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCB0YXJnZXRJc0V4dGVuc2libGUgPSBpc0V4dGVuc2libGUob3JpZ2luYWxUYXJnZXQpO1xuICAgICAgICAgIGlmICghdGFyZ2V0SXNFeHRlbnNpYmxlKSB7XG4gICAgICAgICAgICAgIGxvY2tTaGFkb3dUYXJnZXQobWVtYnJhbmUsIHNoYWRvd1RhcmdldCwgb3JpZ2luYWxUYXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGFyZ2V0SXNFeHRlbnNpYmxlO1xuICAgICAgfVxuICAgICAgc2V0UHJvdG90eXBlT2Yoc2hhZG93VGFyZ2V0LCBwcm90b3R5cGUpIHtcbiAgICAgIH1cbiAgICAgIGdldFByb3RvdHlwZU9mKHNoYWRvd1RhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQgfSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGdldFByb3RvdHlwZU9mKG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzaGFkb3dUYXJnZXQsIGtleSkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWVPYnNlcnZlZCB9ID0gdGhpcy5tZW1icmFuZTtcbiAgICAgICAgICAvLyBrZXlzIGxvb2tlZCB1cCB2aWEgaGFzT3duUHJvcGVydHkgbmVlZCB0byBiZSByZWFjdGl2ZVxuICAgICAgICAgIHZhbHVlT2JzZXJ2ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgbGV0IGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRlc2MpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzaGFkb3dEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNoYWRvd1RhcmdldCwga2V5KTtcbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHNoYWRvd0Rlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzaGFkb3dEZXNjcmlwdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBOb3RlOiBieSBhY2Nlc3NpbmcgdGhlIGRlc2NyaXB0b3IsIHRoZSBrZXkgaXMgbWFya2VkIGFzIG9ic2VydmVkXG4gICAgICAgICAgLy8gYnV0IGFjY2VzcyB0byB0aGUgdmFsdWUsIHNldHRlciBvciBnZXR0ZXIgKGlmIGF2YWlsYWJsZSkgY2Fubm90IG9ic2VydmVcbiAgICAgICAgICAvLyBtdXRhdGlvbnMsIGp1c3QgbGlrZSByZWd1bGFyIG1ldGhvZHMsIGluIHdoaWNoIGNhc2Ugd2UganVzdCBkbyBub3RoaW5nLlxuICAgICAgICAgIGRlc2MgPSB3cmFwRGVzY3JpcHRvcihtZW1icmFuZSwgZGVzYywgd3JhcFZhbHVlKTtcbiAgICAgICAgICBpZiAoIWRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAgIC8vIElmIGRlc2NyaXB0b3IgZnJvbSBvcmlnaW5hbCB0YXJnZXQgaXMgbm90IGNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgLy8gV2UgbXVzdCBjb3B5IHRoZSB3cmFwcGVkIGRlc2NyaXB0b3Igb3ZlciB0byB0aGUgc2hhZG93IHRhcmdldC5cbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBwcm94eSB3aWxsIHRocm93IGFuIGludmFyaWFudCBlcnJvci5cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBvdXIgbGFzdCBjaGFuY2UgdG8gbG9jayB0aGUgdmFsdWUuXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5L2hhbmRsZXIvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yI0ludmFyaWFudHNcbiAgICAgICAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkoc2hhZG93VGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgIH1cbiAgICAgIHByZXZlbnRFeHRlbnNpb25zKHNoYWRvd1RhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lIH0gPSB0aGlzO1xuICAgICAgICAgIGxvY2tTaGFkb3dUYXJnZXQobWVtYnJhbmUsIHNoYWRvd1RhcmdldCwgb3JpZ2luYWxUYXJnZXQpO1xuICAgICAgICAgIHByZXZlbnRFeHRlbnNpb25zKG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmUgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZU11dGF0ZWQgfSA9IG1lbWJyYW5lO1xuICAgICAgICAgIGNvbnN0IHsgY29uZmlndXJhYmxlIH0gPSBkZXNjcmlwdG9yO1xuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gY2hlY2sgZm9yIHZhbHVlIGluIGRlc2NyaXB0b3JcbiAgICAgICAgICAvLyBiZWNhdXNlIE9iamVjdC5mcmVlemUocHJveHkpIGNhbGxzIHRoaXMgbWV0aG9kXG4gICAgICAgICAgLy8gd2l0aCBvbmx5IHsgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGVhYmxlOiBmYWxzZSB9XG4gICAgICAgICAgLy8gQWRkaXRpb25hbGx5LCBtZXRob2Qgd2lsbCBvbmx5IGJlIGNhbGxlZCB3aXRoIHdyaXRlYWJsZTpmYWxzZVxuICAgICAgICAgIC8vIGlmIHRoZSBkZXNjcmlwdG9yIGhhcyBhIHZhbHVlLCBhcyBvcHBvc2VkIHRvIGdldHRlci9zZXR0ZXJcbiAgICAgICAgICAvLyBTbyB3ZSBjYW4ganVzdCBjaGVjayBpZiB3cml0YWJsZSBpcyBwcmVzZW50IGFuZCB0aGVuIHNlZSBpZlxuICAgICAgICAgIC8vIHZhbHVlIGlzIHByZXNlbnQuIFRoaXMgZWxpbWluYXRlcyBnZXR0ZXIgYW5kIHNldHRlciBkZXNjcmlwdG9yc1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc2NyaXB0b3IsICd3cml0YWJsZScpICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc2NyaXB0b3IsICd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IG9yaWdpbmFsRGVzY3JpcHRvci52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkob3JpZ2luYWxUYXJnZXQsIGtleSwgdW53cmFwRGVzY3JpcHRvcihkZXNjcmlwdG9yKSk7XG4gICAgICAgICAgaWYgKGNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkoc2hhZG93VGFyZ2V0LCBrZXksIHdyYXBEZXNjcmlwdG9yKG1lbWJyYW5lLCBkZXNjcmlwdG9yLCB3cmFwVmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVNdXRhdGVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcFJlYWRPbmx5VmFsdWUobWVtYnJhbmUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbWVtYnJhbmUudmFsdWVJc09ic2VydmFibGUodmFsdWUpID8gbWVtYnJhbmUuZ2V0UmVhZE9ubHlQcm94eSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuICBjbGFzcyBSZWFkT25seUhhbmRsZXIge1xuICAgICAgY29uc3RydWN0b3IobWVtYnJhbmUsIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5hbFRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubWVtYnJhbmUgPSBtZW1icmFuZTtcbiAgICAgIH1cbiAgICAgIGdldChzaGFkb3dUYXJnZXQsIGtleSkge1xuICAgICAgICAgIGNvbnN0IHsgbWVtYnJhbmUsIG9yaWdpbmFsVGFyZ2V0IH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3JpZ2luYWxUYXJnZXRba2V5XTtcbiAgICAgICAgICBjb25zdCB7IHZhbHVlT2JzZXJ2ZWQgfSA9IG1lbWJyYW5lO1xuICAgICAgICAgIHZhbHVlT2JzZXJ2ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIG1lbWJyYW5lLmdldFJlYWRPbmx5UHJveHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgc2V0KHNoYWRvd1RhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYXBwbHkoc2hhZG93VGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSkge1xuICAgICAgICAgIC8qIE5vIG9wICovXG4gICAgICB9XG4gICAgICBjb25zdHJ1Y3QodGFyZ2V0LCBhcmdBcnJheSwgbmV3VGFyZ2V0KSB7XG4gICAgICAgICAgLyogTm8gb3AgKi9cbiAgICAgIH1cbiAgICAgIGhhcyhzaGFkb3dUYXJnZXQsIGtleSkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lOiB7IHZhbHVlT2JzZXJ2ZWQgfSB9ID0gdGhpcztcbiAgICAgICAgICB2YWx1ZU9ic2VydmVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIHJldHVybiBrZXkgaW4gb3JpZ2luYWxUYXJnZXQ7XG4gICAgICB9XG4gICAgICBvd25LZXlzKHNoYWRvd1RhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQgfSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIEFycmF5Q29uY2F0LmNhbGwoZ2V0T3duUHJvcGVydHlOYW1lcyhvcmlnaW5hbFRhcmdldCksIGdldE93blByb3BlcnR5U3ltYm9scyhvcmlnaW5hbFRhcmdldCkpO1xuICAgICAgfVxuICAgICAgc2V0UHJvdG90eXBlT2Yoc2hhZG93VGFyZ2V0LCBwcm90b3R5cGUpIHtcbiAgICAgIH1cbiAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzaGFkb3dUYXJnZXQsIGtleSkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWVPYnNlcnZlZCB9ID0gbWVtYnJhbmU7XG4gICAgICAgICAgLy8ga2V5cyBsb29rZWQgdXAgdmlhIGhhc093blByb3BlcnR5IG5lZWQgdG8gYmUgcmVhY3RpdmVcbiAgICAgICAgICB2YWx1ZU9ic2VydmVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIGxldCBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChkZXNjKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2hhZG93RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzaGFkb3dUYXJnZXQsIGtleSk7XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChzaGFkb3dEZXNjcmlwdG9yKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2hhZG93RGVzY3JpcHRvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm90ZTogYnkgYWNjZXNzaW5nIHRoZSBkZXNjcmlwdG9yLCB0aGUga2V5IGlzIG1hcmtlZCBhcyBvYnNlcnZlZFxuICAgICAgICAgIC8vIGJ1dCBhY2Nlc3MgdG8gdGhlIHZhbHVlIG9yIGdldHRlciAoaWYgYXZhaWxhYmxlKSBjYW5ub3QgYmUgb2JzZXJ2ZWQsXG4gICAgICAgICAgLy8ganVzdCBsaWtlIHJlZ3VsYXIgbWV0aG9kcywgaW4gd2hpY2ggY2FzZSB3ZSBqdXN0IGRvIG5vdGhpbmcuXG4gICAgICAgICAgZGVzYyA9IHdyYXBEZXNjcmlwdG9yKG1lbWJyYW5lLCBkZXNjLCB3cmFwUmVhZE9ubHlWYWx1ZSk7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZGVzYywgJ3NldCcpKSB7XG4gICAgICAgICAgICAgIGRlc2Muc2V0ID0gdW5kZWZpbmVkOyAvLyByZWFkT25seSBtZW1icmFuZSBkb2VzIG5vdCBhbGxvdyBzZXR0ZXJzXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgLy8gSWYgZGVzY3JpcHRvciBmcm9tIG9yaWdpbmFsIHRhcmdldCBpcyBub3QgY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAvLyBXZSBtdXN0IGNvcHkgdGhlIHdyYXBwZWQgZGVzY3JpcHRvciBvdmVyIHRvIHRoZSBzaGFkb3cgdGFyZ2V0LlxuICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHByb3h5IHdpbGwgdGhyb3cgYW4gaW52YXJpYW50IGVycm9yLlxuICAgICAgICAgICAgICAvLyBUaGlzIGlzIG91ciBsYXN0IGNoYW5jZSB0byBsb2NrIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkvaGFuZGxlci9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IjSW52YXJpYW50c1xuICAgICAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eShzaGFkb3dUYXJnZXQsIGtleSwgZGVzYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgfVxuICAgICAgcHJldmVudEV4dGVuc2lvbnMoc2hhZG93VGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZGVmaW5lUHJvcGVydHkoc2hhZG93VGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlU2hhZG93VGFyZ2V0KHZhbHVlKSB7XG4gICAgICBsZXQgc2hhZG93VGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgc2hhZG93VGFyZ2V0ID0gW107XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICBzaGFkb3dUYXJnZXQgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaGFkb3dUYXJnZXQ7XG4gIH1cbiAgY29uc3QgT2JqZWN0RG90UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgZnVuY3Rpb24gZGVmYXVsdFZhbHVlSXNPYnNlcnZhYmxlKHZhbHVlKSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGNoZWNraW5nIGZvciBudWxsXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyB0cmVhdCBhbGwgbm9uLW9iamVjdCB0eXBlcywgaW5jbHVkaW5nIHVuZGVmaW5lZCwgYXMgbm9uLW9ic2VydmFibGUgdmFsdWVzXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgICByZXR1cm4gKHByb3RvID09PSBPYmplY3REb3RQcm90b3R5cGUgfHwgcHJvdG8gPT09IG51bGwgfHwgZ2V0UHJvdG90eXBlT2YocHJvdG8pID09PSBudWxsKTtcbiAgfVxuICBjb25zdCBkZWZhdWx0VmFsdWVPYnNlcnZlZCA9IChvYmosIGtleSkgPT4ge1xuICAgICAgLyogZG8gbm90aGluZyAqL1xuICB9O1xuICBjb25zdCBkZWZhdWx0VmFsdWVNdXRhdGVkID0gKG9iaiwga2V5KSA9PiB7XG4gICAgICAvKiBkbyBub3RoaW5nICovXG4gIH07XG4gIGNvbnN0IGRlZmF1bHRWYWx1ZURpc3RvcnRpb24gPSAodmFsdWUpID0+IHZhbHVlO1xuICBmdW5jdGlvbiB3cmFwRGVzY3JpcHRvcihtZW1icmFuZSwgZGVzY3JpcHRvciwgZ2V0VmFsdWUpIHtcbiAgICAgIGNvbnN0IHsgc2V0LCBnZXQgfSA9IGRlc2NyaXB0b3I7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChkZXNjcmlwdG9yLCAndmFsdWUnKSkge1xuICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBnZXRWYWx1ZShtZW1icmFuZSwgZGVzY3JpcHRvci52YWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGdldCkpIHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpbnZva2luZyB0aGUgb3JpZ2luYWwgZ2V0dGVyIHdpdGggdGhlIG9yaWdpbmFsIHRhcmdldFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlKG1lbWJyYW5lLCBnZXQuY2FsbCh1bndyYXAodGhpcykpKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChzZXQpKSB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGRvbid0IGhhdmUgYSBjbGVhciBpbmRpY2F0aW9uIG9mIHdoZXRoZXJcbiAgICAgICAgICAgICAgICAgIC8vIG9yIG5vdCBhIHZhbGlkIG11dGF0aW9uIHdpbGwgb2NjdXIsIHdlIGRvbid0IGhhdmUgdGhlIGtleSxcbiAgICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBhcmUgbm90IHN1cmUgd2h5IGFuZCBob3cgdGhleSBhcmUgaW52b2tpbmcgdGhpcyBzZXR0ZXIuXG4gICAgICAgICAgICAgICAgICAvLyBOZXZlcnRoZWxlc3Mgd2UgcHJlc2VydmUgdGhlIG9yaWdpbmFsIHNlbWFudGljcyBieSBpbnZva2luZyB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIHNldHRlciB3aXRoIHRoZSBvcmlnaW5hbCB0YXJnZXQgYW5kIHRoZSB1bndyYXBwZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgIHNldC5jYWxsKHVud3JhcCh0aGlzKSwgbWVtYnJhbmUudW53cmFwUHJveHkodmFsdWUpKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfVxuICBjbGFzcyBSZWFjdGl2ZU1lbWJyYW5lIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlRGlzdG9ydGlvbiA9IGRlZmF1bHRWYWx1ZURpc3RvcnRpb247XG4gICAgICAgICAgdGhpcy52YWx1ZU11dGF0ZWQgPSBkZWZhdWx0VmFsdWVNdXRhdGVkO1xuICAgICAgICAgIHRoaXMudmFsdWVPYnNlcnZlZCA9IGRlZmF1bHRWYWx1ZU9ic2VydmVkO1xuICAgICAgICAgIHRoaXMudmFsdWVJc09ic2VydmFibGUgPSBkZWZhdWx0VmFsdWVJc09ic2VydmFibGU7XG4gICAgICAgICAgdGhpcy5vYmplY3RHcmFwaCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChvcHRpb25zKSkge1xuICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlRGlzdG9ydGlvbiwgdmFsdWVNdXRhdGVkLCB2YWx1ZU9ic2VydmVkLCB2YWx1ZUlzT2JzZXJ2YWJsZSB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZURpc3RvcnRpb24gPSBpc0Z1bmN0aW9uKHZhbHVlRGlzdG9ydGlvbikgPyB2YWx1ZURpc3RvcnRpb24gOiBkZWZhdWx0VmFsdWVEaXN0b3J0aW9uO1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlTXV0YXRlZCA9IGlzRnVuY3Rpb24odmFsdWVNdXRhdGVkKSA/IHZhbHVlTXV0YXRlZCA6IGRlZmF1bHRWYWx1ZU11dGF0ZWQ7XG4gICAgICAgICAgICAgIHRoaXMudmFsdWVPYnNlcnZlZCA9IGlzRnVuY3Rpb24odmFsdWVPYnNlcnZlZCkgPyB2YWx1ZU9ic2VydmVkIDogZGVmYXVsdFZhbHVlT2JzZXJ2ZWQ7XG4gICAgICAgICAgICAgIHRoaXMudmFsdWVJc09ic2VydmFibGUgPSBpc0Z1bmN0aW9uKHZhbHVlSXNPYnNlcnZhYmxlKSA/IHZhbHVlSXNPYnNlcnZhYmxlIDogZGVmYXVsdFZhbHVlSXNPYnNlcnZhYmxlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdldFByb3h5KHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgdW53cmFwcGVkVmFsdWUgPSB1bndyYXAodmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGRpc3RvcnRlZCA9IHRoaXMudmFsdWVEaXN0b3J0aW9uKHVud3JhcHBlZFZhbHVlKTtcbiAgICAgICAgICBpZiAodGhpcy52YWx1ZUlzT2JzZXJ2YWJsZShkaXN0b3J0ZWQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG8gPSB0aGlzLmdldFJlYWN0aXZlU3RhdGUodW53cmFwcGVkVmFsdWUsIGRpc3RvcnRlZCk7XG4gICAgICAgICAgICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGV4dHJhY3QgdGhlIHdyaXRhYmxlIHZlcnNpb24gb2YgYSByZWFkb25seVxuICAgICAgICAgICAgICAvLyB3ZSByZXR1cm4gdGhlIHJlYWRvbmx5LlxuICAgICAgICAgICAgICByZXR1cm4gby5yZWFkT25seSA9PT0gdmFsdWUgPyB2YWx1ZSA6IG8ucmVhY3RpdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaXN0b3J0ZWQ7XG4gICAgICB9XG4gICAgICBnZXRSZWFkT25seVByb3h5KHZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSB1bndyYXAodmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGRpc3RvcnRlZCA9IHRoaXMudmFsdWVEaXN0b3J0aW9uKHZhbHVlKTtcbiAgICAgICAgICBpZiAodGhpcy52YWx1ZUlzT2JzZXJ2YWJsZShkaXN0b3J0ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlYWN0aXZlU3RhdGUodmFsdWUsIGRpc3RvcnRlZCkucmVhZE9ubHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkaXN0b3J0ZWQ7XG4gICAgICB9XG4gICAgICB1bndyYXBQcm94eShwKSB7XG4gICAgICAgICAgcmV0dXJuIHVud3JhcChwKTtcbiAgICAgIH1cbiAgICAgIGdldFJlYWN0aXZlU3RhdGUodmFsdWUsIGRpc3RvcnRlZFZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgeyBvYmplY3RHcmFwaCwgfSA9IHRoaXM7XG4gICAgICAgICAgbGV0IHJlYWN0aXZlU3RhdGUgPSBvYmplY3RHcmFwaC5nZXQoZGlzdG9ydGVkVmFsdWUpO1xuICAgICAgICAgIGlmIChyZWFjdGl2ZVN0YXRlKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWFjdGl2ZVN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBtZW1icmFuZSA9IHRoaXM7XG4gICAgICAgICAgcmVhY3RpdmVTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgZ2V0IHJlYWN0aXZlKCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVhY3RpdmVIYW5kbGVyID0gbmV3IFJlYWN0aXZlUHJveHlIYW5kbGVyKG1lbWJyYW5lLCBkaXN0b3J0ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAvLyBjYWNoaW5nIHRoZSByZWFjdGl2ZSBwcm94eSBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyBhY2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoY3JlYXRlU2hhZG93VGFyZ2V0KGRpc3RvcnRlZFZhbHVlKSwgcmVhY3RpdmVIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUHJveHkocHJveHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHRoaXMsICdyZWFjdGl2ZScsIHsgdmFsdWU6IHByb3h5IH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZXQgcmVhZE9ubHkoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZWFkT25seUhhbmRsZXIgPSBuZXcgUmVhZE9ubHlIYW5kbGVyKG1lbWJyYW5lLCBkaXN0b3J0ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAvLyBjYWNoaW5nIHRoZSByZWFkT25seSBwcm94eSBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyBhY2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoY3JlYXRlU2hhZG93VGFyZ2V0KGRpc3RvcnRlZFZhbHVlKSwgcmVhZE9ubHlIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyUHJveHkocHJveHksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHRoaXMsICdyZWFkT25seScsIHsgdmFsdWU6IHByb3h5IH0pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBvYmplY3RHcmFwaC5zZXQoZGlzdG9ydGVkVmFsdWUsIHJlYWN0aXZlU3RhdGUpO1xuICAgICAgICAgIHJldHVybiByZWFjdGl2ZVN0YXRlO1xuICAgICAgfVxuICB9XG4gIC8qKiB2ZXJzaW9uOiAwLjI2LjAgKi9cblxuICBmdW5jdGlvbiB3cmFwKGRhdGEsIG11dGF0aW9uQ2FsbGJhY2spIHtcblxuICAgIGxldCBtZW1icmFuZSA9IG5ldyBSZWFjdGl2ZU1lbWJyYW5lKHtcbiAgICAgIHZhbHVlTXV0YXRlZCh0YXJnZXQsIGtleSkge1xuICAgICAgICBtdXRhdGlvbkNhbGxiYWNrKHRhcmdldCwga2V5KTtcbiAgICAgIH1cblxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBtZW1icmFuZS5nZXRQcm94eShkYXRhKSxcbiAgICAgIG1lbWJyYW5lOiBtZW1icmFuZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdW53cmFwJDEobWVtYnJhbmUsIG9ic2VydmFibGUpIHtcbiAgICBsZXQgdW53cmFwcGVkRGF0YSA9IG1lbWJyYW5lLnVud3JhcFByb3h5KG9ic2VydmFibGUpO1xuICAgIGxldCBjb3B5ID0ge307XG4gICAgT2JqZWN0LmtleXModW53cmFwcGVkRGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKFsnJGVsJywgJyRyZWZzJywgJyRuZXh0VGljaycsICckd2F0Y2gnXS5pbmNsdWRlcyhrZXkpKSByZXR1cm47XG4gICAgICBjb3B5W2tleV0gPSB1bndyYXBwZWREYXRhW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICBjbGFzcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsLCBjb21wb25lbnRGb3JDbG9uZSA9IG51bGwpIHtcbiAgICAgIHRoaXMuJGVsID0gZWw7XG4gICAgICBjb25zdCBkYXRhQXR0ciA9IHRoaXMuJGVsLmdldEF0dHJpYnV0ZSgneC1kYXRhJyk7XG4gICAgICBjb25zdCBkYXRhRXhwcmVzc2lvbiA9IGRhdGFBdHRyID09PSAnJyA/ICd7fScgOiBkYXRhQXR0cjtcbiAgICAgIGNvbnN0IGluaXRFeHByZXNzaW9uID0gdGhpcy4kZWwuZ2V0QXR0cmlidXRlKCd4LWluaXQnKTtcbiAgICAgIGxldCBkYXRhRXh0cmFzID0ge1xuICAgICAgICAkZWw6IHRoaXMuJGVsXG4gICAgICB9O1xuICAgICAgbGV0IGNhbm9uaWNhbENvbXBvbmVudEVsZW1lbnRSZWZlcmVuY2UgPSBjb21wb25lbnRGb3JDbG9uZSA/IGNvbXBvbmVudEZvckNsb25lLiRlbCA6IHRoaXMuJGVsO1xuICAgICAgT2JqZWN0LmVudHJpZXMoQWxwaW5lLm1hZ2ljUHJvcGVydGllcykuZm9yRWFjaCgoW25hbWUsIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YUV4dHJhcywgYCQke25hbWV9YCwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNhbm9uaWNhbENvbXBvbmVudEVsZW1lbnRSZWZlcmVuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudW5vYnNlcnZlZERhdGEgPSBjb21wb25lbnRGb3JDbG9uZSA/IGNvbXBvbmVudEZvckNsb25lLmdldFVub2JzZXJ2ZWREYXRhKCkgOiBzYWZlckV2YWwoZWwsIGRhdGFFeHByZXNzaW9uLCBkYXRhRXh0cmFzKTtcbiAgICAgIC8vIENvbnN0cnVjdCBhIFByb3h5LWJhc2VkIG9ic2VydmFibGUuIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGhhbmRsZSByZWFjdGl2aXR5LlxuXG4gICAgICBsZXQge1xuICAgICAgICBtZW1icmFuZSxcbiAgICAgICAgZGF0YVxuICAgICAgfSA9IHRoaXMud3JhcERhdGFJbk9ic2VydmFibGUodGhpcy51bm9ic2VydmVkRGF0YSk7XG4gICAgICB0aGlzLiRkYXRhID0gZGF0YTtcbiAgICAgIHRoaXMubWVtYnJhbmUgPSBtZW1icmFuZTsgLy8gQWZ0ZXIgbWFraW5nIHVzZXItc3VwcGxpZWQgZGF0YSBtZXRob2RzIHJlYWN0aXZlLCB3ZSBjYW4gbm93IGFkZFxuICAgICAgLy8gb3VyIG1hZ2ljIHByb3BlcnRpZXMgdG8gdGhlIG9yaWdpbmFsIGRhdGEgZm9yIGFjY2Vzcy5cblxuICAgICAgdGhpcy51bm9ic2VydmVkRGF0YS4kZWwgPSB0aGlzLiRlbDtcbiAgICAgIHRoaXMudW5vYnNlcnZlZERhdGEuJHJlZnMgPSB0aGlzLmdldFJlZnNQcm94eSgpO1xuICAgICAgdGhpcy5uZXh0VGlja1N0YWNrID0gW107XG5cbiAgICAgIHRoaXMudW5vYnNlcnZlZERhdGEuJG5leHRUaWNrID0gY2FsbGJhY2sgPT4ge1xuICAgICAgICB0aGlzLm5leHRUaWNrU3RhY2sucHVzaChjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLndhdGNoZXJzID0ge307XG5cbiAgICAgIHRoaXMudW5vYnNlcnZlZERhdGEuJHdhdGNoID0gKHByb3BlcnR5LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBpZiAoIXRoaXMud2F0Y2hlcnNbcHJvcGVydHldKSB0aGlzLndhdGNoZXJzW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgICB0aGlzLndhdGNoZXJzW3Byb3BlcnR5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH07XG4gICAgICAvKiBNT0RFUk4tT05MWTpTVEFSVCAqL1xuICAgICAgLy8gV2UgcmVtb3ZlIHRoaXMgcGllY2Ugb2YgY29kZSBmcm9tIHRoZSBsZWdhY3kgYnVpbGQuXG4gICAgICAvLyBJbiBJRTExLCB3ZSBoYXZlIGFscmVhZHkgZGVmaW5lZCBvdXIgaGVscGVycyBhdCB0aGlzIHBvaW50LlxuICAgICAgLy8gUmVnaXN0ZXIgY3VzdG9tIG1hZ2ljIHByb3BlcnRpZXMuXG5cblxuICAgICAgT2JqZWN0LmVudHJpZXMoQWxwaW5lLm1hZ2ljUHJvcGVydGllcykuZm9yRWFjaCgoW25hbWUsIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy51bm9ic2VydmVkRGF0YSwgYCQke25hbWV9YCwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNhbm9uaWNhbENvbXBvbmVudEVsZW1lbnRSZWZlcmVuY2UsIHRoaXMuJGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvKiBNT0RFUk4tT05MWTpFTkQgKi9cblxuICAgICAgdGhpcy5zaG93RGlyZWN0aXZlU3RhY2sgPSBbXTtcbiAgICAgIHRoaXMuc2hvd0RpcmVjdGl2ZUxhc3RFbGVtZW50O1xuICAgICAgY29tcG9uZW50Rm9yQ2xvbmUgfHwgQWxwaW5lLm9uQmVmb3JlQ29tcG9uZW50SW5pdGlhbGl6ZWRzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodGhpcykpO1xuICAgICAgdmFyIGluaXRSZXR1cm5lZENhbGxiYWNrOyAvLyBJZiB4LWluaXQgaXMgcHJlc2VudCBBTkQgd2UgYXJlbid0IGNsb25pbmcgKHNraXAgeC1pbml0IG9uIGNsb25lKVxuXG4gICAgICBpZiAoaW5pdEV4cHJlc3Npb24gJiYgIWNvbXBvbmVudEZvckNsb25lKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gYWxsb3cgZGF0YSBtYW5pcHVsYXRpb24sIGJ1dCBub3QgdHJpZ2dlciBET00gdXBkYXRlcyBqdXN0IHlldC5cbiAgICAgICAgLy8gV2UgaGF2ZW4ndCBldmVuIGluaXRpYWxpemVkIHRoZSBlbGVtZW50cyB3aXRoIHRoZWlyIEFscGluZSBiaW5kaW5ncy4gSSBtZWFuIGMnbW9uLlxuICAgICAgICB0aGlzLnBhdXNlUmVhY3Rpdml0eSA9IHRydWU7XG4gICAgICAgIGluaXRSZXR1cm5lZENhbGxiYWNrID0gdGhpcy5ldmFsdWF0ZVJldHVybkV4cHJlc3Npb24odGhpcy4kZWwsIGluaXRFeHByZXNzaW9uKTtcbiAgICAgICAgdGhpcy5wYXVzZVJlYWN0aXZpdHkgPSBmYWxzZTtcbiAgICAgIH0gLy8gUmVnaXN0ZXIgYWxsIG91ciBsaXN0ZW5lcnMgYW5kIHNldCBhbGwgb3VyIGF0dHJpYnV0ZSBiaW5kaW5ncy5cblxuXG4gICAgICB0aGlzLmluaXRpYWxpemVFbGVtZW50cyh0aGlzLiRlbCk7IC8vIFVzZSBtdXRhdGlvbiBvYnNlcnZlciB0byBkZXRlY3QgbmV3IGVsZW1lbnRzIGJlaW5nIGFkZGVkIHdpdGhpbiB0aGlzIGNvbXBvbmVudCBhdCBydW4tdGltZS5cbiAgICAgIC8vIEFscGluZSdzIGp1c3Qgc28gZGFybiBmbGV4aWJsZSBhbWlyaXRlP1xuXG4gICAgICB0aGlzLmxpc3RlbkZvck5ld0VsZW1lbnRzVG9Jbml0aWFsaXplKCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5pdFJldHVybmVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gUnVuIHRoZSBjYWxsYmFjayByZXR1cm5lZCBmcm9tIHRoZSBcIngtaW5pdFwiIGhvb2sgdG8gYWxsb3cgdGhlIHVzZXIgdG8gZG8gc3R1ZmYgYWZ0ZXJcbiAgICAgICAgLy8gQWxwaW5lJ3MgZ290IGl0J3MgZ3J1YmJ5IGxpdHRsZSBwYXdzIGFsbCBvdmVyIGV2ZXJ5dGhpbmcuXG4gICAgICAgIGluaXRSZXR1cm5lZENhbGxiYWNrLmNhbGwodGhpcy4kZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudEZvckNsb25lIHx8IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBBbHBpbmUub25Db21wb25lbnRJbml0aWFsaXplZHMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh0aGlzKSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBnZXRVbm9ic2VydmVkRGF0YSgpIHtcbiAgICAgIHJldHVybiB1bndyYXAkMSh0aGlzLm1lbWJyYW5lLCB0aGlzLiRkYXRhKTtcbiAgICB9XG5cbiAgICB3cmFwRGF0YUluT2JzZXJ2YWJsZShkYXRhKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBsZXQgdXBkYXRlRG9tID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnVwZGF0ZUVsZW1lbnRzKHNlbGYuJGVsKTtcbiAgICAgIH0sIDApO1xuICAgICAgcmV0dXJuIHdyYXAoZGF0YSwgKHRhcmdldCwga2V5KSA9PiB7XG4gICAgICAgIGlmIChzZWxmLndhdGNoZXJzW2tleV0pIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgd2F0Y2hlciBmb3IgdGhpcyBzcGVjaWZpYyBrZXksIHJ1biBpdC5cbiAgICAgICAgICBzZWxmLndhdGNoZXJzW2tleV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh0YXJnZXRba2V5XSkpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgIC8vIEFycmF5cyBhcmUgc3BlY2lhbCBjYXNlcywgaWYgYW55IG9mIHRoZSBpdGVtcyBjaGFuZ2UsIHdlIGNvbnNpZGVyIHRoZSBhcnJheSBhcyBtdXRhdGVkLlxuICAgICAgICAgIE9iamVjdC5rZXlzKHNlbGYud2F0Y2hlcnMpLmZvckVhY2goZnVsbERvdE5vdGF0aW9uS2V5ID0+IHtcbiAgICAgICAgICAgIGxldCBkb3ROb3RhdGlvblBhcnRzID0gZnVsbERvdE5vdGF0aW9uS2V5LnNwbGl0KCcuJyk7IC8vIElnbm9yZSBsZW5ndGggbXV0YXRpb25zIHNpbmNlIHRoZXkgd291bGQgcmVzdWx0IGluIGR1cGxpY2F0ZSBjYWxscy5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIGNhbGxpbmcgcHVzaCwgd2Ugd291bGQgZ2V0IGEgbXV0YXRpb24gZm9yIHRoZSBpdGVtJ3Mga2V5XG4gICAgICAgICAgICAvLyBhbmQgYSBzZWNvbmQgbXV0YXRpb24gZm9yIHRoZSBsZW5ndGggcHJvcGVydHkuXG5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdsZW5ndGgnKSByZXR1cm47XG4gICAgICAgICAgICBkb3ROb3RhdGlvblBhcnRzLnJlZHVjZSgoY29tcGFyaXNvbkRhdGEsIHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5pcyh0YXJnZXQsIGNvbXBhcmlzb25EYXRhW3BhcnRdKSkge1xuICAgICAgICAgICAgICAgIHNlbGYud2F0Y2hlcnNbZnVsbERvdE5vdGF0aW9uS2V5XS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHRhcmdldCkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb25EYXRhW3BhcnRdO1xuICAgICAgICAgICAgfSwgc2VsZi51bm9ic2VydmVkRGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTGV0J3Mgd2FsayB0aHJvdWdoIHRoZSB3YXRjaGVycyB3aXRoIFwiZG90LW5vdGF0aW9uXCIgKGZvby5iYXIpIGFuZCBzZWVcbiAgICAgICAgICAvLyBpZiB0aGlzIG11dGF0aW9uIGZpdHMgYW55IG9mIHRoZW0uXG4gICAgICAgICAgT2JqZWN0LmtleXMoc2VsZi53YXRjaGVycykuZmlsdGVyKGkgPT4gaS5pbmNsdWRlcygnLicpKS5mb3JFYWNoKGZ1bGxEb3ROb3RhdGlvbktleSA9PiB7XG4gICAgICAgICAgICBsZXQgZG90Tm90YXRpb25QYXJ0cyA9IGZ1bGxEb3ROb3RhdGlvbktleS5zcGxpdCgnLicpOyAvLyBJZiB0aGlzIGRvdC1ub3RhdGlvbiB3YXRjaGVyJ3MgbGFzdCBcInBhcnRcIiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAvLyBrZXksIHRoZW4gc2tpcCBpdCBlYXJseSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cblxuICAgICAgICAgICAgaWYgKGtleSAhPT0gZG90Tm90YXRpb25QYXJ0c1tkb3ROb3RhdGlvblBhcnRzLmxlbmd0aCAtIDFdKSByZXR1cm47IC8vIE5vdywgd2FsayB0aHJvdWdoIHRoZSBkb3Qtbm90YXRpb24gXCJwYXJ0c1wiIHJlY3Vyc2l2ZWx5IHRvIGZpbmRcbiAgICAgICAgICAgIC8vIGEgbWF0Y2gsIGFuZCBjYWxsIHRoZSB3YXRjaGVyIGlmIG9uZSdzIGZvdW5kLlxuXG4gICAgICAgICAgICBkb3ROb3RhdGlvblBhcnRzLnJlZHVjZSgoY29tcGFyaXNvbkRhdGEsIHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKE9iamVjdC5pcyh0YXJnZXQsIGNvbXBhcmlzb25EYXRhKSkge1xuICAgICAgICAgICAgICAgIC8vIFJ1biB0aGUgd2F0Y2hlcnMuXG4gICAgICAgICAgICAgICAgc2VsZi53YXRjaGVyc1tmdWxsRG90Tm90YXRpb25LZXldLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodGFyZ2V0W2tleV0pKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uRGF0YVtwYXJ0XTtcbiAgICAgICAgICAgIH0sIHNlbGYudW5vYnNlcnZlZERhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIERvbid0IHJlYWN0IHRvIGRhdGEgY2hhbmdlcyBmb3IgY2FzZXMgbGlrZSB0aGUgYHgtY3JlYXRlZGAgaG9vay5cblxuXG4gICAgICAgIGlmIChzZWxmLnBhdXNlUmVhY3Rpdml0eSkgcmV0dXJuO1xuICAgICAgICB1cGRhdGVEb20oKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHdhbGtBbmRTa2lwTmVzdGVkQ29tcG9uZW50cyhlbCwgY2FsbGJhY2ssIGluaXRpYWxpemVDb21wb25lbnRDYWxsYmFjayA9ICgpID0+IHt9KSB7XG4gICAgICB3YWxrKGVsLCBlbCA9PiB7XG4gICAgICAgIC8vIFdlJ3ZlIGhpdCBhIGNvbXBvbmVudC5cbiAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgneC1kYXRhJykpIHtcbiAgICAgICAgICAvLyBJZiBpdCdzIG5vdCB0aGUgY3VycmVudCBvbmUuXG4gICAgICAgICAgaWYgKCFlbC5pc1NhbWVOb2RlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBpdCBpZiBpdCdzIG5vdC5cbiAgICAgICAgICAgIGlmICghZWwuX194KSBpbml0aWFsaXplQ29tcG9uZW50Q2FsbGJhY2soZWwpOyAvLyBOb3cgd2UnbGwgbGV0IHRoYXQgc3ViLWNvbXBvbmVudCBkZWFsIHdpdGggaXRzZWxmLlxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVFbGVtZW50cyhyb290RWwsIGV4dHJhVmFycyA9ICgpID0+IHt9KSB7XG4gICAgICB0aGlzLndhbGtBbmRTa2lwTmVzdGVkQ29tcG9uZW50cyhyb290RWwsIGVsID0+IHtcbiAgICAgICAgLy8gRG9uJ3QgdG91Y2ggc3Bhd25zIGZyb20gZm9yIGxvb3BcbiAgICAgICAgaWYgKGVsLl9feF9mb3Jfa2V5ICE9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTsgLy8gRG9uJ3QgdG91Y2ggc3Bhd25zIGZyb20gaWYgZGlyZWN0aXZlc1xuXG4gICAgICAgIGlmIChlbC5fX3hfaW5zZXJ0ZWRfbWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVFbGVtZW50KGVsLCBleHRyYVZhcnMpO1xuICAgICAgfSwgZWwgPT4ge1xuICAgICAgICBlbC5fX3ggPSBuZXcgQ29tcG9uZW50KGVsKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5leGVjdXRlQW5kQ2xlYXJSZW1haW5pbmdTaG93RGlyZWN0aXZlU3RhY2soKTtcbiAgICAgIHRoaXMuZXhlY3V0ZUFuZENsZWFyTmV4dFRpY2tTdGFjayhyb290RWwpO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVFbGVtZW50KGVsLCBleHRyYVZhcnMpIHtcbiAgICAgIC8vIFRvIHN1cHBvcnQgY2xhc3MgYXR0cmlidXRlIG1lcmdpbmcsIHdlIGhhdmUgdG8ga25vdyB3aGF0IHRoZSBlbGVtZW50J3NcbiAgICAgIC8vIG9yaWdpbmFsIGNsYXNzIGF0dHJpYnV0ZSBsb29rZWQgbGlrZSBmb3IgcmVmZXJlbmNlLlxuICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnY2xhc3MnKSAmJiBnZXRYQXR0cnMoZWwsIHRoaXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWwuX194X29yaWdpbmFsX2NsYXNzZXMgPSBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoZWwsIGV4dHJhVmFycyk7XG4gICAgICB0aGlzLnJlc29sdmVCb3VuZEF0dHJpYnV0ZXMoZWwsIHRydWUsIGV4dHJhVmFycyk7XG4gICAgfVxuXG4gICAgdXBkYXRlRWxlbWVudHMocm9vdEVsLCBleHRyYVZhcnMgPSAoKSA9PiB7fSkge1xuICAgICAgdGhpcy53YWxrQW5kU2tpcE5lc3RlZENvbXBvbmVudHMocm9vdEVsLCBlbCA9PiB7XG4gICAgICAgIC8vIERvbid0IHRvdWNoIHNwYXducyBmcm9tIGZvciBsb29wIChhbmQgY2hlY2sgaWYgdGhlIHJvb3QgaXMgYWN0dWFsbHkgYSBmb3IgbG9vcCBpbiBhIHBhcmVudCwgZG9uJ3Qgc2tpcCBpdC4pXG4gICAgICAgIGlmIChlbC5fX3hfZm9yX2tleSAhPT0gdW5kZWZpbmVkICYmICFlbC5pc1NhbWVOb2RlKHRoaXMuJGVsKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoZWwsIGV4dHJhVmFycyk7XG4gICAgICB9LCBlbCA9PiB7XG4gICAgICAgIGVsLl9feCA9IG5ldyBDb21wb25lbnQoZWwpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmV4ZWN1dGVBbmRDbGVhclJlbWFpbmluZ1Nob3dEaXJlY3RpdmVTdGFjaygpO1xuICAgICAgdGhpcy5leGVjdXRlQW5kQ2xlYXJOZXh0VGlja1N0YWNrKHJvb3RFbCk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZUFuZENsZWFyTmV4dFRpY2tTdGFjayhlbCkge1xuICAgICAgLy8gU2tpcCBzcGF3bnMgZnJvbSBhbHBpbmUgZGlyZWN0aXZlc1xuICAgICAgaWYgKGVsID09PSB0aGlzLiRlbCAmJiB0aGlzLm5leHRUaWNrU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBXZSBydW4gdGhlIHRpY2sgc3RhY2sgYWZ0ZXIgdGhlIG5leHQgZnJhbWUgdG8gYWxsb3cgYW55XG4gICAgICAgIC8vIHJ1bm5pbmcgdHJhbnNpdGlvbnMgdG8gcGFzcyB0aGUgaW5pdGlhbCBzaG93IHN0YWdlLlxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHdoaWxlICh0aGlzLm5leHRUaWNrU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0VGlja1N0YWNrLnNoaWZ0KCkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4ZWN1dGVBbmRDbGVhclJlbWFpbmluZ1Nob3dEaXJlY3RpdmVTdGFjaygpIHtcbiAgICAgIC8vIFRoZSBnb2FsIGhlcmUgaXMgdG8gc3RhcnQgYWxsIHRoZSB4LXNob3cgdHJhbnNpdGlvbnNcbiAgICAgIC8vIGFuZCBidWlsZCBhIG5lc3RlZCBwcm9taXNlIGNoYWluIHNvIHRoYXQgZWxlbWVudHNcbiAgICAgIC8vIG9ubHkgaGlkZSB3aGVuIHRoZSBjaGlsZHJlbiBhcmUgZmluaXNoZWQgaGlkaW5nLlxuICAgICAgdGhpcy5zaG93RGlyZWN0aXZlU3RhY2sucmV2ZXJzZSgpLm1hcChoYW5kbGVyID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBoYW5kbGVyKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkucmVkdWNlKChwcm9taXNlQ2hhaW4sIHByb21pc2UpID0+IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VDaGFpbi50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZpbmlzaEVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgZmluaXNoRWxlbWVudCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sIFByb21pc2UucmVzb2x2ZSgoKSA9PiB7fSkpLmNhdGNoKGUgPT4ge1xuICAgICAgICBpZiAoZSAhPT0gVFJBTlNJVElPTl9DQU5DRUxMRUQpIHRocm93IGU7XG4gICAgICB9KTsgLy8gV2UndmUgcHJvY2Vzc2VkIHRoZSBoYW5kbGVyIHN0YWNrLiBsZXQncyBjbGVhciBpdC5cblxuICAgICAgdGhpcy5zaG93RGlyZWN0aXZlU3RhY2sgPSBbXTtcbiAgICAgIHRoaXMuc2hvd0RpcmVjdGl2ZUxhc3RFbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHVwZGF0ZUVsZW1lbnQoZWwsIGV4dHJhVmFycykge1xuICAgICAgdGhpcy5yZXNvbHZlQm91bmRBdHRyaWJ1dGVzKGVsLCBmYWxzZSwgZXh0cmFWYXJzKTtcbiAgICB9XG5cbiAgICByZWdpc3Rlckxpc3RlbmVycyhlbCwgZXh0cmFWYXJzKSB7XG4gICAgICBnZXRYQXR0cnMoZWwsIHRoaXMpLmZvckVhY2goKHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgZXhwcmVzc2lvblxuICAgICAgfSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdvbic6XG4gICAgICAgICAgICByZWdpc3Rlckxpc3RlbmVyKHRoaXMsIGVsLCB2YWx1ZSwgbW9kaWZpZXJzLCBleHByZXNzaW9uLCBleHRyYVZhcnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdtb2RlbCc6XG4gICAgICAgICAgICByZWdpc3Rlck1vZGVsTGlzdGVuZXIodGhpcywgZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXNvbHZlQm91bmRBdHRyaWJ1dGVzKGVsLCBpbml0aWFsVXBkYXRlID0gZmFsc2UsIGV4dHJhVmFycykge1xuICAgICAgbGV0IGF0dHJzID0gZ2V0WEF0dHJzKGVsLCB0aGlzKTtcbiAgICAgIGF0dHJzLmZvckVhY2goKHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG1vZGlmaWVycyxcbiAgICAgICAgZXhwcmVzc2lvblxuICAgICAgfSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdtb2RlbCc6XG4gICAgICAgICAgICBoYW5kbGVBdHRyaWJ1dGVCaW5kaW5nRGlyZWN0aXZlKHRoaXMsIGVsLCAndmFsdWUnLCBleHByZXNzaW9uLCBleHRyYVZhcnMsIHR5cGUsIG1vZGlmaWVycyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2JpbmQnOlxuICAgICAgICAgICAgLy8gVGhlIDprZXkgYmluZGluZyBvbiBhbiB4LWZvciBpcyBzcGVjaWFsLCBpZ25vcmUgaXQuXG4gICAgICAgICAgICBpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGVtcGxhdGUnICYmIHZhbHVlID09PSAna2V5JykgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlQXR0cmlidXRlQmluZGluZ0RpcmVjdGl2ZSh0aGlzLCBlbCwgdmFsdWUsIGV4cHJlc3Npb24sIGV4dHJhVmFycywgdHlwZSwgbW9kaWZpZXJzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5ldmFsdWF0ZVJldHVybkV4cHJlc3Npb24oZWwsIGV4cHJlc3Npb24sIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBoYW5kbGVUZXh0RGlyZWN0aXZlKGVsLCBvdXRwdXQsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgIGhhbmRsZUh0bWxEaXJlY3RpdmUodGhpcywgZWwsIGV4cHJlc3Npb24sIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3Nob3cnOlxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBleHByZXNzaW9uLCBleHRyYVZhcnMpO1xuICAgICAgICAgICAgaGFuZGxlU2hvd0RpcmVjdGl2ZSh0aGlzLCBlbCwgb3V0cHV0LCBtb2RpZmllcnMsIGluaXRpYWxVcGRhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdpZic6XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgYWxzbyBoYXMgeC1mb3Igb24gaXQsIGRvbid0IHByb2Nlc3MgeC1pZi5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgbGV0IHRoZSBcIngtZm9yXCIgZGlyZWN0aXZlIGhhbmRsZSB0aGUgXCJpZlwiaW5nLlxuICAgICAgICAgICAgaWYgKGF0dHJzLnNvbWUoaSA9PiBpLnR5cGUgPT09ICdmb3InKSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBleHByZXNzaW9uLCBleHRyYVZhcnMpO1xuICAgICAgICAgICAgaGFuZGxlSWZEaXJlY3RpdmUodGhpcywgZWwsIG91dHB1dCwgaW5pdGlhbFVwZGF0ZSwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZm9yJzpcbiAgICAgICAgICAgIGhhbmRsZUZvckRpcmVjdGl2ZSh0aGlzLCBlbCwgZXhwcmVzc2lvbiwgaW5pdGlhbFVwZGF0ZSwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2xvYWsnOlxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCd4LWNsb2FrJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBleHByZXNzaW9uLCBleHRyYVZhcnMgPSAoKSA9PiB7fSkge1xuICAgICAgcmV0dXJuIHNhZmVyRXZhbChlbCwgZXhwcmVzc2lvbiwgdGhpcy4kZGF0YSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGV4dHJhVmFycygpKSwge30sIHtcbiAgICAgICAgJGRpc3BhdGNoOiB0aGlzLmdldERpc3BhdGNoRnVuY3Rpb24oZWwpXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgZXZhbHVhdGVDb21tYW5kRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzID0gKCkgPT4ge30pIHtcbiAgICAgIHJldHVybiBzYWZlckV2YWxOb1JldHVybihlbCwgZXhwcmVzc2lvbiwgdGhpcy4kZGF0YSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGV4dHJhVmFycygpKSwge30sIHtcbiAgICAgICAgJGRpc3BhdGNoOiB0aGlzLmdldERpc3BhdGNoRnVuY3Rpb24oZWwpXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgZ2V0RGlzcGF0Y2hGdW5jdGlvbihlbCkge1xuICAgICAgcmV0dXJuIChldmVudCwgZGV0YWlsID0ge30pID0+IHtcbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgICBkZXRhaWwsXG4gICAgICAgICAgYnViYmxlczogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGxpc3RlbkZvck5ld0VsZW1lbnRzVG9Jbml0aWFsaXplKCkge1xuICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuJGVsO1xuICAgICAgY29uc3Qgb2JzZXJ2ZXJPcHRpb25zID0ge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH07XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgLy8gRmlsdGVyIG91dCBtdXRhdGlvbnMgdHJpZ2dlcmVkIGZyb20gY2hpbGQgY29tcG9uZW50cy5cbiAgICAgICAgICBjb25zdCBjbG9zZXN0UGFyZW50Q29tcG9uZW50ID0gbXV0YXRpb25zW2ldLnRhcmdldC5jbG9zZXN0KCdbeC1kYXRhXScpO1xuICAgICAgICAgIGlmICghKGNsb3Nlc3RQYXJlbnRDb21wb25lbnQgJiYgY2xvc2VzdFBhcmVudENvbXBvbmVudC5pc1NhbWVOb2RlKHRoaXMuJGVsKSkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKG11dGF0aW9uc1tpXS50eXBlID09PSAnYXR0cmlidXRlcycgJiYgbXV0YXRpb25zW2ldLmF0dHJpYnV0ZU5hbWUgPT09ICd4LWRhdGEnKSB7XG4gICAgICAgICAgICBjb25zdCB4QXR0ciA9IG11dGF0aW9uc1tpXS50YXJnZXQuZ2V0QXR0cmlidXRlKCd4LWRhdGEnKSB8fCAne30nO1xuICAgICAgICAgICAgY29uc3QgcmF3RGF0YSA9IHNhZmVyRXZhbCh0aGlzLiRlbCwgeEF0dHIsIHtcbiAgICAgICAgICAgICAgJGVsOiB0aGlzLiRlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyYXdEYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLiRkYXRhW2tleV0gIT09IHJhd0RhdGFba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGRhdGFba2V5XSA9IHJhd0RhdGFba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG11dGF0aW9uc1tpXS5hZGRlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG11dGF0aW9uc1tpXS5hZGRlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxIHx8IG5vZGUuX194X2luc2VydGVkX21lKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgaWYgKG5vZGUubWF0Y2hlcygnW3gtZGF0YV0nKSAmJiAhbm9kZS5fX3gpIHtcbiAgICAgICAgICAgICAgICBub2RlLl9feCA9IG5ldyBDb21wb25lbnQobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRWxlbWVudHMobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXROb2RlLCBvYnNlcnZlck9wdGlvbnMpO1xuICAgIH1cblxuICAgIGdldFJlZnNQcm94eSgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciByZWZPYmogPSB7fTtcbiAgICAgIC8vIE9uZSBvZiB0aGUgZ29hbHMgb2YgdGhpcyBpcyB0byBub3QgaG9sZCBlbGVtZW50cyBpbiBtZW1vcnksIGJ1dCByYXRoZXIgcmUtZXZhbHVhdGVcbiAgICAgIC8vIHRoZSBET00gd2hlbiB0aGUgc3lzdGVtIG5lZWRzIHNvbWV0aGluZyBmcm9tIGl0LiBUaGlzIHdheSwgdGhlIGZyYW1ld29yayBpcyBmbGV4aWJsZSBhbmRcbiAgICAgIC8vIGZyaWVuZGx5IHRvIG91dHNpZGUgRE9NIGNoYW5nZXMgZnJvbSBsaWJyYXJpZXMgbGlrZSBWdWUvTGl2ZXdpcmUuXG4gICAgICAvLyBGb3IgdGhpcyByZWFzb24sIEknbSB1c2luZyBhbiBcIm9uLWRlbWFuZFwiIHByb3h5IHRvIGZha2UgYSBcIiRyZWZzXCIgb2JqZWN0LlxuXG4gICAgICByZXR1cm4gbmV3IFByb3h5KHJlZk9iaiwge1xuICAgICAgICBnZXQob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJyRpc0FscGluZVByb3h5JykgcmV0dXJuIHRydWU7XG4gICAgICAgICAgdmFyIHJlZjsgLy8gV2UgY2FuJ3QganVzdCBxdWVyeSB0aGUgRE9NIGJlY2F1c2UgaXQncyBoYXJkIHRvIGZpbHRlciBvdXQgcmVmcyBpblxuICAgICAgICAgIC8vIG5lc3RlZCBjb21wb25lbnRzLlxuXG4gICAgICAgICAgc2VsZi53YWxrQW5kU2tpcE5lc3RlZENvbXBvbmVudHMoc2VsZi4kZWwsIGVsID0+IHtcbiAgICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3gtcmVmJykgJiYgZWwuZ2V0QXR0cmlidXRlKCd4LXJlZicpID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICByZWYgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuICAgIH1cblxuICB9XG5cbiAgY29uc3QgQWxwaW5lID0ge1xuICAgIHZlcnNpb246IFwiMi44LjBcIixcbiAgICBwYXVzZU11dGF0aW9uT2JzZXJ2ZXI6IGZhbHNlLFxuICAgIG1hZ2ljUHJvcGVydGllczoge30sXG4gICAgb25Db21wb25lbnRJbml0aWFsaXplZHM6IFtdLFxuICAgIG9uQmVmb3JlQ29tcG9uZW50SW5pdGlhbGl6ZWRzOiBbXSxcbiAgICBpZ25vcmVGb2N1c2VkRm9yVmFsdWVCaW5kaW5nOiBmYWxzZSxcbiAgICBzdGFydDogYXN5bmMgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBpZiAoIWlzVGVzdGluZygpKSB7XG4gICAgICAgIGF3YWl0IGRvbVJlYWR5KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGlzY292ZXJDb21wb25lbnRzKGVsID0+IHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplQ29tcG9uZW50KGVsKTtcbiAgICAgIH0pOyAvLyBJdCdzIGVhc2llciBhbmQgbW9yZSBwZXJmb3JtYW50IHRvIGp1c3Qgc3VwcG9ydCBUdXJib2xpbmtzIHRoYW4gbGlzdGVuXG4gICAgICAvLyB0byBNdXRhdGlvbk9ic2VydmVyIG11dGF0aW9ucyBhdCB0aGUgZG9jdW1lbnQgbGV2ZWwuXG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0dXJib2xpbmtzOmxvYWRcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmRpc2NvdmVyVW5pbml0aWFsaXplZENvbXBvbmVudHMoZWwgPT4ge1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbXBvbmVudChlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmxpc3RlbkZvck5ld1VuaW5pdGlhbGl6ZWRDb21wb25lbnRzQXRSdW5UaW1lKCk7XG4gICAgfSxcbiAgICBkaXNjb3ZlckNvbXBvbmVudHM6IGZ1bmN0aW9uIGRpc2NvdmVyQ29tcG9uZW50cyhjYWxsYmFjaykge1xuICAgICAgY29uc3Qgcm9vdEVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1t4LWRhdGFdJyk7XG4gICAgICByb290RWxzLmZvckVhY2gocm9vdEVsID0+IHtcbiAgICAgICAgY2FsbGJhY2socm9vdEVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGlzY292ZXJVbmluaXRpYWxpemVkQ29tcG9uZW50czogZnVuY3Rpb24gZGlzY292ZXJVbmluaXRpYWxpemVkQ29tcG9uZW50cyhjYWxsYmFjaywgZWwgPSBudWxsKSB7XG4gICAgICBjb25zdCByb290RWxzID0gKGVsIHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKCdbeC1kYXRhXScpO1xuICAgICAgQXJyYXkuZnJvbShyb290RWxzKS5maWx0ZXIoZWwgPT4gZWwuX194ID09PSB1bmRlZmluZWQpLmZvckVhY2gocm9vdEVsID0+IHtcbiAgICAgICAgY2FsbGJhY2socm9vdEVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbGlzdGVuRm9yTmV3VW5pbml0aWFsaXplZENvbXBvbmVudHNBdFJ1blRpbWU6IGZ1bmN0aW9uIGxpc3RlbkZvck5ld1VuaW5pdGlhbGl6ZWRDb21wb25lbnRzQXRSdW5UaW1lKCkge1xuICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcbiAgICAgIGNvbnN0IG9ic2VydmVyT3B0aW9ucyA9IHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9O1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICBpZiAodGhpcy5wYXVzZU11dGF0aW9uT2JzZXJ2ZXIpIHJldHVybjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAvLyBEaXNjYXJkIG5vbi1lbGVtZW50IG5vZGVzIChsaWtlIGxpbmUtYnJlYWtzKVxuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuOyAvLyBEaXNjYXJkIGFueSBjaGFuZ2VzIGhhcHBlbmluZyB3aXRoaW4gYW4gZXhpc3RpbmcgY29tcG9uZW50LlxuICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgdGFrZSBjYXJlIG9mIHRoZW1zZWx2ZXMuXG5cbiAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50RWxlbWVudCAmJiBub2RlLnBhcmVudEVsZW1lbnQuY2xvc2VzdCgnW3gtZGF0YV0nKSkgcmV0dXJuO1xuICAgICAgICAgICAgICB0aGlzLmRpc2NvdmVyVW5pbml0aWFsaXplZENvbXBvbmVudHMoZWwgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbXBvbmVudChlbCk7XG4gICAgICAgICAgICAgIH0sIG5vZGUucGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXROb2RlLCBvYnNlcnZlck9wdGlvbnMpO1xuICAgIH0sXG4gICAgaW5pdGlhbGl6ZUNvbXBvbmVudDogZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbXBvbmVudChlbCkge1xuICAgICAgaWYgKCFlbC5fX3gpIHtcbiAgICAgICAgLy8gV3JhcCBpbiBhIHRyeS9jYXRjaCBzbyB0aGF0IHdlIGRvbid0IHByZXZlbnQgb3RoZXIgY29tcG9uZW50c1xuICAgICAgICAvLyBmcm9tIGluaXRpYWxpemluZyB3aGVuIG9uZSBjb21wb25lbnQgY29udGFpbnMgYW4gZXJyb3IuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZWwuX194ID0gbmV3IENvbXBvbmVudChlbCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGNvbXBvbmVudCwgbmV3RWwpIHtcbiAgICAgIGlmICghbmV3RWwuX194KSB7XG4gICAgICAgIG5ld0VsLl9feCA9IG5ldyBDb21wb25lbnQobmV3RWwsIGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGRNYWdpY1Byb3BlcnR5OiBmdW5jdGlvbiBhZGRNYWdpY1Byb3BlcnR5KG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm1hZ2ljUHJvcGVydGllc1tuYW1lXSA9IGNhbGxiYWNrO1xuICAgIH0sXG4gICAgb25Db21wb25lbnRJbml0aWFsaXplZDogZnVuY3Rpb24gb25Db21wb25lbnRJbml0aWFsaXplZChjYWxsYmFjaykge1xuICAgICAgdGhpcy5vbkNvbXBvbmVudEluaXRpYWxpemVkcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9uQmVmb3JlQ29tcG9uZW50SW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uIG9uQmVmb3JlQ29tcG9uZW50SW5pdGlhbGl6ZWQoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25CZWZvcmVDb21wb25lbnRJbml0aWFsaXplZHMucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIGlmICghaXNUZXN0aW5nKCkpIHtcbiAgICB3aW5kb3cuQWxwaW5lID0gQWxwaW5lO1xuXG4gICAgaWYgKHdpbmRvdy5kZWZlckxvYWRpbmdBbHBpbmUpIHtcbiAgICAgIHdpbmRvdy5kZWZlckxvYWRpbmdBbHBpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuQWxwaW5lLnN0YXJ0KCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LkFscGluZS5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBBbHBpbmU7XG5cbn0pKSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxXQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/alpinejs/dist/alpine.js\n");

/***/ }),

/***/ "./node_modules/nprogress/nprogress.js":
/*!*********************************************!*\
  !*** ./node_modules/nprogress/nprogress.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\n * @license MIT */\n\n;(function(root, factory) {\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})(this, function() {\n  var NProgress = {};\n\n  NProgress.version = '0.2.0';\n\n  var Settings = NProgress.settings = {\n    minimum: 0.08,\n    easing: 'ease',\n    positionUsing: '',\n    speed: 200,\n    trickle: true,\n    trickleRate: 0.02,\n    trickleSpeed: 800,\n    showSpinner: true,\n    barSelector: '[role=\"bar\"]',\n    spinnerSelector: '[role=\"spinner\"]',\n    parent: 'body',\n    template: '<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div><div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>'\n  };\n\n  /**\n   * Updates configuration.\n   *\n   *     NProgress.configure({\n   *       minimum: 0.1\n   *     });\n   */\n  NProgress.configure = function(options) {\n    var key, value;\n    for (key in options) {\n      value = options[key];\n      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\n    }\n\n    return this;\n  };\n\n  /**\n   * Last number.\n   */\n\n  NProgress.status = null;\n\n  /**\n   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\n   *\n   *     NProgress.set(0.4);\n   *     NProgress.set(1.0);\n   */\n\n  NProgress.set = function(n) {\n    var started = NProgress.isStarted();\n\n    n = clamp(n, Settings.minimum, 1);\n    NProgress.status = (n === 1 ? null : n);\n\n    var progress = NProgress.render(!started),\n        bar      = progress.querySelector(Settings.barSelector),\n        speed    = Settings.speed,\n        ease     = Settings.easing;\n\n    progress.offsetWidth; /* Repaint */\n\n    queue(function(next) {\n      // Set positionUsing if it hasn't already been set\n      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\n\n      // Add transition\n      css(bar, barPositionCSS(n, speed, ease));\n\n      if (n === 1) {\n        // Fade out\n        css(progress, { \n          transition: 'none', \n          opacity: 1 \n        });\n        progress.offsetWidth; /* Repaint */\n\n        setTimeout(function() {\n          css(progress, { \n            transition: 'all ' + speed + 'ms linear', \n            opacity: 0 \n          });\n          setTimeout(function() {\n            NProgress.remove();\n            next();\n          }, speed);\n        }, speed);\n      } else {\n        setTimeout(next, speed);\n      }\n    });\n\n    return this;\n  };\n\n  NProgress.isStarted = function() {\n    return typeof NProgress.status === 'number';\n  };\n\n  /**\n   * Shows the progress bar.\n   * This is the same as setting the status to 0%, except that it doesn't go backwards.\n   *\n   *     NProgress.start();\n   *\n   */\n  NProgress.start = function() {\n    if (!NProgress.status) NProgress.set(0);\n\n    var work = function() {\n      setTimeout(function() {\n        if (!NProgress.status) return;\n        NProgress.trickle();\n        work();\n      }, Settings.trickleSpeed);\n    };\n\n    if (Settings.trickle) work();\n\n    return this;\n  };\n\n  /**\n   * Hides the progress bar.\n   * This is the *sort of* the same as setting the status to 100%, with the\n   * difference being `done()` makes some placebo effect of some realistic motion.\n   *\n   *     NProgress.done();\n   *\n   * If `true` is passed, it will show the progress bar even if its hidden.\n   *\n   *     NProgress.done(true);\n   */\n\n  NProgress.done = function(force) {\n    if (!force && !NProgress.status) return this;\n\n    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\n  };\n\n  /**\n   * Increments by a random amount.\n   */\n\n  NProgress.inc = function(amount) {\n    var n = NProgress.status;\n\n    if (!n) {\n      return NProgress.start();\n    } else {\n      if (typeof amount !== 'number') {\n        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\n      }\n\n      n = clamp(n + amount, 0, 0.994);\n      return NProgress.set(n);\n    }\n  };\n\n  NProgress.trickle = function() {\n    return NProgress.inc(Math.random() * Settings.trickleRate);\n  };\n\n  /**\n   * Waits for all supplied jQuery promises and\n   * increases the progress as the promises resolve.\n   *\n   * @param $promise jQUery Promise\n   */\n  (function() {\n    var initial = 0, current = 0;\n\n    NProgress.promise = function($promise) {\n      if (!$promise || $promise.state() === \"resolved\") {\n        return this;\n      }\n\n      if (current === 0) {\n        NProgress.start();\n      }\n\n      initial++;\n      current++;\n\n      $promise.always(function() {\n        current--;\n        if (current === 0) {\n            initial = 0;\n            NProgress.done();\n        } else {\n            NProgress.set((initial - current) / initial);\n        }\n      });\n\n      return this;\n    };\n\n  })();\n\n  /**\n   * (Internal) renders the progress bar markup based on the `template`\n   * setting.\n   */\n\n  NProgress.render = function(fromStart) {\n    if (NProgress.isRendered()) return document.getElementById('nprogress');\n\n    addClass(document.documentElement, 'nprogress-busy');\n    \n    var progress = document.createElement('div');\n    progress.id = 'nprogress';\n    progress.innerHTML = Settings.template;\n\n    var bar      = progress.querySelector(Settings.barSelector),\n        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\n        parent   = document.querySelector(Settings.parent),\n        spinner;\n    \n    css(bar, {\n      transition: 'all 0 linear',\n      transform: 'translate3d(' + perc + '%,0,0)'\n    });\n\n    if (!Settings.showSpinner) {\n      spinner = progress.querySelector(Settings.spinnerSelector);\n      spinner && removeElement(spinner);\n    }\n\n    if (parent != document.body) {\n      addClass(parent, 'nprogress-custom-parent');\n    }\n\n    parent.appendChild(progress);\n    return progress;\n  };\n\n  /**\n   * Removes the element. Opposite of render().\n   */\n\n  NProgress.remove = function() {\n    removeClass(document.documentElement, 'nprogress-busy');\n    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\n    var progress = document.getElementById('nprogress');\n    progress && removeElement(progress);\n  };\n\n  /**\n   * Checks if the progress bar is rendered.\n   */\n\n  NProgress.isRendered = function() {\n    return !!document.getElementById('nprogress');\n  };\n\n  /**\n   * Determine which positioning CSS rule to use.\n   */\n\n  NProgress.getPositioningCSS = function() {\n    // Sniff on document.body.style\n    var bodyStyle = document.body.style;\n\n    // Sniff prefixes\n    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\n                       ('MozTransform' in bodyStyle) ? 'Moz' :\n                       ('msTransform' in bodyStyle) ? 'ms' :\n                       ('OTransform' in bodyStyle) ? 'O' : '';\n\n    if (vendorPrefix + 'Perspective' in bodyStyle) {\n      // Modern browsers with 3D support, e.g. Webkit, IE10\n      return 'translate3d';\n    } else if (vendorPrefix + 'Transform' in bodyStyle) {\n      // Browsers without 3D support, e.g. IE9\n      return 'translate';\n    } else {\n      // Browsers without translate() support, e.g. IE7-8\n      return 'margin';\n    }\n  };\n\n  /**\n   * Helpers\n   */\n\n  function clamp(n, min, max) {\n    if (n < min) return min;\n    if (n > max) return max;\n    return n;\n  }\n\n  /**\n   * (Internal) converts a percentage (`0..1`) to a bar translateX\n   * percentage (`-100%..0%`).\n   */\n\n  function toBarPerc(n) {\n    return (-1 + n) * 100;\n  }\n\n\n  /**\n   * (Internal) returns the correct CSS for changing the bar's\n   * position given an n percentage, and speed and ease from Settings\n   */\n\n  function barPositionCSS(n, speed, ease) {\n    var barCSS;\n\n    if (Settings.positionUsing === 'translate3d') {\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\n    } else if (Settings.positionUsing === 'translate') {\n      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\n    } else {\n      barCSS = { 'margin-left': toBarPerc(n)+'%' };\n    }\n\n    barCSS.transition = 'all '+speed+'ms '+ease;\n\n    return barCSS;\n  }\n\n  /**\n   * (Internal) Queues a function to be executed.\n   */\n\n  var queue = (function() {\n    var pending = [];\n    \n    function next() {\n      var fn = pending.shift();\n      if (fn) {\n        fn(next);\n      }\n    }\n\n    return function(fn) {\n      pending.push(fn);\n      if (pending.length == 1) next();\n    };\n  })();\n\n  /**\n   * (Internal) Applies css properties to an element, similar to the jQuery \n   * css method.\n   *\n   * While this helper does assist with vendor prefixed property names, it \n   * does not perform any manipulation of values prior to setting styles.\n   */\n\n  var css = (function() {\n    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\n        cssProps    = {};\n\n    function camelCase(string) {\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\n        return letter.toUpperCase();\n      });\n    }\n\n    function getVendorProp(name) {\n      var style = document.body.style;\n      if (name in style) return name;\n\n      var i = cssPrefixes.length,\n          capName = name.charAt(0).toUpperCase() + name.slice(1),\n          vendorName;\n      while (i--) {\n        vendorName = cssPrefixes[i] + capName;\n        if (vendorName in style) return vendorName;\n      }\n\n      return name;\n    }\n\n    function getStyleProp(name) {\n      name = camelCase(name);\n      return cssProps[name] || (cssProps[name] = getVendorProp(name));\n    }\n\n    function applyCss(element, prop, value) {\n      prop = getStyleProp(prop);\n      element.style[prop] = value;\n    }\n\n    return function(element, properties) {\n      var args = arguments,\n          prop, \n          value;\n\n      if (args.length == 2) {\n        for (prop in properties) {\n          value = properties[prop];\n          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\n        }\n      } else {\n        applyCss(element, args[1], args[2]);\n      }\n    }\n  })();\n\n  /**\n   * (Internal) Determines if an element or space separated list of class names contains a class name.\n   */\n\n  function hasClass(element, name) {\n    var list = typeof element == 'string' ? element : classList(element);\n    return list.indexOf(' ' + name + ' ') >= 0;\n  }\n\n  /**\n   * (Internal) Adds a class to an element.\n   */\n\n  function addClass(element, name) {\n    var oldList = classList(element),\n        newList = oldList + name;\n\n    if (hasClass(oldList, name)) return; \n\n    // Trim the opening space.\n    element.className = newList.substring(1);\n  }\n\n  /**\n   * (Internal) Removes a class from an element.\n   */\n\n  function removeClass(element, name) {\n    var oldList = classList(element),\n        newList;\n\n    if (!hasClass(element, name)) return;\n\n    // Replace the class name.\n    newList = oldList.replace(' ' + name + ' ', ' ');\n\n    // Trim the opening and closing spaces.\n    element.className = newList.substring(1, newList.length - 1);\n  }\n\n  /**\n   * (Internal) Gets a space separated list of the class names on the element. \n   * The list is wrapped with a single space on each end to facilitate finding \n   * matches within the list.\n   */\n\n  function classList(element) {\n    return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' ');\n  }\n\n  /**\n   * (Internal) Removes an element from the DOM.\n   */\n\n  function removeElement(element) {\n    element && element.parentNode && element.parentNode.removeChild(element);\n  }\n\n  return NProgress;\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbnByb2dyZXNzL25wcm9ncmVzcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ucHJvZ3Jlc3MvbnByb2dyZXNzLmpzPzMyM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyogTlByb2dyZXNzLCAoYykgMjAxMywgMjAxNCBSaWNvIFN0YS4gQ3J1eiAtIGh0dHA6Ly9yaWNvc3RhY3J1ei5jb20vbnByb2dyZXNzXG4gKiBAbGljZW5zZSBNSVQgKi9cblxuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290Lk5Qcm9ncmVzcyA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgdmFyIE5Qcm9ncmVzcyA9IHt9O1xuXG4gIE5Qcm9ncmVzcy52ZXJzaW9uID0gJzAuMi4wJztcblxuICB2YXIgU2V0dGluZ3MgPSBOUHJvZ3Jlc3Muc2V0dGluZ3MgPSB7XG4gICAgbWluaW11bTogMC4wOCxcbiAgICBlYXNpbmc6ICdlYXNlJyxcbiAgICBwb3NpdGlvblVzaW5nOiAnJyxcbiAgICBzcGVlZDogMjAwLFxuICAgIHRyaWNrbGU6IHRydWUsXG4gICAgdHJpY2tsZVJhdGU6IDAuMDIsXG4gICAgdHJpY2tsZVNwZWVkOiA4MDAsXG4gICAgc2hvd1NwaW5uZXI6IHRydWUsXG4gICAgYmFyU2VsZWN0b3I6ICdbcm9sZT1cImJhclwiXScsXG4gICAgc3Bpbm5lclNlbGVjdG9yOiAnW3JvbGU9XCJzcGlubmVyXCJdJyxcbiAgICBwYXJlbnQ6ICdib2R5JyxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJiYXJcIiByb2xlPVwiYmFyXCI+PGRpdiBjbGFzcz1cInBlZ1wiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJzcGlubmVyXCIgcm9sZT1cInNwaW5uZXJcIj48ZGl2IGNsYXNzPVwic3Bpbm5lci1pY29uXCI+PC9kaXY+PC9kaXY+J1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuY29uZmlndXJlKHtcbiAgICogICAgICAgbWluaW11bTogMC4xXG4gICAqICAgICB9KTtcbiAgICovXG4gIE5Qcm9ncmVzcy5jb25maWd1cmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIFNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTGFzdCBudW1iZXIuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5zdGF0dXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9ncmVzcyBiYXIgc3RhdHVzLCB3aGVyZSBgbmAgaXMgYSBudW1iZXIgZnJvbSBgMC4wYCB0byBgMS4wYC5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMC40KTtcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMS4wKTtcbiAgICovXG5cbiAgTlByb2dyZXNzLnNldCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgc3RhcnRlZCA9IE5Qcm9ncmVzcy5pc1N0YXJ0ZWQoKTtcblxuICAgIG4gPSBjbGFtcChuLCBTZXR0aW5ncy5taW5pbXVtLCAxKTtcbiAgICBOUHJvZ3Jlc3Muc3RhdHVzID0gKG4gPT09IDEgPyBudWxsIDogbik7XG5cbiAgICB2YXIgcHJvZ3Jlc3MgPSBOUHJvZ3Jlc3MucmVuZGVyKCFzdGFydGVkKSxcbiAgICAgICAgYmFyICAgICAgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLmJhclNlbGVjdG9yKSxcbiAgICAgICAgc3BlZWQgICAgPSBTZXR0aW5ncy5zcGVlZCxcbiAgICAgICAgZWFzZSAgICAgPSBTZXR0aW5ncy5lYXNpbmc7XG5cbiAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDsgLyogUmVwYWludCAqL1xuXG4gICAgcXVldWUoZnVuY3Rpb24obmV4dCkge1xuICAgICAgLy8gU2V0IHBvc2l0aW9uVXNpbmcgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzZXRcbiAgICAgIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAnJykgU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9IE5Qcm9ncmVzcy5nZXRQb3NpdGlvbmluZ0NTUygpO1xuXG4gICAgICAvLyBBZGQgdHJhbnNpdGlvblxuICAgICAgY3NzKGJhciwgYmFyUG9zaXRpb25DU1Mobiwgc3BlZWQsIGVhc2UpKTtcblxuICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgY3NzKHByb2dyZXNzLCB7IFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJywgXG4gICAgICAgICAgb3BhY2l0eTogMSBcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2dyZXNzLm9mZnNldFdpZHRoOyAvKiBSZXBhaW50ICovXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjc3MocHJvZ3Jlc3MsIHsgXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsICcgKyBzcGVlZCArICdtcyBsaW5lYXInLCBcbiAgICAgICAgICAgIG9wYWNpdHk6IDAgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9LCBzcGVlZCk7XG4gICAgICAgIH0sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQobmV4dCwgc3BlZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgTlByb2dyZXNzLmlzU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0eXBlb2YgTlByb2dyZXNzLnN0YXR1cyA9PT0gJ251bWJlcic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgc2V0dGluZyB0aGUgc3RhdHVzIHRvIDAlLCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGdvIGJhY2t3YXJkcy5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgKlxuICAgKi9cbiAgTlByb2dyZXNzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFOUHJvZ3Jlc3Muc3RhdHVzKSBOUHJvZ3Jlc3Muc2V0KDApO1xuXG4gICAgdmFyIHdvcmsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuO1xuICAgICAgICBOUHJvZ3Jlc3MudHJpY2tsZSgpO1xuICAgICAgICB3b3JrKCk7XG4gICAgICB9LCBTZXR0aW5ncy50cmlja2xlU3BlZWQpO1xuICAgIH07XG5cbiAgICBpZiAoU2V0dGluZ3MudHJpY2tsZSkgd29yaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlICpzb3J0IG9mKiB0aGUgc2FtZSBhcyBzZXR0aW5nIHRoZSBzdGF0dXMgdG8gMTAwJSwgd2l0aCB0aGVcbiAgICogZGlmZmVyZW5jZSBiZWluZyBgZG9uZSgpYCBtYWtlcyBzb21lIHBsYWNlYm8gZWZmZWN0IG9mIHNvbWUgcmVhbGlzdGljIG1vdGlvbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKCk7XG4gICAqXG4gICAqIElmIGB0cnVlYCBpcyBwYXNzZWQsIGl0IHdpbGwgc2hvdyB0aGUgcHJvZ3Jlc3MgYmFyIGV2ZW4gaWYgaXRzIGhpZGRlbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKHRydWUpO1xuICAgKi9cblxuICBOUHJvZ3Jlc3MuZG9uZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSAmJiAhTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gTlByb2dyZXNzLmluYygwLjMgKyAwLjUgKiBNYXRoLnJhbmRvbSgpKS5zZXQoMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgYnkgYSByYW5kb20gYW1vdW50LlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuaW5jID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgdmFyIG4gPSBOUHJvZ3Jlc3Muc3RhdHVzO1xuXG4gICAgaWYgKCFuKSB7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBhbW91bnQgPSAoMSAtIG4pICogY2xhbXAoTWF0aC5yYW5kb20oKSAqIG4sIDAuMSwgMC45NSk7XG4gICAgICB9XG5cbiAgICAgIG4gPSBjbGFtcChuICsgYW1vdW50LCAwLCAwLjk5NCk7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnNldChuKTtcbiAgICB9XG4gIH07XG5cbiAgTlByb2dyZXNzLnRyaWNrbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTlByb2dyZXNzLmluYyhNYXRoLnJhbmRvbSgpICogU2V0dGluZ3MudHJpY2tsZVJhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYWxsIHN1cHBsaWVkIGpRdWVyeSBwcm9taXNlcyBhbmRcbiAgICogaW5jcmVhc2VzIHRoZSBwcm9ncmVzcyBhcyB0aGUgcHJvbWlzZXMgcmVzb2x2ZS5cbiAgICpcbiAgICogQHBhcmFtICRwcm9taXNlIGpRVWVyeSBQcm9taXNlXG4gICAqL1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluaXRpYWwgPSAwLCBjdXJyZW50ID0gMDtcblxuICAgIE5Qcm9ncmVzcy5wcm9taXNlID0gZnVuY3Rpb24oJHByb21pc2UpIHtcbiAgICAgIGlmICghJHByb21pc2UgfHwgJHByb21pc2Uuc3RhdGUoKSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA9PT0gMCkge1xuICAgICAgICBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbCsrO1xuICAgICAgY3VycmVudCsrO1xuXG4gICAgICAkcHJvbWlzZS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGN1cnJlbnQtLTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWwgPSAwO1xuICAgICAgICAgICAgTlByb2dyZXNzLmRvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5zZXQoKGluaXRpYWwgLSBjdXJyZW50KSAvIGluaXRpYWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJlbmRlcnMgdGhlIHByb2dyZXNzIGJhciBtYXJrdXAgYmFzZWQgb24gdGhlIGB0ZW1wbGF0ZWBcbiAgICogc2V0dGluZy5cbiAgICovXG5cbiAgTlByb2dyZXNzLnJlbmRlciA9IGZ1bmN0aW9uKGZyb21TdGFydCkge1xuICAgIGlmIChOUHJvZ3Jlc3MuaXNSZW5kZXJlZCgpKSByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICBcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcm9ncmVzcy5pZCA9ICducHJvZ3Jlc3MnO1xuICAgIHByb2dyZXNzLmlubmVySFRNTCA9IFNldHRpbmdzLnRlbXBsYXRlO1xuXG4gICAgdmFyIGJhciAgICAgID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5iYXJTZWxlY3RvciksXG4gICAgICAgIHBlcmMgICAgID0gZnJvbVN0YXJ0ID8gJy0xMDAnIDogdG9CYXJQZXJjKE5Qcm9ncmVzcy5zdGF0dXMgfHwgMCksXG4gICAgICAgIHBhcmVudCAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5wYXJlbnQpLFxuICAgICAgICBzcGlubmVyO1xuICAgIFxuICAgIGNzcyhiYXIsIHtcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMCBsaW5lYXInLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIHBlcmMgKyAnJSwwLDApJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFTZXR0aW5ncy5zaG93U3Bpbm5lcikge1xuICAgICAgc3Bpbm5lciA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3Muc3Bpbm5lclNlbGVjdG9yKTtcbiAgICAgIHNwaW5uZXIgJiYgcmVtb3ZlRWxlbWVudChzcGlubmVyKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ICE9IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGFkZENsYXNzKHBhcmVudCwgJ25wcm9ncmVzcy1jdXN0b20tcGFyZW50Jyk7XG4gICAgfVxuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHByb2dyZXNzKTtcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQuIE9wcG9zaXRlIG9mIHJlbmRlcigpLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnBhcmVudCksICducHJvZ3Jlc3MtY3VzdG9tLXBhcmVudCcpO1xuICAgIHZhciBwcm9ncmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcbiAgICBwcm9ncmVzcyAmJiByZW1vdmVFbGVtZW50KHByb2dyZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwcm9ncmVzcyBiYXIgaXMgcmVuZGVyZWQuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5pc1JlbmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hpY2ggcG9zaXRpb25pbmcgQ1NTIHJ1bGUgdG8gdXNlLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuZ2V0UG9zaXRpb25pbmdDU1MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTbmlmZiBvbiBkb2N1bWVudC5ib2R5LnN0eWxlXG4gICAgdmFyIGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG5cbiAgICAvLyBTbmlmZiBwcmVmaXhlc1xuICAgIHZhciB2ZW5kb3JQcmVmaXggPSAoJ1dlYmtpdFRyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdXZWJraXQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdNb3pUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnTW96JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnbXNUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnbXMnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdPVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ08nIDogJyc7XG5cbiAgICBpZiAodmVuZG9yUHJlZml4ICsgJ1BlcnNwZWN0aXZlJyBpbiBib2R5U3R5bGUpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VycyB3aXRoIDNEIHN1cHBvcnQsIGUuZy4gV2Via2l0LCBJRTEwXG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkJztcbiAgICB9IGVsc2UgaWYgKHZlbmRvclByZWZpeCArICdUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkge1xuICAgICAgLy8gQnJvd3NlcnMgd2l0aG91dCAzRCBzdXBwb3J0LCBlLmcuIElFOVxuICAgICAgcmV0dXJuICd0cmFuc2xhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VycyB3aXRob3V0IHRyYW5zbGF0ZSgpIHN1cHBvcnQsIGUuZy4gSUU3LThcbiAgICAgIHJldHVybiAnbWFyZ2luJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhbXAobiwgbWluLCBtYXgpIHtcbiAgICBpZiAobiA8IG1pbikgcmV0dXJuIG1pbjtcbiAgICBpZiAobiA+IG1heCkgcmV0dXJuIG1heDtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIGNvbnZlcnRzIGEgcGVyY2VudGFnZSAoYDAuLjFgKSB0byBhIGJhciB0cmFuc2xhdGVYXG4gICAqIHBlcmNlbnRhZ2UgKGAtMTAwJS4uMCVgKS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9CYXJQZXJjKG4pIHtcbiAgICByZXR1cm4gKC0xICsgbikgKiAxMDA7XG4gIH1cblxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJldHVybnMgdGhlIGNvcnJlY3QgQ1NTIGZvciBjaGFuZ2luZyB0aGUgYmFyJ3NcbiAgICogcG9zaXRpb24gZ2l2ZW4gYW4gbiBwZXJjZW50YWdlLCBhbmQgc3BlZWQgYW5kIGVhc2UgZnJvbSBTZXR0aW5nc1xuICAgKi9cblxuICBmdW5jdGlvbiBiYXJQb3NpdGlvbkNTUyhuLCBzcGVlZCwgZWFzZSkge1xuICAgIHZhciBiYXJDU1M7XG5cbiAgICBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZTNkJykge1xuICAgICAgYmFyQ1NTID0geyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnK3RvQmFyUGVyYyhuKSsnJSwwLDApJyB9O1xuICAgIH0gZWxzZSBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZScpIHtcbiAgICAgIGJhckNTUyA9IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcrdG9CYXJQZXJjKG4pKyclLDApJyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJDU1MgPSB7ICdtYXJnaW4tbGVmdCc6IHRvQmFyUGVyYyhuKSsnJScgfTtcbiAgICB9XG5cbiAgICBiYXJDU1MudHJhbnNpdGlvbiA9ICdhbGwgJytzcGVlZCsnbXMgJytlYXNlO1xuXG4gICAgcmV0dXJuIGJhckNTUztcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIFF1ZXVlcyBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKi9cblxuICB2YXIgcXVldWUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBlbmRpbmcgPSBbXTtcbiAgICBcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIGZuID0gcGVuZGluZy5zaGlmdCgpO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgcGVuZGluZy5wdXNoKGZuKTtcbiAgICAgIGlmIChwZW5kaW5nLmxlbmd0aCA9PSAxKSBuZXh0KCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSBBcHBsaWVzIGNzcyBwcm9wZXJ0aWVzIHRvIGFuIGVsZW1lbnQsIHNpbWlsYXIgdG8gdGhlIGpRdWVyeSBcbiAgICogY3NzIG1ldGhvZC5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBoZWxwZXIgZG9lcyBhc3Npc3Qgd2l0aCB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkgbmFtZXMsIGl0IFxuICAgKiBkb2VzIG5vdCBwZXJmb3JtIGFueSBtYW5pcHVsYXRpb24gb2YgdmFsdWVzIHByaW9yIHRvIHNldHRpbmcgc3R5bGVzLlxuICAgKi9cblxuICB2YXIgY3NzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjc3NQcmVmaXhlcyA9IFsgJ1dlYmtpdCcsICdPJywgJ01veicsICdtcycgXSxcbiAgICAgICAgY3NzUHJvcHMgICAgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXi1tcy0vLCAnbXMtJykucmVwbGFjZSgvLShbXFxkYS16XSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmVuZG9yUHJvcChuYW1lKSB7XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgaWYgKG5hbWUgaW4gc3R5bGUpIHJldHVybiBuYW1lO1xuXG4gICAgICB2YXIgaSA9IGNzc1ByZWZpeGVzLmxlbmd0aCxcbiAgICAgICAgICBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgdmVuZG9yTmFtZTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmVuZG9yTmFtZSA9IGNzc1ByZWZpeGVzW2ldICsgY2FwTmFtZTtcbiAgICAgICAgaWYgKHZlbmRvck5hbWUgaW4gc3R5bGUpIHJldHVybiB2ZW5kb3JOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdHlsZVByb3AobmFtZSkge1xuICAgICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcbiAgICAgIHJldHVybiBjc3NQcm9wc1tuYW1lXSB8fCAoY3NzUHJvcHNbbmFtZV0gPSBnZXRWZW5kb3JQcm9wKG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJvcCA9IGdldFN0eWxlUHJvcChwcm9wKTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcHJvcCwgXG4gICAgICAgICAgdmFsdWU7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIGFwcGx5Q3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlDc3MoZWxlbWVudCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIERldGVybWluZXMgaWYgYW4gZWxlbWVudCBvciBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lcyBjb250YWlucyBhIGNsYXNzIG5hbWUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgbGlzdCA9IHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnID8gZWxlbWVudCA6IGNsYXNzTGlzdChlbGVtZW50KTtcbiAgICByZXR1cm4gbGlzdC5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpID49IDA7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBBZGRzIGEgY2xhc3MgdG8gYW4gZWxlbWVudC5cbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBvbGRMaXN0ID0gY2xhc3NMaXN0KGVsZW1lbnQpLFxuICAgICAgICBuZXdMaXN0ID0gb2xkTGlzdCArIG5hbWU7XG5cbiAgICBpZiAoaGFzQ2xhc3Mob2xkTGlzdCwgbmFtZSkpIHJldHVybjsgXG5cbiAgICAvLyBUcmltIHRoZSBvcGVuaW5nIHNwYWNlLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50LlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIG9sZExpc3QgPSBjbGFzc0xpc3QoZWxlbWVudCksXG4gICAgICAgIG5ld0xpc3Q7XG5cbiAgICBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpKSByZXR1cm47XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBjbGFzcyBuYW1lLlxuICAgIG5ld0xpc3QgPSBvbGRMaXN0LnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcblxuICAgIC8vIFRyaW0gdGhlIG9wZW5pbmcgYW5kIGNsb3Npbmcgc3BhY2VzLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSwgbmV3TGlzdC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIEdldHMgYSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiB0aGUgY2xhc3MgbmFtZXMgb24gdGhlIGVsZW1lbnQuIFxuICAgKiBUaGUgbGlzdCBpcyB3cmFwcGVkIHdpdGggYSBzaW5nbGUgc3BhY2Ugb24gZWFjaCBlbmQgdG8gZmFjaWxpdGF0ZSBmaW5kaW5nIFxuICAgKiBtYXRjaGVzIHdpdGhpbiB0aGUgbGlzdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhc3NMaXN0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gKCcgJyArIChlbGVtZW50LmNsYXNzTmFtZSB8fCAnJykgKyAnICcpLnJlcGxhY2UoL1xccysvZ2ksICcgJyk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gTlByb2dyZXNzO1xufSk7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nprogress/nprogress.js\n");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./js/app.js */"./js/app.js");


/***/ })

/******/ });